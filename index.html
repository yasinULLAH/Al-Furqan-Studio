<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nur Al-Quran Studio Offline - By Yasin Ullah</title>
    <meta name="author" content="Yasin Ullah, Pakistani">
    <meta name="description"
        content="An offline-first, client-side Quranic study environment with personal Tafsir, thematic linking, root analysis, Hifz tracking, and advanced search.">
    <script type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/vis-network@latest/dist/vis-network.min.js"></script>
    <style>
        :root {
            --color-bg-primary: #e8f5e9;
            --color-bg-secondary: #c8e6c9;
            --color-text-primary: #1b5e20;
            --color-text-secondary: #388e3c;
            --color-accent: #4caf50;
            --color-accent-dark: #388e3c;
            --color-border: #a5d6a7;
            --color-shadow: rgba(0, 0, 0, 0.1);
            --color-highlight: #fff9c4;
            --color-error: #ef5350;
            --color-success: #66bb6a;
            --font-arabic: 'Scheherazade New', 'Lateef', 'Amiri', 'Traditional Arabic', calibri;
            --font-urdu: 'Jameel Noori Nastaleeq', 'Noto Nastaliq Urdu', 'Pak Nastaleeq', calibri;
            --font-Bangali: 'Noto Sans Bangali', 'Arial', calibri;
            --font-english: 'Roboto', 'Segoe UI', calibri;
            --font-general: 'Roboto', 'Segoe UI', calibri;
            --border-radius: 8px;
            --padding-main: 20px;
            --transition-speed: 0.3s;
        }
        body.theme-manuscript {
            --color-bg-primary: #f5f5dc;
            --color-bg-secondary: #fff8dc;
            --color-text-primary: #5d4037;
            --color-text-secondary: #795548;
            --color-accent: #ffb300;
            --color-accent-dark: #fb8c00;
            --color-border: #d7ccc8;
            --color-shadow: rgba(0, 0, 0, 0.15);
            --color-highlight: #ffe082;
            --color-error: #c62828;
            --color-success: #388e3c;
            --font-arabic: 'Scheherazade New', calibri;
            --font-urdu: 'Jameel Noori Nastaleeq', calibri;
            --font-Bangali: 'Noto Sans Bangali', calibri;
            --font-english: 'Merriweather', calibri;
            --font-general: 'Merriweather', calibri;
        }
        body.theme-holo {
            --color-bg-primary: #0d1a2b;
            --color-bg-secondary: #1a2b3c;
            --color-text-primary: #e0f7fa;
            --color-text-secondary: #b2ebf2;
            --color-accent: #00bcd4;
            --color-accent-dark: #00838f;
            --color-border: #26a69a;
            --color-shadow: rgba(0, 188, 212, 0.2);
            --color-highlight: #80deea;
            --color-error: #ff5252;
            --color-success: #00e676;
            --font-arabic: 'Orbitron', calibri;
            --font-urdu: 'Orbitron', calibri;
            --font-Bangali: 'Orbitron', calibri;
            --font-english: 'Orbitron', calibri;
            --font-general: 'Orbitron', calibri;
            --border-radius: 4px;
        }
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: var(--font-general);
            line-height: 1.6;
            color: var(--color-text-primary);
            background-color: var(--color-bg-primary);
            transition: background-color var(--transition-speed), color var(--transition-speed);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-y: scroll;
        }
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            color: var(--color-text-secondary);
            margin-bottom: 15px;
        }
        button,
        input[type="submit"],
        input[type="button"] {
            font-family: var(--font-general);
            background-color: var(--color-accent);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color var(--transition-speed), opacity var(--transition-speed);
            font-size: 1rem;
        }
        button:hover,
        input[type="submit"]:hover,
        input[type="button"]:hover {
            background-color: var(--color-accent-dark);
            opacity: 0.9;
        }
        button:focus,
        input[type="submit"]:focus,
        input[type="button"]:focus {
            outline: 2px solid var(--color-accent-dark);
            outline-offset: 2px;
        }
        input[type="text"],
        input[type="number"],
        textarea,
        select {
            font-family: var(--font-general);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
            width: 100%;
            max-width: 400px;
        }
        input[type="text"]:focus,
        input[type="number"]:focus,
        textarea:focus,
        select:focus {
            outline: 2px solid var(--color-accent);
            border-color: var(--color-accent);
        }
        textarea {
            min-height: 150px;
            resize: vertical;
            max-width: 100%;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--color-text-secondary);
        }
        a {
            color: var(--color-accent-dark);
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .container {
            display: flex;
            flex-grow: 1;
            padding: 6px 0px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }
        .sidebar {
            width: 250px;
            margin-right: var(--padding-main);
            flex-shrink: 0;
            background-color: var(--color-bg-secondary);
            padding: 7px;
            border-radius: var(--border-radius);
            box-shadow: 0 8px 14px rgb(0 0 0);
            margin-top: -61px;
        }
        .main-content {
            flex-grow: 1;
            background-color: var(--color-bg-secondary);
            padding: var(--padding-main);
            border-radius: var(--border-radius);
            box-shadow: 0 2px 5px var(--color-shadow);
            overflow-y: auto;
        }
        header {
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
            padding: 5px var(--padding-main);
            box-shadow: 0 2px 5px var(--color-shadow);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        header h1 {
            margin: 0;
            font-size: 1.8rem;
            color: var(--color-text-primary);
            margin-right: 16px;
        }
        nav ul {
            list-style: none;
            padding: 0;
        }
        nav ul li {
            margin-bottom: 10px;
        }
        nav a {
            display: block;
            padding: 10px;
            background-color: var(--color-bg-primary);
            border-radius: var(--border-radius);
            color: var(--color-text-primary);
            transition: background-color var(--transition-speed), color var(--transition-speed);
        }
        nav a:hover,
        nav a.active {
            background-color: var(--color-accent);
            color: white;
            text-decoration: none;
        }
        .section {
            display: none;
        }
        .section.active {
            display: block;
        }
        .quran-viewer h2 {
            text-align: center;
            margin-bottom: 20px;
        }
        .ayah {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            transition: background-color var(--transition-speed);
        }
        .ayah:hover {
            background-color: var(--color-highlight);
        }
        .ayah-number {
            font-weight: bold;
            color: var(--color-accent-dark);
            margin-bottom: 10px;
            display: block;
            text-align: center;
        }
        .ayah-arabic {
            font-family: var(--font-arabic);
            font-size: 1.8rem;
            text-align: right;
            direction: rtl;
            margin-bottom: 10px;
            line-height: 2.5;
        }
        .ayah-arabic span {
            cursor: pointer;
            padding: 2px 4px;
            border-bottom: 1px dashed transparent;
            transition: background-color 0.2s, border-bottom-color 0.2s;
        }
        .ayah-arabic span:hover {
            background-color: rgba(var(--color-accent-dark-rgb, 56, 142, 60), 0.2);
            border-bottom-color: var(--color-accent-dark);
        }
        :root {
            --color-accent-dark-rgb: 56, 142, 60;
        }
        body.theme-manuscript {
            --color-accent-dark-rgb: 251, 140, 0;
        }
        body.theme-holo {
            --color-accent-dark-rgb: 0, 131, 143;
        }
        .ayah-translation {
            font-size: 1.1rem;
            color: var(--color-text-secondary);
        }
        .tafsir-editor {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--color-border);
        }
        .tafsir-editor textarea {
            width: 100%;
            max-width: 100%;
            margin-bottom: 10px;
            font-size: medium;
        }
        .theme-manager,
        .theme-linker {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
        }
        .theme-list ul {
            list-style: none;
            padding-left: 20px;
        }
        .theme-list li {
            margin-bottom: 5px;
        }
        .theme-list li span {
            cursor: pointer;
            color: var(--color-text-secondary);
            transition: color var(--transition-speed);
        }
        .theme-list li span:hover {
            color: var(--color-accent-dark);
            text-decoration: underline;
        }
        .theme-list .theme-actions button {
            padding: 3px 8px;
            font-size: 0.8rem;
            margin-left: 5px;
        }
        .root-analyzer-form {
            margin-bottom: 20px;
        }
        .root-results ul {
            list-style: none;
            padding: 0;
        }
        .root-results li {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            font-size: 1.5rem;
        }
        .recitation-log-form {
            margin-bottom: 20px;
        }
        .recitation-list ul {
            list-style: none;
            padding: 0;
        }
        .recitation-list li {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
        }
        .hifz-ayah-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: var(--border-radius);
            font-size: 0.9rem;
            margin-left: 10px;
        }
        .status-not-started {
            background-color: #e0e0e0;
            color: #424242;
        }
        .status-in-progress {
            background-color: #fff59d;
            color: #fbc02d;
        }
        .status-memorized {
            background-color: #a5d6a7;
            color: #388e3c;
        }
        .search-options label {
            display: inline-block;
            margin-right: 15px;
            font-weight: normal;
        }
        .search-results ul {
            list-style: none;
            padding: 0;
            margin-top: 20px;
        }
        .search-results li {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
        }
        .search-results .result-context {
            font-size: large;
            color: var(--color-text-secondary);
            margin-top: 5px;
        }
        .settings-section {
            margin-bottom: 20px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: var(--color-bg-secondary);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 15px var(--color-shadow);
            max-width: 600px;
            width: 90%;
            position: relative;
        }
        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            color: var(--color-text-secondary);
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }
        #loading-overlay {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 1.5rem;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            display: none;
        }
        .text-center {
            text-align: center;
        }
        .mt-20 {
            margin-top: 20px;
        }
        .mb-10 {
            margin-bottom: 10px;
        }
        .mb-20 {
            margin-bottom: 20px;
        }
        .flex-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        [tabindex="0"]:focus,
        button:focus,
        input:focus,
        select:focus,
        textarea:focus,
        a:focus {
            outline: 3px solid var(--color-accent-dark);
            outline-offset: 2px;
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
        [dir="rtl"] .ayah-arabic,
        [dir="rtl"] .ayah-translation {
            text-align: right;
        }
        [dir="rtl"] .sidebar {
            margin-right: 0;
            margin-left: var(--padding-main);
        }
        [dir="rtl"] .theme-list ul {
            padding-left: 0;
            padding-right: 20px;
        }
        [dir="rtl"] .theme-list .theme-actions button {
            margin-left: 0;
            margin-right: 5px;
        }
        [dir="rtl"] .hifz-ayah-status {
            margin-left: 0;
            margin-right: 10px;
        }
        [dir="rtl"] .search-options label {
            margin-right: 0;
            margin-left: 15px;
        }
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                padding: 10px;
            }
            .sidebar {
                width: 100%;
                margin-right: 0;
                margin-bottom: 20px;
            }
            [dir="rtl"] .sidebar {
                margin-left: 0;
                margin-bottom: 20px;
            }
            .main-content {
                padding: 15px;
            }
            header {
                flex-direction: column;
                align-items: flex-start;
                padding: 10px;
            }
            header h1 {
                margin-bottom: 10px;
            }
            nav ul {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
            }
            nav ul li {
                margin-bottom: 0;
            }
            nav a {
                padding: 8px 12px;
                font-size: 0.9rem;
            }
            input[type="text"],
            input[type="number"],
            textarea,
            select {
                max-width: 100%;
            }
            .flex-group {
                flex-direction: column;
                gap: 10px;
            }
            .flex-group button,
            .flex-group input {
                width: 100%;
            }
        }
        body.theme-holo .ayah:hover {
            background: linear-gradient(90deg, rgba(0, 188, 212, 0.1) 0%, rgba(0, 188, 212, 0.05) 100%);
        }
        body.theme-holo .ayah-arabic span:hover {
            background-color: rgba(0, 188, 212, 0.3);
            border-bottom-color: var(--color-highlight);
        }
        body.theme-holo nav a.active {
            background-color: var(--color-accent);
            box-shadow: 0 0 8px var(--color-accent);
        }
        #loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            text-align: center;
            padding: 20px;
        }
        .loading-content {
            background-color: var(--color-bg-secondary, #1a2b3c);
            padding: 30px 40px;
            border-radius: var(--border-radius, 8px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
        }
        body.theme-serene .loading-content {
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
        }
        body.theme-manuscript .loading-content {
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
        }
        body.theme-holo .loading-content {
            background-color: #1a2b3c;
            color: #e0f7fa;
        }
        #loading-message-primary {
            font-size: 1.4rem;
            font-weight: bold;
            margin-bottom: 10px;
        }
        #loading-message-secondary {
            font-size: 1rem;
            margin-bottom: 20px;
            min-height: 1.6em;
        }
        #loading-progress-bar-container {
            width: 100%;
            background-color: var(--color-border, #a5d6a7);
            border-radius: var(--border-radius, 8px);
            overflow: hidden;
            height: 20px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        body.theme-holo #loading-progress-bar-container {
            background-color: #26a69a;
        }
        #loading-progress-bar {
            height: 100%;
            background-color: var(--color-accent, #4caf50);
            width: 0%;
            transition: width 0.3s ease-out;
            border-radius: var(--border-radius, 8px) 0 0 var(--border-radius, 8px);
        }
        body.theme-holo #loading-progress-bar {
            background-color: var(--color-accent);
        }
        #loading-percentage {
            font-size: 1.1rem;
            font-weight: bold;
        }
        #loading-first-time-notice {
            font-size: 0.85em;
            margin-top: 15px;
            opacity: 0.8;
        }
        .view-switcher label {
            display: inline-block;
            margin-bottom: 0;
        }
        .view-switcher div>label {
            margin-left: 3px;
        }
        .root-view-content {
            display: none;
        }
        .root-view-content.active-view {
            display: block;
        }
        #root-network-graph-container {
            margin-top: 20px;
        }
        .view-switcher label {
            display: inline-block;
            margin-bottom: 0;
        }
        .view-switcher div>label {
            margin-left: 3px;
        }
        .root-view-content {
            display: none;
        }
        .root-view-content.active-view {
            display: block;
        }
        #root-network-graph-container {
            margin-top: 20px;
        }
        .custom-popup#root-node-popup {
            position: absolute;
            background-color: var(--color-bg-secondary);
            border: 1px solid var(--color-border);
            padding: 15px;
            box-shadow: 0 8px 36px black;
            display: none;
            border-radius: var(--border-radius);
            word-wrap: break-word;
            font-size: 1.1rem !important;
        }
        .custom-popup#root-node-popup h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--color-accent-dark);
            font-family: var(--font-arabic);
            font-size: 1.5rem;
        }
        .custom-popup#root-node-popup p {
            margin: 0;
            line-height: 2;
            font-size: 1.3rem;
        }
        #root-graph-placeholder {
            text-align: center;
            margin: 20px 0;
        }
        body.graph-fullscreen-active {
            overflow: hidden;
        }
        #root-network-graph-container.fullscreen-graph {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1500;
            background-color: var(--color-bg-primary);
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: stretch;
        }
        #root-network-graph-container.fullscreen-graph #root-network-graph {
            flex-grow: 1;
            border: none;
            width: 100%;
            height: 100%;
        }
        .graph-fullscreen-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 1501;
            padding: 8px 15px;
            font-size: 1.2rem;
            background-color: var(--color-error);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
        }
        #root-network-graph-container.fullscreen-graph #root-graph-pagination-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(var(--color-bg-secondary-rgb, 200, 230, 201), 0.9);
            padding: 5px 10px;
            border-radius: var(--border-radius);
            z-index: 1501;
        }
        :root {
            --color-bg-secondary-rgb: 200, 230, 201;
        }
        body.theme-manuscript {
            --color-bg-secondary-rgb: 255, 248, 220;
        }
        body.theme-holo {
            --color-bg-secondary-rgb: 26, 43, 60;
        }
        div#root-node-popup {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            font-family: var(--font-arabic) !important;
            direction: rtl !important;
            text-align: right !important;
            z-index: 2147483647 !important;
        }
        button#launchFullScreenReaderBtnEnhanced {
            position: absolute;
            right: 83px;
            top: 71px;
        }
        button#quitGameButton {
            position: fixed;
            bottom: 1px;
            left: 3px;
        }
        #fsReaderSettingsPanel>div:nth-child(2)>label:nth-child(7) {
            display: none;
        }
        span.item-surah-ayah.theme-modal-ayah-link {
            cursor: pointer;
        }
    </style>
    <!-- Optional: Include fonts if not available locally -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Scheherazade+New:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Jameel+Noori+Nastaleeq&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Nastaliq+Urdu&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+Bangali&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap">
</head>
<body dir="ltr"> <!-- Default direction, will be set dynamically if needed -->
    <div id="loading-overlay">
        <div class="loading-content">
            <div id="loading-message-primary">Loading Quran data...</div>
            <div id="loading-message-secondary">Initializing...</div>
            <div id="loading-progress-bar-container">
                <div id="loading-progress-bar" style="width: 0%;"></div>
            </div>
            <div id="loading-percentage">0%</div>
            <div id="loading-first-time-notice" style="font-size: 0.9em; margin-top: 10px;">
                (This intensive loading typically occurs only on the first visit or after an app update. Subsequent
                loads will be much faster.)
            </div>
        </div>
    </div>
    <header>
        <h1>Nur Al-Quran Studio Offline</h1>
        <div class="header-controls">
            <label for="theme-switcher" class="sr-only">Choose Theme</label>
            <select id="theme-switcher" aria-label="Choose Theme">
                <option value="serene">Serene Digital Mosque</option>
                <option value="manuscript">Ancient Illuminated Manuscript</option>
                <option value="holo">Futuristic Holo-Quran</option>
            </select>
        </div>
    </header>
    <div class="container">
        <aside class="sidebar">
            <nav>
                <ul>
                    <li><a href="#quran" class="nav-link active" data-section="quran">Quran Viewer</a></li>
                    <li><a href="#tafsir" class="nav-link" data-section="tafsir">Personal Tafsir</a></li>
                    <li><a href="#themes" class="nav-link" data-section="themes">Thematic Linker</a></li>
                    <li><a href="#roots" class="nav-link" data-section="roots">Root Word Analyzer</a></li>
                    <li><a href="#recitation" class="nav-link" data-section="recitation">Recitation Log</a></li>
                    <li><a href="#hifz" class="nav-link" data-section="hifz">Memorization Hub</a></li>
                    <li><a href="#search" class="nav-link" data-section="search">Advanced Search</a></li>
                    <li><a href="#data" class="nav-link" data-section="data">Data Management</a></li>
                </ul>
            </nav>
        </aside>
        <main class="main-content">
            <section id="quran" class="section active" role="region" aria-labelledby="quran-heading">
                <h2 id="quran-heading">Quran Viewer</h2>
                <div class="quran-controls flex-group mb-20">
                    <label for="surah-select" class="sr-only">Select Surah</label>
                    <select id="surah-select" aria-label="Select Surah"></select>
                    <label for="ayah-select" class="sr-only">Select Ayah</label>
                    <select id="ayah-select" aria-label="Select Ayah"></select>
                </div>
                <div class="quran-controls flex-group mb-20">
                    <label for="translation-select" class="sr-only">Select Translation</label>
                    <select id="translation-select" aria-label="Select Translation">
                        <option value="urdu">Urdu (Included)</option>
                        <option value="english">English (Included)</option>
                        <option value="Bangali">Bangali (Included)</option>
                    </select>
                </div>
                <div id="quran-display" class="quran-viewer" lang="ar" dir="rtl">
                    <!-- Quran Ayahs will be loaded here -->
                    <p class="text-center">Select a Surah and Ayah to start.</p>
                </div>
                <div id="word-translation-area" class="mt-20">
                    <!-- Word translation or full ayah translation on word click -->
                    <p class="text-center">Click on an Arabic word to see its translation.</p>
                </div>
            </section>
            <section id="tafsir" class="section" role="region" aria-labelledby="tafsir-heading">
                <h2 id="tafsir-heading">Personal Tafsir Builder</h2>
                <p>Write your notes and reflections for the current Ayah.</p>
                <div id="current-ayah-tafsir" class="ayah mb-20">
                    <!-- Current Ayah will be displayed here -->
                    <p class="text-center">Navigate to an Ayah in the Quran Viewer to add Tafsir.</p>
                </div>
                <div class="tafsir-editor">
                    <label for="tafsir-notes">Your Tafsir Notes:</label>
                    <textarea id="tafsir-notes"
                        placeholder="Enter your personal notes, interpretations, and reflections here..."></textarea>
                    <button id="save-tafsir-btn">Save Tafsir</button>
                    <p id="tafsir-status" aria-live="polite"></p>
                </div>
            </section>
            <section id="themes" class="section" role="region" aria-labelledby="themes-heading">
                <h2 id="themes-heading">Thematic Linker Pro</h2>
                <p>Create and manage themes, and link Ayahs to them.</p>
                <div class="theme-manager mb-20">
                    <h3>Manage Themes</h3>
                    <div class="flex-group mb-10">
                        <label for="new-theme-name" class="sr-only">New Theme Name</label>
                        <input type="text" id="new-theme-name" placeholder="New Theme Name">
                        <label for="parent-theme-select" class="sr-only">Parent Theme (Optional)</label>
                        <select id="parent-theme-select" aria-label="Parent Theme (Optional)">
                            <option value="">-- No Parent --</option>
                            <!-- Options populated by JS -->
                        </select>
                        <button id="add-theme-btn">Add Theme</button>
                    </div>
                    <div class="theme-list">
                        <h4>Existing Themes</h4>
                        <ul id="themes-list">
                            <!-- Themes populated by JS -->
                            <li>No themes added yet.</li>
                        </ul>
                    </div>
                    <p id="theme-manager-status" aria-live="polite"></p>
                </div>
                <div class="theme-linker">
                    <h3>Link Current Ayah (<span id="current-ayah-theme-ref">N/A</span>)</h3>
                    <div id="current-ayah-theme-text" class="ayah mb-20">
                        <!-- Current Ayah text will be displayed here -->
                        <p class="text-center">Navigate to an Ayah in the Quran Viewer to link themes.</p>
                    </div>
                    <label for="link-theme-select">Select Theme to Link:</label>
                    <select id="link-theme-select" aria-label="Select Theme to Link">
                        <option value="">-- Select Theme --</option>
                        <!-- Options populated by JS -->
                    </select>
                    <label for="theme-link-notes">Notes for this link (Optional):</label>
                    <textarea id="theme-link-notes"
                        placeholder="Notes on why this Ayah relates to this theme..."></textarea>
                    <button id="link-ayah-to-theme-btn">Link Ayah</button>
                    <p id="theme-linker-status" aria-live="polite"></p>
                    <h4 class="mt-20">Ayahs Linked to Selected Theme: <span id="linked-theme-name">N/A</span></h4>
                    <ul id="linked-ayahs-list">
                        <!-- Linked ayahs populated by JS -->
                        <li>Select a theme above to see linked ayahs.</li>
                    </ul>
                </div>
            </section>
            <section id="roots" class="section" role="region" aria-labelledby="roots-heading">
                <h2 id="roots-heading">Root Word Analyzer & Concordance</h2>
                <p>Input an Arabic root word to find occurrences in the Quran.</p>
                <div class="root-analyzer-form mb-20">
                    <div class="flex-group mb-10">
                        <label for="root-input" class="sr-only">Arabic Root Word</label>
                        <input type="text" id="root-input"
                            placeholder="Enter Arabic Root (e.g., ق-و-ل) or (ع ل م) or (ر۔ب)" lang="ar" dir="rtl">
                        <button id="analyze-root-btn">Analyze Root</button>
                    </div>
                    <label for="root-description">Description/Notes for this Root (Optional):</label>
                    <textarea id="root-description" placeholder="Your notes on this root's meaning..."></textarea>
                    <button id="save-root-notes-btn">Save Root Notes</button>
                    <p id="root-status" aria-live="polite"></p>
                </div>
                <!-- View Switcher -->
                <div class="view-switcher mb-10 flex-group" style="justify-content: flex-start;">
                    <label style="margin-bottom:0;">View Mode: </label>
                    <div>
                        <input type="radio" id="root-view-list" name="root-view-mode" value="list" checked>
                        <label for="root-view-list" style="margin-right: 10px; font-weight:normal;">List</label>
                    </div>
                    <div>
                        <input type="radio" id="root-view-tree" name="root-view-mode" value="tree">
                        <label for="root-view-tree" style="font-weight:normal;">Tree Graph</label>
                    </div>
                </div>
                <div class="root-results">
                    <h3>Occurrences Found for: <span id="analyzed-root-term">N/A</span></h3>
                    <!-- List View Container -->
                    <ul id="root-occurrences-list" class="root-view-content active-view">
                        <li>Enter a root word and click "Analyze Root".</li>
                    </ul>
                    <!-- Tree View Container -->
                    <div id="root-network-graph-container" class="root-view-content" style="display: none;">
                        <p id="root-graph-placeholder" class="text-center" style="display:none; margin: 20px 0;">Graph
                            will appear here after analysis.</p>
                        <div id="root-network-graph"
                            style="width: 100%; height: 500px; border: 1px solid var(--color-border);"></div>
                        <!-- Pagination Controls for Graph -->
                        <div id="root-graph-pagination-controls" class="flex-group mt-10"
                            style="justify-content: center; display: none;">
                            <button id="prev-root-graph-page-btn" disabled>« Previous</button>
                            <span id="root-graph-page-info" style="margin: 0 15px; font-weight: normal;">Page 1 of
                                1</span>
                            <button id="next-root-graph-page-btn" disabled>Next »</button>
                        </div>
                    </div>
                </div>
                <!-- Custom Popup for Vis.js Graph Nodes -->
                <div id="root-node-popup" class="custom-popup"
                    style="font-family: var(--font-arabic); direction: rtl; text-align: right;">
                    <!-- Popup content will be injected here by JavaScript -->
                </div>
            </section>
            <section id="recitation" class="section" role="region" aria-labelledby="recitation-heading">
                <h2 id="recitation-heading">Comparative Recitation Log</h2>
                <p>Log your listening sessions to different Qaris.</p>
                <div class="recitation-log-form mb-20">
                    <h3>Add Log Entry</h3>
                    <div class="flex-group mb-10">
                        <label for="rec-surah-select" class="sr-only">Surah</label>
                        <select id="rec-surah-select" aria-label="Surah"></select>
                        <label for="rec-ayah-start" class="sr-only">Ayah Start</label>
                        <input type="number" id="rec-ayah-start" required placeholder="Ayah Start" min="1">
                        <label for="rec-ayah-end" class="sr-only">Ayah End</label>
                        <input type="number" id="rec-ayah-end" required placeholder="Ayah End" min="1">
                    </div>
                    <div class="flex-group mb-10">
                        <label for="rec-qari" class="sr-only">Qari/Source</label>
                        <input type="text" id="rec-qari"
                            placeholder="Qari or Source (e.g., Mishary Alafasy, Local Masjid Imam)">
                        <label for="rec-date" class="sr-only">Date</label>
                        <input type="date" id="rec-date" aria-label="Date">
                    </div>
                    <label for="rec-notes">Notes (Tajweed, Style, Impact):</label>
                    <textarea id="rec-notes" placeholder="Notes on Tajweed, style, emotional impact..."></textarea>
                    <button id="save-recitation-btn">Save Log Entry</button>
                    <p id="recitation-status" aria-live="polite"></p>
                </div>
                <div class="recitation-list">
                    <h3>Log Entries</h3>
                    <ul id="recitations-list">
                        <!-- Log entries populated by JS -->
                        <li>No entries logged yet.</li>
                    </ul>
                </div>
            </section>
            <section id="hifz" class="section" role="region" aria-labelledby="hifz-heading">
                <h2 id="hifz-heading">Memorization Hub</h2>
                <p>Track your Hifz progress and review schedule.</p>
                <div class="hifz-controls flex-group mb-20">
                    <label for="hifz-surah-select" class="sr-only">Select Surah for Hifz</label>
                    <select id="hifz-surah-select" aria-label="Select Surah for Hifz"></select>
                </div>
                <div id="hifz-ayahs-list">
                    <!-- List of ayahs for the selected surah with status/controls -->
                    <p class="text-center">Select a Surah to track Hifz progress.</p>
                </div>
                <p id="hifz-status" aria-live="polite"></p>
            </section>
            <section id="search" class="section" role="region" aria-labelledby="search-heading">
                <h2 id="search-heading">Advanced Search</h2>
                <p>Search across Quran text, translations, and your personal data.</p>
                <div class="search-form mb-20">
                    <label for="search-input" class="sr-only">Search Term</label>
                    <input type="text" id="search-input" placeholder="Enter search term">
                    <div class="search-options mb-10" role="group" aria-label="Search Scope">
                        <label><input type="checkbox" class="search-scope" value="quran-arabic" checked> Quran
                            Arabic</label>
                        <label><input type="checkbox" class="search-scope" value="quran-translation" checked> Quran
                            Translation</label>
                        <label><input type="checkbox" class="search-scope" value="tafsir"> Personal Tafsir</label>
                        <label><input type="checkbox" class="search-scope" value="themes"> Theme Notes</label>
                        <label><input type="checkbox" class="search-scope" value="roots"> Root Notes</label>
                        <label><input type="checkbox" class="search-scope" value="recitation"> Recitation Notes</label>
                        <label><input type="checkbox" class="search-scope" value="hifz"> Hifz Notes</label>
                    </div>
                    <button id="perform-search-btn">Search</button>
                    <p id="search-status" aria-live="polite"></p>
                </div>
                <div class="search-results">
                    <h3>Search Results</h3>
                    <ul id="search-results-list">
                        <!-- Search results populated by JS -->
                        <li>Enter a search term and click "Search".</li>
                    </ul>
                </div>
            </section>
            <section id="data" class="section" role="region" aria-labelledby="data-heading">
                <h2 id="data-heading">Data Management</h2>
                <p>Manage your personal data (Tafsir, Themes, Roots, Logs, Hifz).</p>
                <div class="settings-section mb-20">
                    <h3>Backup Data</h3>
                    <p>Export your personal data as a JSON file.</p>
                    <button id="export-data-btn">Export Data</button>
                    <p id="export-status" aria-live="polite"></p>
                </div>
                <div class="settings-section mb-20">
                    <h3>Restore Data</h3>
                    <p>Import your personal data from a JSON file. This will overwrite existing data.</p>
                    <label for="import-file" class="sr-only">Choose JSON file to import</label>
                    <input type="file" id="import-file" accept="application/json">
                    <button id="import-data-btn" disabled>Import Data</button>
                    <p id="import-status" aria-live="polite"></p>
                </div>
                <div class="settings-section">
                    <h3>Clear All Personal Data</h3>
                    <p class="mb-10" style="color: var(--color-error);">Warning: This will permanently delete ALL your
                        personal Tafsir, Themes, Roots, Logs, and Hifz data.</p>
                    <button id="clear-data-btn" style="background-color: var(--color-error);">Clear All Data</button>
                    <p id="clear-status" aria-live="polite"></p>
                </div>
                <div class="settings-section mb-20">
                    <h3>Export Personal Tafsir to Word (.docx)</h3>
                    <p>Generates a .docx file of all your Tafsir notes (basic styling).</p>
                    <button id="export-tafsir-to-docx-btn">Export Tafsir to .docx</button>
                    <p id="export-tafsir-docx-status" aria-live="polite"></p>
                </div>
            </section>
        </main>
    </div>
    <!-- Modal for Theme Ayahs -->
    <div id="themeAyahsModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="themeAyahsModalTitle">
        <div class="modal-content">
            <span class="close-button" aria-label="Close Theme Ayahs Modal">&times;</span>
            <h3 id="themeAyahsModalTitle">Ayahs Linked to Theme: <span id="modal-theme-name"></span></h3>
            <ul id="modal-linked-ayahs-list">
                <!-- Linked ayahs populated here -->
            </ul>
        </div>
    </div>
    <!-- Modal for Root Occurrences -->
    <div id="rootOccurrencesModal" class="modal" role="dialog" aria-modal="true"
        aria-labelledby="rootOccurrencesModalTitle">
        <div class="modal-content">
            <span class="close-button" aria-label="Close Root Occurrences Modal">&times;</span>
            <h3 id="rootOccurrencesModalTitle">Occurrences for Root: <span id="modal-root-term"></span></h3>
            <ul id="modal-root-occurrences-list">
                <!-- Root occurrences populated here -->
            </ul>
        </div>
    </div>
    <script>
        const DB_NAME = 'NurAlQuranStudioDBz';
        const DB_VERSION = 7; // << UPDATED for new word_metadata store and word_translations key
        let db;
        let rootNetwork = null; // To hold the vis.js network instance
        let rootNodePopupEl = null; // To hold the popup DOM element
        let activeRootNodeIdForPopup = null; // Track which node's popup is open
        let allRootOccurrencesCache = []; // To store all occurrences for the current analyzed root
        let currentRootGraphPage = 1;
        const rootGraphItemsPerPage = 20; // Number of occurrence nodes per page
        const STORE_QURAN = 'quran';
        const STORE_TAFSIR = 'tafsir';
        const STORE_THEMES = 'themes';
        const STORE_THEME_AYAHS = 'theme_ayahs';
        const STORE_ROOTS = 'roots';
        const STORE_ROOT_AYAHS = 'root_ayahs';
        const STORE_RECITATIONS = 'recitations';
        const STORE_HIFZ = 'hifz';
        const STORE_SETTINGS = 'settings';
        const STORE_WORD_TRANSLATIONS = 'word_translations'; // Keyed by word_id
        const STORE_WORD_METADATA = 'word_metadata';         // Keyed by word_id, indexed by location
        let totalProgressUnits = 0;
        let completedProgressUnits = 0;
        const WORD_TRANSLATION_FILE = 'data5 new.AM'; // Contains word_id, ur_meaning, en_meaning
        const WORD_METADATA_FILE = 'word2.AM';       // Contains word_id, surah, ayah, word_postion
        let currentSurah = 1;
        let currentAyah = 1;
        let totalAyahsInSurah = 7; // Default for Surah 1
        let quranDataLoaded = false;
        const juzStartSurahs = [0, 1, 2, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 20, 21, 22, 23, 25, 26, 27, 29, 33, 36, 39, 41, 46, 51, 58, 67, 78]; // Example: Surah where Juz N+1 starts
        const juzStartAyahs = [0, 1, 142, 253, 93, 24, 148, 82, 111, 41, 88, 93, 6, 53, 1, 1, 75, 1, 1, 56, 47, 31, 28, 36, 46, 60, 31, 1, 31, 28, 22, 47, 1, 31, 1, 1, 1]; // Example: Ayah where Juz N+1 starts (for the surah above)
        const juzBoundariesData = [
            { juz: 1, name: "Alif laam meem (آلم)", startSurah: 1, startAyah: 1 },
            { juz: 2, name: "Sayaqulu (سَيَقُولُ)", startSurah: 2, startAyah: 142 },
            { juz: 3, name: "Tilka r Rusulu (تِلْكَ الرُّسُلُ)", startSurah: 2, startAyah: 253 },
            { juz: 4, name: "Lan Tana Loo (لَنْ تَنَالُوا)", startSurah: 3, startAyah: 93 }, // 92 in some, 93 in others. Using 93 as per some common divisions.
            { juz: 5, name: "Wal Mohsanat (وَالْمُحْصَنَاتُ)", startSurah: 4, startAyah: 24 },
            { juz: 6, name: "La Yahubbullah (لَا يُحِبُّ اللَّهُ)", startSurah: 4, startAyah: 148 },
            { juz: 7, name: "Wa Iza Samiu (وَإِذَا سَمِعُوا)", startSurah: 5, startAyah: 82 }, // some say 83
            { juz: 8, name: "Wa Lau Annana (وَلَوْ أَنَّنَا)", startSurah: 6, startAyah: 111 },
            { juz: 9, name: "Qalal Malao (قَالَ الْمَلَأُ)", startSurah: 7, startAyah: 88 },
            { juz: 10, name: "Wa A'lamu (وَاعْلَمُوا)", startSurah: 8, startAyah: 41 },
            { juz: 11, name: "Yatazeroon (يَعْتَذِرُونَ)", startSurah: 9, startAyah: 93 }, // some say 94
            { juz: 12, name: "Wa Mamin Da'abat (وَمَا مِنْ دَابَّةٍ)", startSurah: 11, startAyah: 6 },
            { juz: 13, name: "Wa Ma Ubiroo (وَمَا أُبَرِّئُ)", startSurah: 12, startAyah: 53 },
            { juz: 14, name: "Rubama (رُبَمَا)", startSurah: 15, startAyah: 1 }, // Al-Hijr
            { juz: 15, name: "Subhanallazi (سُبْحَانَ الَّذِي)", startSurah: 17, startAyah: 1 }, // Al-Isra
            { juz: 16, name: "Qal Alam (قَالَ أَلَمْ)", startSurah: 18, startAyah: 75 }, // Al-Kahf
            { juz: 17, name: "Aqtarabo (اقْتَرَبَ لِلنَّاسِ)", startSurah: 21, startAyah: 1 }, // Al-Anbiya
            { juz: 18, name: "Qadd Aflaha (قَدْ أَفْلَحَ)", startSurah: 23, startAyah: 1 }, // Al-Mu'minun
            { juz: 19, name: "Wa Qalallazina (وَقَالَ الَّذِينَ)", startSurah: 25, startAyah: 21 }, // Al-Furqan
            { juz: 20, name: "A'man Khalaq (أَمَّنْ خَلَقَ)", startSurah: 27, startAyah: 56 }, // An-Naml (some 60)
            { juz: 21, name: "Utlu Ma Oohi (اتْلُ مَا أُوحِيَ)", startSurah: 29, startAyah: 46 }, // Al-'Ankabut
            { juz: 22, name: "Wa Manyaqnut (وَمَنْ يَقْنُتْ)", startSurah: 33, startAyah: 31 }, // Al-Ahzab
            { juz: 23, name: "Wa Mali (وَمَا لِيَ)", startSurah: 36, startAyah: 28 }, // Ya-Sin (some 22)
            { juz: 24, name: "Faman Azlam (فَمَنْ أَظْلَمُ)", startSurah: 39, startAyah: 32 }, // Az-Zumar
            { juz: 25, name: "Elahe Yuruddo (إِلَيْهِ يُرَدُّ)", startSurah: 41, startAyah: 47 }, // Fussilat
            { juz: 26, name: "Ha'a Meem (حم)", startSurah: 46, startAyah: 1 }, // Al-Ahqaf
            { juz: 27, name: "Qala Fama Khatbukum (قَالَ فَمَا خَطْبُكُمْ)", startSurah: 51, startAyah: 31 }, // Adh-Dhariyat
            { juz: 28, name: "Qadd Sami Allah (قَدْ سَمِعَ اللَّهُ)", startSurah: 58, startAyah: 1 }, // Al-Mujadila
            { juz: 29, name: "Tabarakallazi (تَبَارَكَ الَّذِي)", startSurah: 67, startAyah: 1 }, // Al-Mulk
            { juz: 30, name: "Amma Yatasa'aloon (عَمَّ يَتَسَاءَلُونَ)", startSurah: 78, startAyah: 1 } // An-Naba
        ];
        const staticQuranicThemes = [
            { id: 'static_01', name: "Ayat al-Kursi (Verse of the Throne)", exampleSurah: 2, exampleAyah: 255, description: "Greatest verse, protection, affirmation of Allah's sovereignty." },
            { id: 'static_02', name: "Surah Al-Fatihah (The Opening)", exampleSurah: 1, exampleAyah: 1, description: "Essence of the Quran, recited in every prayer." },
            { id: 'static_03', name: "Surah Yasin (Heart of the Quran)", exampleSurah: 36, exampleAyah: 1, description: "Recited for blessings, ease, and for the deceased." },
            { id: 'static_04', name: "Surah Al-Mulk (The Dominion - Protector from Grave)", exampleSurah: 67, exampleAyah: 1, description: "Recited for protection from torment of the grave." },
            { id: 'static_05', name: "Surah Al-Waqi'ah (The Inevitable - Sustenance)", exampleSurah: 56, exampleAyah: 1, description: "Recited for protection against poverty and for sustenance." },
            { id: 'static_06', name: "Surah Ar-Rahman (The Most Merciful - Bride of Quran)", exampleSurah: 55, exampleAyah: 1, description: "Highlights Allah's bounties and mercy." },
            { id: 'static_07', name: "Surah Al-Kahf (The Cave - Protection from Dajjal)", exampleSurah: 18, exampleAyah: 1, description: "Recited on Fridays, protection from Dajjal, stories of guidance." },
            { id: 'static_08', name: "Last two Ayahs of Surah Al-Baqarah", exampleSurah: 2, exampleAyah: 285, description: "Sufficient for protection and blessings if recited at night." },
            { id: 'static_09', name: "Surah Al-Ikhlas (Sincerity - Equals 1/3rd Quran)", exampleSurah: 112, exampleAyah: 1, description: "Pure monotheism, immense reward." },
            { id: 'static_10', name: "Surah Al-Falaq (The Daybreak - Protection)", exampleSurah: 113, exampleAyah: 1, description: "Seeking refuge from evil." },
            { id: 'static_11', name: "Surah An-Nas (Mankind - Protection)", exampleSurah: 114, exampleAyah: 1, description: "Seeking refuge from whispers of Shaytan." },
            { id: 'static_12', name: "Ayah for seeking Forgiveness (Syed-ul-Istighfar concept)", exampleSurah: 3, exampleAyah: 135, description: "Verses encouraging repentance and seeking forgiveness." }, // Rabbana zalamna anfusana
            { id: 'static_13', name: "Dua of Yunus (AS) / Ayat-e-Karima", exampleSurah: 21, exampleAyah: 87, description: "For relief from distress: La ilaha illa anta subhanaka inni kuntu minaz-zalimin." },
            { id: 'static_14', name: "Verse of Light (Ayat an-Nur)", exampleSurah: 24, exampleAyah: 35, description: "Metaphorical description of Allah's light and guidance." },
            { id: 'static_15', name: "Four Quls (Al-Kafirun, Al-Ikhlas, Al-Falaq, An-Nas)", exampleSurah: 109, exampleAyah: 1, description: "Collective term for these four protective Surahs." }, // Starts with Al-Kafirun
            { id: 'static_16', name: "Guidance in Decision Making (Istikhara concept)", exampleSurah: 2, exampleAyah: 216, description: "Trusting Allah's knowledge in what is good/bad for us." },
            { id: 'static_17', name: "Marriage and Family", exampleSurah: 30, exampleAyah: 21, description: "Signs of Allah in creating spouses for tranquility and affection." },
            { id: 'static_18', name: "Dealing with Grief and Loss", exampleSurah: 2, exampleAyah: 156, description: "Inna lillahi wa inna ilayhi raji'un - Turning to Allah in times of calamity." },
            { id: 'static_19', name: "Financial Dealings & Charity", exampleSurah: 2, exampleAyah: 261, description: "Parable of those who spend in Allah's way." },
            { id: 'static_20', name: "Good Conduct and Speech", exampleSurah: 17, exampleAyah: 53, description: "Speak that which is best." },
            { id: 'static_21', name: "Patience in Adversity", exampleSurah: 39, exampleAyah: 10, description: "The patient will be given their reward without account." },
            { id: 'static_22', name: "Seeking Knowledge", exampleSurah: 20, exampleAyah: 114, description: "Rabbi zidni ilma - My Lord, increase me in knowledge." },
            { id: 'static_23', name: "Respect for Parents", exampleSurah: 17, exampleAyah: 23, description: "Decree to not worship except Him, and to parents, good treatment." },
            { id: 'static_24', name: "Maintaining Ties of Kinship", exampleSurah: 4, exampleAyah: 1, description: "Fear Allah through whom you demand your mutual rights, and reverence the wombs." },
            { id: 'static_25', name: "Trust in Allah (Tawakkul)", exampleSurah: 65, exampleAyah: 3, description: "And whoever relies upon Allah - then He is sufficient for him." },
            { id: 'static_26', name: "Prohibition of Backbiting & Slander", exampleSurah: 49, exampleAyah: 12, description: "Avoid suspicion, do not spy or backbite each other." },
            { id: 'static_27', name: "Importance of Justice", exampleSurah: 5, exampleAyah: 8, description: "Be just; that is nearer to righteousness." },
            { id: 'static_28', name: "Humility", exampleSurah: 25, exampleAyah: 63, description: "Servants of the Most Merciful are those who walk upon the earth easily..." },
            { id: 'static_29', name: "Gratitude for Blessings", exampleSurah: 16, exampleAyah: 114, description: "So eat of what Allah has provided you lawful and good and be grateful for the favor of Allah." },
            { id: 'static_30', name: "Remembrance of Allah (Dhikr)", exampleSurah: 13, exampleAyah: 28, description: "Unquestionably, by the remembrance of Allah hearts are assured." },
            { id: 'static_31', name: "Overcoming Anxiety & Stress", exampleSurah: 94, exampleAyah: 5, description: "For indeed, with hardship [will be] ease." }, // Surah Ash-Sharh
            { id: 'static_32', name: "The Power of Dua (Supplication)", exampleSurah: 40, exampleAyah: 60, description: "And your Lord says, 'Call upon Me; I will respond to you.'" },
            { id: 'static_33', name: "Warning Against Arrogance", exampleSurah: 31, exampleAyah: 18, description: "And do not turn your cheek [in contempt] toward people..." },
            { id: 'static_34', name: "Importance of Consultation (Shura)", exampleSurah: 42, exampleAyah: 38, description: "...and whose affair is [determined by] consultation among themselves..." },
            { id: 'static_35', name: "Forgiving Others", exampleSurah: 64, exampleAyah: 14, description: "...but if you pardon and overlook and forgive - then indeed, Allah is Forgiving and Merciful." },
            { id: 'static_36', name: "Unity of the Ummah", exampleSurah: 3, exampleAyah: 103, description: "And hold firmly to the rope of Allah all together and do not become divided." },
            { id: 'static_37', name: "The Brevity of Worldly Life", exampleSurah: 57, exampleAyah: 20, description: "Know that the life of this world is but amusement and diversion..." },
            { id: 'static_38', name: "Reward for Good Deeds", exampleSurah: 99, exampleAyah: 7, description: "So whoever does an atom's weight of good will see it." },
            { id: 'static_39', name: "Call to Reflection (Tadabbur)", exampleSurah: 47, exampleAyah: 24, description: "Then do they not reflect upon the Qur'an, or are there locks upon [their] hearts?" },
            { id: 'static_40', name: "Friday Prayer (Jumu'ah)", exampleSurah: 62, exampleAyah: 9, description: "O you who have believed, when the adhan is called for the prayer on the day of Jumu'ah..." }
        ];
        function getJuzFromSurahAyah(surah, ayah) {
            if (isNaN(surah) || isNaN(ayah) || surah < 1 || ayah < 1) return 1; // Default for invalid input
            for (let i = juzBoundariesData.length - 1; i >= 0; i--) {
                const boundary = juzBoundariesData[i];
                if (surah > boundary.startSurah || (surah === boundary.startSurah && ayah >= boundary.startAyah)) {
                    return boundary.juz;
                }
            }
            return 1; // Should not happen if data is correct and input is valid Quran range
        }
        const surahNames = [
            "Al-Fatihah", "Al-Baqarah", "Al 'Imran", "An-Nisa'", "Al-Ma'idah", "Al-An'am", "Al-A'raf", "Al-Anfal", "At-Tawbah", "Yunus",
            "Hud", "Yusuf", "Ar-Ra'd", "Ibrahim", "Al-Hijr", "An-Nahl", "Al-Isra'", "Al-Kahf", "Maryam", "Taha",
            "Al-Anbya'", "Al-Hajj", "Al-Mu'minun", "An-Nur", "Al-Furqan", "Ash-Shu'ara'", "An-Naml", "Al-Qasas", "Al-'Ankabut", "Ar-Rum",
            "Luqman", "As-Sajdah", "Al-Ahzab", "Saba'", "Fatir", "Ya-Sin", "As-Saffat", "Sad", "Az-Zumar", "Ghafir",
            "Fussilat", "Ash-Shura", "Az-Zukhruf", "Ad-Dukhan", "Al-Jathiyah", "Al-Ahqaf", "Muhammad", "Al-Fath", "Al-Hujurat", "Qaf",
            "Adh-Dhariyat", "At-Tur", "An-Najm", "Al-Qamar", "Ar-Rahman", "Al-Waqi'ah", "Al-Hadid", "Al-Mujadilah", "Al-Hashr", "Al-Mumtahanah",
            "As-Saff", "Al-Jumu'ah", "Al-Munafiqun", "At-Taghabun", "At-Talaq", "At-Tahrim", "Al-Mulk", "Al-Qalam", "Al-Haqqah", "Al-Ma'arij",
            "Nuh", "Al-Jinn", "Al-Muzzammil", "Al-Muddaththir", "Al-Qiyamah", "Al-Insan", "Al-Mursalat", "An-Naba'", "An-Nazi'at", "'Abasa",
            "At-Takwir", "Al-Infitar", "Al-Mutaffifin", "Al-Inshiqaq", "Al-Buruj", "At-Tariq", "Al-A'la", "Al-Ghashiyah", "Al-Fajr", "Al-Balad",
            "Ash-Shams", "Al-Layl", "Ad-Duha", "Ash-Sharh", "At-Tin", "Al-'Alaq", "Al-Qadr", "Al-Bayyinah", "Az-Zalzalah", "Al-'Adiyat",
            "Al-Qari'ah", "At-Takathur", "Al-'Asr", "Al-Humazah", "Al-Fil", "Quraysh", "Al-Ma'un", "Al-Kawthar", "Al-Kafirun", "An-Nasr",
            "Al-Masad", "Al-Ikhlas", "Al-Falaq", "An-Nas"
        ];
        const surahAyahCounts = [
            0, 7, 286, 200, 176, 120, 165, 206, 75, 129, 109, 123, 111, 43, 52, 99, 128, 111, 110, 98, 135, 112, 78, 118, 64, 77, 227, 93, 88, 69,
            60, 34, 30, 73, 54, 45, 83, 182, 88, 75, 85, 54, 53, 89, 59, 37, 35, 38, 29, 18, 45, 60, 49, 62, 55, 78, 96, 29, 22, 24,
            13, 14, 11, 11, 18, 12, 12, 30, 52, 52, 44, 28, 28, 20, 56, 40, 31, 50, 40, 46, 42, 29, 19, 36, 25, 22, 17, 19, 26, 30,
            20, 15, 21, 11, 8, 5, 19, 5, 8, 8, 11, 11, 8, 3, 9, 5, 4, 7, 3, 6, 3, 5, 4, 5, 6
        ];
        const TRANSLATION_CONFIG = {
            urdu: { file: 'data new.AM', lang: 'ur', dir: 'rtl', label: 'Urdu' },
            english: { file: 'dataENG.AM', lang: 'en', dir: 'ltr', label: 'English' },
            Bangali: { file: 'dataBNG.AM', lang: 'bn', dir: 'ltr', label: 'Bangali' }
        };
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    const oldVersion = event.oldVersion;
                    console.log(`IndexedDB upgrade needed from version ${oldVersion} to ${DB_VERSION}.`);
                    if (!db.objectStoreNames.contains(STORE_QURAN)) {
                        db.createObjectStore(STORE_QURAN, { keyPath: ['surah', 'ayah'] });
                    } else if (oldVersion < 2) { // Example for multi-translation support (adjust version if needed)
                        console.log(`Upgrading ${STORE_QURAN} store schema. Clearing existing data for re-population.`);
                        db.deleteObjectStore(STORE_QURAN);
                        db.createObjectStore(STORE_QURAN, { keyPath: ['surah', 'ayah'] });
                    }
                    if (!db.objectStoreNames.contains(STORE_TAFSIR)) {
                        db.createObjectStore(STORE_TAFSIR, { keyPath: ['surah', 'ayah'] });
                    }
                    if (!db.objectStoreNames.contains(STORE_THEMES)) {
                        db.createObjectStore(STORE_THEMES, { keyPath: 'id', autoIncrement: true });
                    }
                    if (!db.objectStoreNames.contains(STORE_THEME_AYAHS)) {
                        const themeAyahsStore = db.createObjectStore(STORE_THEME_AYAHS, { keyPath: 'id', autoIncrement: true });
                        themeAyahsStore.createIndex('themeId', 'themeId', { unique: false });
                        themeAyahsStore.createIndex('surahAyah', ['surah', 'ayah'], { unique: false });
                    }
                    if (!db.objectStoreNames.contains(STORE_ROOTS)) {
                        db.createObjectStore(STORE_ROOTS, { keyPath: 'id', autoIncrement: true });
                    }
                    if (!db.objectStoreNames.contains(STORE_ROOT_AYAHS)) {
                        const rootAyahsStore = db.createObjectStore(STORE_ROOT_AYAHS, { keyPath: 'id', autoIncrement: true });
                        rootAyahsStore.createIndex('rootId', 'rootId', { unique: false });
                        rootAyahsStore.createIndex('surahAyah', ['surah', 'ayah'], { unique: false });
                        rootAyahsStore.createIndex('word', 'word', { unique: false });
                    }
                    if (!db.objectStoreNames.contains(STORE_RECITATIONS)) {
                        const recitationStore = db.createObjectStore(STORE_RECITATIONS, { keyPath: 'id', autoIncrement: true });
                        recitationStore.createIndex('surah', 'surah', { unique: false });
                        recitationStore.createIndex('date', 'date', { unique: false });
                    }
                    if (!db.objectStoreNames.contains(STORE_HIFZ)) {
                        const hifzStore = db.createObjectStore(STORE_HIFZ, { keyPath: ['surah', 'ayah'] });
                        hifzStore.createIndex('status', 'status', { unique: false });
                        hifzStore.createIndex('nextReviewDate', 'nextReviewDate', { unique: false });
                    }
                    if (!db.objectStoreNames.contains(STORE_SETTINGS)) {
                        db.createObjectStore(STORE_SETTINGS, { keyPath: 'name' });
                    }
                    if (db.objectStoreNames.contains(STORE_WORD_TRANSLATIONS)) {
                        if (oldVersion < 7) { // Version 7 introduced word_id keying
                            console.log(`Re-creating '${STORE_WORD_TRANSLATIONS}' for DB_VERSION ${DB_VERSION} to be keyed by 'word_id'.`);
                            db.deleteObjectStore(STORE_WORD_TRANSLATIONS);
                            db.createObjectStore(STORE_WORD_TRANSLATIONS, { keyPath: 'word_id' });
                        }
                    } else {
                        console.log(`Creating new '${STORE_WORD_TRANSLATIONS}' store, keyed by 'word_id'.`);
                        db.createObjectStore(STORE_WORD_TRANSLATIONS, { keyPath: 'word_id' });
                    }
                    if (!db.objectStoreNames.contains(STORE_WORD_METADATA)) {
                        console.log(`Creating new '${STORE_WORD_METADATA}' store for DB_VERSION ${DB_VERSION}.`);
                        const wordMetadataStore = db.createObjectStore(STORE_WORD_METADATA, { keyPath: 'word_id' });
                        wordMetadataStore.createIndex('location_idx', ['surah', 'ayah', 'word_position'], { unique: true });
                    } else if (oldVersion < 7) { // Version 7 introduced this store
                        console.log(`Re-creating '${STORE_WORD_METADATA}' for DB_VERSION ${DB_VERSION}.`);
                        db.deleteObjectStore(STORE_WORD_METADATA);
                        const wordMetadataStore = db.createObjectStore(STORE_WORD_METADATA, { keyPath: 'word_id' });
                        wordMetadataStore.createIndex('location_idx', ['surah', 'ayah', 'word_position'], { unique: true });
                    }
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("IndexedDB opened successfully.");
                    resolve(db);
                };
                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.errorCode, event.target.error);
                    reject("Failed to open IndexedDB: " + event.target.error.message);
                };
            });
        }
        async function populateThemeSelects() {
            if (!db) return;
            const themeSelectElements = [
                document.getElementById('parent-theme-select'),
                document.getElementById('link-theme-select')
            ];
            try {
                const themes = await getAllData(STORE_THEMES);
                themeSelectElements.forEach(select => {
                    if (!select) return;
                    const preservedValue = select.value;
                    select.innerHTML = ''; // Clear existing options
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.textContent = select.id === 'parent-theme-select' ? "-- No Parent --" : "-- Select Theme --";
                    select.appendChild(defaultOption);
                    themes.forEach(theme => {
                        const option = document.createElement('option');
                        option.value = theme.id;
                        option.textContent = theme.name;
                        select.appendChild(option);
                    });
                    if (select.querySelector(`option[value="${preservedValue}"]`)) {
                        select.value = preservedValue;
                    } else {
                        select.value = ""; // Default to the "-- Select --" or "-- No Parent --" option
                    }
                });
            } catch (error) {
                console.error("Error populating theme selects:", error);
                if (typeof setStatusMessage === "function" && document.getElementById('theme-manager-status')) {
                    setStatusMessage('theme-manager-status', 'Failed to load themes for dropdowns.', true);
                }
            }
        }
        function getObjectStore(storeName, mode) {
            if (!db) {
                console.error("getObjectStore called but DB is not initialized.");
                throw new Error("Database not initialized.");
            }
            const transaction = db.transaction(storeName, mode);
            return transaction.objectStore(storeName);
        }
        async function populateThemesIndexList() {
            const themeListEl = document.getElementById('fsIndexThemeList');
            const searchInput = document.getElementById('fsThematicIndexSearchInput');
            if (!themeListEl) {
                const contentDiv = document.getElementById('fsReaderContent');
                if (contentDiv) contentDiv.innerHTML = "<p style='color:red; text-align:center;'>Error: Theme list UI element missing.</p>";
                return;
            }
            if (!searchInput) {
            }
            themeListEl.innerHTML = '<li>Loading themes...</li>'; // Initial message
            let dbThemes = [];
            try {
                if (db && typeof getAllData === "function") { // Ensure DB is open and function exists
                    dbThemes = await getAllData(STORE_THEMES);
                } else {
                }
            } catch (dbError) {
            }
            if (typeof staticQuranicThemes === 'undefined' || !Array.isArray(staticQuranicThemes)) {
                themeListEl.innerHTML = '<li>Error: Static theme data is missing.</li>';
                return;
            }
            const combinedThemes = [
                ...staticQuranicThemes.map(st => ({
                    id: st.id,
                    name: st.name,
                    isStatic: true,
                    exampleSurah: st.exampleSurah,
                    exampleAyah: st.exampleAyah,
                    description: st.description || "" // Add description for search
                })),
                ...(dbThemes || []).map(dbt => ({ // Handle if dbThemes is null/undefined
                    id: dbt.id,
                    name: dbt.name,
                    isStatic: false,
                    description: dbt.description || "" // Assuming DB themes might have a description
                }))
            ];
            let themesToDisplay = [...combinedThemes];
            const renderList = (themes) => {
                themeListEl.innerHTML = ''; // Clear previous items (like "Loading themes...")
                if (themes.length === 0) {
                    themeListEl.innerHTML = '<li>No themes found.</li>'; // This is the message you are seeing
                    return;
                }
                themes.sort((a, b) => a.name.localeCompare(b.name));
                themes.forEach(theme => {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = '#';
                    a.dataset.themeId = theme.id;
                    a.dataset.isStatic = theme.isStatic;
                    if (theme.isStatic) {
                        a.dataset.exampleSurah = theme.exampleSurah;
                        a.dataset.exampleAyah = theme.exampleAyah;
                    }
                    a.textContent = theme.name;
                    a.addEventListener('click', handleIndexThemeClick);
                    li.appendChild(a);
                    themeListEl.appendChild(li);
                });
            };
            renderList(themesToDisplay); // Render the combined list
            if (searchInput) { // Only add listener if searchInput exists
                searchInput.removeEventListener('input', themeSearchHandler); // Remove previous listener
                searchInput.addEventListener('input', themeSearchHandler);
            }
        }
        function themeSearchHandler(e) {
            const themeListEl = document.getElementById('fsIndexThemeList'); // Re-fetch in handler scope
            if (!themeListEl) return;
            const searchTerm = e.target.value.toLowerCase().trim();
            let currentDbThemes = [];
            if (db && typeof getAllData === "function") {
                getAllData(STORE_THEMES).then(fetchedDbThemes => { // Asynchronous, this logic flow for live search needs care
                    currentDbThemes = fetchedDbThemes || [];
                    filterAndRender(currentDbThemes);
                }).catch(() => filterAndRender([])); // Handle error by filtering static only
            } else {
                filterAndRender([]);
            }
            function filterAndRender(dbThemesForFilter) {
                const allCombinedForSearch = [
                    ...staticQuranicThemes.map(st => ({ id: st.id, name: st.name, isStatic: true, exampleSurah: st.exampleSurah, exampleAyah: st.exampleAyah, description: st.description || "" })),
                    ...(dbThemesForFilter).map(dbt => ({ id: dbt.id, name: dbt.name, isStatic: false, description: dbt.description || "" }))
                ];
                let filteredThemes;
                if (!searchTerm) {
                    filteredThemes = [...allCombinedForSearch];
                } else {
                    filteredThemes = allCombinedForSearch.filter(theme =>
                        theme.name.toLowerCase().includes(searchTerm) ||
                        (theme.description && theme.description.toLowerCase().includes(searchTerm)) // Also search description
                    );
                }
                themeListEl.innerHTML = '';
                if (filteredThemes.length === 0) {
                    themeListEl.innerHTML = '<li>No themes match your search.</li>';
                    return;
                }
                filteredThemes.sort((a, b) => a.name.localeCompare(b.name));
                filteredThemes.forEach(theme => {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = '#';
                    a.dataset.themeId = theme.id;
                    a.dataset.isStatic = theme.isStatic;
                    if (theme.isStatic) {
                        a.dataset.exampleSurah = theme.exampleSurah;
                        a.dataset.exampleAyah = theme.exampleAyah;
                    }
                    a.textContent = theme.name;
                    a.addEventListener('click', handleIndexThemeClick);
                    li.appendChild(a);
                    themeListEl.appendChild(li);
                });
            }
        }
        function addData(storeName, data) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.add(data);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error adding data to ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function putData(storeName, data) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.put(data);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error putting data to ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function getData(storeName, key) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readonly');
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error getting data from ${storeName} with key ${key}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function getAllData(storeName) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readonly');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error getting all data from ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function deleteData(storeName, key) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.delete(key);
                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error(`Error deleting data from ${storeName} with key ${key}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function clearStore(storeName) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error(`Error clearing store ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        async function loadQuranData() {
            completedProgressUnits = 0;
            totalProgressUnits = 0;
            const WEIGHT_CHECK_SETTINGS = 1;
            const WEIGHT_FETCH_FILE = 2;
            const WEIGHT_PARSE_QURAN_FILE = 8; // Per full Quran text file
            const WEIGHT_PARSE_WORD_FILE = 12; // Per word data file (translations or metadata)
            const WEIGHT_DB_TRANSACTION_SETUP = 2;
            const WEIGHT_DB_TRANSACTION_ITEM = 0.01; // Small weight per item stored
            const WEIGHT_DB_TRANSACTION_COMPLETE = 5;
            try {
                const settingsLoadedQuran = await getData(STORE_SETTINGS, 'quranDataLoaded').catch(() => null);
                const settingsLoadedWordTranslations = await getData(STORE_SETTINGS, 'wordTranslationsLoaded').catch(() => null);
                const settingsLoadedWordMetadata = await getData(STORE_SETTINGS, 'wordMetadataLoaded').catch(() => null);
                const lastLoadedVersionEntry = await getData(STORE_SETTINGS, 'lastLoadedDBVersion').catch(() => null);
                const lastLoadedVersion = lastLoadedVersionEntry ? lastLoadedVersionEntry.value : 0;
                const currentDBVersionForCheck = DB_VERSION; // Use the global DB_VERSION
                const needsUpdateDueToVersion = DB_VERSION > lastLoadedVersion;
                const shouldLoadQuran = !(settingsLoadedQuran && settingsLoadedQuran.value === true && !needsUpdateDueToVersion && DB_VERSION >= 2);
                const shouldLoadWordTranslations = !(settingsLoadedWordTranslations && settingsLoadedWordTranslations.value === true && !needsUpdateDueToVersion && DB_VERSION >= currentDBVersionForCheck);
                const shouldLoadWordMetadata = !(settingsLoadedWordMetadata && settingsLoadedWordMetadata.value === true && !needsUpdateDueToVersion && DB_VERSION >= currentDBVersionForCheck);
                totalProgressUnits += WEIGHT_CHECK_SETTINGS;
                if (shouldLoadQuran) {
                    totalProgressUnits += Object.keys(TRANSLATION_CONFIG).length * (WEIGHT_FETCH_FILE + WEIGHT_PARSE_QURAN_FILE);
                    totalProgressUnits += 6236 * WEIGHT_DB_TRANSACTION_ITEM;
                }
                if (shouldLoadWordTranslations) {
                    totalProgressUnits += WEIGHT_FETCH_FILE + WEIGHT_PARSE_WORD_FILE;
                    totalProgressUnits += 80000 * WEIGHT_DB_TRANSACTION_ITEM;
                }
                if (shouldLoadWordMetadata) {
                    totalProgressUnits += WEIGHT_FETCH_FILE + WEIGHT_PARSE_WORD_FILE;
                    totalProgressUnits += 80000 * WEIGHT_DB_TRANSACTION_ITEM;
                }
                if (shouldLoadQuran || shouldLoadWordTranslations || shouldLoadWordMetadata) {
                    totalProgressUnits += WEIGHT_DB_TRANSACTION_SETUP + WEIGHT_DB_TRANSACTION_COMPLETE;
                }
                if (totalProgressUnits <= WEIGHT_CHECK_SETTINGS && !shouldLoadQuran && !shouldLoadWordTranslations && !shouldLoadWordMetadata) {
                    console.log("All necessary Quran, word translation, and word metadata already loaded and up-to-date.");
                    quranDataLoaded = true;
                    await populateSurahAyahSelects();
                    await loadAyah(currentSurah, currentAyah);
                    return;
                }
                let primaryLoadingMessage = "Setting up Quran Studio for the first time...";
                if (lastLoadedVersion > 0) { // Not the very first time
                    if (needsUpdateDueToVersion) {
                        primaryLoadingMessage = "Updating Quran Studio data for a new version...";
                    } else {
                        primaryLoadingMessage = "Verifying Quran Studio data...";
                    }
                }
                showLoading(primaryLoadingMessage, "Checking existing data...", 0);
                updateLoadingProgress(WEIGHT_CHECK_SETTINGS, "Checked local data status.");
                if (!shouldLoadQuran && !shouldLoadWordTranslations && !shouldLoadWordMetadata) {
                    console.log("All necessary Quran, word translation, and word metadata already loaded.");
                    quranDataLoaded = true;
                    await populateSurahAyahSelects();
                    await loadAyah(currentSurah, currentAyah);
                    updateLoadingProgress(totalProgressUnits - completedProgressUnits, "Data verified. Launching Studio..."); // Complete progress
                    setTimeout(hideLoading, 500); // Brief pause before hiding
                    return;
                }
                const storesToAccessInTransaction = [STORE_SETTINGS];
                if (shouldLoadQuran) storesToAccessInTransaction.push(STORE_QURAN);
                if (shouldLoadWordTranslations) storesToAccessInTransaction.push(STORE_WORD_TRANSLATIONS);
                if (shouldLoadWordMetadata) storesToAccessInTransaction.push(STORE_WORD_METADATA);
                const allQuranDataMap = new Map();
                let wordTranslationEntries = [];
                let wordMetadataEntries = [];
                if (shouldLoadQuran) {
                    console.log("Fetching full Quran ayah texts and translations...");
                    for (const key in TRANSLATION_CONFIG) {
                        const config = TRANSLATION_CONFIG[key];
                        try {
                            updateLoadingProgress(0, `Fetching ${config.label} text (${config.file.substring(0, 15)})...`);
                            const response = await fetch(config.file);
                            updateLoadingProgress(WEIGHT_FETCH_FILE, `Processing ${config.label} (${config.file.substring(0, 15)})...`);
                            if (!response.ok) {
                                console.warn(`HTTP error! status: ${response.status} for ${config.file}. Skipping.`);
                                updateLoadingProgress(WEIGHT_PARSE_QURAN_FILE, `Skipped ${config.label} due to error.`);
                                continue;
                            }
                            const text = await response.text();
                            console.log(`${config.label} data fetched (${config.file}). Parsing...`);
                            const lines = text.split('\n').filter(line => line.trim() !== '');
                            for (const line of lines) {
                                const parts = line.split(' ترجمہ: ');
                                if (parts.length < 2) continue;
                                const arabicPart = parts[0].trim();
                                const rest = parts[1];
                                const metaMatch = rest.match(/<br\/>\s*(?:s|س)\s*\.?\s*(\d{1,3})\s*(?:a|آ)\s*\.?\s*(\d{1,3})\s*$/i);
                                if (!metaMatch) continue;
                                const translationPart = rest.substring(0, metaMatch.index).trim();
                                const surahNum = parseInt(metaMatch[1], 10);
                                const ayahNum = parseInt(metaMatch[2], 10);
                                if (isNaN(surahNum) || isNaN(ayahNum) || surahNum < 1 || surahNum > 114 || ayahNum < 1) continue;
                                const mapKey = `${surahNum}-${ayahNum}`;
                                let entry = allQuranDataMap.get(mapKey);
                                if (!entry) {
                                    entry = { surah: surahNum, ayah: ayahNum, arabic: arabicPart, urdu: '', english: '', Bangali: '' };
                                    allQuranDataMap.set(mapKey, entry);
                                }
                                entry[key] = translationPart;
                            }
                            updateLoadingProgress(WEIGHT_PARSE_QURAN_FILE, `Processed ${config.label} data.`);
                        } catch (fetchError) {
                            console.error(`Error fetching/parsing ${config.file}:`, fetchError);
                            updateLoadingProgress(WEIGHT_PARSE_QURAN_FILE, `Error with ${config.label}.`);
                        }
                    }
                    console.log(`Parsed ${allQuranDataMap.size} unique full ayahs.`);
                }
                if (shouldLoadWordTranslations) {
                    console.log(`Fetching word translations from ${WORD_TRANSLATION_FILE}...`);
                    try {
                        updateLoadingProgress(0, `Fetching word translations (${WORD_TRANSLATION_FILE.substring(0, 15)})...`);
                        const response = await fetch(WORD_TRANSLATION_FILE);
                        updateLoadingProgress(WEIGHT_FETCH_FILE, `Processing word translations (${WORD_TRANSLATION_FILE.substring(0, 15)})...`);
                        if (!response.ok) {
                            console.warn(`Failed to fetch ${WORD_TRANSLATION_FILE}: ${response.status}`);
                            updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Skipped word translations due to error.`);
                        } else {
                            const csvText = await response.text();
                            const lines = csvText.split('\n').filter(line => line.trim() !== '');
                            if (lines.length > 0) {
                                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                                const wordIdIndex = headers.indexOf('word_id');
                                const urMeaningIndex = headers.indexOf('ur_meaning');
                                const enMeaningIndex = headers.indexOf('en_meaning');
                                if (wordIdIndex === -1) {
                                    console.error(`'word_id' header not found in ${WORD_TRANSLATION_FILE}. Cannot process word translations.`);
                                } else {
                                    for (let i = 1; i < lines.length; i++) {
                                        const values = lines[i].split(',');
                                        const word_id_val = values[wordIdIndex] ? values[wordIdIndex].trim() : null;
                                        if (!word_id_val) continue;
                                        const entry = {
                                            word_id: parseInt(word_id_val, 10),
                                            ur_meaning: urMeaningIndex > -1 && values[urMeaningIndex] ? values[urMeaningIndex].trim() : '',
                                            en_meaning: enMeaningIndex > -1 && values[enMeaningIndex] ? values[enMeaningIndex].trim() : '',
                                        };
                                        if (!isNaN(entry.word_id)) {
                                            wordTranslationEntries.push(entry);
                                        }
                                    }
                                    console.log(`Parsed ${wordTranslationEntries.length} word translation entries from ${WORD_TRANSLATION_FILE}.`);
                                }
                            }
                            updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Processed ${wordTranslationEntries.length} word translations.`);
                        }
                    } catch (fetchError) {
                        console.error(`Error fetching/parsing ${WORD_TRANSLATION_FILE}:`, fetchError);
                        updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Error with word translations.`);
                    }
                }
                if (shouldLoadWordMetadata) {
                    console.log(`Fetching word metadata from ${WORD_METADATA_FILE}...`);
                    try {
                        updateLoadingProgress(0, `Fetching word metadata (${WORD_METADATA_FILE.substring(0, 15)})...`);
                        const response = await fetch(WORD_METADATA_FILE);
                        updateLoadingProgress(WEIGHT_FETCH_FILE, `Processing word metadata (${WORD_METADATA_FILE.substring(0, 15)})...`);
                        if (!response.ok) {
                            console.warn(`Failed to fetch ${WORD_METADATA_FILE}: ${response.status}`);
                            updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Skipped word metadata due to error.`);
                        } else {
                            const csvText = await response.text();
                            const lines = csvText.split('\n').filter(line => line.trim() !== '');
                            if (lines.length > 0) {
                                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                                const wordIdIndex = headers.indexOf('word_id');
                                const surahIndex = headers.indexOf('surah');
                                const ayahIndex = headers.indexOf('ayah');
                                const positionIndex = headers.indexOf('word_postion');
                                if (wordIdIndex === -1 || surahIndex === -1 || ayahIndex === -1 || positionIndex === -1) {
                                    console.error(`One or more required headers not found in ${WORD_METADATA_FILE}.`);
                                } else {
                                    for (let i = 1; i < lines.length; i++) {
                                        const values = lines[i].split(',');
                                        const entry = {
                                            word_id: parseInt(values[wordIdIndex] ? values[wordIdIndex].trim() : '', 10),
                                            surah: parseInt(values[surahIndex] ? values[surahIndex].trim() : '', 10),
                                            ayah: parseInt(values[ayahIndex] ? values[ayahIndex].trim() : '', 10),
                                            word_position: parseInt(values[positionIndex] ? values[positionIndex].trim() : '', 10)
                                        };
                                        if (!isNaN(entry.word_id) && !isNaN(entry.surah) && !isNaN(entry.ayah) && !isNaN(entry.word_position)) {
                                            wordMetadataEntries.push(entry);
                                        }
                                    }
                                    console.log(`Parsed ${wordMetadataEntries.length} word metadata entries from ${WORD_METADATA_FILE}.`);
                                }
                            }
                            updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Processed ${wordMetadataEntries.length} word metadata entries.`);
                        }
                    } catch (fetchError) {
                        console.error(`Error fetching/parsing ${WORD_METADATA_FILE}:`, fetchError);
                        updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Error with word metadata.`);
                    }
                }
                if (storesToAccessInTransaction.length > 1 && (shouldLoadQuran || shouldLoadWordTranslations || shouldLoadWordMetadata)) {
                    updateLoadingProgress(WEIGHT_DB_TRANSACTION_SETUP, "Preparing to save data to local database...");
                    const transaction = db.transaction(storesToAccessInTransaction, 'readwrite');
                    transaction.oncomplete = async () => {
                        console.log("Data loading/storing transaction complete.");
                        if (shouldLoadQuran) await putData(STORE_SETTINGS, { name: 'quranDataLoaded', value: true }).catch(console.error);
                        if (shouldLoadWordTranslations) await putData(STORE_SETTINGS, { name: 'wordTranslationsLoaded', value: true }).catch(console.error);
                        if (shouldLoadWordMetadata) await putData(STORE_SETTINGS, { name: 'wordMetadataLoaded', value: true }).catch(console.error);
                        await putData(STORE_SETTINGS, { name: 'lastLoadedDBVersion', value: DB_VERSION }).catch(console.error);
                        updateLoadingProgress(WEIGHT_DB_TRANSACTION_COMPLETE, "All data saved locally!");
                        const finalRemaining = totalProgressUnits - completedProgressUnits;
                        if (finalRemaining > 0) updateLoadingProgress(finalRemaining, "Finalizing setup...");
                        quranDataLoaded = true;
                        await populateSurahAyahSelects();
                        await loadAyah(currentSurah, currentAyah);
                        setTimeout(hideLoading, 500); // Give a moment for user to see "complete"
                    };
                    transaction.onerror = (event) => {
                        console.error("Transaction failed during initial data load:", event.target.error);
                        updateLoadingProgress(WEIGHT_DB_TRANSACTION_COMPLETE, "Error saving data. Please try refreshing.");
                        alert("Failed to store initial data: " + event.target.error.message + "\nPlease clear website data (cache and site data for this page) and refresh.");
                    };
                    if (shouldLoadQuran && allQuranDataMap.size > 0) {
                        updateLoadingProgress(0, `Saving ${allQuranDataMap.size} Ayahs to database...`);
                        const quranStore = transaction.objectStore(STORE_QURAN);
                        if (needsUpdateDueToVersion || !(settingsLoadedQuran && settingsLoadedQuran.value === true)) { // Clear only if new load or version update
                            await new Promise(resolve => quranStore.clear().onsuccess = resolve); // Clear before repopulating
                        }
                        let count = 0;
                        for (const entry of allQuranDataMap.values()) {
                            quranStore.put(entry);
                            count++;
                            if (count % 500 === 0) updateLoadingProgress(500 * WEIGHT_DB_TRANSACTION_ITEM, `Saved ${count} Ayahs...`);
                        }
                        updateLoadingProgress((allQuranDataMap.size % 500) * WEIGHT_DB_TRANSACTION_ITEM, `Finished saving Ayahs.`);
                    }
                    if (shouldLoadWordTranslations && wordTranslationEntries.length > 0) {
                        updateLoadingProgress(0, `Saving ${wordTranslationEntries.length} word translations...`);
                        const store = transaction.objectStore(STORE_WORD_TRANSLATIONS);
                        if (needsUpdateDueToVersion || !(settingsLoadedWordTranslations && settingsLoadedWordTranslations.value === true)) {
                            await new Promise(resolve => store.clear().onsuccess = resolve);
                        }
                        let count = 0;
                        for (const entry of wordTranslationEntries) {
                            store.put(entry);
                            count++;
                            if (count % 2000 === 0) updateLoadingProgress(2000 * WEIGHT_DB_TRANSACTION_ITEM, `Saved ${count} word translations...`);
                        }
                        updateLoadingProgress((wordTranslationEntries.length % 2000) * WEIGHT_DB_TRANSACTION_ITEM, `Finished saving word translations.`);
                    }
                    if (shouldLoadWordMetadata && wordMetadataEntries.length > 0) {
                        updateLoadingProgress(0, `Saving ${wordMetadataEntries.length} word metadata entries...`);
                        const store = transaction.objectStore(STORE_WORD_METADATA);
                        if (needsUpdateDueToVersion || !(settingsLoadedWordMetadata && settingsLoadedWordMetadata.value === true)) {
                            await new Promise(resolve => store.clear().onsuccess = resolve);
                        }
                        let count = 0;
                        for (const entry of wordMetadataEntries) {
                            store.put(entry);
                            count++;
                            if (count % 2000 === 0) updateLoadingProgress(2000 * WEIGHT_DB_TRANSACTION_ITEM, `Saved ${count} word metadata entries...`);
                        }
                        updateLoadingProgress((wordMetadataEntries.length % 2000) * WEIGHT_DB_TRANSACTION_ITEM, `Finished saving word metadata.`);
                    }
                } else {
                    console.log("No new data needed to be fetched and stored. Initializing UI.");
                    quranDataLoaded = true;
                    await populateSurahAyahSelects();
                    await loadAyah(currentSurah, currentAyah);
                    const remainingUnits = totalProgressUnits - completedProgressUnits;
                    if (remainingUnits > 0) updateLoadingProgress(remainingUnits, "Data verification complete.");
                    setTimeout(hideLoading, 500);
                }
            } catch (error) {
                console.error("Error in loadQuranData:", error);
                if (document.getElementById('loading-overlay').style.display === 'none') {
                    showLoading("Application Error", "An error occurred during initialization.", 100);
                } else {
                    updateLoadingProgress(0, "Critical error during setup.");
                }
                document.getElementById('loading-message-secondary').textContent = `Error: ${error.message}. Please try refreshing.`;
                document.getElementById('loading-message-secondary').style.color = 'var(--color-error, red)';
                alert("Failed to load application data: " + error.message + "\nIf the problem persists, try clearing website data for this page and then refresh.");
            }
        }
        function populateSurahAyahSelects() {
            const surahSelect = document.getElementById('surah-select');
            const ayahSelect = document.getElementById('ayah-select');
            const recSurahSelect = document.getElementById('rec-surah-select');
            const hifzSurahSelect = document.getElementById('hifz-surah-select');
            if (surahSelect.options.length === 0) {
                for (let i = 1; i <= 114; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `${i}. ${surahNames[i - 1]}`;
                    surahSelect.appendChild(option.cloneNode(true));
                    recSurahSelect.appendChild(option.cloneNode(true));
                    hifzSurahSelect.appendChild(option.cloneNode(true));
                }
            }
            surahSelect.value = currentSurah;
            recSurahSelect.value = currentSurah;
            hifzSurahSelect.value = currentSurah;
            updateAyahSelect(currentSurah);
            ayahSelect.value = currentAyah;
        }
        function updateAyahSelect(surahNum) {
            const ayahSelect = document.getElementById('ayah-select');
            ayahSelect.innerHTML = '';
            totalAyahsInSurah = surahAyahCounts[surahNum];
            for (let i = 1; i <= totalAyahsInSurah; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                ayahSelect.appendChild(option);
            }
            if (currentAyah > totalAyahsInSurah) {
                currentAyah = 1;
            }
            ayahSelect.value = currentAyah;
        }
        async function loadAyah(surah, ayah) {
            if (!db) {
                console.error("Database not open for loadAyah.");
                document.getElementById('quran-display').innerHTML = `<p class="text-center" style="color: var(--color-error);">Database not ready. Please try again later.</p>`;
                return;
            }
            showLoading(`Loading Ayah ${surah}:${ayah}...`);
            try {
                const quran = await getData(STORE_QURAN, [surah, ayah]);
                const tafsir = await getData(STORE_TAFSIR, [surah, ayah]);
                const displayArea = document.getElementById('quran-display');
                const tafsirAyahDisplay = document.getElementById('current-ayah-tafsir');
                const themeAyahDisplay = document.getElementById('current-ayah-theme-text');
                const tafsirNotes = document.getElementById('tafsir-notes');
                displayArea.innerHTML = '';
                tafsirAyahDisplay.innerHTML = '';
                themeAyahDisplay.innerHTML = '';
                tafsirNotes.value = '';
                if (quran) {
                    currentSurah = surah;
                    currentAyah = ayah;
                    document.getElementById('surah-select').value = surah;
                    document.getElementById('ayah-select').value = ayah;
                    document.getElementById('rec-surah-select').value = surah;
                    document.getElementById('hifz-surah-select').value = surah;
                    updateAyahSelect(surah);
                    const ayahElement = document.createElement('div');
                    ayahElement.classList.add('ayah');
                    ayahElement.setAttribute('data-surah', surah);
                    ayahElement.setAttribute('data-ayah', ayah);
                    const ayahNumber = document.createElement('div');
                    ayahNumber.classList.add('ayah-number');
                    ayahNumber.textContent = `Surah ${surah}:${ayah} (${surahNames[surah - 1]})`;
                    ayahElement.appendChild(ayahNumber);
                    const arabicTextElement = document.createElement('div');
                    arabicTextElement.classList.add('ayah-arabic');
                    arabicTextElement.setAttribute('lang', 'ar');
                    arabicTextElement.setAttribute('dir', 'rtl');
                    const words = quran.arabic.split(/\s+/).filter(w => w.trim() !== '');
                    words.forEach((wordText, index) => {
                        const span = document.createElement('span');
                        span.textContent = wordText + ' ';
                        span.setAttribute('data-word-text', wordText.trim());
                        span.setAttribute('data-word-position', index);
                        span.setAttribute('data-surah', surah);
                        span.setAttribute('data-ayah', ayah);
                        span.setAttribute('tabindex', '0');
                        span.setAttribute('role', 'button');
                        arabicTextElement.appendChild(span);
                    });
                    ayahElement.appendChild(arabicTextElement);
                    const translationText = document.createElement('div');
                    translationText.classList.add('ayah-translation');
                    const selectedTranslationKey = document.getElementById('translation-select').value;
                    const translationInfo = TRANSLATION_CONFIG[selectedTranslationKey];
                    if (translationInfo) {
                        translationText.setAttribute('lang', translationInfo.lang);
                        translationText.setAttribute('dir', translationInfo.dir);
                        translationText.style.fontFamily = `var(--font-${selectedTranslationKey})`;
                        translationText.style.textAlign = translationInfo.dir === 'rtl' ? 'right' : 'left';
                        translationText.textContent = quran[selectedTranslationKey] || "Translation not available.";
                    } else {
                        translationText.textContent = "Translation configuration error.";
                    }
                    ayahElement.appendChild(translationText);
                    displayArea.appendChild(ayahElement);
                    const tafsirAyahElement = ayahElement.cloneNode(true);
                    tafsirAyahElement.querySelector('.ayah-number').textContent = `Tafsir for Surah ${surah}:${ayah}`;
                    tafsirAyahElement.querySelectorAll('.ayah-arabic span').forEach(span => span.outerHTML = span.textContent);
                    tafsirAyahDisplay.innerHTML = '';
                    tafsirAyahDisplay.appendChild(tafsirAyahElement);
                    tafsirNotes.value = tafsir ? tafsir.notes : '';
                    const themeAyahElement = ayahElement.cloneNode(true);
                    themeAyahElement.querySelector('.ayah-number').textContent = `Ayah for Linking: Surah ${surah}:${ayah}`;
                    themeAyahElement.querySelectorAll('.ayah-arabic span').forEach(span => span.outerHTML = span.textContent);
                    themeAyahDisplay.innerHTML = '';
                    themeAyahDisplay.appendChild(themeAyahElement);
                    document.getElementById('current-ayah-theme-ref').textContent = `${surah}:${ayah}`;
                    await populateThemeSelects();
                    await displayLinkedAyahsForCurrentTheme();
                    addWordClickListeners();
                } else {
                    displayArea.innerHTML = `<p class="text-center" style="color: var(--color-error);">Ayah ${surah}:${ayah} not found in data.</p>`;
                    tafsirAyahDisplay.innerHTML = `<p class="text-center">Navigate to a valid Ayah to add Tafsir.</p>`;
                    themeAyahDisplay.innerHTML = `<p class="text-center">Navigate to a valid Ayah to link themes.</p>`;
                    document.getElementById('current-ayah-theme-ref').textContent = 'N/A';
                    tafsirNotes.value = '';
                }
                document.getElementById('word-translation-area').innerHTML = '<p class="text-center">Click on an Arabic word to see its translation.</p>';
            } catch (error) {
                console.error("Error loading ayah:", error);
                document.getElementById('quran-display').innerHTML = `<p class="text-center" style="color: var(--color-error);">Error loading Ayah: ${error.message}</p>`;
            } finally {
                hideLoading();
            }
        }
        function addWordClickListeners() {
            document.querySelectorAll('.ayah-arabic span').forEach(wordSpan => {
                wordSpan.removeEventListener('click', handleWordClick);
                wordSpan.addEventListener('click', handleWordClick);
                wordSpan.removeEventListener('focus', handleWordFocus);
                wordSpan.addEventListener('focus', handleWordFocus);
                wordSpan.removeEventListener('blur', handleWordBlur);
                wordSpan.addEventListener('blur', handleWordBlur);
            });
        }
        async function handleWordClick(event) {
            const wordSpan = event.target;
            const clickedWordActualText = wordSpan.getAttribute('data-word-text');
            const surahNum = parseInt(wordSpan.getAttribute('data-surah'), 10);
            const ayahNum = parseInt(wordSpan.getAttribute('data-ayah'), 10);
            const wordPosition = parseInt(wordSpan.getAttribute('data-word-position'), 10);
            if (!clickedWordActualText || isNaN(surahNum) || isNaN(ayahNum) || isNaN(wordPosition)) {
                console.warn("[handleWordClick] Clicked word span is missing required data attributes.", wordSpan.dataset);
                document.getElementById('word-translation-area').innerHTML = `<p style="color: var(--color-error);">Error: Could not identify clicked word's metadata.</p>`;
                return;
            }
            console.log(`[handleWordClick] Clicked: "${clickedWordActualText}" (S:${surahNum}, A:${ayahNum}, Pos:${wordPosition})`);
            const ayahElement = wordSpan.closest('.ayah');
            const fullAyahTranslationDiv = ayahElement.querySelector('.ayah-translation');
            const fullAyahTranslationText = fullAyahTranslationDiv ? fullAyahTranslationDiv.textContent : 'Full ayah translation not found.';
            const selectedFullTranslationKey = document.getElementById('translation-select').value;
            const fullTranslationInfo = TRANSLATION_CONFIG[selectedFullTranslationKey];
            const fullTranslationLabel = fullTranslationInfo ? fullTranslationInfo.label : 'Selected Translation';
            const fullTranslationLang = fullTranslationInfo ? fullTranslationInfo.lang : 'en';
            const fullTranslationDir = fullTranslationInfo ? fullTranslationInfo.dir : 'ltr';
            const fullTranslationFont = fullTranslationInfo ? `var(--font-${selectedFullTranslationKey})` : `var(--font-general)`;
            const fullTranslationTextAlign = fullTranslationInfo && fullTranslationInfo.dir === 'rtl' ? 'right' : 'left';
            let wordUrduMeaning = "N/A";
            let wordEnglishMeaning = "N/A";
            try {
                const metadataStore = getObjectStore(STORE_WORD_METADATA, 'readonly');
                const locationIndex = metadataStore.index('location_idx');
                const metadataRequest = locationIndex.get([surahNum, ayahNum, wordPosition]);
                const wordMetadataEntry = await new Promise((resolve, reject) => {
                    metadataRequest.onsuccess = () => resolve(metadataRequest.result);
                    metadataRequest.onerror = (e) => {
                        console.error("Error fetching from word_metadata:", e.target.error);
                        reject(e.target.error);
                    };
                });
                if (wordMetadataEntry && typeof wordMetadataEntry.word_id !== 'undefined') {
                    const word_id = wordMetadataEntry.word_id;
                    console.log(`[handleWordClick] Found word_id: ${word_id}`);
                    const translationEntry = await getData(STORE_WORD_TRANSLATIONS, word_id);
                    if (translationEntry) {
                        console.log(`[handleWordClick] Translation data for word_id ${word_id}:`, translationEntry);
                        wordUrduMeaning = translationEntry.ur_meaning || "N/A";
                        wordEnglishMeaning = translationEntry.en_meaning || "N/A";
                        if (translationEntry.ur_meaning === "") wordUrduMeaning = "N/A (empty)";
                        if (translationEntry.en_meaning === "") wordEnglishMeaning = "N/A (empty)";
                    } else {
                        console.warn(`[handleWordClick] No translation entry in '${STORE_WORD_TRANSLATIONS}' for word_id: ${word_id}.`);
                    }
                } else {
                    console.warn(`[handleWordClick] No metadata entry in '${STORE_WORD_METADATA}' for S${surahNum}:A${ayahNum}, Pos:${wordPosition}. Word: "${clickedWordActualText}"`);
                }
            } catch (error) {
                console.error("[handleWordClick] Error during word data lookup:", error);
                wordUrduMeaning = "Lookup Error";
                wordEnglishMeaning = "Lookup Error";
            }
            const translationArea = document.getElementById('word-translation-area');
            translationArea.innerHTML = `
                <p><strong>Selected Word:</strong> <span lang="ar" dir="rtl" style="font-family: var(--font-arabic); font-size: 1.2rem;">${clickedWordActualText}</span></p>
                <p><strong>Urdu Meaning:</strong> <span lang="ur" dir="rtl" style="font-family: var(--font-urdu);">${wordUrduMeaning}</span></p>
                <p><strong>English Meaning:</strong> <span lang="en" dir="ltr" style="font-family: var(--font-english);">${wordEnglishMeaning}</span></p>
                <p><strong>Full Ayah Translation (${surahNum}:${ayahNum}) - ${fullTranslationLabel}:</strong> <span lang="${fullTranslationLang}" dir="${fullTranslationDir}" style="font-family: ${fullTranslationFont}; text-align: ${fullTranslationTextAlign};">${fullAyahTranslationText}</span></p>
            `;
            document.querySelectorAll('.ayah-arabic span').forEach(span => {
                span.style.backgroundColor = 'transparent';
            });
            wordSpan.style.backgroundColor = 'var(--color-highlight)';
        }
        function handleWordFocus(event) {
            handleWordClick(event);
        }
        function handleWordBlur(event) {
            event.target.style.backgroundColor = 'transparent';
        }
        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
                section.setAttribute('aria-hidden', 'true');
            });
            const activeSection = document.getElementById(sectionId);
            if (activeSection) {
                activeSection.classList.add('active');
                activeSection.setAttribute('aria-hidden', 'false');
                activeSection.focus(); // For accessibility, focus the new section
            }
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                link.setAttribute('aria-current', 'false');
            });
            const activeLink = document.querySelector(`.nav-link[data-section="${sectionId}"]`);
            if (activeLink) {
                activeLink.classList.add('active');
                activeLink.setAttribute('aria-current', 'page');
            }
            if (sectionId === 'themes') {
                populateThemeSelects();
                displayLinkedAyahsForCurrentTheme();
            } else if (sectionId === 'recitation') {
                loadRecitationLogs();
            } else if (sectionId === 'hifz') {
                const hifzSurahSelect = document.getElementById('hifz-surah-select');
                if (hifzSurahSelect.value) {
                    loadHifzForSurah(parseInt(hifzSurahSelect.value, 10));
                }
            }
        }
        function showLoading(primaryMessage, secondaryMessage = "Initializing...", initialPercentage = 0) {
            const loadingOverlay = document.getElementById('loading-overlay');
            const primaryMsgEl = document.getElementById('loading-message-primary');
            const secondaryMsgEl = document.getElementById('loading-message-secondary');
            const progressBarEl = document.getElementById('loading-progress-bar');
            const percentageEl = document.getElementById('loading-percentage');
            const firstTimeNoticeEl = document.getElementById('loading-first-time-notice');
            if (primaryMsgEl) primaryMsgEl.textContent = primaryMessage;
            if (secondaryMsgEl) secondaryMsgEl.textContent = secondaryMessage;
            if (progressBarEl) progressBarEl.style.width = `${initialPercentage}%`;
            if (percentageEl) percentageEl.textContent = `${initialPercentage}%`;
            const currentTheme = document.body.className.includes('theme-manuscript') ? 'manuscript' :
                document.body.className.includes('theme-holo') ? 'holo' : 'serene';
            const loadingContent = loadingOverlay.querySelector('.loading-content');
            if (loadingContent) {
                if (currentTheme === 'holo') {
                    loadingContent.style.backgroundColor = 'var(--color-bg-secondary)'; // From holo theme
                    loadingContent.style.color = 'var(--color-text-primary)'; // From holo theme
                    if (document.getElementById('loading-progress-bar-container')) document.getElementById('loading-progress-bar-container').style.backgroundColor = '#26a69a';
                    if (progressBarEl) progressBarEl.style.backgroundColor = 'var(--color-accent)'; // From holo theme
                } else if (currentTheme === 'manuscript') {
                    loadingContent.style.backgroundColor = 'var(--color-bg-secondary)'; // From manuscript theme
                    loadingContent.style.color = 'var(--color-text-primary)'; // From manuscript theme
                    if (document.getElementById('loading-progress-bar-container')) document.getElementById('loading-progress-bar-container').style.backgroundColor = 'var(--color-border)';
                    if (progressBarEl) progressBarEl.style.backgroundColor = 'var(--color-accent)';
                } else { // Serene (default)
                    loadingContent.style.backgroundColor = 'var(--color-bg-secondary)';
                    loadingContent.style.color = 'var(--color-text-primary)';
                    if (document.getElementById('loading-progress-bar-container')) document.getElementById('loading-progress-bar-container').style.backgroundColor = 'var(--color-border)';
                    if (progressBarEl) progressBarEl.style.backgroundColor = 'var(--color-accent)';
                }
            }
            loadingOverlay.style.display = 'flex';
            document.body.setAttribute('aria-busy', 'true');
        }
        function updateLoadingProgress(unitsIncrement, secondaryMessage) {
            if (totalProgressUnits === 0) return; // Avoid division by zero if not set
            completedProgressUnits += unitsIncrement;
            const percentage = Math.min(100, Math.round((completedProgressUnits / totalProgressUnits) * 100));
            const secondaryMsgEl = document.getElementById('loading-message-secondary');
            const progressBarEl = document.getElementById('loading-progress-bar');
            const percentageEl = document.getElementById('loading-percentage');
            if (secondaryMsgEl) secondaryMsgEl.textContent = secondaryMessage;
            if (progressBarEl) progressBarEl.style.width = `${percentage}%`;
            if (percentageEl) percentageEl.textContent = `${percentage}%`;
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
            document.body.setAttribute('aria-busy', 'false');
            completedProgressUnits = 0;
            totalProgressUnits = 0; // Reset this as well
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
            document.body.setAttribute('aria-busy', 'false');
        }
        function setStatusMessage(elementId, message, isError = false) {
            const statusElement = document.getElementById(elementId);
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.style.color = isError ? 'var(--color-error)' : 'var(--color-success)';
                statusElement.style.fontWeight = 'bold';
                setTimeout(() => {
                    statusElement.textContent = '';
                    statusElement.style.color = '';
                    statusElement.style.fontWeight = '';
                }, 7000);
            }
        }
        async function saveTafsir() {
            if (!db) return;
            const notes = document.getElementById('tafsir-notes').value.trim();
            if (!notes) {
                setStatusMessage('tafsir-status', 'Tafsir notes cannot be empty.', true);
                return;
            }
            if (currentSurah === 0 || currentAyah === 0) {
                setStatusMessage('tafsir-status', 'Navigate to an Ayah first.', true);
                return;
            }
            showLoading(`Saving Tafsir for ${currentSurah}:${currentAyah}...`);
            try {
                await putData(STORE_TAFSIR, { surah: currentSurah, ayah: currentAyah, notes: notes });
                setStatusMessage('tafsir-status', `Tafsir saved for ${currentSurah}:${currentAyah}.`, false);
            } catch (error) {
                setStatusMessage('tafsir-status', 'Failed to save Tafsir.', true);
            } finally {
                hideLoading();
            }
        }
        async function handleIndexThemeClick(event) {
            event.preventDefault();
            const clickedAnchorElement = event.currentTarget; // Use a more descriptive name
            if (!clickedAnchorElement || !clickedAnchorElement.dataset) {
                console.error("handleIndexThemeClick: clickedAnchorElement or its dataset is invalid.", clickedAnchorElement);
                return;
            }
            const themeId = clickedAnchorElement.dataset.themeId;
            const isStatic = clickedAnchorElement.dataset.isStatic === 'true';
            const exampleSurahStr = clickedAnchorElement.dataset.exampleSurah;
            const exampleAyahStr = clickedAnchorElement.dataset.exampleAyah;
            if (!themeId) {
                console.error("Theme ID missing from clicked element's dataset.");
                return;
            }
            const indexPanel = document.getElementById('fsReaderIndexPanel');
            if (indexPanel) indexPanel.style.display = 'none';
            stopAndClearAudio();
            let targetSurah, targetAyah;
            if (isStatic) {
                targetSurah = exampleSurahStr ? parseInt(exampleSurahStr) : NaN;
                targetAyah = exampleAyahStr ? parseInt(exampleAyahStr) : NaN;
                const staticTheme = staticQuranicThemes.find(st => st.id === themeId);
                if (staticTheme) {
                    const surahTitleEl = document.getElementById('fsReaderSurahTitle');
                    const pageInfoEl = document.getElementById('fsReaderPageInfo');
                    if (surahTitleEl) surahTitleEl.textContent = `Theme: ${staticTheme.name}`;
                    if (pageInfoEl) {
                        if (isNaN(targetSurah) || isNaN(targetAyah)) {
                            pageInfoEl.textContent = "(Example Ayah not set or invalid)";
                        } else {
                            pageInfoEl.textContent = `(Example: S${targetSurah}:A${targetAyah})`;
                        }
                    }
                }
            } else {
                try {
                    const dbThemeId = parseInt(themeId);
                    if (isNaN(dbThemeId)) {
                        console.error("Invalid DB Theme ID:", themeId);
                        return;
                    }
                    const allThemeAyahLinks = await getAllData(STORE_THEME_AYAHS);
                    const linksForThisTheme = allThemeAyahLinks
                        .filter(link => link.themeId === dbThemeId)
                        .sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                    if (linksForThisTheme.length > 0) {
                        const firstLink = linksForThisTheme[0];
                        targetSurah = firstLink.surah;
                        targetAyah = firstLink.ayah;
                    } else {
                        alert("No Ayahs are currently linked to this user-defined theme.");
                        const themeData = await getData(STORE_THEMES, dbThemeId);
                        const surahTitleEl = document.getElementById('fsReaderSurahTitle');
                        const pageInfoEl = document.getElementById('fsReaderPageInfo');
                        if (themeData && surahTitleEl) surahTitleEl.textContent = `Theme: ${themeData.name}`;
                        if (pageInfoEl) pageInfoEl.textContent = "(No linked Ayahs)";
                        return;
                    }
                } catch (error) {
                    console.error("Error fetching links for DB theme:", error);
                    alert("Could not retrieve linked Ayahs for this theme.");
                    return;
                }
            }
            if (!isNaN(targetSurah) && !isNaN(targetAyah) && targetSurah >= 1 && targetSurah <= 114 && targetAyah >= 1) {
                const maxAyahs = (surahAyahCounts[targetSurah]) ? surahAyahCounts[targetSurah] : 0;
                if (maxAyahs > 0 && targetAyah <= maxAyahs) {
                    fullScreenReaderCurrentSurah = targetSurah;
                    fullScreenReaderCurrentAyah = targetAyah;
                    if (fullScreenReaderViewMode === 'paged') {
                        fullScreenReaderCurrentPage = surahToPageEnhanced(targetSurah, targetAyah);
                        await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
                        setTimeout(() => highlightAndScrollToAyahInPage(targetSurah, targetAyah), 300); // slight increase
                    } else {
                        continuousScrollNextSurahToLoad = targetSurah;
                        continuousScrollNextAyahToLoad = targetAyah;
                        await initializeContinuousScroll();
                    }
                } else {
                    console.warn(`Invalid Ayah number ${targetAyah} for Surah ${targetSurah}. Max is ${maxAyahs}. Cannot navigate.`);
                    if (isStatic) alert(`The example Ayah (S${targetSurah}:A${targetAyah}) for this static theme is invalid.`);
                }
            } else if (isStatic) {
            } else {
                console.warn(`Navigation aborted for theme "${themeId}" due to invalid targetSurah/Ayah.`);
            }
        }
        let isLoadingThemesListGlobalFlag = false;
        async function displayThemesList() {
            if (!db) {
                return;
            }
            if (isLoadingThemesListGlobalFlag) {
                return;
            }
            isLoadingThemesListGlobalFlag = true;
            const themesListElement = document.getElementById('themes-list');
            if (!themesListElement) {
                console.error('[displayThemesList] Element with ID "themes-list" not found.');
                isLoadingThemesListGlobalFlag = false;
                return;
            }
            themesListElement.innerHTML = ''; // Clear the list at the very beginning
            try {
                const themes = await getAllData(STORE_THEMES);
                if (!themesListElement.parentNode) {
                    isLoadingThemesListGlobalFlag = false;
                    return;
                }
                if (themes.length === 0) {
                    themesListElement.innerHTML = '<li>No themes added yet.</li>';
                } else {
                    themes.forEach(theme => {
                        const li = document.createElement('li');
                        li.innerHTML = `
                            <span data-theme-id="${theme.id}" class="view-theme-ayahs" tabindex="0" role="button" aria-label="View ayahs for theme ${theme.name}">${theme.name}</span>
                            <div class="theme-actions" style="display: inline-block;">
                                <button data-theme-id="${theme.id}" class="delete-theme-btn" aria-label="Delete theme ${theme.name}">Delete</button>
                            </div>
                        `;
                        themesListElement.appendChild(li);
                    });
                    themesListElement.querySelectorAll('.view-theme-ayahs').forEach(span => {
                        const newSpan = span.cloneNode(true);
                        span.parentNode.replaceChild(newSpan, span);
                        newSpan.addEventListener('click', handleViewThemeAyahs);
                        newSpan.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') handleViewThemeAyahs(e); });
                    });
                    themesListElement.querySelectorAll('.delete-theme-btn').forEach(button => {
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', handleDeleteTheme);
                    });
                }
            } catch (error) {
                console.error("[displayThemesList] Error:", error);
                if (themesListElement) {
                    themesListElement.innerHTML = `<li>Error loading themes: ${error.message}</li>`;
                }
            } finally {
                isLoadingThemesListGlobalFlag = false; // Reset the flag
            }
        }
        async function addTheme() {
            if (!db) return;
            const nameInput = document.getElementById('new-theme-name');
            const parentSelect = document.getElementById('parent-theme-select');
            const name = nameInput.value.trim();
            const parentId = parentSelect.value ? parseInt(parentSelect.value, 10) : null;
            if (!name) {
                setStatusMessage('theme-manager-status', 'Theme name cannot be empty.', true);
                return;
            }
            showLoading("Adding theme...");
            try {
                await addData(STORE_THEMES, { name: name, parentId: parentId, description: '' }); // Add description field
                setStatusMessage('theme-manager-status', `Theme "${name}" added.`, false);
                nameInput.value = '';
                parentSelect.value = '';
                await populateThemeSelects();
                await displayThemesList();
            } catch (error) {
                setStatusMessage('theme-manager-status', 'Failed to add theme.', true);
            } finally {
                hideLoading();
            }
        }
        async function handleDeleteTheme(event) {
            if (!db) return;
            const themeId = parseInt(event.target.getAttribute('data-theme-id'), 10);
            if (isNaN(themeId) || !confirm("Delete this theme and all its linked ayahs?")) return;
            showLoading("Deleting theme...");
            try {
                await deleteData(STORE_THEMES, themeId);
                const store = getObjectStore(STORE_THEME_AYAHS, 'readwrite');
                const index = store.index('themeId');
                const request = index.openCursor(IDBKeyRange.only(themeId));
                request.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        cursor.delete();
                        cursor.continue();
                    } else {
                        setStatusMessage('theme-manager-status', 'Theme and linked ayahs deleted.', false);
                        populateThemeSelects();
                        displayThemesList();
                        hideLoading();
                    }
                };
                request.onerror = () => {
                    setStatusMessage('theme-manager-status', 'Theme deleted, but failed to delete all linked ayahs.', true);
                    hideLoading();
                };
            } catch (error) {
                setStatusMessage('theme-manager-status', 'Failed to delete theme.', true);
                hideLoading();
            }
        }
        async function linkAyahToTheme() {
            if (!db) return;
            const themeSelect = document.getElementById('link-theme-select');
            const notesInput = document.getElementById('theme-link-notes');
            const themeId = themeSelect.value ? parseInt(themeSelect.value, 10) : null;
            const notes = notesInput.value.trim();
            if (!themeId) {
                setStatusMessage('theme-linker-status', 'Please select a theme.', true);
                return;
            }
            if (currentSurah === 0 || currentAyah === 0) {
                setStatusMessage('theme-linker-status', 'Navigate to an Ayah first.', true);
                return;
            }
            showLoading(`Linking Ayah ${currentSurah}:${currentAyah}...`);
            try {
                const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                const index = store.index('surahAyah');
                const request = index.getAll(IDBKeyRange.only([currentSurah, currentAyah]));
                const existingLinks = await new Promise(r => { request.onsuccess = () => r(request.result); });
                if (existingLinks.some(link => link.themeId === themeId)) {
                    setStatusMessage('theme-linker-status', 'Ayah already linked to this theme.', true);
                } else {
                    await addData(STORE_THEME_AYAHS, { themeId: themeId, surah: currentSurah, ayah: currentAyah, notes: notes });
                    setStatusMessage('theme-linker-status', `Ayah ${currentSurah}:${currentAyah} linked.`, false);
                    notesInput.value = '';
                    await displayLinkedAyahsForCurrentTheme();
                }
            } catch (error) {
                setStatusMessage('theme-linker-status', 'Failed to link Ayah.', true);
            } finally {
                hideLoading();
            }
        }
        async function handleGoToAyahFromThemeModal(event) {
            const surah = parseInt(event.currentTarget.getAttribute('data-surah'), 10);
            const ayah = parseInt(event.currentTarget.getAttribute('data-ayah'), 10);
            if (!isNaN(surah) && !isNaN(ayah)) {
                const modal = document.getElementById('themeAyahsModal');
                if (modal) {
                    modal.style.display = 'none';
                }
                if (typeof loadAyah === 'function' && typeof window.showSection === 'function') {
                    await loadAyah(surah, ayah);
                    window.showSection('quran'); // Use the globally patched showSection
                } else {
                    console.error("loadAyah or showSection function not found.");
                    alert("Error navigating to Ayah. Required functions are missing.");
                }
            } else {
                console.warn("Invalid Surah/Ayah data on clicked element:", event.currentTarget.dataset);
            }
        }
        async function handleViewThemeAyahs(event) {
            if (!db) return;
            const themeId = parseInt(event.target.closest('[data-theme-id]').getAttribute('data-theme-id'), 10); // More robust target selection
            if (isNaN(themeId)) {
                console.warn("handleViewThemeAyahs: Could not determine themeId from event target.", event.target);
                return;
            }
            showLoading("Loading linked ayahs...");
            try {
                const theme = await getData(STORE_THEMES, themeId);
                if (!theme) {
                    setStatusMessage('theme-manager-status', 'Theme not found.', true);
                    hideLoading();
                    return;
                }
                document.getElementById('modal-theme-name').textContent = theme.name;
                const listEl = document.getElementById('modal-linked-ayahs-list');
                listEl.innerHTML = ''; // Clear previous
                const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                const index = store.index('themeId');
                const request = index.openCursor(IDBKeyRange.only(themeId));
                const linkedAyahs = [];
                request.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        linkedAyahs.push(cursor.value);
                        cursor.continue();
                    } else {
                        if (linkedAyahs.length === 0) {
                            listEl.innerHTML = '<li>No ayahs linked yet.</li>';
                        } else {
                            linkedAyahs.sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                            linkedAyahs.forEach(link => {
                                const li = document.createElement('li');
                                li.innerHTML = `
                                    <strong>
                                        <span class="item-surah-ayah theme-modal-ayah-link" 
                                            data-surah="${link.surah}" 
                                            data-ayah="${link.ayah}" 
                                            tabindex="0" 
                                            role="button"
                                            title="Go to Surah ${link.surah}, Ayah ${link.ayah} in Quran Viewer">
                                            Surah ${link.surah}:${link.ayah}
                                        </span>
                                    </strong>
                                    ${link.notes ? ` - <em>${link.notes.substring(0, 100)}${link.notes.length > 100 ? '...' : ''}</em>` : ''}
                                    <button data-link-id="${link.id}" class="delete-theme-link-btn" style="margin-left: 10px;" aria-label="Unlink Ayah ${link.surah}:${link.ayah} from this theme">Unlink</button>
                                `;
                                listEl.appendChild(li);
                            });
                            listEl.querySelectorAll('.delete-theme-link-btn').forEach(button => {
                                const newButton = button.cloneNode(true); // Clone to ensure fresh listeners
                                button.parentNode.replaceChild(newButton, button);
                                newButton.addEventListener('click', handleDeleteThemeLink);
                            });
                            listEl.querySelectorAll('.theme-modal-ayah-link').forEach(span => {
                                const newSpan = span.cloneNode(true); // Clone for clean listeners
                                span.parentNode.replaceChild(newSpan, span);
                                newSpan.addEventListener('click', handleGoToAyahFromThemeModal);
                                newSpan.addEventListener('keydown', (ev) => {
                                    if (ev.key === 'Enter' || ev.key === ' ') {
                                        handleGoToAyahFromThemeModal(ev);
                                    }
                                });
                            });
                        }
                        hideLoading();
                        document.getElementById('themeAyahsModal').style.display = 'flex';
                        document.getElementById('themeAyahsModal').querySelector('.modal-content').setAttribute('data-current-theme-id', themeId);
                        document.getElementById('themeAyahsModalTitle').focus();
                    }
                };
                request.onerror = () => {
                    listEl.innerHTML = `<li>Error loading linked Ayahs.</li>`;
                    hideLoading();
                };
            } catch (error) {
                setStatusMessage('theme-manager-status', 'Failed to load theme details.', true);
                hideLoading();
            }
        }
        async function handleDeleteThemeLink(event) {
            if (!db) return;
            const linkId = parseInt(event.target.getAttribute('data-link-id'), 10);
            if (isNaN(linkId) || !confirm("Unlink this Ayah?")) return;
            showLoading("Unlinking Ayah...");
            try {
                await deleteData(STORE_THEME_AYAHS, linkId);
                setStatusMessage('theme-linker-status', 'Ayah unlinked.', false);
                const modalContent = event.target.closest('.modal-content');
                const currentModalThemeId = parseInt(modalContent.getAttribute('data-current-theme-id'), 10);
                if (!isNaN(currentModalThemeId)) {
                    await displayLinkedAyahsForThemeInModal(currentModalThemeId);
                } else {
                    document.getElementById('themeAyahsModal').style.display = 'none';
                    displayThemesList();
                }
            } catch (error) {
                setStatusMessage('theme-linker-status', 'Failed to unlink Ayah.', true);
            } finally {
                hideLoading();
            }
        }
        async function displayLinkedAyahsForThemeInModal(themeId) {
            if (!db) return;
            const listEl = document.getElementById('modal-linked-ayahs-list');
            listEl.innerHTML = '';
            try {
                const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                const index = store.index('themeId');
                const request = index.openCursor(IDBKeyRange.only(themeId));
                const linkedAyahs = [];
                request.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        linkedAyahs.push(cursor.value);
                        cursor.continue();
                    } else {
                        if (linkedAyahs.length === 0) { listEl.innerHTML = '<li>No ayahs linked.</li>'; }
                        else {
                            linkedAyahs.sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                            linkedAyahs.forEach(link => {
                                const li = document.createElement('li');
                                li.innerHTML = `
                                     <strong>Surah ${link.surah}:${link.ayah}</strong>
                                     ${link.notes ? ` - <em>${link.notes}</em>` : ''}
                                     <button data-link-id="${link.id}" class="delete-theme-link-btn">Unlink</button>
                                 `;
                                listEl.appendChild(li);
                            });
                            listEl.querySelectorAll('.delete-theme-link-btn').forEach(b => b.addEventListener('click', handleDeleteThemeLink));
                        }
                    }
                };
                request.onerror = () => { listEl.innerHTML = `<li>Error refreshing list.</li>`; };
            } catch (error) { listEl.innerHTML = `<li>Error: ${error.message}</li>`; }
        }
        async function displayLinkedAyahsForCurrentTheme() {
            if (!db) return;
            const themeSelect = document.getElementById('link-theme-select');
            const themeId = themeSelect.value ? parseInt(themeSelect.value, 10) : null;
            const listEl = document.getElementById('linked-ayahs-list');
            const nameEl = document.getElementById('linked-theme-name');
            listEl.innerHTML = '';
            if (!themeId) {
                nameEl.textContent = 'N/A';
                listEl.innerHTML = '<li>Select a theme to see linked ayahs.</li>';
                return;
            }
            showLoading("Loading linked ayahs...");
            try {
                const theme = await getData(STORE_THEMES, themeId);
                nameEl.textContent = theme ? theme.name : 'Unknown';
                const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                const index = store.index('themeId');
                const request = index.openCursor(IDBKeyRange.only(themeId));
                const linkedAyahs = [];
                request.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        linkedAyahs.push(cursor.value);
                        cursor.continue();
                    } else {
                        if (linkedAyahs.length === 0) { listEl.innerHTML = '<li>No ayahs linked.</li>'; }
                        else {
                            linkedAyahs.sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                            linkedAyahs.forEach(link => {
                                const li = document.createElement('li');
                                li.innerHTML = `<strong>S ${link.surah}:${link.ayah}</strong> ${link.notes ? `- <em>${link.notes}</em>` : ''}`;
                                listEl.appendChild(li);
                            });
                        }
                        hideLoading();
                    }
                };
                request.onerror = () => { listEl.innerHTML = `<li>Error loading.</li>`; hideLoading(); };
            } catch (error) {
                nameEl.textContent = 'Error'; listEl.innerHTML = `<li>Error: ${error.message}</li>`; hideLoading();
            }
        }
        async function analyzeRoot() {
            if (!db) return;
            const rootInput = document.getElementById('root-input');
            const rootTerm = rootInput.value.trim();
            const analyzedRootTermElement = document.getElementById('analyzed-root-term');
            const currentViewMode = document.querySelector('input[name="root-view-mode"]:checked').value; // Get current view mode at the start
            const occurrencesListElement = document.getElementById('root-occurrences-list');
            const graphContainer = document.getElementById('root-network-graph');
            const graphPlaceholder = document.getElementById('root-graph-placeholder');
            const paginationControls = document.getElementById('root-graph-pagination-controls');
            analyzedRootTermElement.textContent = rootTerm || 'N/A';
            allRootOccurrencesCache = [];
            currentRootGraphPage = 1;
            occurrencesListElement.innerHTML = '';
            graphContainer.innerHTML = '';
            if (rootNetwork) {
                rootNetwork.destroy();
                rootNetwork = null;
            }
            graphPlaceholder.style.display = 'none';
            paginationControls.style.display = 'none';
            if (!rootTerm) {
                setStatusMessage('root-status', 'Please enter an Arabic root word.', true);
                if (currentViewMode === 'list') occurrencesListElement.innerHTML = '<li>Please enter an Arabic root word.</li>';
                else { graphPlaceholder.textContent = 'Please enter an Arabic root word.'; graphPlaceholder.style.display = 'block'; }
                return;
            }
            if (rootTerm.length < 2) {
                setStatusMessage('root-status', 'Root term should be at least 2 characters.', true);
                if (currentViewMode === 'list') occurrencesListElement.innerHTML = '<li>Root term too short.</li>';
                else { graphPlaceholder.textContent = 'Root term too short.'; graphPlaceholder.style.display = 'block'; }
                return;
            }
            showLoading(`Analyzing root "${rootTerm}"...`);
            try {
                const allAyahs = await getAllData(STORE_QURAN);
                const foundOccurrences = []; // Temp array for this analysis run
                allAyahs.forEach(ayahData => {
                    const words = ayahData.arabic.split(/\s+/);
                    words.forEach(word => {
                        let wordanClean = word.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "");
                        let wordanNormalized = wordanClean
                            .replace(/ؤ|و/g, "(و|ؤ)")
                            .replace(/ك|ک/g, "(ك|ک)")
                            .replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)")
                            .replace(/ى|ی|ي/g, "(ى|ی|ي)")
                            .replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)")
                            .replace(/ے/g, "(ے|ی)")
                            .replace(/م/g, "(مٰ|م)");
                        let rootTermPatternPart = rootTerm.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "")
                            .replace(/ؤ|و/g, "(و|ؤ)")
                            .replace(/ك|ک/g, "(ك|ک)")
                            .replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)")
                            .replace(/ى|ی|ي/g, "(ى|ی|ي)")
                            .replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)")
                            .replace(/ے/g, "(ے|ی)")
                            .replace(/م/g, "(مٰ|م)");
                        let flexibleRootPatternStr = rootTermPatternPart
                            .replace(/ /g, ".{0,1}")
                            .replace(/-/g, ".{0,1}")
                            .replace(/۔/g, ".{0,1}");
                        let flexibleRegex = new RegExp(flexibleRootPatternStr);
                        let strictRootPatternStr = rootTermPatternPart.replace(/[ \-۔]/g, "");
                        if (flexibleRegex.test(wordanClean) || wordanClean.includes(strictRootPatternStr)) {
                            foundOccurrences.push({
                                surah: ayahData.surah,
                                ayah: ayahData.ayah,
                                word: word,
                                context: ayahData.arabic
                            });
                        }
                    });
                });
                allRootOccurrencesCache = [...foundOccurrences]; // Update the global cache
                if (allRootOccurrencesCache.length === 0) {
                    setStatusMessage('root-status', `No occurrences found for "${rootTerm}".`, false);
                    if (currentViewMode === 'list') {
                        occurrencesListElement.innerHTML = '<li>No occurrences found.</li>';
                    } else {
                        graphPlaceholder.textContent = 'No occurrences found to display in graph.';
                        graphPlaceholder.style.display = 'block';
                    }
                } else {
                    setStatusMessage('root-status', `Found ${allRootOccurrencesCache.length} occurrences for "${rootTerm}".`, false);
                    if (currentViewMode === 'list') {
                        occurrencesListElement.innerHTML = ''; // Clear any "graph active" message
                        allRootOccurrencesCache.forEach(occ => {
                            const li = document.createElement('li');
                            li.innerHTML = `
                                 <strong>Surah ${occ.surah}:${occ.ayah}</strong> - Word: <span lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.word}</span>
                                 <div class="result-context" lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.context}</div>
                             `;
                            occurrencesListElement.appendChild(li);
                        });
                    } else if (currentViewMode === 'tree') {
                        occurrencesListElement.innerHTML = '<li>Graph view active. Results may be paginated below.</li>';
                        graphPlaceholder.style.display = 'none';
                        updateRootGraphView(); // This will render the first page of the graph
                        paginationControls.style.display = (allRootOccurrencesCache.length > rootGraphItemsPerPage) ? 'flex' : 'none';
                    }
                }
            } catch (error) {
                console.error("Error analyzing root:", error);
                setStatusMessage('root-status', 'Failed to analyze root.', true);
                if (currentViewMode === 'list') occurrencesListElement.innerHTML = `<li>Error analyzing root: ${error.message}</li>`;
                else { graphPlaceholder.textContent = `Error analyzing root: ${error.message}`; graphPlaceholder.style.display = 'block'; }
            } finally {
                hideLoading();
            }
        }
        async function saveRootNotes() { // This function remains largely the same
            if (!db) return;
            const rootInput = document.getElementById('root-input');
            const descriptionInput = document.getElementById('root-description');
            const rootTerm = rootInput.value.trim();
            const description = descriptionInput.value.trim();
            if (!rootTerm) {
                setStatusMessage('root-status', 'Enter root word to save notes.', true);
                return;
            }
            showLoading("Saving root notes...");
            try {
                const allRoots = await getAllData(STORE_ROOTS);
                let existingRoot = allRoots.find(r => r.root === rootTerm);
                if (existingRoot) {
                    existingRoot.description = description;
                    await putData(STORE_ROOTS, existingRoot);
                    setStatusMessage('root-status', `Notes updated for "${rootTerm}".`, false);
                } else {
                    await addData(STORE_ROOTS, { root: rootTerm, description: description });
                    setStatusMessage('root-status', `Root "${rootTerm}" and notes saved.`, false);
                }
            } catch (error) {
                setStatusMessage('root-status', 'Failed to save root notes.', true);
            } finally {
                hideLoading();
            }
        }
        function updateRootGraphView() {
            const graphContainerWrapper = document.getElementById('root-network-graph-container');
            const graphContainer = document.getElementById('root-network-graph');
            const graphPlaceholder = document.getElementById('root-graph-placeholder');
            const paginationControls = document.getElementById('root-graph-pagination-controls');
            const analyzedRootTermElement = document.getElementById('analyzed-root-term');
            const rootTermForRender = analyzedRootTermElement ? analyzedRootTermElement.textContent : 'N/A'; // Defensive read
            if (graphContainerWrapper && !graphContainerWrapper.classList.contains('active-view')) {
                console.warn("updateRootGraphView called while graph view wrapper was not active. Forcing visible.");
                document.querySelectorAll('.root-view-content').forEach(el => {
                    el.classList.remove('active-view');
                    el.style.display = 'none';
                });
                graphContainerWrapper.classList.add('active-view');
                graphContainerWrapper.style.display = 'block';
            }
            if (rootTermForRender === 'N/A' || rootTermForRender.trim() === '') {
                if (graphContainer) graphContainer.innerHTML = '';
                if (rootNetwork) { rootNetwork.destroy(); rootNetwork = null; }
                if (graphPlaceholder) {
                    graphPlaceholder.textContent = 'Please analyze a root term first.';
                    graphPlaceholder.style.display = 'block';
                }
                if (paginationControls) paginationControls.style.display = 'none';
                console.log("updateRootGraphView: No root term analyzed.");
                return;
            }
            if (allRootOccurrencesCache.length === 0) {
                if (graphContainer) graphContainer.innerHTML = '';
                if (rootNetwork) { rootNetwork.destroy(); rootNetwork = null; }
                if (graphPlaceholder) {
                    graphPlaceholder.textContent = `No occurrences found for "${rootTermForRender}" to display in graph.`;
                    graphPlaceholder.style.display = 'block';
                }
                if (paginationControls) paginationControls.style.display = 'none';
                console.log("updateRootGraphView: allRootOccurrencesCache is empty.");
                return;
            }
            if (graphPlaceholder) graphPlaceholder.style.display = 'none';
            const startIndex = (currentRootGraphPage - 1) * rootGraphItemsPerPage;
            const endIndex = startIndex + rootGraphItemsPerPage;
            const occurrencesForPage = allRootOccurrencesCache.slice(startIndex, endIndex);
            console.log(`updateRootGraphView: Rendering page ${currentRootGraphPage} for root "${rootTermForRender}" with ${occurrencesForPage.length} items (from index ${startIndex} to ${endIndex - 1}).`);
            renderRootTreeGraph(rootTermForRender, occurrencesForPage);
            const totalPages = Math.ceil(allRootOccurrencesCache.length / rootGraphItemsPerPage);
            const pageInfoEl = document.getElementById('root-graph-page-info');
            const prevButton = document.getElementById('prev-root-graph-page-btn');
            const nextButton = document.getElementById('next-root-graph-page-btn');
            if (pageInfoEl) pageInfoEl.textContent = `Page ${currentRootGraphPage} of ${totalPages}`;
            if (prevButton) prevButton.disabled = (currentRootGraphPage === 1);
            if (nextButton) nextButton.disabled = (currentRootGraphPage >= totalPages);
            if (paginationControls) {
                if (totalPages > 1) {
                    paginationControls.style.display = 'flex';
                } else {
                    paginationControls.style.display = 'none';
                }
            }
            console.log(`Pagination updated: Page ${currentRootGraphPage}/${totalPages}. Prev disabled: ${prevButton ? prevButton.disabled : 'N/A'}, Next disabled: ${nextButton ? nextButton.disabled : 'N/A'}`);
        }
        function renderRootTreeGraph(rootTerm, occurrences) {
            if (typeof vis === 'undefined') {
                console.error("vis.js library is not loaded!");
                const errContainer = document.getElementById('root-network-graph');
                if (errContainer) errContainer.innerHTML = '<p style="color:red; text-align:center; padding:20px;">Error: Visualization library not loaded.</p>';
                return;
            }
            const container = document.getElementById('root-network-graph');
            if (!container) {
                console.error("Graph container #root-network-graph not found!");
                return;
            }
            container.innerHTML = ''; // Clear previous graph or placeholder
            if (rootNetwork) {
                rootNetwork.destroy();
                rootNetwork = null;
            }
            if (rootNodePopupEl) rootNodePopupEl.style.display = 'none';
            activeRootNodeIdForPopup = null;
            if (occurrences.length === 0 && rootTerm !== 'N/A' && rootTerm.trim() !== '') {
                container.innerHTML = `<p class="text-center" style="padding:20px;">No occurrences for "${rootTerm}" on this page.</p>`;
                return;
            } else if (rootTerm === 'N/A' || rootTerm.trim() === '') {
                container.innerHTML = `<p class="text-center" style="padding:20px;">Please analyze a root term.</p>`;
                return;
            }
            const arabicFontFamily = getCssVar('--font-arabic');
            const textPrimaryColor = getCssVar('--color-text-primary');
            const textSecondaryColor = getCssVar('--color-text-secondary');
            const bgSecondaryColor = getCssVar('--color-bg-secondary');
            const highlightBgColor = getCssVar('--color-highlight');
            const accentColorVar = getCssVar('--color-accent');
            const accentDarkColor = getCssVar('--color-accent-dark');
            const shadowColor = getCssVar('--color-shadow');
            const visNodes = new vis.DataSet();
            const visEdges = new vis.DataSet();
            const centralRootNodeId = 'ROOT_TERM_ID';
            visNodes.add({
                id: centralRootNodeId,
                label: rootTerm,
                font: { size: 22, face: arabicFontFamily, color: '#ffffff', strokeWidth: 0 },
                color: { background: accentDarkColor, border: accentColorVar, highlight: { background: accentColorVar, border: accentDarkColor } },
                shape: 'ellipse', size: 35, margin: { top: 15, right: 15, bottom: 15, left: 15 },
                fixed: false,
                isCentralRoot: true // Custom property
            });
            occurrences.forEach((occ, index) => {
                const pageSpecificIndex = ((currentRootGraphPage - 1) * rootGraphItemsPerPage) + index;
                const nodeId = `occ_${occ.surah}_${occ.ayah}_${pageSpecificIndex}_${occ.word.replace(/[^a-zA-Z0-9א-آء-ي]/g, '')}`;
                visNodes.add({
                    id: nodeId,
                    label: `${occ.word} (S${occ.surah}:A${occ.ayah})`,
                    details_context: occ.context, // CRITICAL: For popup content
                    details_surah: occ.surah,
                    details_ayah: occ.ayah,
                    details_word: occ.word,
                    font: { face: arabicFontFamily, size: 16, color: textPrimaryColor, multi: true },
                    color: { background: bgSecondaryColor, border: accentColorVar, highlight: { background: highlightBgColor, border: accentDarkColor } },
                    margin: { top: 8, right: 8, bottom: 8, left: 8 }, widthConstraint: { maximum: 300 }, heightConstraint: { minimum: 40 },
                    shape: 'box',
                    isCentralRoot: false // Custom property
                });
                visEdges.add({
                    from: centralRootNodeId, to: nodeId, arrows: 'to',
                    length: 180 + (occurrences.length > 10 ? occurrences.length * 2.5 : 0),
                    color: { color: textSecondaryColor, highlight: accentDarkColor, hover: accentColorVar }
                });
            });
            const data = { nodes: visNodes, edges: visEdges };
            const options = {
                layout: { hierarchical: false },
                interaction: { dragNodes: true, dragView: true, hover: true, tooltipDelay: 200, navigationButtons: true, keyboard: true },
                physics: {
                    enabled: true, barnesHut: { gravitationalConstant: -12000, centralGravity: 0.2, springLength: 180, springConstant: 0.025, damping: 0.08, avoidOverlap: 0.1 },
                    solver: 'barnesHut', stabilization: { enabled: true, iterations: 800, fit: true, updateInterval: 30 }
                },
                nodes: { borderWidth: 1.5, shadow: { enabled: true, size: 7, x: 4, y: 4, color: shadowColor } },
                edges: {
                    smooth: { enabled: true, type: "continuous", roundness: 0.5 },
                    arrows: { to: { enabled: true, scaleFactor: 0.9, type: 'arrow' } },
                    width: 1.8
                }
            };
            try {
                rootNetwork = new vis.Network(container, data, options);
            } catch (e) {
                console.error("Error initializing Vis.js Network:", e);
                container.innerHTML = `<p style="color:red;text-align:center;padding:20px;">Error creating graph. Check console.</p>`;
                return;
            }
            rootNetwork.on("click", function (params) {
                activeRootNodeIdForPopup = null;
                if (rootNodePopupEl) rootNodePopupEl.style.display = 'none';
                if (params.nodes.length > 0) {
                    const clickedNodeId = params.nodes[0];
                    activeRootNodeIdForPopup = clickedNodeId;
                    positionRootNodePopupElement(clickedNodeId);
                } else {
                }
            });
            const updatePopupOnMoveOrZoom = () => {
                if (activeRootNodeIdForPopup !== null && rootNodePopupEl && rootNodePopupEl.style.display === 'block') {
                    positionRootNodePopupElement(activeRootNodeIdForPopup);
                }
            };
            rootNetwork.on("dragging", updatePopupOnMoveOrZoom);
            rootNetwork.on("zoom", updatePopupOnMoveOrZoom);
            rootNetwork.on("dragEnd", function (params) {
                if (activeRootNodeIdForPopup !== null && params.nodes && params.nodes.includes(activeRootNodeIdForPopup)) {
                    positionRootNodePopupElement(activeRootNodeIdForPopup);
                }
            });
        }
        function positionRootNodePopupElement(nodeId) {
            if (!rootNetwork || !rootNodePopupEl) {
                console.warn("positionRootNodePopupElement: rootNetwork or rootNodePopupEl not available.");
                if (rootNodePopupEl) rootNodePopupEl.style.display = 'none';
                return;
            }
            if (nodeId === null) { // Call this to hide the popup
                rootNodePopupEl.style.display = 'none';
                activeRootNodeIdForPopup = null; // Reset active node ID
                return;
            }
            const visNodesDataSet = rootNetwork.body.data.nodes; // Access the DataSet
            const clickedNodeData = visNodesDataSet.get(nodeId);
            if (!clickedNodeData) {
                console.warn("Node data not found for ID:", nodeId, "in vis.DataSet. Hiding popup.");
                rootNodePopupEl.style.display = 'none';
                activeRootNodeIdForPopup = null;
                return;
            }
            let popupHTML = "";
            const arabicFont = getCssVar('--font-arabic');
            const accentDarkColor = getCssVar('--color-accent-dark');
            const textPrimaryColor = getCssVar('--color-text-primary'); // For general text if needed
            const generalFontSize = '1.1rem';
            const arabicContextFontSize = '1.6rem';
            const generalLineHeight = '1.8';
            const arabicContextLineHeight = '2';
            if (clickedNodeData.isCentralRoot) {
                const rootDescriptionText = document.getElementById('root-description').value; // Get live value
                popupHTML = `
                        <h4 style="font-family: ${arabicFont}; font-size: 1.5rem; color: ${accentDarkColor}; margin-top:0; margin-bottom:10px;">Root: ${clickedNodeData.label}</h4>
                        <p style="margin:0; line-height: ${generalLineHeight}; font-size: ${generalFontSize}; color: ${textPrimaryColor};">
                            ${rootDescriptionText.trim() !== "" ? rootDescriptionText.replace(/\n/g, '<br>') : "No description available for this root."}
                        </p>`;
            } else { // This is for the occurrence nodes (Ayah context)
                const wordDisplay = clickedNodeData.details_word || clickedNodeData.label.split(' (S')[0];
                popupHTML = `
                        <h4 style="font-family: ${arabicFont}; font-size: 1.5rem; color: ${accentDarkColor}; margin-top:0; margin-bottom:10px;">
                            ${wordDisplay} (S${clickedNodeData.details_surah || '?'}:A${clickedNodeData.details_ayah || '?'})
                        </h4>
                        <p style="margin:0; line-height: ${arabicContextLineHeight}; font-size: ${arabicContextFontSize}; font-family: ${arabicFont}; direction: rtl; text-align: right; color: ${textPrimaryColor};">
                            ${clickedNodeData.details_context || "Full Ayah context not available."}
                        </p>`;
            }
            rootNodePopupEl.innerHTML = popupHTML;
            try {
                const nodePosition = rootNetwork.getPositions([nodeId])[nodeId];
                if (!nodePosition) {
                    rootNodePopupEl.style.display = 'none'; return;
                }
                const domPosition = rootNetwork.canvasToDOM(nodePosition);
                rootNodePopupEl.style.display = 'block'; // Make it visible to measure
                let popupLeft = domPosition.x + 25;
                let popupTop = domPosition.y - (rootNodePopupEl.offsetHeight / 2);
                const popupRect = rootNodePopupEl.getBoundingClientRect();
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                if (popupLeft + popupRect.width > vw - 15) {
                    popupLeft = domPosition.x - popupRect.width - 25;
                }
                if (popupLeft < 15) {
                    popupLeft = 15;
                }
                if (popupTop + popupRect.height > vh - 15) {
                    popupTop = vh - popupRect.height - 15;
                }
                if (popupTop < 15) {
                    popupTop = 15;
                }
                rootNodePopupEl.style.left = popupLeft + 'px';
                rootNodePopupEl.style.top = popupTop + 'px';
            } catch (e) {
                console.warn("Could not get node position for popup:", e);
                if (rootNodePopupEl) rootNodePopupEl.style.display = 'none';
            }
        }
        let isLoadingRecitationLogsGlobalFlag = false;
        async function loadRecitationLogs() {
            if (!db) {
                return;
            }
            if (isLoadingRecitationLogsGlobalFlag) {
                return;
            }
            isLoadingRecitationLogsGlobalFlag = true;
            const listEl = document.getElementById('recitations-list');
            if (!listEl) {
                console.error('[loadRecitationLogs] Element with ID "recitations-list" not found.');
                isLoadingRecitationLogsGlobalFlag = false;
                return;
            }
            listEl.innerHTML = ''; // Clear the list at the very beginning
            showLoading("Loading recitation logs...");
            try {
                const logs = await getAllData(STORE_RECITATIONS);
                if (!listEl.parentNode) {
                    isLoadingRecitationLogsGlobalFlag = false;
                    hideLoading();
                    return;
                }
                if (logs.length === 0) {
                    listEl.innerHTML = '<li>No entries logged yet.</li>';
                } else {
                    logs.sort((a, b) => new Date(b.date) - new Date(a.date));
                    logs.forEach(log => {
                        const li = document.createElement('li');
                        const range = log.ayahStart && log.ayahEnd ? `Ayahs ${log.ayahStart}-${log.ayahEnd}` :
                            log.ayahStart ? `Ayah ${log.ayahStart}` : 'Full Surah';
                        li.innerHTML = `
                                <strong>S ${log.surah} (${surahNames[log.surah - 1]})</strong> - ${range} <br>
                                Qari: ${log.qari || 'N/A'} | Date: ${log.date || 'N/A'}
                                ${log.notes ? `<br>Notes: <em>${log.notes}</em>` : ''}
                                <div style="margin-top: 5px;">
                                    <button data-log-id="${log.id}" class="delete-recitation-btn">Delete</button>
                                </div>
                            `;
                        listEl.appendChild(li);
                    });
                    listEl.querySelectorAll('.delete-recitation-btn').forEach(button => {
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', handleDeleteRecitationLog);
                    });
                }
            } catch (error) {
                console.error("[loadRecitationLogs] Error:", error);
                if (listEl) { // Check if listEl still exists before modifying
                    listEl.innerHTML = `<li>Error loading recitation logs: ${error.message}</li>`;
                }
            } finally {
                hideLoading();
                isLoadingRecitationLogsGlobalFlag = false; // Reset the flag
            }
        }
        async function saveRecitationLog() {
            if (!db) return;
            const surah = parseInt(document.getElementById('rec-surah-select').value, 10);
            const ayahStart = document.getElementById('rec-ayah-start').value ? parseInt(document.getElementById('rec-ayah-start').value, 10) : null;
            const ayahEnd = document.getElementById('rec-ayah-end').value ? parseInt(document.getElementById('rec-ayah-end').value, 10) : null;
            const qari = document.getElementById('rec-qari').value.trim();
            const date = document.getElementById('rec-date').value;
            const notes = document.getElementById('rec-notes').value.trim();
            if (isNaN(surah)) { setStatusMessage('recitation-status', 'Select Surah.', true); return; }
            if (!date) { setStatusMessage('recitation-status', 'Select date.', true); return; }
            if (ayahStart && (isNaN(ayahStart) || ayahStart < 1 || ayahStart > surahAyahCounts[surah])) {
                setStatusMessage('recitation-status', `Invalid Ayah Start.`, true); return;
            }
            if (ayahEnd && (isNaN(ayahEnd) || ayahEnd < 1 || ayahEnd > surahAyahCounts[surah])) {
                setStatusMessage('recitation-status', `Invalid Ayah End.`, true); return;
            }
            if (ayahStart && ayahEnd && ayahStart > ayahEnd) {
                setStatusMessage('recitation-status', 'Start Ayah > End Ayah.', true); return;
            }
            showLoading("Saving recitation log...");
            try {
                await addData(STORE_RECITATIONS, { surah, ayahStart, ayahEnd, qari, date, notes });
                setStatusMessage('recitation-status', 'Log entry saved.', false);
                ['rec-ayah-start', 'rec-ayah-end', 'rec-qari', 'rec-date', 'rec-notes'].forEach(id => document.getElementById(id).value = '');
                loadRecitationLogs();
            } catch (error) {
                setStatusMessage('recitation-status', 'Failed to save log.', true);
            } finally {
                hideLoading();
            }
        }
        async function handleDeleteRecitationLog(event) {
            if (!db) return;
            const logId = parseInt(event.target.getAttribute('data-log-id'), 10);
            if (isNaN(logId) || !confirm("Delete this log entry?")) return;
            showLoading("Deleting log entry...");
            try {
                await deleteData(STORE_RECITATIONS, logId);
                setStatusMessage('recitation-status', 'Log entry deleted.', false);
                loadRecitationLogs();
            } catch (error) {
                setStatusMessage('recitation-status', 'Failed to delete log.', true);
            } finally {
                hideLoading();
            }
        }
        let isLoadingHifzForSurahGlobalFlag = false;
        async function loadHifzForSurah(surah) {
            if (!db) {
                return;
            }
            if (isLoadingHifzForSurahGlobalFlag) {
                return;
            }
            isLoadingHifzForSurahGlobalFlag = true;
            const listEl = document.getElementById('hifz-ayahs-list');
            if (!listEl) {
                console.error('[loadHifzForSurah] Element with ID "hifz-ayahs-list" not found.');
                isLoadingHifzForSurahGlobalFlag = false;
                return;
            }
            listEl.innerHTML = ''; // Clear the list at the very beginning
            if (isNaN(surah) || surah < 1 || surah > 114) {
                listEl.innerHTML = '<p class="text-center">Select a valid Surah.</p>';
                isLoadingHifzForSurahGlobalFlag = false;
                return;
            }
            showLoading(`Loading Hifz for Surah ${surah} (${surahNames[surah - 1] || ''})...`);
            try {
                const totalAyahs = surahAyahCounts[surah]; // Ensure surahAyahCounts is globally available
                const store = getObjectStore(STORE_HIFZ, 'readonly');
                const keyRange = IDBKeyRange.bound([surah, 1], [surah, totalAyahs + 1]); // +1 to be inclusive of last ayah
                const request = store.getAll(keyRange);
                const hifzEntries = await new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => {
                        console.error(`Error fetching hifz entries for Surah ${surah}:`, event.target.error);
                        reject(event.target.error);
                    };
                });
                if (!listEl.parentNode) {
                    console.warn(`[loadHifzForSurah] listEl no longer in DOM after fetching data for Surah ${surah}.`);
                    isLoadingHifzForSurahGlobalFlag = false;
                    hideLoading();
                    return;
                }
                const hifzMap = new Map(hifzEntries.map(e => [e.ayah, e]));
                if (totalAyahs === 0) {
                    listEl.innerHTML = `<p class="text-center">No Ayahs listed for Surah ${surah}.</p>`;
                } else {
                    for (let i = 1; i <= totalAyahs; i++) {
                        const ayahData = hifzMap.get(i) || { surah, ayah: i, status: 'not-started', lastReviewDate: null, nextReviewDate: null, reviewCount: 0, notes: '' };
                        const li = document.createElement('div'); // Using div as per original for class 'ayah'
                        li.classList.add('ayah'); // This class usually has padding/border
                        li.setAttribute('data-ayah-ref', `${surah}:${i}`); // For easier debugging
                        let statusText = ayahData.status.replace('-', ' ');
                        let reviewInfo = '';
                        if (ayahData.status === 'memorized' && ayahData.nextReviewDate) {
                            reviewInfo = ` | Next Review: ${ayahData.nextReviewDate}`;
                        }
                        li.innerHTML = `
                            <div class="ayah-number">S ${surah}:${i}</div>
                            <div class="hifz-ayah-details" style="margin-bottom: 8px;">
                                Status: <span class="hifz-ayah-status status-${ayahData.status}">${statusText}</span>${reviewInfo}
                            </div>
                            <div class="hifz-ayah-controls flex-group" style="justify-content: flex-start; gap: 5px;">
                                <button data-surah="${surah}" data-ayah="${i}" data-status="not-started" class="set-hifz-status-btn" aria-label="Set Surah ${surah} Ayah ${i} to Not Started" ${ayahData.status === 'not-started' ? 'disabled' : ''}>Not Started</button>
                                <button data-surah="${surah}" data-ayah="${i}" data-status="in-progress" class="set-hifz-status-btn" aria-label="Set Surah ${surah} Ayah ${i} to In Progress" ${ayahData.status === 'in-progress' ? 'disabled' : ''}>In Progress</button>
                                <button data-surah="${surah}" data-ayah="${i}" data-status="memorized" class="set-hifz-status-btn" aria-label="Set Surah ${surah} Ayah ${i} to Memorized" ${ayahData.status === 'memorized' ? 'disabled' : ''}>Memorized</button>
                                ${ayahData.status === 'memorized' ? `<button data-surah="${surah}" data-ayah="${i}" class="record-review-btn" aria-label="Record review for Surah ${surah} Ayah ${i}">Record Review</button>` : ''}
                                <button data-surah="${surah}" data-ayah="${i}" class="view-hifz-notes-btn" aria-label="View or edit notes for Surah ${surah} Ayah ${i}">Notes</button>
                            </div>
                        `;
                        listEl.appendChild(li);
                    }
                    listEl.querySelectorAll('.set-hifz-status-btn').forEach(button => {
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', handleSetHifzStatus);
                    });
                    listEl.querySelectorAll('.record-review-btn').forEach(button => {
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', handleRecordReview);
                    });
                    listEl.querySelectorAll('.view-hifz-notes-btn').forEach(button => {
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', handleViewHifzNotes);
                    });
                }
            } catch (error) {
                console.error(`[loadHifzForSurah] Error for Surah ${surah}:`, error);
                if (listEl) { // Check if listEl still exists
                    listEl.innerHTML = `<li>Error loading Hifz data for Surah ${surah}: ${error.message}</li>`;
                }
            } finally {
                hideLoading();
                isLoadingHifzForSurahGlobalFlag = false; // Reset the flag
            }
        }
        async function handleSetHifzStatus(event) {
            if (!db) return;
            const surah = parseInt(event.target.getAttribute('data-surah'), 10);
            const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
            const status = event.target.getAttribute('data-status');
            showLoading(`Setting status for ${surah}:${ayah}...`);
            try {
                const existing = await getData(STORE_HIFZ, [surah, ayah]) || { surah, ayah, status: 'not-started', lastReviewDate: null, nextReviewDate: null, reviewCount: 0, notes: '' };
                existing.status = status;
                if (status !== 'memorized') {
                    existing.lastReviewDate = null; existing.nextReviewDate = null; existing.reviewCount = 0;
                } else if (!existing.lastReviewDate) {
                    existing.lastReviewDate = new Date().toISOString().split('T')[0];
                    existing.reviewCount = 0;
                    existing.nextReviewDate = calculateNextReview(existing.lastReviewDate, existing.reviewCount);
                }
                await putData(STORE_HIFZ, existing);
                setStatusMessage('hifz-status', `Status updated for ${surah}:${ayah}.`, false);
                loadHifzForSurah(surah);
            } catch (error) {
                setStatusMessage('hifz-status', 'Failed to update status.', true);
            } finally {
                hideLoading();
            }
        }
        async function handleRecordReview(event) {
            if (!db) return;
            const surah = parseInt(event.target.getAttribute('data-surah'), 10);
            const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
            showLoading(`Recording review for ${surah}:${ayah}...`);
            try {
                const existing = await getData(STORE_HIFZ, [surah, ayah]);
                if (!existing || existing.status !== 'memorized') {
                    setStatusMessage('hifz-status', 'Ayah not memorized.', true); hideLoading(); return;
                }
                existing.lastReviewDate = new Date().toISOString().split('T')[0];
                existing.reviewCount = (existing.reviewCount || 0) + 1;
                existing.nextReviewDate = calculateNextReview(existing.lastReviewDate, existing.reviewCount);
                await putData(STORE_HIFZ, existing);
                setStatusMessage('hifz-status', `Review recorded. Next: ${existing.nextReviewDate}`, false);
                loadHifzForSurah(surah);
            } catch (error) {
                setStatusMessage('hifz-status', 'Failed to record review.', true);
            } finally {
                hideLoading();
            }
        }
        function calculateNextReview(lastReviewDate, reviewCount) {
            const date = new Date(lastReviewDate);
            let daysToAdd = [1, 3, 7, 15, 30, 60, 90][Math.min(reviewCount, 6)] || 120; // Cap at 120 or extend
            date.setDate(date.getDate() + daysToAdd);
            return date.toISOString().split('T')[0];
        }
        async function handleViewHifzNotes(event) {
            if (!db) return;
            const surah = parseInt(event.target.getAttribute('data-surah'), 10);
            const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
            showLoading(`Loading notes for ${surah}:${ayah}...`);
            try {
                const existing = await getData(STORE_HIFZ, [surah, ayah]) || { surah, ayah, status: 'not-started', notes: '' };
                const notes = prompt(`Notes for Surah ${surah}:${ayah}:\n${existing.notes}\nEdit notes:`, existing.notes || '');
                if (notes !== null && notes !== existing.notes) {
                    existing.notes = notes;
                    await putData(STORE_HIFZ, existing);
                    setStatusMessage('hifz-status', `Notes updated.`, false);
                    loadHifzForSurah(surah);
                } else {
                    setStatusMessage('hifz-status', 'Notes unchanged.', false);
                }
            } catch (error) {
                setStatusMessage('hifz-status', 'Failed to load/save notes.', true);
            } finally {
                hideLoading();
            }
        }
        async function performSearch() {
            if (!db) return;
            const searchTerm = document.getElementById('search-input').value.trim().toLowerCase();
            const searchScopes = Array.from(document.querySelectorAll('.search-scope:checked')).map(cb => cb.value);
            const searchResultsList = document.getElementById('search-results-list');
            searchResultsList.innerHTML = '';
            if (!searchTerm) {
                setStatusMessage('search-status', 'Please enter a search term.', true);
                return;
            }
            if (searchScopes.length === 0) {
                setStatusMessage('search-status', 'Please select at least one search scope.', true);
                return;
            }
            showLoading(`Searching for "${searchTerm}"...`);
            try {
                const results = [];
                if (searchScopes.includes('quran-arabic') || searchScopes.includes('quran-translation')) {
                    const allAyahs = await getAllData(STORE_QURAN);
                    allAyahs.forEach(ayah => {
                        const normalizedSearchTerm = searchTerm.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").replace(/ؤ|و/g, "(و|ؤ)").replace(/ك|ک/g, "(ك|ک)").replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)").replace(/ى|ی|ي/g, "(ى|ی|ي)").replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)").replace(/ے/g, "(ے|ی)").replace(/م/g, "(مٰ|م)");
                        const matchArabic = searchScopes.includes('quran-arabic') &&
                            ayah.arabic.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").replace(/ؤ|و/g, "(و|ؤ)").replace(/ك|ک/g, "(ك|ک)").replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)").replace(/ى|ی|ي/g, "(ى|ی|ي)").replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)").replace(/ے/g, "(ے|ی)").replace(/م/g, "(مٰ|م)").includes(normalizedSearchTerm);
                        let matchTranslation = false;
                        let translationSource = '';
                        let allTranslationsContext = [];
                        if (searchScopes.includes('quran-translation')) {
                            for (const langKey in TRANSLATION_CONFIG) {
                                if (ayah[langKey] && ayah[langKey].toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").includes(normalizedSearchTerm)) {
                                    matchTranslation = true;
                                    translationSource = TRANSLATION_CONFIG[langKey].label; // Get human-readable label
                                }
                                if (ayah[langKey]) {
                                    allTranslationsContext.push(`${TRANSLATION_CONFIG[langKey].label}: ${ayah[langKey]}`);
                                }
                            }
                        }
                        if (matchArabic || matchTranslation) {
                            results.push({
                                type: 'Quran',
                                ref: `Surah ${ayah.surah}:${ayah.ayah}`,
                                surah: ayah.surah,
                                ayah: ayah.ayah,
                                context: `${ayah.arabic}${allTranslationsContext.length > 0 ? ' - ' + allTranslationsContext.join(' - ') : ''}`,
                                source: matchArabic && matchTranslation ? `Arabic & Translation (${translationSource})` : matchArabic ? 'Arabic' : `Translation (${translationSource})`
                            });
                        }
                    });
                }
                if (searchScopes.includes('tafsir')) {
                    const allTafsir = await getAllData(STORE_TAFSIR);
                    allTafsir.forEach(tafsir => {
                        if (tafsir.notes && tafsir.notes.toLowerCase().includes(searchTerm)) {
                            results.push({
                                type: 'Tafsir',
                                ref: `Surah ${tafsir.surah}:${tafsir.ayah}`,
                                surah: tafsir.surah,
                                ayah: tafsir.ayah,
                                context: tafsir.notes,
                                source: 'Personal Tafsir'
                            });
                        }
                    });
                }
                if (searchScopes.includes('themes')) {
                    const allThemes = await getAllData(STORE_THEMES);
                    allThemes.forEach(theme => {
                        if (theme.description && theme.description.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").includes(searchTerm)) {
                            results.push({
                                type: 'Theme',
                                ref: `Theme: ${theme.name}`,
                                context: theme.description,
                                source: 'Theme Description'
                            });
                        }
                    });
                    const allThemeAyahLinks = await getAllData(STORE_THEME_AYAHS);
                    const themesMap = new Map((await getAllData(STORE_THEMES)).map(t => [t.id, t.name]));
                    allThemeAyahLinks.forEach(link => {
                        if (link.notes && link.notes.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").includes(searchTerm)) {
                            results.push({
                                type: 'Theme Link',
                                ref: `Surah ${link.surah}:${link.ayah} (Theme: ${themesMap.get(link.themeId) || 'Unknown'})`,
                                surah: link.surah,
                                ayah: link.ayah,
                                context: link.notes,
                                source: 'Theme Link Notes'
                            });
                        }
                    });
                }
                if (searchScopes.includes('roots')) {
                    const allRoots = await getAllData(STORE_ROOTS);
                    allRoots.forEach(root => {
                        if (root.description && root.description.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").includes(searchTerm)) { // Assuming 'description' is the notes field
                            results.push({
                                type: 'Root',
                                ref: `Root: ${root.root}`,
                                context: root.description,
                                source: 'Root Notes'
                            });
                        }
                    });
                }
                if (searchScopes.includes('recitation')) {
                    const allRecitations = await getAllData(STORE_RECITATIONS);
                    allRecitations.forEach(log => {
                        if (log.notes && log.notes.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").includes(searchTerm)) {
                            const range = log.ayahStart && log.ayahEnd ? `${log.ayahStart}-${log.ayahEnd}` :
                                log.ayahStart ? `${log.ayahStart}` :
                                    log.ayahEnd ? `Up to ${log.ayahEnd}` : 'Full Surah';
                            results.push({
                                type: 'Recitation Log',
                                ref: `Surah ${log.surah} (${range})`,
                                context: log.notes,
                                source: 'Recitation Notes'
                            });
                        }
                    });
                }
                if (searchScopes.includes('hifz')) {
                    const allHifz = await getAllData(STORE_HIFZ);
                    allHifz.forEach(hifz => {
                        if (hifz.notes && hifz.notes.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").includes(searchTerm)) {
                            results.push({
                                type: 'Hifz',
                                ref: `Surah ${hifz.surah}:${hifz.ayah}`,
                                surah: hifz.surah,
                                ayah: hifz.ayah,
                                context: hifz.notes,
                                source: 'Hifz Notes'
                            });
                        }
                    });
                }
                if (results.length === 0) {
                    searchResultsList.innerHTML = '<li>No results found.</li>';
                    setStatusMessage('search-status', `No results found for "${searchTerm}".`, false);
                } else {
                    setStatusMessage('search-status', `Found ${results.length} results for "${searchTerm}".`, false);
                    results.sort((a, b) => {
                        if (a.surah && b.surah && a.surah !== b.surah) return a.surah - b.surah;
                        if (a.ayah && b.ayah) return a.ayah - b.ayah;
                        return 0; // Don't sort other types
                    });
                    results.forEach(result => {
                        const li = document.createElement('li');
                        li.innerHTML = `
                             <strong>${result.type}: ${result.ref}</strong> (${result.source})
                             <div class="result-context">${highlightMatch(result.context, searchTerm)}</div>
                             ${(result.type === 'Quran' || result.type === 'Tafsir' || result.type === 'Hifz') ?
                                `<button data-surah="${result.surah}" data-ayah="${result.ayah}" class="go-to-ayah-btn" style="margin-top: 5px; padding: 3px 8px; font-size: 0.8rem;">Go to Ayah</button>` : ''}
                         `;
                        searchResultsList.appendChild(li);
                    });
                    searchResultsList.querySelectorAll('.go-to-ayah-btn').forEach(button => {
                        button.addEventListener('click', handleGoToAyahFromSearch);
                    });
                }
            } catch (error) {
                console.error("Error during search:", error);
                setStatusMessage('search-status', 'Failed to perform search.', true);
                searchResultsList.innerHTML = `<li>Error during search: ${error.message}</li>`;
            } finally {
                hideLoading();
            }
        }
        function highlightMatch(text, searchTerm) {
            if (!text || !searchTerm) return text;
            const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }
        async function handleGoToAyahFromSearch(event) {
            const surah = parseInt(event.target.getAttribute('data-surah'), 10);
            const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
            if (!isNaN(surah) && !isNaN(ayah)) {
                await loadAyah(surah, ayah);
                showSection('quran');
            }
        }
        async function exportData() {
            if (!db) return;
            showLoading("Exporting data...");
            try {
                const data = {};
                const userStores = [STORE_TAFSIR, STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS, STORE_HIFZ];
                for (const storeName of userStores) {
                    data[storeName] = await getAllData(storeName);
                }
                const jsonString = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `nur-al-quran-studio-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                setStatusMessage('export-status', 'Data exported.', false);
            } catch (error) {
                setStatusMessage('export-status', 'Export failed.', true);
            } finally {
                hideLoading();
            }
        }
        function getCssVar(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }
        async function importData(file) {
            if (!db || !file || !confirm("Importing will overwrite existing data. Continue?")) return;
            showLoading("Importing data...");
            try {
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        const userStores = [STORE_TAFSIR, STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS, STORE_HIFZ];
                        for (const storeName of userStores) {
                            if (!Array.isArray(data[storeName])) throw new Error(`Invalid data for ${storeName}`);
                        }
                        const transaction = db.transaction(userStores, 'readwrite');
                        transaction.oncomplete = async () => {
                            setStatusMessage('import-status', 'Data imported.', false);
                            await loadAyah(currentSurah, currentAyah); // Refresh UI
                            displayThemesList(); loadRecitationLogs();
                            if (document.getElementById('hifz-surah-select').value) loadHifzForSurah(parseInt(document.getElementById('hifz-surah-select').value, 10));
                            hideLoading();
                        };
                        transaction.onerror = () => { setStatusMessage('import-status', 'Import transaction failed.', true); hideLoading(); };
                        for (const storeName of userStores) {
                            const store = transaction.objectStore(storeName);
                            store.clear();
                            if (data[storeName]) {
                                data[storeName].forEach(item => {
                                    if ([STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS].includes(storeName)) {
                                        const newItem = { ...item };
                                        delete newItem.id; // Let DB assign new ID
                                        store.add(newItem).catch(e => console.warn(`Could not add item to ${storeName} during import: `, item, e));
                                    } else {
                                        store.put(item).catch(e => console.warn(`Could not put item to ${storeName} during import: `, item, e));
                                    }
                                });
                            }
                        }
                    } catch (parseError) {
                        setStatusMessage('import-status', 'Invalid import file format.', true); hideLoading();
                    }
                };
                reader.onerror = () => { setStatusMessage('import-status', 'Failed to read file.', true); hideLoading(); };
                reader.readAsText(file);
            } catch (error) {
                setStatusMessage('import-status', 'Import initiation failed.', true); hideLoading();
            }
        }
        async function clearAllPersonalData() {
            if (!db || !confirm("DELETE ALL personal data? This cannot be undone.")) return;
            showLoading("Clearing all personal data...");
            try {
                const userStores = [STORE_TAFSIR, STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS, STORE_HIFZ];
                const transaction = db.transaction(userStores, 'readwrite');
                transaction.oncomplete = () => {
                    setStatusMessage('clear-status', 'All personal data cleared.', false);
                    document.getElementById('tafsir-notes').value = '';
                    document.getElementById('themes-list').innerHTML = '<li>No themes added yet.</li>';
                    document.getElementById('root-occurrences-list').innerHTML = '<li>Enter a root word and click "Analyze Root".</li>';
                    document.getElementById('recitations-list').innerHTML = '<li>No entries logged yet.</li>';
                    document.getElementById('hifz-ayahs-list').innerHTML = '<p class="text-center">Select a Surah to track Hifz progress.</p>';
                    populateThemeSelects();
                    hideLoading();
                };
                transaction.onerror = () => { setStatusMessage('clear-status', 'Failed to clear data.', true); hideLoading(); };
                userStores.forEach(storeName => transaction.objectStore(storeName).clear());
            } catch (error) {
                setStatusMessage('clear-status', 'Data clear failed.', true); hideLoading();
            }
        }
        function applyTheme(themeName) {
            document.body.className = '';
            if (themeName !== 'serene') document.body.classList.add(`theme-${themeName}`);
            if (db) putData(STORE_SETTINGS, { name: 'theme', value: themeName }).catch(console.error);
        }
        async function loadThemePreference() {
            if (!db) return;
            try {
                const settings = await getData(STORE_SETTINGS, 'theme');
                const theme = settings ? settings.value : 'serene';
                document.getElementById('theme-switcher').value = theme;
                applyTheme(theme);
            } catch (error) { // Fallback to default
                document.getElementById('theme-switcher').value = 'serene'; applyTheme('serene');
            }
        }
        function setupEventListeners() {
            document.getElementById('surah-select').addEventListener('change', (event) => {
                currentSurah = parseInt(event.target.value, 10);
                updateAyahSelect(currentSurah);
                loadAyah(currentSurah, currentAyah);
            });
            document.getElementById('ayah-select').addEventListener('change', (event) => {
                currentAyah = parseInt(event.target.value, 10);
                loadAyah(currentSurah, currentAyah);
            });
            document.getElementById('translation-select').addEventListener('change', () => loadAyah(currentSurah, currentAyah));
            document.querySelectorAll('.nav-link').forEach(link => {
                link.addEventListener('click', (event) => {
                    event.preventDefault();
                    showSection(event.target.getAttribute('data-section'));
                });
            });
            document.getElementById('save-tafsir-btn').addEventListener('click', saveTafsir);
            document.getElementById('add-theme-btn').addEventListener('click', addTheme);
            document.getElementById('link-ayah-to-theme-btn').addEventListener('click', linkAyahToTheme);
            document.getElementById('link-theme-select').addEventListener('change', displayLinkedAyahsForCurrentTheme);
            document.getElementById('analyze-root-btn').addEventListener('click', analyzeRoot);
            document.getElementById('save-root-notes-btn').addEventListener('click', saveRootNotes);
            document.getElementById('save-recitation-btn').addEventListener('click', saveRecitationLog);
            document.getElementById('rec-surah-select').addEventListener('change', (event) => {
                const surah = parseInt(event.target.value, 10);
                const totalAyahs = surahAyahCounts[surah];
                document.getElementById('rec-ayah-start').max = totalAyahs;
                document.getElementById('rec-ayah-end').max = totalAyahs;
            });
            document.getElementById('hifz-surah-select').addEventListener('change', (event) => {
                loadHifzForSurah(parseInt(event.target.value, 10));
            });
            document.getElementById('perform-search-btn').addEventListener('click', performSearch);
            document.getElementById('export-data-btn').addEventListener('click', exportData);
            document.getElementById('import-file').addEventListener('change', (event) => {
                document.getElementById('import-data-btn').disabled = !event.target.files[0];
            });
            document.getElementById('import-data-btn').addEventListener('click', () => {
                const fileInput = document.getElementById('import-file');
                if (fileInput.files.length > 0) importData(fileInput.files[0]);
                else setStatusMessage('import-status', 'Select file to import.', true);
            });
            document.getElementById('clear-data-btn').addEventListener('click', clearAllPersonalData);
            document.getElementById('theme-switcher').addEventListener('change', (event) => applyTheme(event.target.value));
            document.querySelectorAll('.modal .close-button').forEach(button => {
                button.addEventListener('click', (event) => event.target.closest('.modal').style.display = 'none');
            });
            window.addEventListener('click', (event) => {
                document.querySelectorAll('.modal').forEach(modal => { if (event.target === modal) modal.style.display = 'none'; });
            });
            window.addEventListener('keydown', (event) => { // Close modals with Escape key
                if (event.key === 'Escape') {
                    document.querySelectorAll('.modal').forEach(modal => modal.style.display = 'none');
                }
            });
            setupTafsirDocxButton();
            document.querySelectorAll('input[name="root-view-mode"]').forEach(radio => {
                radio.addEventListener('change', function () {
                    const newViewMode = this.value;
                    const rootContents = document.querySelectorAll('.root-view-content');
                    rootContents.forEach(el => {
                        el.classList.remove('active-view');
                        el.style.display = 'none'; // Explicitly hide all first
                    });
                    document.getElementById('root-graph-placeholder').style.display = 'none';
                    const paginationControls = document.getElementById('root-graph-pagination-controls');
                    const occurrencesListElement = document.getElementById('root-occurrences-list');
                    const graphContainerWrapper = document.getElementById('root-network-graph-container'); // The wrapper
                    const graphContainer = document.getElementById('root-network-graph'); // The vis.js target
                    const analyzedRootTerm = document.getElementById('analyzed-root-term').textContent;
                    if (newViewMode === 'list') {
                        occurrencesListElement.classList.add('active-view');
                        occurrencesListElement.style.display = 'block'; // Explicitly show
                        paginationControls.style.display = 'none';
                        if (analyzedRootTerm !== 'N/A' && allRootOccurrencesCache.length > 0) {
                            occurrencesListElement.innerHTML = '';
                            allRootOccurrencesCache.forEach(occ => {
                                const li = document.createElement('li');
                                li.innerHTML = `
                                <strong>Surah ${occ.surah}:${occ.ayah}</strong> - Word: <span lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.word}</span>
                                <div class="result-context" lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.context}</div>
                            `;
                                occurrencesListElement.appendChild(li);
                            });
                        } else if (analyzedRootTerm === 'N/A') {
                            occurrencesListElement.innerHTML = '<li>Enter a root word and click "Analyze Root".</li>';
                        } else {
                            occurrencesListElement.innerHTML = '<li>No occurrences found or error in analysis.</li>';
                        }
                    } else if (newViewMode === 'tree') {
                        graphContainerWrapper.classList.add('active-view');
                        graphContainerWrapper.style.display = 'block'; // CRITICAL: Make wrapper visible BEFORE graph update
                        occurrencesListElement.innerHTML = '<li>Graph view active. Results may be paginated below if applicable.</li>';
                        if (analyzedRootTerm !== 'N/A' && allRootOccurrencesCache.length > 0) {
                            updateRootGraphView(); // Now this will find a visible container
                            paginationControls.style.display = (allRootOccurrencesCache.length > rootGraphItemsPerPage) ? 'flex' : 'none';
                        } else if (analyzedRootTerm !== 'N/A' && allRootOccurrencesCache.length === 0 && graphContainer.children.length === 0) {
                            analyzeRoot(); // analyzeRoot itself will handle calling updateRootGraphView
                        } else if (analyzedRootTerm === 'N/A') {
                            graphContainer.innerHTML = '';
                            document.getElementById('root-graph-placeholder').style.display = 'block';
                            document.getElementById('root-graph-placeholder').textContent = 'Enter a root and click "Analyze Root" to see the graph.';
                            paginationControls.style.display = 'none';
                        }
                    }
                });
            });
            function goToPrevRootGraphPage() {
                if (currentRootGraphPage > 1) {
                    currentRootGraphPage--;
                    updateRootGraphView();
                }
            }
            function goToNextRootGraphPage() {
                const totalPages = Math.ceil(allRootOccurrencesCache.length / rootGraphItemsPerPage);
                if (currentRootGraphPage < totalPages) {
                    currentRootGraphPage++;
                    updateRootGraphView();
                }
            }
            document.getElementById('prev-root-graph-page-btn').addEventListener('click', goToPrevRootGraphPage);
            document.getElementById('next-root-graph-page-btn').addEventListener('click', goToNextRootGraphPage);
            let graphCloseButton = null; // Keep a reference to the close button
            document.querySelectorAll('input[name="root-view-mode"]').forEach(radio => {
                radio.addEventListener('change', function () {
                    const newViewMode = this.value;
                    const rootSection = document.getElementById('roots');
                    const graphContainerWrapper = document.getElementById('root-network-graph-container');
                    const occurrencesListElement = document.getElementById('root-occurrences-list');
                    const mainContent = document.querySelector('.main-content'); // For restoring scroll
                    const header = document.querySelector('header'); // To hide/show
                    const sidebar = document.querySelector('.sidebar'); // To hide/show
                    if (graphCloseButton && graphCloseButton.parentNode) {
                        graphCloseButton.parentNode.removeChild(graphCloseButton);
                        graphCloseButton = null;
                    }
                    if (rootNodePopupEl) rootNodePopupEl.style.display = 'none';
                    activeRootNodeIdForPopup = null;
                    if (newViewMode === 'tree') {
                        document.body.classList.add('graph-fullscreen-active');
                        graphContainerWrapper.classList.add('fullscreen-graph');
                        if (header) header.style.display = 'none';
                        if (sidebar) sidebar.style.display = 'none';
                        mainContent.style.overflowY = 'hidden'; // Prevent main content from scrolling
                        occurrencesListElement.classList.remove('active-view');
                        occurrencesListElement.style.display = 'none';
                        graphContainerWrapper.classList.add('active-view');
                        graphContainerWrapper.style.display = 'flex'; // Changed to flex for alignment
                        graphCloseButton = document.createElement('button');
                        graphCloseButton.textContent = 'Close Graph (Esc)';
                        graphCloseButton.classList.add('graph-fullscreen-close-btn');
                        graphCloseButton.onclick = () => {
                            document.getElementById('root-view-list').click(); // Simulate click on list view radio
                        };
                        graphContainerWrapper.appendChild(graphCloseButton);
                        if (allRootOccurrencesCache.length > 0 || document.getElementById('analyzed-root-term').textContent !== 'N/A') {
                            updateRootGraphView(); // This should call renderRootTreeGraph
                        } else {
                            document.getElementById('root-network-graph').innerHTML = ''; // Clear
                            document.getElementById('root-graph-placeholder').textContent = 'Analyze a root to see the graph.';
                            document.getElementById('root-graph-placeholder').style.display = 'block';
                        }
                        const paginationControls = document.getElementById('root-graph-pagination-controls');
                        if (paginationControls) {
                            paginationControls.style.display = (allRootOccurrencesCache.length > rootGraphItemsPerPage) ? 'flex' : 'none';
                        }
                    } else { // newViewMode === 'list'
                        document.body.classList.remove('graph-fullscreen-active');
                        graphContainerWrapper.classList.remove('fullscreen-graph');
                        if (header) header.style.display = ''; // Or 'flex' depending on its default
                        if (sidebar) sidebar.style.display = '';
                        mainContent.style.overflowY = 'auto';
                        graphContainerWrapper.classList.remove('active-view');
                        graphContainerWrapper.style.display = 'none';
                        occurrencesListElement.classList.add('active-view');
                        occurrencesListElement.style.display = 'block';
                        document.getElementById('root-graph-pagination-controls').style.display = 'none';
                        const analyzedRootTermText = document.getElementById('analyzed-root-term').textContent;
                        if (analyzedRootTermText !== 'N/A' && allRootOccurrencesCache.length > 0) {
                            occurrencesListElement.innerHTML = ''; // Clear previous
                            allRootOccurrencesCache.forEach(occ => {
                                const li = document.createElement('li');
                                li.innerHTML = `<strong>Surah ${occ.surah}:${occ.ayah}</strong> - Word: <span lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.word}</span><div class="result-context" lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.context}</div>`;
                                occurrencesListElement.appendChild(li);
                            });
                        } else if (analyzedRootTermText === 'N/A' || analyzedRootTermText.trim() === '') {
                            occurrencesListElement.innerHTML = '<li>Enter a root word and click "Analyze Root".</li>';
                        } else {
                            occurrencesListElement.innerHTML = '<li>No occurrences found or error in analysis.</li>';
                        }
                    }
                });
            });
            window.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' && document.body.classList.contains('graph-fullscreen-active')) {
                    if (graphCloseButton) {
                        graphCloseButton.click(); // Trigger the close button's logic
                    }
                }
            });
        }
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await openDB();
                await loadThemePreference();
                setupEventListeners(); // Setup listeners after DB is open
                await loadQuranData(); // This populates selects and loads initial ayah
                displayThemesList();
            } catch (error) {
                console.error("App initialization failed:", error);
                hideLoading();
                alert("Failed to initialize: " + error.message + "\nPlease clear website data and refresh. Check console for details.");
            }
            rootNodePopupEl = document.getElementById('root-node-popup');
            if (!rootNodePopupEl) {
                console.error("CRITICAL: Popup element #root-node-popup not found in the DOM!");
            }
        });
    </script>
</body>
</html>
<script>
    async function loadDocxJs() {
        return new Promise((resolve, reject) => {
            if (window.docx) { // Check if already loaded
                console.log("docx.js already loaded.");
                resolve(window.docx);
                return;
            }
            console.log("Loading docx.js library...");
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/docx@9.5.0/dist/index.iife.min.js';
            script.onload = () => {
                console.log("docx.js loaded successfully.");
                resolve(window.docx); // The library attaches itself to window.docx
            };
            script.onerror = (err) => {
                console.error("Failed to load docx.js library:", err);
                reject("Failed to load DOCX library. Please check your internet connection.");
            };
            document.head.appendChild(script);
        });
    }
    async function exportTafsirToDocx() {
        setStatusMessage('export-tafsir-docx-status', 'Initializing DOCX export...', false);
        showLoading("Preparing Tafsir for DOCX export...");
        let docx;
        try {
            docx = await loadDocxJs();
            if (!docx || !docx.Document || !docx.Packer || !docx.Paragraph || !docx.TextRun || !docx.HeadingLevel) {
                throw new Error("DOCX library not loaded correctly or is an incompatible version.");
            }
        } catch (error) {
            console.error("Error loading DOCX library:", error);
            setStatusMessage('export-tafsir-docx-status', typeof error === 'string' ? error : 'Failed to load DOCX library.', true);
            hideLoading();
            return;
        }
        if (!db) {
            setStatusMessage('export-tafsir-docx-status', 'Database not ready.', true);
            hideLoading();
            return;
        }
        try {
            const allTafsirEntries = await getAllData(STORE_TAFSIR);
            if (!allTafsirEntries || allTafsirEntries.length === 0) {
                setStatusMessage('export-tafsir-docx-status', 'No Tafsir notes found to export.', false);
                hideLoading();
                return;
            }
            allTafsirEntries.sort((a, b) => {
                if (a.surah !== b.surah) return a.surah - b.surah;
                return a.ayah - b.ayah;
            });
            const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, ShadingType, convertInchesToTwip } = docx;
            const children = [];
            children.push(
                new Paragraph({
                    text: "My Personal Quran Tafsir",
                    heading: HeadingLevel.TITLE,
                    alignment: AlignmentType.CENTER,
                })
            );
            children.push(new Paragraph(" ")); // Spacer
            let currentProcessingSurah = -1;
            for (const tafsirEntry of allTafsirEntries) {
                if (tafsirEntry.surah !== currentProcessingSurah) {
                    currentProcessingSurah = tafsirEntry.surah;
                    const surahNameStr = surahNames[currentProcessingSurah - 1] || `Surah ${currentProcessingSurah}`;
                    children.push(
                        new Paragraph({
                            children: [
                                new TextRun({
                                    text: `Surah ${currentProcessingSurah}: ${surahNameStr}`,
                                    bold: true,
                                    size: 32, // 16pt font size (2 * 16)
                                    color: "2E74B5", // A blue color
                                }),
                            ],
                            heading: HeadingLevel.HEADING_1,
                            spacing: { before: convertInchesToTwip(0.2), after: convertInchesToTwip(0.1) },
                        })
                    );
                }
                const quranAyahData = await getData(STORE_QURAN, [tafsirEntry.surah, tafsirEntry.ayah]);
                const arabicText = quranAyahData ? quranAyahData.arabic : "Arabic text not found.";
                children.push(
                    new Paragraph({
                        children: [
                            new TextRun({
                                text: `Ayah ${tafsirEntry.ayah}`,
                                bold: true,
                                size: 28, // 14pt
                                color: "1F4E79", // Darker blue
                            }),
                        ],
                        spacing: { before: convertInchesToTwip(0.15), after: convertInchesToTwip(0.05) },
                    })
                );
                children.push(
                    new Paragraph({
                        children: [
                            new TextRun({
                                text: arabicText,
                                font: "Scheherazade New", // Specify an Arabic font
                                size: 36, // 18pt
                                rightToLeft: true, // Crucial for Arabic
                            }),
                        ],
                        alignment: AlignmentType.RIGHT,
                        bidirectional: true, // Important for mixed LTR/RTL content handling in Word
                        shading: { // Basic background color
                            type: ShadingType.SOLID,
                            color: "E8F5E9", // Light green (hex without #)
                            fill: "E8F5E9",
                        },
                        spacing: { after: convertInchesToTwip(0.1) },
                    })
                );
                const notesLines = tafsirEntry.notes.split('\n');
                notesLines.forEach((line, index) => {
                    children.push(
                        new Paragraph({
                            children: [
                                new TextRun({
                                    text: line,
                                    size: 24, // 12pt
                                }),
                            ],
                            indentation: { left: convertInchesToTwip(0.25) }, // Indent Tafsir notes
                            spacing: { after: (index === notesLines.length - 1) ? convertInchesToTwip(0.15) : convertInchesToTwip(0.02) },
                        })
                    );
                });
                children.push(new Paragraph(" ")); // Spacer after each tafsir entry
            }
            const doc = new Document({
                sections: [{
                    properties: {
                        page: {
                            margin: {
                                top: convertInchesToTwip(0.75),
                                right: convertInchesToTwip(0.75),
                                bottom: convertInchesToTwip(0.75),
                                left: convertInchesToTwip(0.75),
                            },
                        },
                    },
                    children: children,
                }],
                styles: {
                    default: {
                        document: {
                            run: {
                                font: "Calibri", // Default LTR font
                                size: 22, // 11pt default
                            },
                            paragraph: {
                                spacing: { line: 276 } // approx 1.15 line spacing
                            }
                        },
                    },
                    paragraphStyles: [
                        {
                            id: "arabicStyle",
                            name: "Arabic Text",
                            basedOn: "Normal",
                            next: "Normal",
                            run: {
                                font: "Scheherazade New",
                                size: 36,
                                rightToLeft: true,
                            },
                            paragraph: {
                                alignment: AlignmentType.RIGHT,
                                bidirectional: true,
                            }
                        }
                    ]
                }
            });
            Packer.toBlob(doc).then(blob => {
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = `Personal-Tafsir-${new Date().toISOString().split('T')[0]}.docx`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                setStatusMessage('export-tafsir-docx-status', 'Tafsir DOCX file generated.', false);
            }).catch(packError => {
                console.error("Error packing DOCX:", packError);
                setStatusMessage('export-tafsir-docx-status', 'Failed to generate DOCX file.', true);
            });
        } catch (error) {
            console.error("Error exporting Tafsir to DOCX:", error);
            setStatusMessage('export-tafsir-docx-status', 'Failed to export Tafsir to DOCX.', true);
        } finally {
            hideLoading();
        }
    }
    function setupTafsirDocxButton() {
        const exportDocxBtn = document.getElementById('export-tafsir-to-docx-btn');
        if (exportDocxBtn) {
            exportDocxBtn.addEventListener('click', exportTafsirToDocx);
        } else {
            console.warn("Export Tafsir to DOCX button not found.");
        }
    }
    function exitBrowserFullscreen() {
        if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
            if (document.exitFullscreen) {
                document.exitFullscreen().catch(err => console.error("Error exiting fullscreen:", err.message, err.name));
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) { /* Firefox */
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
            return true; // Indicate an exit was attempted
        }
        return false; // Indicate not in fullscreen or no attempt made
    }
    function requestBrowserFullscreenForDocument() {
        const docEl = document.documentElement;
        if (docEl.requestFullscreen) {
            docEl.requestFullscreen().catch(err => console.warn("FS Doc: Request failed:", err.message, err.name));
        } else if (docEl.webkitRequestFullscreen) { /* Safari */
            docEl.webkitRequestFullscreen();
        } else if (docEl.mozRequestFullScreen) { /* Firefox */
            docEl.mozRequestFullScreen();
        } else if (docEl.msRequestFullscreen) { /* IE/Edge */
            docEl.msRequestFullscreen();
        } else {
            console.warn("FS Doc: Browser Fullscreen API not supported for documentElement.");
        }
    }
    function setupGameModal() {
        const gameModalHTML = `
    <div id="quranGameModal" class="modal game-modal" role="dialog" aria-modal="true" aria-labelledby="gameModalTitle" style="display: none;">
        <div class="modal-content game-modal-content">
            <span class="close-button game-close-button" aria-label="Close Game">×</span>
            <h2 id="gameModalTitle">Quranic Games</h2>
            <div class="game-selection-area"> <!-- Using class here -->
                <p>Choose a game to play:</p>
                <button id="startGameWordWhiz" class="game-select-btn">Word Whiz (Vocabulary)</button>
                <button id="startGameAyahJumble" class="game-select-btn">Ayah Jumble (Order)</button>
            </div>
            <div id="gamePlayArea" class="game-play-area" style="display: none;">
                <!-- Game content will be loaded here -->
            </div>
                <div id="gameScoreArea" class="game-score-area" style="display: none;">
                    <p>Score: <span id="gameCurrentScore">0</span></p>
                    <p>High Score: <span id="gameHighScore">0</span> (for this session)</p>
                </div>
                <div class="game-controls">
                     <button id="quitGameButton" style="display:none; background-color: var(--color-error); margin-top:15px;">Quit Current Game</button>
                </div>
            </div>
        </div>
    `;
        document.body.insertAdjacentHTML('beforeend', gameModalHTML);
        const gameModalCSS = `
        .game-modal .modal-content {
            max-width: 90%;
            width: 700px; /* Adjust as needed */
            max-height: 90vh;
            overflow-y: auto;
            background-color: var(--color-bg-primary); /* Use theme colors */
            color: var(--color-text-primary);
        }
        .game-modal-content h2 {
            text-align: center;
            color: var(--color-text-secondary);
            margin-bottom: 0px;
        }
        .game-selection-area {
            text-align: center;
            margin-bottom: -3px;
        }
        .game-select-btn {
            margin: 10px;
            padding: 12px 20px;
            font-size: 1.1rem;
        }
        .game-play-area {
            padding: 8px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-secondary);
            min-height: fit-content;
            text-align: center;
        }
        .game-question-arabic {
            font-family: var(--font-arabic);
            font-size: 2rem;
            margin-bottom: 13px;
            direction: rtl;
        }
        .game-options-list {
            list-style: none;
            padding: 0;
            margin: 0 auto;
            max-width: 400px; /* Or adjust based on content */
        }
        .game-options-list li button {
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 12px;
            background-color: var(--color-accent);
            border: 1px solid var(--color-accent-dark);
            color: white;
            font-family: var(--font-general); /* Or specific language font */
        }
        .game-options-list li button:hover {
            background-color: var(--color-accent-dark);
        }
        .game-options-list li button.correct {
            background-color: #1050c5 !important;
        }
        .game-options-list li button.incorrect {
            background-color: var(--color-error) !important;
        }
        .game-feedback {
            margin-top: 15px;
            font-weight: bold;
        }
        .game-score-area {
            text-align: center;
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid var(--color-border);
        }
        .game-controls {
            text-align: center;
            margin-top: 20px;
        }
        .jumble-word-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            min-height: 50px; /* So it doesn't collapse */
            padding: 10px;
            border: 1px dashed var(--color-border);
            border-radius: var(--border-radius);
        }
        .jumble-word {
            font-family: var(--font-arabic);
            font-size: 1.8rem;
            padding: 8px 12px;
            background-color: var(--color-bg-primary);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            cursor: grab;
            user-select: none; /* Prevent text selection during drag */
            direction: rtl;
        }
        .jumble-word.dragging {
            opacity: 0.5;
            background-color: var(--color-highlight);
        }
        .jumble-target-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start; /* RTL friendly start */
            gap: 5px; /* Small gap for visual separation */
            padding: 10px;
            border: 2px solid var(--color-accent);
            border-radius: var(--border-radius);
            min-height: 70px;
            background-color: var(--color-bg-secondary);
            direction: rtl; /* Important for correct ordering display */
        }
        .jumble-target-area .jumble-word {
             cursor: default; /* No longer grabbable once placed */
        }
        #jumbleSubmitAnswer { margin-top: 15px; }
        .game-modal.fullscreen {
            padding: 0;
        }
        .game-modal.fullscreen .modal-content {
            width: 100%;
            max-width: 100%;
            height: 100vh;
            max-height: 100vh;
            border-radius: 0;
            display: flex;
            flex-direction: column;
        }
        .game-modal.fullscreen .game-play-area {
            flex-grow: 1;
            overflow-y: auto;
        }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.type = "text/css";
        styleSheet.innerText = gameModalCSS;
        document.head.appendChild(styleSheet);
        const gameModal = document.getElementById('quranGameModal');
        const closeButton = gameModal.querySelector('.game-close-button');
        const startGameWordWhizBtn = document.getElementById('startGameWordWhiz');
        const startGameAyahJumbleBtn = document.getElementById('startGameAyahJumble');
        const quitGameButton = document.getElementById('quitGameButton');
        function performModalCloseActions(switchToQuranViewer = true) {
            if (gameModal.style.display !== 'none') {
                const wasGameModalTheFullscreenElement = (
                    document.fullscreenElement === gameModal ||
                    document.webkitFullscreenElement === gameModal ||
                    document.mozFullScreenElement === gameModal || // Note: Older Firefox used mozFullScreenElement
                    document.msFullscreenElement === gameModal
                );
                gameModal.style.display = 'none';
                gameModal.classList.remove('fullscreen'); // CSS class for styling
                resetGameUI(); // This will also call restoreModalInteractivity
                activeGame = null;
                if (typeof recitationGame_State !== 'undefined' && recitationGame_State.gameActive) {
                    if (typeof stopReferenceAudio_Engine === 'function') stopReferenceAudio_Engine();
                    if (recitationGame_State.isRecording && typeof stopUserRecording_Recitation_Engine === 'function') stopUserRecording_Recitation_Engine();
                    if (recitationGame_State.speechRecognition && typeof recitationGame_State.speechRecognition.abort === 'function') recitationGame_State.speechRecognition.abort();
                    recitationGame_State.gameActive = false;
                    recitationGame_State.isRecording = false;
                }
                if (typeof ayahTypingGameActive !== 'undefined' && ayahTypingGameActive) {
                    if (typeof ayahTypingTimerInterval !== 'undefined' && ayahTypingTimerInterval) {
                        clearInterval(ayahTypingTimerInterval);
                        ayahTypingTimerInterval = null;
                    }
                    ayahTypingGameActive = false;
                }
                if (switchToQuranViewer && typeof showSection === 'function') {
                    showSection('quran');
                    const quranViewerSection = document.getElementById('quran');
                    if (quranViewerSection) {
                        quranViewerSection.setAttribute('tabindex', '-1'); // Make it focusable
                        quranViewerSection.focus();
                    }
                }
                if (wasGameModalTheFullscreenElement) {
                    if (exitBrowserFullscreen()) { // Check if exit was actually attempted
                        setTimeout(() => {
                            requestBrowserFullscreenForDocument();
                        }, 150); // Adjust delay if needed, 100-200ms usually okay
                    } else {
                        console.log("exitBrowserFullscreen reported not in FS, but wasGameModalTheFullscreenElement was true. This is odd. Focusing Quran viewer.");
                        const quranViewerSection = document.getElementById('quran');
                        if (quranViewerSection) quranViewerSection.focus();
                    }
                }
            }
        }
        function restoreModalInteractivity() {
            if (gameModal) {
                gameModal.style.pointerEvents = ''; // Or 'auto'
            }
        }
        function resetGameUI() {
            restoreModalInteractivity();
            setTimeout(() => {
                const gamePlayArea = document.getElementById('gamePlayArea');
                const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
                const gameScoreArea = document.getElementById('gameScoreArea');
                const quitGameButton = document.getElementById('quitGameButton');
                const gameModalTitle = document.getElementById('gameModalTitle');
                if (gameSelectionArea) {
                    gameSelectionArea.style.display = 'block';
                } else {
                    console.error("[MainGameModal] resetGameUI: gameSelectionArea (.game-selection-area) not found.");
                }
                if (gamePlayArea) {
                    gamePlayArea.style.display = 'none';
                    gamePlayArea.innerHTML = '';
                } else {
                    console.error("[MainGameModal] resetGameUI: gamePlayArea not found");
                }
                if (gameScoreArea) {
                    gameScoreArea.style.display = 'none';
                } else {
                    console.error("[MainGameModal] resetGameUI: gameScoreArea not found");
                }
                if (quitGameButton) {
                    quitGameButton.style.display = 'none';
                } else {
                    console.error("[MainGameModal] resetGameUI: quitGameButton not found");
                }
                if (gameModalTitle) {
                    gameModalTitle.textContent = "Quranic Games";
                } else {
                    console.error("[MainGameModal] resetGameUI: gameModalTitle not found");
                }
            }, 400);
        }
        function showGamePlayUI(gameTitle) {
            restoreModalInteractivity();
            const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
            const gamePlayArea = document.getElementById('gamePlayArea');
            const gameScoreArea = document.getElementById('gameScoreArea');
            const quitGameButton = document.getElementById('quitGameButton');
            const gameModalTitle = document.getElementById('gameModalTitle');
            if (gameSelectionArea) {
                gameSelectionArea.style.display = 'none';
            } else {
                console.error("[MainGameModal] showGamePlayUI: game-selection-area (.game-selection-area) not found.");
            }
            if (gamePlayArea) {
                gamePlayArea.style.display = 'block';
            } else {
                console.error("[MainGameModal] showGamePlayUI: gamePlayArea not found");
            }
            if (gameScoreArea) {
                gameScoreArea.style.display = 'block';
                if (typeof updateScoreDisplay === "function") updateScoreDisplay();
            } else {
                console.error("[MainGameModal] showGamePlayUI: gameScoreArea not found");
            }
            if (quitGameButton) {
                quitGameButton.style.display = 'block';
            } else {
                console.error("[MainGameModal] showGamePlayUI: quitGameButton not found");
            }
            if (gameModalTitle) {
                gameModalTitle.textContent = gameTitle;
            } else {
                console.error("[MainGameModal] showGamePlayUI: gameModalTitle not found");
            }
        }
        closeButton.addEventListener('click', () => {
            performModalCloseActions(true);
        });
        window.addEventListener('click', (event) => {
            if (event.target === gameModal) {
                performModalCloseActions(true);
            }
        });
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && gameModal.style.display === 'flex') {
                performModalCloseActions(true);
            }
        });
        startGameWordWhizBtn.addEventListener('click', () => startWordWhizGame());
        startGameAyahJumbleBtn.addEventListener('click', () => startAyahJumbleGame());
        quitGameButton.addEventListener('click', () => {
            activeGame = null;
            resetGameUI(); // Go back to game selection within the modal
        });
        const sidebarNav = document.querySelector('.sidebar nav ul');
        if (sidebarNav) {
            const gameLi = document.createElement('li');
            const gameLink = document.createElement('a');
            gameLink.href = "#games";
            gameLink.textContent = "Quranic Games";
            gameLink.id = "openGamesModalBtn"; // Important for your fullscreen IIFE
            gameLi.appendChild(gameLink);
            sidebarNav.appendChild(gameLi);
            gameLink.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('.nav-link.active').forEach(l => l.classList.remove('active'));
                gameLink.classList.add('active');
                restoreModalInteractivity();
                gameModal.style.display = 'flex';
                gameModal.classList.add('fullscreen'); // CSS class for styling the modal content
                resetGameUI(); // Show game selection screen
            });
        }
        addFlashcardSuiteButtonToModal();
        addAyahTypingGameButtonToModal();
        addEnhancedFullScreenReaderLaunchButton();
    }
    let activeGame = null; // To track which game is running
    let gameScore = 0;
    let gameHighScore = 0; // Session high score
    let wordWhizQuestions = [];
    let currentWordWhizQuestionIndex = 0;
    let ayahJumbleQuestion = null;
    function resetGameUI() {
        setTimeout(() => {
            const gamePlayArea = document.getElementById('gamePlayArea');
            const gameSelectionArea = document.getElementById('game-selection-area'); // THIS IS KEY
            const gameScoreArea = document.getElementById('gameScoreArea');
            const quitGameButton = document.getElementById('quitGameButton');
            const gameModalTitle = document.getElementById('gameModalTitle');
            if (!gameSelectionArea) {
                if (!gamePlayArea) {
                }
                const modalContent = document.querySelector('#quranGameModal .modal-content');
                if (modalContent && !gameSelectionArea) { // Check modalContent exists and gameSelectionArea is still missing
                }
            } else {
                gameSelectionArea.style.display = 'block';
            }
            if (gamePlayArea) {
                gamePlayArea.style.display = 'none';
                gamePlayArea.innerHTML = ''; // Clear any specific game content
            } else {
            }
            if (gameScoreArea) {
                gameScoreArea.style.display = 'none';
            } else {
                console.error("[MainGameModal] resetGameUI: gameScoreArea not found");
            }
            if (quitGameButton) {
                quitGameButton.style.display = 'none';
            } else {
                console.error("[MainGameModal] resetGameUI: quitGameButton not found");
            }
            if (gameModalTitle) {
                gameModalTitle.textContent = "Quranic Games"; // Default title
            } else {
                console.error("[MainGameModal] resetGameUI: gameModalTitle not found");
            }
        }, 400); // 400 millisecond timeout
    }
    function showGamePlayUI(gameTitle) {
        console.log(`[MainGameModal] showGamePlayUI called for title: "${gameTitle}".`);
        const gameSelectionArea = document.getElementById('game-selection-area'); // THIS IS KEY
        const gamePlayArea = document.getElementById('gamePlayArea');
        const gameScoreArea = document.getElementById('gameScoreArea');
        const quitGameButton = document.getElementById('quitGameButton');
        const gameModalTitle = document.getElementById('gameModalTitle');
        if (gameSelectionArea) {
            gameSelectionArea.style.display = 'none';
        } else {
            console.error("[MainGameModal] CRITICAL in showGamePlayUI: game-selection-area NOT FOUND.");
        }
        if (gamePlayArea) {
            gamePlayArea.style.display = 'block'; // Or 'flex' if your games use flex layout
        } else {
            console.error("[MainGameModal] showGamePlayUI: gamePlayArea not found");
        }
        if (gameScoreArea) {
            gameScoreArea.style.display = 'block';
            updateScoreDisplay();
        } else {
            console.error("[MainGameModal] showGamePlayUI: gameScoreArea not found");
        }
        if (quitGameButton) {
            quitGameButton.style.display = 'block';
        } else {
            console.error("[MainGameModal] showGamePlayUI: quitGameButton not found");
        }
        if (gameModalTitle) {
            gameModalTitle.textContent = gameTitle;
        } else {
            console.error("[MainGameModal] showGamePlayUI: gameModalTitle not found");
        }
    }
    function showGamePlayUI(gameTitle) {
        const gameSelectionArea = document.getElementById('game-selection-area');
        const gamePlayArea = document.getElementById('gamePlayArea');
        const gameScoreArea = document.getElementById('gameScoreArea');
        const quitGameButton = document.getElementById('quitGameButton');
        const gameModalTitle = document.getElementById('gameModalTitle');
        if (gameSelectionArea) {
            gameSelectionArea.style.display = 'none';
        } else {
        }
        if (gamePlayArea) {
            gamePlayArea.style.display = 'block';
        } else {
        }
        if (gameScoreArea) {
            gameScoreArea.style.display = 'block';
            updateScoreDisplay(); // Call this only if gameScoreArea exists
        } else {
        }
        if (quitGameButton) {
            quitGameButton.style.display = 'block';
        } else {
        }
        if (gameModalTitle) {
            gameModalTitle.textContent = gameTitle;
        } else {
        }
    }
    function updateScoreDisplay() {
        const gameCurrentScoreEl = document.getElementById('gameCurrentScore');
        const gameHighScoreEl = document.getElementById('gameHighScore');
        if (gameCurrentScoreEl) {
            gameCurrentScoreEl.textContent = gameScore;
        } else {
            console.error("updateScoreDisplay: gameCurrentScore element not found");
        }
        if (gameHighScoreEl) {
            gameHighScoreEl.textContent = gameHighScore;
        } else {
            console.error("updateScoreDisplay: gameHighScore element not found");
        }
    }
    function updateScoreDisplay() {
        document.getElementById('gameCurrentScore').textContent = gameScore;
        document.getElementById('gameHighScore').textContent = gameHighScore;
    }
    async function startWordWhizGame() {
        activeGame = 'wordWhiz';
        gameScore = 0;
        updateScoreDisplay();
        showGamePlayUI("Word Whiz Challenge");
        document.getElementById('gamePlayArea').innerHTML = '<p>Loading questions...</p>';
        try {
            const allWordMetadata = await getAllData(STORE_WORD_METADATA);
            const allWordTranslations = await getAllData(STORE_WORD_TRANSLATIONS);
            if (allWordMetadata.length < 10 || allWordTranslations.length < 10) {
                document.getElementById('gamePlayArea').innerHTML = '<p>Not enough word data to start the game. Please load Quran data first.</p>';
                return;
            }
            const translationMap = new Map();
            allWordTranslations.forEach(wt => translationMap.set(wt.word_id, wt));
            wordWhizQuestions = [];
            const selectedWordIds = new Set(); // To avoid duplicate questions with same word_id
            for (let i = 0; i < 10; i++) { // Generate 10 questions
                let attempt = 0;
                let randomMetaEntry, quranAyah, wordText, translationEntry;
                while (attempt < 50) { // Try to find a valid word
                    randomMetaEntry = allWordMetadata[Math.floor(Math.random() * allWordMetadata.length)];
                    if (selectedWordIds.has(randomMetaEntry.word_id)) {
                        attempt++;
                        continue;
                    }
                    translationEntry = translationMap.get(randomMetaEntry.word_id);
                    if (!translationEntry || (!translationEntry.en_meaning && !translationEntry.ur_meaning && !translationEntry.bn_meaning)) { // Check if any translation exists
                        attempt++;
                        continue;
                    }
                    quranAyah = await getData(STORE_QURAN, [randomMetaEntry.surah, randomMetaEntry.ayah]);
                    if (!quranAyah) {
                        attempt++;
                        continue;
                    }
                    const wordsInAyah = quranAyah.arabic.split(/\s+/);
                    if (randomMetaEntry.word_position < wordsInAyah.length) {
                        wordText = wordsInAyah[randomMetaEntry.word_position];
                        if (wordText && wordText.trim() !== "") break; // Found a valid word
                    }
                    attempt++;
                }
                if (!wordText) continue; // Skip if no valid word found after attempts
                selectedWordIds.add(randomMetaEntry.word_id);
                const selectedTranslationLang = document.getElementById('translation-select').value; // urdu, english, Bangali
                let correctAnswerText;
                let fontPreference;
                if (selectedTranslationLang === 'urdu' && translationEntry.ur_meaning) {
                    correctAnswerText = translationEntry.ur_meaning;
                    fontPreference = 'var(--font-urdu)';
                } else if (selectedTranslationLang === 'english' && translationEntry.en_meaning) {
                    correctAnswerText = translationEntry.en_meaning;
                    fontPreference = 'var(--font-english)';
                } else if (selectedTranslationLang === 'Bangali' && translationEntry.bn_meaning) { // Assuming you add bn_meaning to data5
                    correctAnswerText = translationEntry.bn_meaning || (translationMap.get(randomMetaEntry.word_id).en_meaning || "No Bengali Translation"); // Fallback
                    fontPreference = 'var(--font-Bangali)';
                } else { // Fallback to English or whatever is available
                    correctAnswerText = translationEntry.en_meaning || translationEntry.ur_meaning || "Meaning N/A";
                    fontPreference = 'var(--font-english)';
                }
                if (correctAnswerText === "Meaning N/A" || correctAnswerText.trim() === "") continue; // Skip if no good answer
                const options = [correctAnswerText];
                let distractorCount = 0;
                while (distractorCount < 3 && options.length < allWordTranslations.length) {
                    const randomDistractorTrans = allWordTranslations[Math.floor(Math.random() * allWordTranslations.length)];
                    let distractorText;
                    if (selectedTranslationLang === 'urdu' && randomDistractorTrans.ur_meaning) {
                        distractorText = randomDistractorTrans.ur_meaning;
                    } else if (selectedTranslationLang === 'english' && randomDistractorTrans.en_meaning) {
                        distractorText = randomDistractorTrans.en_meaning;
                    } else if (selectedTranslationLang === 'Bangali' && randomDistractorTrans.bn_meaning) {
                        distractorText = randomDistractorTrans.bn_meaning || randomDistractorTrans.en_meaning;
                    } else {
                        distractorText = randomDistractorTrans.en_meaning || randomDistractorTrans.ur_meaning;
                    }
                    if (distractorText && distractorText.trim() !== "" && !options.includes(distractorText) && distractorText !== correctAnswerText) {
                        options.push(distractorText);
                        distractorCount++;
                    }
                }
                shuffleArray(options); // Randomize options order
                wordWhizQuestions.push({
                    word_id: randomMetaEntry.word_id,
                    arabicWord: wordText,
                    options: options,
                    correctAnswer: correctAnswerText,
                    fontPreference: fontPreference,
                    translationLangDir: selectedTranslationLang === 'urdu' ? 'rtl' : 'ltr'
                });
            }
            if (wordWhizQuestions.length === 0) {
                document.getElementById('gamePlayArea').innerHTML = '<p>Could not generate questions. Try again or check data.</p>';
                return;
            }
            currentWordWhizQuestionIndex = 0;
            displayWordWhizQuestion();
        } catch (error) {
            console.error("Error starting WordWhiz game:", error);
            document.getElementById('gamePlayArea').innerHTML = `<p>Error loading game: ${error.message}</p>`;
        }
    }
    function displayWordWhizQuestion() {
        if (currentWordWhizQuestionIndex >= wordWhizQuestions.length) {
            endWordWhizGame();
            return;
        }
        const q = wordWhizQuestions[currentWordWhizQuestionIndex];
        let optionsHTML = '<ul class="game-options-list">';
        q.options.forEach(option => {
            optionsHTML += `<li><button data-answer="${option}" style="font-family: ${q.fontPreference}; direction: ${q.translationLangDir}; text-align: ${q.translationLangDir === 'rtl' ? 'right' : 'left'};">${option}</button></li>`;
        });
        optionsHTML += '</ul>';
        const gamePlayArea = document.getElementById('gamePlayArea');
        gamePlayArea.innerHTML = `
        <p>What is the meaning of this word(in Quran)?</p>
        <div class="game-question-arabic">${q.arabicWord}</div>
        ${optionsHTML}
        <div class="game-feedback" id="wordWhizFeedback"></div>
        <button id="nextWordWhizQuestion" style="display:none; margin-top: 10px;">Next Question</button>
    `;
        gamePlayArea.querySelectorAll('.game-options-list button').forEach(button => {
            button.addEventListener('click', handleWordWhizAnswer);
        });
        document.getElementById('nextWordWhizQuestion').addEventListener('click', () => {
            currentWordWhizQuestionIndex++;
            displayWordWhizQuestion();
        });
    }
    function handleWordWhizAnswer(event) {
        const selectedButton = event.target;
        const selectedAnswer = selectedButton.dataset.answer;
        const q = wordWhizQuestions[currentWordWhizQuestionIndex];
        const feedbackEl = document.getElementById('wordWhizFeedback');
        const nextButton = document.getElementById('nextWordWhizQuestion');
        document.querySelectorAll('.game-options-list button').forEach(btn => {
            btn.disabled = true; // Disable all options
            if (btn.dataset.answer === q.correctAnswer) {
                btn.classList.add('correct');
            }
        });
        if (selectedAnswer === q.correctAnswer) {
            feedbackEl.textContent = "Correct!";
            feedbackEl.style.color = 'var(--color-success)';
            gameScore += 10;
            if (gameScore > gameHighScore) gameHighScore = gameScore;
            updateScoreDisplay();
        } else {
            feedbackEl.textContent = `Incorrect. The correct answer is: ${q.correctAnswer}`;
            feedbackEl.style.color = 'var(--color-error)';
            selectedButton.classList.add('incorrect'); // Mark the specific wrong choice
        }
        nextButton.style.display = 'inline-block';
    }
    function endWordWhizGame() {
        document.getElementById('gamePlayArea').innerHTML = `
        <h3>Game Over!</h3>
        <p>Your final score: ${gameScore}</p>
        <button id="playWordWhizAgain">Play Again</button>
    `;
        document.getElementById('playWordWhizAgain').addEventListener('click', startWordWhizGame);
        activeGame = null;
    }
    let jumbledWords = [];
    let correctOrderWords = [];
    let draggedItem = null;
    async function startAyahJumbleGame() {
        activeGame = 'ayahJumble';
        gameScore = 0; // Reset score for this game type
        updateScoreDisplay();
        showGamePlayUI("Ayah Jumble Challenge");
        document.getElementById('gamePlayArea').innerHTML = '<p>Loading Ayah...</p>';
        try {
            let randomAyahData, words;
            let attempts = 0;
            const MAX_ATTEMPTS = 20;
            const MIN_WORDS = 4;
            const MAX_WORDS = 10; // Keep ayahs relatively short for jumbling
            while (attempts < MAX_ATTEMPTS) {
                const randomSurah = Math.floor(Math.random() * 114) + 1;
                const randomAyahNum = Math.floor(Math.random() * surahAyahCounts[randomSurah]) + 1;
                randomAyahData = await getData(STORE_QURAN, [randomSurah, randomAyahNum]);
                if (randomAyahData && randomAyahData.arabic) {
                    words = randomAyahData.arabic.trim().split(/\s+/).filter(w => w.length > 0);
                    if (words.length >= MIN_WORDS && words.length <= MAX_WORDS) {
                        break; // Found a suitable Ayah
                    }
                }
                attempts++;
            }
            if (!words || words.length < MIN_WORDS) {
                document.getElementById('gamePlayArea').innerHTML = '<p>Could not find a suitable Ayah for the game. Please try again.</p>';
                return;
            }
            correctOrderWords = [...words]; // Store the correct order
            jumbledWords = shuffleArray([...words]); // Shuffle a copy for display
            ayahJumbleQuestion = {
                originalAyah: randomAyahData.arabic,
                words: words,
                surah: randomAyahData.surah,
                ayah: randomAyahData.ayah
            };
            displayAyahJumbleQuestion();
        } catch (error) {
            console.error("Error starting AyahJumble game:", error);
            document.getElementById('gamePlayArea').innerHTML = `<p>Error loading game: ${error.message}</p>`;
        }
    }
    function displayAyahJumbleQuestion() {
        const gamePlayArea = document.getElementById('gamePlayArea');
        let jumbledWordsHTML = '';
        jumbledWords.forEach((word, index) => {
            jumbledWordsHTML += `<div class="jumble-word" draggable="true" data-index="${index}" data-word="${word}">${word}</div>`;
        });
        gamePlayArea.innerHTML = `
        <p>Arrange the words to form the correct Ayah (Drag or Click):</p>
        <div id="jumbleSourceContainer" class="jumble-word-container">
            ${jumbledWordsHTML}
        </div>
        <p style="margin-top: 20px;">Your arrangement:</p>
        <div id="jumbleTargetContainer" class="jumble-target-area">
            <!-- Dropped/Clicked words will appear here -->
        </div>
        <button id="jumbleSubmitAnswer">Check Answer</button>
        <button id="jumbleResetArrangement" style="margin-left:10px;">Reset</button>
        <div class="game-feedback" id="ayahJumbleFeedback"></div>
        <button id="nextAyahJumbleQuestion" style="display:none; margin-top: 10px;">Next Ayah</button>
    `;
        addJumbleDragDropListeners(); // Sets up drag/drop
        const jumbleArea = gamePlayArea; // Or a more specific parent of both containers
        jumbleArea.removeEventListener('click', handleJumbleWordClick); // Remove old if any
        jumbleArea.addEventListener('click', handleJumbleWordClick);
        document.getElementById('jumbleSubmitAnswer').addEventListener('click', handleAyahJumbleSubmit);
        document.getElementById('jumbleResetArrangement').addEventListener('click', resetJumbleArrangement);
        document.getElementById('nextAyahJumbleQuestion').addEventListener('click', () => startAyahJumbleGame());
    }
    function addJumbleDragDropListeners() {
        const sourceContainer = document.getElementById('jumbleSourceContainer');
        const targetContainer = document.getElementById('jumbleTargetContainer');
        const attachListenersToWords = (containerSelector) => {
            document.querySelectorAll(`${containerSelector} .jumble-word`).forEach(draggable => {
                draggable.removeEventListener('dragstart', dragStartHandler); // Example of removing first
                draggable.addEventListener('dragstart', dragStartHandler);
                draggable.removeEventListener('dragend', dragEndHandler);
                draggable.addEventListener('dragend', dragEndHandler);
            });
        };
        const dragStartHandler = (e) => {
            draggedItem = e.target;
            setTimeout(() => draggedItem.classList.add('dragging'), 0);
        };
        const dragEndHandler = () => {
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
            }
            draggedItem = null;
        };
        attachListenersToWords('#jumbleSourceContainer');
        attachListenersToWords('#jumbleTargetContainer'); // If you want to drag within target too
        [sourceContainer, targetContainer].forEach(container => {
            container.removeEventListener('dragover', dragOverHandler);
            container.addEventListener('dragover', dragOverHandler);
            container.removeEventListener('drop', dropHandler);
            container.addEventListener('drop', dropHandler);
        });
    }
    const dragOverHandler = (e) => {
        e.preventDefault(); // Allow drop
    };
    const dropHandler = (e) => {
        e.preventDefault();
        const targetDropContainer = e.target.closest('.jumble-word-container, .jumble-target-area');
        if (draggedItem && targetDropContainer) { // Ensure draggedItem exists and drop is on a valid container
            const afterElement = getDragAfterElement(targetDropContainer, e.clientY, e.clientX);
            if (afterElement == null) {
                targetDropContainer.appendChild(draggedItem);
            } else {
                targetDropContainer.insertBefore(draggedItem, afterElement);
            }
            const feedbackEl = document.getElementById('ayahJumbleFeedback');
            const submitButton = document.getElementById('jumbleSubmitAnswer');
            if (feedbackEl) feedbackEl.textContent = '';
            if (submitButton) submitButton.disabled = false;
        }
    }
    function handleJumbleWordClick(event) {
        const clickedWord = event.target.closest('.jumble-word');
        if (!clickedWord) return;
        const sourceContainer = document.getElementById('jumbleSourceContainer');
        const targetContainer = document.getElementById('jumbleTargetContainer');
        const feedbackEl = document.getElementById('ayahJumbleFeedback');
        const submitButton = document.getElementById('jumbleSubmitAnswer');
        if (clickedWord.parentNode === sourceContainer) {
            targetContainer.appendChild(clickedWord);
        } else if (clickedWord.parentNode === targetContainer) {
            sourceContainer.appendChild(clickedWord); // Temporarily append
            const wordsInSource = [...sourceContainer.children];
            wordsInSource.sort((a, b) => parseInt(a.dataset.index) - parseInt(b.dataset.index));
            wordsInSource.forEach(word => sourceContainer.appendChild(word)); // Re-append in sorted order
        }
        if (feedbackEl) feedbackEl.textContent = '';
        if (submitButton) submitButton.disabled = false;
    }
    function getDragAfterElement(container, y, x) {
        const draggableElements = [...container.querySelectorAll('.jumble-word:not(.dragging)')];
        const containerDir = getComputedStyle(container).direction;
        for (const child of draggableElements) {
            const box = child.getBoundingClientRect();
            const childMidY = box.top + box.height / 2;
            const childMidX = box.left + box.width / 2; // Horizontal midpoint of the child element
            if (Math.abs(y - childMidY) < box.height) { // Is drop y-coordinate within the vertical span of the child?
                if (containerDir === 'rtl') {
                    if (x > childMidX) { // << REVERSED THIS COMPARISON for RTL
                        return child;
                    }
                } else { // LTR
                    if (x < childMidX) {
                        return child;
                    }
                }
            } else if (y < childMidY) {
                return child;
            }
        }
        return null; // If no element is found to insert before, append to the end of the container.
    }
    function resetJumbleArrangement() {
        const targetContainer = document.getElementById('jumbleTargetContainer');
        const sourceContainer = document.getElementById('jumbleSourceContainer');
        [...targetContainer.children].forEach(child => sourceContainer.appendChild(child));
        const wordsInSource = [...sourceContainer.children];
        wordsInSource.sort((a, b) => parseInt(a.dataset.index) - parseInt(b.dataset.index));
        wordsInSource.forEach(word => sourceContainer.appendChild(word)); // Re-append in sorted order
        if (document.getElementById('ayahJumbleFeedback')) {
            document.getElementById('ayahJumbleFeedback').textContent = '';
        }
        const submitButton = document.getElementById('jumbleSubmitAnswer');
        if (submitButton) {
            submitButton.disabled = false;
        }
        const nextButton = document.getElementById('nextAyahJumbleQuestion');
        if (nextButton) {
            nextButton.style.display = 'none';
        }
    }
    function handleAyahJumbleSubmit() {
        const targetContainer = document.getElementById('jumbleTargetContainer');
        const userAnswerWords = [...targetContainer.children].map(el => el.textContent.trim());
        const feedbackEl = document.getElementById('ayahJumbleFeedback');
        const nextButton = document.getElementById('nextAyahJumbleQuestion');
        const submitButton = document.getElementById('jumbleSubmitAnswer');
        if (userAnswerWords.join(' ') === correctOrderWords.join(' ')) {
            feedbackEl.textContent = "Correct! Masha'Allah!";
            feedbackEl.style.color = 'var(--color-success)';
            gameScore += 20; // Jumble might be harder
            if (gameScore > gameHighScore) gameHighScore = gameScore;
            updateScoreDisplay();
            nextButton.style.display = 'inline-block';
            submitButton.disabled = true;
            [...targetContainer.children].forEach(child => child.style.backgroundColor = 'var(--color-success)');
        } else {
            feedbackEl.textContent = `Not quite. Try again or reset. The correct Ayah is: ${ayahJumbleQuestion.originalAyah}`;
            feedbackEl.style.color = 'var(--color-error)';
            nextButton.style.display = 'none'; // Don't show next if wrong, encourage retry
            [...targetContainer.children].forEach(child => child.style.backgroundColor = 'var(--color-error)');
            setTimeout(() => { // Reset color after a bit
                [...targetContainer.children].forEach(child => child.style.backgroundColor = '');
            }, 2000);
        }
    }
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            await openDB();
            await loadThemePreference();
            setupEventListeners(); // Your existing listeners
            await loadQuranData();
            displayThemesList();
            setupTafsirDocxButton(); // Your existing function for docx
            setTimeout(setupGameModal, 200);
        } catch (error) {
            console.error("App initialization failed:", error);
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay && loadingOverlay.style.display !== 'none') {
                document.getElementById('loading-message-primary').textContent = "Initialization Error";
                document.getElementById('loading-message-secondary').textContent = `Critical error: ${error.message}. Please refresh or clear site data.`;
            } else {
                alert("Failed to initialize: " + error.message + "\nPlease clear website data and refresh. Check console for details.");
            }
        }
    });
    let flashcardQuestions = [];
    let currentFlashcardIndex = 0;
    let flashcardShowAnswer = false;
    let memoryMatchCardsArray = []; // Renamed to avoid conflict if 'memoryMatchCards' is used elsewhere
    let memoryFirstCardFlipped = null; // Renamed
    let memorySecondCardFlipped = null; // Renamed
    let memoryLockBoardActive = false; // Renamed
    let memoryPairsFoundCount = 0; // Renamed
    let memoryAttemptCount = 0; // Renamed
    let memoryWordPairsForGame = []; // Renamed
    function injectFlashcardGameCSS_Suite() {
        const cssId = "flashcardGameStylesSuite"; // Unique ID
        if (document.getElementById(cssId)) return;
        const styles = `
        .flashcard-game-area { display: flex; flex-direction: column; align-items: center; width: 100%; padding: 10px; }
        .flashcard-container { perspective: 1000px; width: 90%; max-width: 320px; min-height: 180px; height: auto; aspect-ratio: 3 / 2; margin: 15px auto; cursor: pointer; }
        .flashcard { width: 100%; height: 100%; position: relative; transform-style: preserve-3d; transition: transform 0.6s; border: 1px solid var(--color-border); border-radius: var(--border-radius); }
        .flashcard.is-flipped { transform: rotateY(180deg); }
        .flashcard-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 15px; text-align: center; border-radius: var(--border-radius); background-color: var(--color-bg-secondary); color: var(--color-text-primary); overflow-wrap: break-word; word-break: break-word; }
        .flashcard-front { font-family: var(--font-arabic); font-size: clamp(1.8rem, 6vw, 2.8rem); direction: rtl; }
        .flashcard-back { transform: rotateY(180deg); font-size: clamp(1rem, 4vw, 1.4rem); }
        .flashcard-controls { margin-top: 15px; text-align: center; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; }
        .flashcard-controls button { min-width: 100px; }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
    }
    function injectMemoryMatchGameCSS_Suite() {
        const cssId = "memoryMatchGameStylesSuite"; // Unique ID
        if (document.getElementById(cssId)) return;
        const styles = `
        .memory-match-info { text-align: center; margin-bottom: 10px; font-size: 1.1rem; }
        .memory-match-attempts { font-weight: bold; color: var(--color-text-secondary); }
        .memory-match-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 10px; padding: 10px; max-width: 500px; margin: 15px auto; }
        .memory-card { aspect-ratio: 1 / 1; background-color: var(--color-accent); border: 1px solid var(--color-accent-dark); border-radius: var(--border-radius); display: flex; justify-content: center; align-items: center; cursor: pointer; font-size: 1rem; color: white; user-select: none; transform-style: preserve-3d; transition: transform 0.3s, background-color 0.3s; }
        .memory-card .card-content { display: none; text-align: center; overflow-wrap: break-word; word-break: break-word; padding: 5px; }
        .memory-card.arabic-text .card-content { font-family: var(--font-arabic); direction: rtl; font-size: clamp(1.1rem, 3.5vw, 1.6rem); }
        .memory-card.meaning-text .card-content { font-size: clamp(0.7rem, 2.5vw, 1rem); }
        .memory-card.is-flipped .card-content { display: block; }
        .memory-card.is-flipped { background-color: var(--color-bg-secondary); color: var(--color-text-primary); }
        .memory-card.is-matched { background-color: var(--color-success) !important; color: white !important; cursor: default; opacity: 0.8; }
        .memory-card.is-matched .card-content { display: block; }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
    }
    async function startFlashcardGame_Suite() {
        activeGame = 'flashcards_suite'; // Unique game ID
        showGamePlayUI("Flashcard Frenzy"); // Your global function
        injectFlashcardGameCSS_Suite();
        const gamePlayArea = document.getElementById('gamePlayArea');
        if (!gamePlayArea) { console.error("Flashcard: gamePlayArea not found!"); return; }
        gamePlayArea.innerHTML = '<p style="text-align:center; padding:20px;">Loading flashcards...</p>';
        try {
            const allWordMetadata = await getAllData(STORE_WORD_METADATA);
            const allWordTranslations = await getAllData(STORE_WORD_TRANSLATIONS);
            if (!allWordMetadata || allWordMetadata.length < 3 || !allWordTranslations || allWordTranslations.length < 3) {
                gamePlayArea.innerHTML = '<p style="text-align:center; padding:20px; color:var(--color-error);">Not enough word data for flashcards.</p>';
                return;
            }
            const translationMap = new Map(allWordTranslations.map(wt => [wt.word_id, wt]));
            flashcardQuestions = [];
            const selectedWordIds = new Set();
            const maxCards = 10;
            for (let i = 0; i < maxCards * 2 && flashcardQuestions.length < maxCards; i++) {
                let attempt = 0;
                let randomMetaEntry, quranAyah, wordText, translationEntry;
                while (attempt < 20) {
                    randomMetaEntry = allWordMetadata[Math.floor(Math.random() * allWordMetadata.length)];
                    if (selectedWordIds.has(randomMetaEntry.word_id)) { attempt++; continue; }
                    translationEntry = translationMap.get(randomMetaEntry.word_id);
                    if (!translationEntry || (!translationEntry.en_meaning && !translationEntry.ur_meaning && !translationEntry.bn_meaning)) { attempt++; continue; }
                    quranAyah = await getData(STORE_QURAN, [randomMetaEntry.surah, randomMetaEntry.ayah]);
                    if (!quranAyah || !quranAyah.arabic) { attempt++; continue; }
                    const wordsInAyah = quranAyah.arabic.split(/\s+/);
                    if (randomMetaEntry.word_position < wordsInAyah.length) {
                        wordText = wordsInAyah[randomMetaEntry.word_position];
                        if (wordText && wordText.trim() !== "") break;
                    }
                    attempt++;
                }
                if (!wordText) continue;
                selectedWordIds.add(randomMetaEntry.word_id);
                const selectedTranslationKey = document.getElementById('translation-select').value;
                let meaningText, meaningLangDir = 'ltr', meaningFont = 'var(--font-english)';
                if (selectedTranslationKey === 'urdu' && translationEntry.ur_meaning) {
                    meaningText = translationEntry.ur_meaning; meaningLangDir = 'rtl'; meaningFont = 'var(--font-urdu)';
                } else if (selectedTranslationKey === 'english' && translationEntry.en_meaning) {
                    meaningText = translationEntry.en_meaning;
                } else if (selectedTranslationKey === 'Bangali' && translationEntry.bn_meaning) {
                    meaningText = translationEntry.bn_meaning; meaningFont = 'var(--font-Bangali)';
                } else {
                    meaningText = translationEntry.en_meaning || translationEntry.ur_meaning || translationEntry.bn_meaning;
                    if (translationEntry.en_meaning) { }
                    else if (translationEntry.ur_meaning) { meaningLangDir = 'rtl'; meaningFont = 'var(--font-urdu)'; }
                    else if (translationEntry.bn_meaning) { meaningFont = 'var(--font-Bangali)'; }
                }
                if (!meaningText || meaningText.trim() === "" || meaningText.trim().toLowerCase() === "n/a") {
                    selectedWordIds.delete(randomMetaEntry.word_id); continue;
                }
                flashcardQuestions.push({ arabicWord: wordText, meaning: meaningText, meaningLangDir, meaningFont });
            }
            if (flashcardQuestions.length === 0) {
                gamePlayArea.innerHTML = '<p style="text-align:center; padding:20px; color:var(--color-error);">Could not generate any flashcards.</p>';
                return;
            }
            currentFlashcardIndex = 0;
            displayFlashcard_Suite();
        } catch (error) {
            console.error("Error starting Flashcard game (Suite):", error);
            gamePlayArea.innerHTML = `<p style="text-align:center; padding:20px; color:var(--color-error);">Error loading game: ${error.message}.</p>`;
        }
    }
    function displayFlashcard_Suite() {
        if (currentFlashcardIndex >= flashcardQuestions.length) {
            endFlashcardGame_Suite();
            return;
        }
        flashcardShowAnswer = false;
        const cardData = flashcardQuestions[currentFlashcardIndex];
        const gamePlayArea = document.getElementById('gamePlayArea');
        gamePlayArea.innerHTML = '';
        const gameAreaWrapper = document.createElement('div'); // Wrapper for content
        gameAreaWrapper.className = 'flashcard-game-area';
        const container = document.createElement('div');
        container.className = 'flashcard-container';
        const card = document.createElement('div');
        card.className = 'flashcard';
        const frontFace = document.createElement('div');
        frontFace.className = 'flashcard-face flashcard-front';
        frontFace.textContent = cardData.arabicWord;
        const backFace = document.createElement('div');
        backFace.className = 'flashcard-face flashcard-back';
        backFace.textContent = cardData.meaning;
        backFace.style.fontFamily = cardData.meaningFont;
        backFace.style.direction = cardData.meaningLangDir;
        backFace.style.textAlign = cardData.meaningLangDir === 'rtl' ? 'right' : 'left';
        card.append(frontFace, backFace);
        container.appendChild(card);
        gameAreaWrapper.appendChild(container);
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'flashcard-controls';
        const flipButton = document.createElement('button');
        flipButton.textContent = 'Flip Card';
        const gotItButton = document.createElement('button');
        gotItButton.textContent = 'Got it!';
        gotItButton.style.display = 'none';
        const notYetButton = document.createElement('button');
        notYetButton.textContent = 'Not Yet';
        notYetButton.style.display = 'none';
        controlsDiv.append(flipButton, gotItButton, notYetButton);
        gameAreaWrapper.appendChild(controlsDiv);
        gamePlayArea.appendChild(gameAreaWrapper);
        container.addEventListener('click', () => toggleFlashcardFlip_Suite(card, gotItButton, notYetButton, flipButton));
        flipButton.addEventListener('click', () => toggleFlashcardFlip_Suite(card, gotItButton, notYetButton, flipButton));
        gotItButton.addEventListener('click', () => handleFlashcardResponse_Suite(true));
        notYetButton.addEventListener('click', () => handleFlashcardResponse_Suite(false));
    }
    function toggleFlashcardFlip_Suite(cardEl, gotItBtn, notYetBtn, flipBtn) {
        cardEl.classList.toggle('is-flipped');
        flashcardShowAnswer = cardEl.classList.contains('is-flipped');
        gotItBtn.style.display = flashcardShowAnswer ? 'inline-block' : 'none';
        notYetBtn.style.display = flashcardShowAnswer ? 'inline-block' : 'none';
        flipBtn.textContent = flashcardShowAnswer ? 'Show Question' : 'Flip Card';
    }
    function handleFlashcardResponse_Suite(knewIt) {
        if (knewIt) {
        } else {
            const currentCardData = flashcardQuestions[currentFlashcardIndex]; // Get before incrementing
            flashcardQuestions.push(currentCardData); // Re-add to end
        }
        currentFlashcardIndex++;
        displayFlashcard_Suite();
    }
    function endFlashcardGame_Suite() {
        const gamePlayArea = document.getElementById('gamePlayArea');
        if (!gamePlayArea) return;
        const originalFlashcardSet = flashcardQuestions.slice(0, currentFlashcardIndex);
        const uniqueWordsForMemory = [];
        const seenArabicWords = new Set();
        for (const card of originalFlashcardSet) {
            if (!seenArabicWords.has(card.arabicWord) && uniqueWordsForMemory.length < 6) { // Max 6 pairs for memory game
                uniqueWordsForMemory.push(card);
                seenArabicWords.add(card.arabicWord);
            }
            if (uniqueWordsForMemory.length >= 6) break;
        }
        const canPlayMemory = uniqueWordsForMemory.length >= 2;
        let memoryBtnHTML = canPlayMemory ? `<button id="startMemoryMatchGameBtn_Suite">Test Your Memory!</button>` : `<p style="font-size:0.9em; margin-top:10px;">(Not enough unique cards seen for a memory game.)</p>`;
        gamePlayArea.innerHTML = `
        <div style="text-align:center; padding: 20px;">
            <h3>Flashcard Session Over!</h3>
            <p style="font-size:0.9em;">(Cards marked "Not Yet" are re-added to the end for more practice in the next flashcard round.)</p>
            <div style="margin-top: 20px; display:flex; flex-direction:column; align-items:center; gap:10px;">
                <button id="playFlashcardsAgain_Suite">Practice Flashcards Again</button>
                ${memoryBtnHTML}
            </div>
        </div>
    `;
        const playAgainFCBtn = document.getElementById('playFlashcardsAgain_Suite');
        if (playAgainFCBtn) playAgainFCBtn.addEventListener('click', startFlashcardGame_Suite);
        if (canPlayMemory) {
            const startMemoryBtn = document.getElementById('startMemoryMatchGameBtn_Suite');
            if (startMemoryBtn) startMemoryBtn.addEventListener('click', () => startMemoryMatchGame_Suite(uniqueWordsForMemory));
        }
        activeGame = null;
    }
    async function startMemoryMatchGame_Suite(wordDataForGame) {
        activeGame = 'memoryMatch_suite';
        showGamePlayUI("Memory Match Challenge");
        injectMemoryMatchGameCSS_Suite();
        const gamePlayArea = document.getElementById('gamePlayArea');
        if (!gamePlayArea) { console.error("Memory Match: gamePlayArea not found!"); return; }
        gamePlayArea.innerHTML = '<p style="text-align:center; padding:20px;">Setting up the memory board...</p>';
        memoryWordPairsForGame = [...wordDataForGame];
        memoryMatchCardsArray = [];
        memoryPairsFoundCount = 0;
        memoryAttemptCount = 0;
        memoryLockBoardActive = false;
        memoryFirstCardFlipped = null;
        memorySecondCardFlipped = null;
        memoryWordPairsForGame.forEach((pair, index) => {
            memoryMatchCardsArray.push({ id: `arabic-${index}`, type: 'arabic', content: pair.arabicWord, pairId: index, isFlipped: false, isMatched: false });
            memoryMatchCardsArray.push({ id: `meaning-${index}`, type: 'meaning', content: pair.meaning, pairId: index, font: pair.meaningFont, dir: pair.meaningLangDir, isFlipped: false, isMatched: false });
        });
        shuffleArray(memoryMatchCardsArray); // Your global shuffle function
        renderMemoryBoard_Suite();
        updateMemoryGameInfo_Suite();
    }
    function renderMemoryBoard_Suite() {
        const gamePlayArea = document.getElementById('gamePlayArea');
        gamePlayArea.innerHTML = '';
        const infoDiv = document.createElement('div');
        infoDiv.className = 'memory-match-info';
        infoDiv.innerHTML = `Pairs Found: <span id="memoryPairsFoundEl_Suite">0</span>/${memoryWordPairsForGame.length} | Attempts: <span id="memoryAttemptsEl_Suite" class="memory-match-attempts">0</span>`;
        gamePlayArea.appendChild(infoDiv);
        const grid = document.createElement('div');
        grid.className = 'memory-match-grid';
        const numCards = memoryMatchCardsArray.length;
        let columns = (numCards <= 6) ? 3 : (numCards <= 8) ? 4 : (numCards <= 12) ? 4 : 4;
        grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
        memoryMatchCardsArray.forEach(cardData => {
            const cardElement = document.createElement('div');
            cardElement.className = 'memory-card';
            cardElement.dataset.id = cardData.id;
            const contentSpan = document.createElement('span');
            contentSpan.className = 'card-content';
            contentSpan.textContent = cardData.content;
            if (cardData.type === 'arabic') cardElement.classList.add('arabic-text');
            else {
                cardElement.classList.add('meaning-text');
                contentSpan.style.fontFamily = cardData.font;
                contentSpan.style.direction = cardData.dir;
                contentSpan.style.textAlign = cardData.dir === 'rtl' ? 'right' : 'left';
            }
            cardElement.appendChild(contentSpan);
            if (cardData.isFlipped) cardElement.classList.add('is-flipped');
            if (cardData.isMatched) cardElement.classList.add('is-matched', 'is-flipped');
            cardElement.addEventListener('click', () => handleMemoryCardClick_Suite(cardElement, cardData));
            grid.appendChild(cardElement);
        });
        gamePlayArea.appendChild(grid);
    }
    function handleMemoryCardClick_Suite(cardEl, cardData) {
        if (memoryLockBoardActive || cardData.isFlipped || cardData.isMatched) return;
        cardData.isFlipped = true;
        cardEl.classList.add('is-flipped');
        if (!memoryFirstCardFlipped) {
            memoryFirstCardFlipped = cardData;
            return;
        }
        memorySecondCardFlipped = cardData;
        memoryLockBoardActive = true;
        memoryAttemptCount++;
        updateMemoryGameInfo_Suite();
        checkForMemoryMatch_Suite();
    }
    function checkForMemoryMatch_Suite() {
        const isMatch = memoryFirstCardFlipped.pairId === memorySecondCardFlipped.pairId;
        if (isMatch) {
            memoryFirstCardFlipped.isMatched = true;
            memorySecondCardFlipped.isMatched = true;
            memoryPairsFoundCount++;
            updateMemoryGameInfo_Suite();
            document.querySelector(`.memory-card[data-id="${memoryFirstCardFlipped.id}"]`)?.classList.add('is-matched');
            document.querySelector(`.memory-card[data-id="${memorySecondCardFlipped.id}"]`)?.classList.add('is-matched');
            resetMemoryTurn_Suite();
            if (memoryPairsFoundCount === memoryWordPairsForGame.length) {
                setTimeout(endMemoryMatchGame_Suite, 600);
            }
        } else {
            setTimeout(() => {
                if (memoryFirstCardFlipped) memoryFirstCardFlipped.isFlipped = false; // Check if nullified by rapid clicks
                if (memorySecondCardFlipped) memorySecondCardFlipped.isFlipped = false;
                document.querySelector(`.memory-card[data-id="${memoryFirstCardFlipped?.id}"]`)?.classList.remove('is-flipped');
                document.querySelector(`.memory-card[data-id="${memorySecondCardFlipped?.id}"]`)?.classList.remove('is-flipped');
                resetMemoryTurn_Suite();
            }, 1200);
        }
    }
    function resetMemoryTurn_Suite() {
        memoryFirstCardFlipped = null;
        memorySecondCardFlipped = null;
        memoryLockBoardActive = false;
    }
    function updateMemoryGameInfo_Suite() {
        const pairsEl = document.getElementById('memoryPairsFoundEl_Suite');
        const attemptsEl = document.getElementById('memoryAttemptsEl_Suite');
        if (pairsEl) pairsEl.textContent = memoryPairsFoundCount;
        if (attemptsEl) attemptsEl.textContent = memoryAttemptCount;
    }
    function endMemoryMatchGame_Suite() {
        const gamePlayArea = document.getElementById('gamePlayArea');
        if (!gamePlayArea) return;
        gamePlayArea.innerHTML = `
        <div style="text-align:center; padding: 20px;">
            <h3>Memory Game Cleared!</h3>
            <p>You found all ${memoryPairsFoundCount} pairs in ${memoryAttemptCount} attempts!</p>
            <div style="margin-top:15px; display:flex; justify-content:center; gap:10px;">
                <button id="playMemoryMatchAgainBtn_Suite">Play Memory Again</button>
                <button id="backToGameSelectionBtn_Suite">Game Selection</button>
            </div>
        </div>
    `;
        const playAgainMMBtn = document.getElementById('playMemoryMatchAgainBtn_Suite');
        if (playAgainMMBtn) playAgainMMBtn.addEventListener('click', () => startMemoryMatchGame_Suite(memoryWordPairsForGame)); // Restart with same words
        const backBtn = document.getElementById('backToGameSelectionBtn_Suite');
        if (backBtn) backBtn.addEventListener('click', () => { activeGame = null; resetGameUI(); });
        activeGame = null;
    }
    function addFlashcardSuiteButtonToModal() {
        const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
        const buttonId = 'startGameFlashcardSuiteBtn';
        if (gameSelectionArea && !document.getElementById(buttonId)) {
            const suiteButton = document.createElement('button');
            suiteButton.id = buttonId;
            suiteButton.className = 'game-select-btn';
            suiteButton.textContent = 'Flashcard & Memory'; // Combined name
            suiteButton.addEventListener('click', startFlashcardGame_Suite);
            const existingButtons = gameSelectionArea.querySelectorAll('.game-select-btn');
            if (existingButtons.length > 0) {
                existingButtons[existingButtons.length - 1].insertAdjacentElement('afterend', suiteButton);
            } else {
                gameSelectionArea.appendChild(suiteButton);
            }
        }
    }
    let isFullScreenReaderActive = false;
    let fullScreenReaderCurrentPage = 1; // For 15-line Taj Company style pages
    let fullScreenReaderCurrentSurah = 1;
    let fullScreenReaderCurrentAyah = 1;
    let fullScreenReaderViewMode = 'paged'; // 'paged' or 'continuous-scroll'
    let fullScreenReaderAudioPlayer = null;
    let fullScreenReaderAudioQueue = []; // For continuous play
    let fullScreenReaderIsPlayingAudio = false;
    let fullScreenReaderContinuousAudioMode = false; // New setting
    let fullScreenReaderSettings = {
        arabicFont: 'Scheherazade New',
        fontSize: '2.5rem', // Base size, applied to a container
        linesPerPage: 15, // For paged view estimation
        showTransliteration: false,
        autoScrollAudio: true, // For highlighting and view adjustment
        highlightColor: 'rgba(255, 255, 150, 0.4)', // Lighter yellow
        continuousAudio: false // New: User setting for continuous play
    };
    const TAJ_COMPANY_PAGES = 604;
    let tajMushafPageData = []; // Populated by loadTajMushafPageData()
    let continuousScrollNextSurahToLoad = 1;
    let continuousScrollNextAyahToLoad = 1;
    const CONTINUOUS_SCROLL_LOAD_COUNT = 60; // Ayahs to load at a time
    let isLoadingMoreAyahs = false;
    let continuousScrollSurahContainer = null; // The main div holding all surah content
    function injectEnhancedFullScreenReaderCSS() {
        const cssId = "enhancedFullScreenReaderStyles";
        if (document.getElementById(cssId)) return;
        const styles = `
        #fullScreenReaderOverlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: var(--color-bg-primary, #f0f0f0); /* Lighter bg for reader */
            z-index: 10000; display: flex; flex-direction: column; overflow: hidden;
            font-family: var(--font-arabic);
        }
        #fsReaderHeader, #fsReaderFooter {
            padding: 8px 12px; background-color: var(--color-bg-secondary, #e0e0e0);
            border-bottom: 1px solid var(--color-border, #ccc); flex-shrink: 0;
            display: flex; justify-content: space-between; align-items: center;
        }
        #fsReaderFooter { border-top: 1px solid var(--color-border, #ccc); border-bottom: none; }
        #fsReaderHeader .title-page-container { text-align: center; flex-grow: 1; }
        #fsReaderHeader .title { font-size: 1.1rem; font-weight: bold; color: var(--color-text-primary); }
        #fsReaderHeader .page-info { font-size: 0.9rem; color: var(--color-text-secondary); }
        #fsReaderContent {
            flex-grow: 1; overflow-y: auto; overflow-x: hidden; padding: 5px;
            display: flex; flex-direction: column; align-items: center; /* Centers paged view */
        }
        .fsReaderPage {
            background-color: #fff; border: 1px solid #ddd; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 15px 20px; margin-bottom: 15px; width: 96%; /* max-width: 750px; */ direction: rtl;
        }
        #continuousScrollSurahContainer { width: 96%; /* Centered */ margin: 0 auto; }
        .continuousSurahBlock {
            padding: 10px 15px; margin-bottom: 20px; direction: rtl;
            border-bottom: 2px solid var(--color-accent, #4caf50); /* Separator */
        }
        .continuousSurahBlock h2.surahNameHeader { /* For Surah Name in Continuous */
            text-align: center; font-size: 1.8em; /* Relative to parent font-size */
            color: var(--color-accent-dark, #388e3c); margin-bottom: 0.8em;
            padding: 5px; border-bottom: 1px solid var(--color-border);
        }
        .bismillahText {
            text-align: center; font-size: 1.5em; /* Relative */ margin: 1em 0;
            font-family: 'KFGQPC Uthman Taha Naskh', var(--font-arabic); /* Often specific font for Bismillah */
        }
        .fsReaderAyah {
            display: inline; margin-right: 0.1em; line-height: 2.3; /* Increased line-height */
            transition: background-color 0.2s; cursor: pointer; /* Click to play Ayah */
        }
        .fsReaderAyahNumber {
            font-size: 0.65em; color: var(--color-accent-dark, #388e3c);
            padding: 0px 0.25em; margin: 0 0.15em;
            border: 1px solid var(--color-accent, #4caf50); border-radius: 50%;
            display: inline-block; line-height: 1.2; vertical-align: middle;
        }
        .fsReaderTransliteration {
            display: block; font-size: 0.7em; color: #666;
            font-family: var(--font-english); direction: ltr; text-align: right;
            margin-top: -1em; margin-bottom: 0.6em; padding-right: 2em; /* Indent under Arabic */
        }
        .highlighted-ayah { border-radius: 3px; } /* Background set by JS */
        #fsReaderFooter button, #fsReaderHeader button { font-size: 1.4rem; padding: 6px 8px; }
        #fsReaderScrubSlider { flex-grow:1; margin:0 10px; accent-color: var(--color-accent); }
        .fsReaderSlidingPanel {
            position: absolute; top: 33px; /* Below header */
            width: 320px; max-width: 90%; background-color: var(--color-bg-primary);
            border: 1px solid var(--color-border); box-shadow: 0 3px 10px rgba(0,0,0,0.15);
            padding: 15px; z-index: 10001; display: none;
            color: var(--color-text-primary); overflow-y:auto;
        }
        #fsReaderSettingsPanel { right: 0; border-radius: 0 0 0 var(--border-radius); }
        #fsReaderIndexPanel { left: 0; border-radius: 0 0 var(--border-radius) 0; }
        .fsReaderSlidingPanel h4 { margin-top: 0; margin-bottom:12px; color: var(--color-text-secondary); border-bottom: 1px solid var(--color-border); padding-bottom: 8px;}
        .fsReaderSlidingPanel label { display: block; margin-top: 8px; margin-bottom: 2px; font-size:0.95em; font-weight:normal; color: var(--color-text-secondary); }
        .fsReaderSlidingPanel select, .fsReaderSlidingPanel input[type=range], .fsReaderSlidingPanel input[type=checkbox], .fsReaderSlidingPanel input[type=color] { 
            width: 100%; margin-bottom:12px; 
        }
        .fsReaderSlidingPanel input[type=range] { padding: 0; }
        .fsReaderSlidingPanel .panel-section { margin-bottom:15px; }
        .fsReaderSlidingPanel .panel-section h5 { margin-bottom:5px; font-size:1em; color: var(--color-text-primary); }
        #fsReaderIndexPanel .index-tabs { display:flex; margin-bottom:10px; border-bottom: 1px solid var(--color-border); }
        #fsReaderIndexPanel .index-tab { padding: 8px 12px; cursor:pointer; border-radius: 4px 4px 0 0; }
        #fsReaderIndexPanel .index-tab.active-tab { background-color: var(--color-bg-secondary); border: 1px solid var(--color-border); border-bottom:1px solid var(--color-bg-secondary); }
        .index-list { list-style: none; padding-left: 0; max-height: calc(100vh - 200px); overflow-y: auto;}
        .index-list li a { display: block; padding: 7px 5px; color: var(--color-text-primary); font-size:0.95em; border-bottom: 1px dotted var(--color-border); }
        .index-list li a:hover { background-color: var(--color-bg-secondary); text-decoration:none; }
        .index-list-item-num { color: var(--color-accent-dark); font-weight:bold; margin-right:8px; display:inline-block; width:25px; text-align:right;}
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
    }
    async function launchFullScreenQuranReaderEnhanced() {
        if (isFullScreenReaderActive) return;
        isFullScreenReaderActive = true;
        document.body.style.overflow = 'hidden';
        injectEnhancedFullScreenReaderCSS();
        await loadTajMushafPageDataIfNeeded(); // Ensure page data is loaded
        loadFullScreenReaderSettings(); // Load user preferences
        const overlay = document.createElement('div');
        overlay.id = 'fullScreenReaderOverlay';
        overlay.innerHTML = `
        <div id="fsReaderHeader">
            <button id="fsReaderIndexToggleBtn" title="Index">☰</button>
            <div class="title-page-container">
                <div id="fsReaderSurahTitle" class="title">Loading...</div>
                <div id="fsReaderPageInfo" class="page-info">Page ...</div>
            </div>
            <button id="fsReaderSettingsToggleBtn" title="Settings">⚙️</button>
        </div>
        <div id="fsReaderContent" style="font-size: ${fullScreenReaderSettings.fontSize};">
            <p>Loading Quran content...</p>
        </div>
        <div id="fsReaderFooter">
            <button id="fsReaderPrevBtn" title="Previous">◀</button>
            <input type="range" id="fsReaderScrubSlider" min="1" max="${TAJ_COMPANY_PAGES}" value="1" title="Navigate">
            <button id="fsReaderNextBtn" title="Next">▶</button>
            <button id="fsReaderPlayPauseBtn" title="Play/Pause">🔊</button>
            <button id="fsReaderCloseBtnEnhanced" title="Close Reader">✕</button>
        </div>
        <!-- Settings Panel -->
        <div id="fsReaderSettingsPanel" class="fsReaderSlidingPanel">
            <h4>Reader Settings</h4>
            <div class="panel-section">
                <h5>Appearance</h5>
                <label for="fsArabicFontSelect">Arabic Font:</label>
                <select id="fsArabicFontSelect">
                    <option value="Scheherazade New">Scheherazade New</option>
                    <option value="KFGQPC Uthman Taha Naskh">KFGQPC Uthman Naskh</option>
                    <option value="Amiri">Amiri</option>
                    <option value="Lateef">Lateef</option>
                    <option value="Noto Naskh Arabic">Noto Naskh Arabic</option>
                    <option value="var(--font-arabic)">App Default Arabic</option>
                </select>
                <label for="fsFontSizeSlider">Base Font Size (<span id="fsFontSizeValue">${fullScreenReaderSettings.fontSize}</span>):</label>
                <input type="range" id="fsFontSizeSlider" min="1.8" max="4.0" step="0.1" value="${parseFloat(fullScreenReaderSettings.fontSize)}">
                <div id="fsLinesPerPageSettingDiv">
                    <label for="fsLinesPerPageSlider">Lines Per Page (Paged View) (<span id="fsLinesPerPageValue">${fullScreenReaderSettings.linesPerPage}</span>):</label>
                    <input type="range" id="fsLinesPerPageSlider" min="10" max="20" step="1" value="${fullScreenReaderSettings.linesPerPage}">
                </div>
                <label><input type="checkbox" id="fsShowTransliterationCheck"> Show Transliteration</label>
            </div>
            <div class="panel-section">
                <h5>Audio</h5>
                <label><input type="checkbox" id="fsContinuousAudioCheck"> Continuous Audio Playback</label>
                <label><input type="checkbox" id="fsAutoScrollAudioCheck"> Auto-scroll with Audio</label>
                <label for="fsHighlightColorPicker">Highlight Color:</label>
                <input type="color" id="fsHighlightColorPicker" value="${fullScreenReaderSettings.highlightColor.startsWith('rgba') ? '#ffff96' : fullScreenReaderSettings.highlightColor}">
            </div>
            <div class="panel-section">
                <h5>Navigation</h5>
                <label for="fsViewModeSelect">View Mode:</label>
                <select id="fsViewModeSelect">
                    <option value="paged">Paged (Mushaf Style)</option>
                    <option value="continuous-scroll">Continuous Scroll</option>
                </select>
            </div>
        </div>
        <!-- Index Panel -->
        <div id="fsReaderIndexPanel" class="fsReaderSlidingPanel">
            <h4>Index</h4>
            <div class="index-tabs">
                <span class="index-tab active-tab" data-tab="surahs">Surahs</span>
                <span class="index-tab" data-tab="juz">Juz (Parahs)</span>
                <span class="index-tab" data-tab="themes">Themes</span>
            </div>
            <div id="fsIndexContentSurahs" class="index-content-panel">
                <ul class="index-list" id="fsIndexSurahList"></ul>
            </div>
            <div id="fsIndexContentJuz" class="index-content-panel" style="display:none;">
                <ul class="index-list" id="fsIndexJuzList"></ul>
            </div>
            <div id="fsIndexContentThemes" class="index-content-panel" style="display:none;">
                 <input type="text" id="fsThematicIndexSearchInput" placeholder="Search themes..." style="width:100%; margin-bottom:10px;">
                <ul class="index-list" id="fsIndexThemeList">
                    <li><a href="#" data-s="2" data-a="255">Ayat al-Kursi</a></li>
                    <!-- Add more themes -->
                </ul>
            </div>
        </div>
    `;
        document.body.appendChild(overlay);
        setupEnhancedFullScreenReaderEventListeners();
        populateIndexLists();
        loadLastReadPosition(); // Load last position, then render
        if (fullScreenReaderViewMode === 'paged') {
            document.getElementById('fsLinesPerPageSettingDiv').style.display = 'block';
            await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
        } else {
            document.getElementById('fsLinesPerPageSettingDiv').style.display = 'none';
            continuousScrollNextSurahToLoad = fullScreenReaderCurrentSurah; // Start loading from current
            continuousScrollNextAyahToLoad = fullScreenReaderCurrentAyah;
            await initializeContinuousScroll();
        }
        updateReaderHeaderInfo();
        updateScrubSliderRangeAndValue();
    }
    function closeFullScreenQuranReaderEnhanced() {
        const overlay = document.getElementById('fullScreenReaderOverlay');
        if (overlay) {
            document.body.removeChild(overlay);
        }
        document.body.style.overflow = 'auto';
        isFullScreenReaderActive = false;
        stopAndClearAudio(); // Your existing function
        saveLastReadPosition(); // Your existing function
        saveFullScreenReaderSettings(); // Save any last minute changes
    }
    async function loadTajMushafPageDataIfNeeded() {
        if (tajMushafPageData.length > 0) return;
        tajMushafPageData = [];
        let currentS = 1, currentA = 1;
        let currentJuz = 1;
        const pagePerJuzApprox = TAJ_COMPANY_PAGES / 30;
        for (let page = 1; page <= TAJ_COMPANY_PAGES; page++) {
            const pageStartS = currentS;
            const pageStartA = currentA;
            let ayahsOnPageCount = 0; // Count ayahs added to this page
            let pageEndS = currentS;
            let pageEndA = currentA;
            if (page > (currentJuz * pagePerJuzApprox) && currentJuz < 30) {
                currentJuz++;
            }
            while (ayahsOnPageCount < fullScreenReaderSettings.linesPerPage && currentS <= 114) {
                ayahsOnPageCount++; // This is a line counter, not strictly ayah counter for Taj layout
                pageEndS = currentS;
                pageEndA = currentA;
                currentA++;
                if (currentA > surahAyahCounts[currentS]) { // surahAyahCounts must be globally available
                    currentS++;
                    currentA = 1;
                    if (currentS > 114) break;
                }
            }
            tajMushafPageData.push({
                page: page,
                startSurah: pageStartS, startAyah: pageStartA,
                endSurah: pageEndS, endAyah: pageEndA,
                juz: currentJuz
            });
            if (currentS > 114) break;
        }
        console.log("Taj Mushaf Page Data Loaded (Simulated):", tajMushafPageData.length, "pages");
    }
    async function renderQuranPageEnhanced(pageNumber) {
        const contentDiv = document.getElementById('fsReaderContent');
        if (!contentDiv || !tajMushafPageData.length) {
            console.error("renderQuranPageEnhanced: Content div or page data missing.");
            if (contentDiv) contentDiv.innerHTML = "<p style='color:red;text-align:center;'>Error rendering page.</p>";
            return;
        }
        contentDiv.innerHTML = '';
        contentDiv.style.alignItems = 'center';
        contentDiv.style.fontSize = fullScreenReaderSettings.fontSize;
        const pageData = tajMushafPageData.find(p => p.page === pageNumber);
        if (!pageData) {
            contentDiv.innerHTML = `<div class="fsReaderPage" style="text-align:center; padding: 50px;">Page ${pageNumber} data not found.</div>`;
            return;
        }
        fullScreenReaderCurrentPage = pageNumber;
        fullScreenReaderCurrentSurah = pageData.startSurah; // Set global current S/A to page start
        fullScreenReaderCurrentAyah = pageData.startAyah;  // for header and play button context
        const pageDiv = document.createElement('div');
        pageDiv.className = 'fsReaderPage';
        let currentS_loop_var = pageData.startSurah; // Use loop-specific variables
        let currentA_loop_var = pageData.startAyah;
        let lineCountApproximation = 0;
        while (true) {
            if (currentS_loop_var > pageData.endSurah || (currentS_loop_var === pageData.endSurah && currentA_loop_var > pageData.endAyah)) {
                break;
            }
            if (currentS_loop_var > 114) break;
            const ayahData = await getData(STORE_QURAN, [currentS_loop_var, currentA_loop_var]);
            if (ayahData && ayahData.arabic) {
                if (currentA_loop_var === 1 && currentS_loop_var !== 1 && currentS_loop_var !== 9) {
                    const bismDiv = document.createElement('div');
                    bismDiv.className = 'bismillahText';
                    bismDiv.style.fontFamily = fullScreenReaderSettings.arabicFont;
                    bismDiv.textContent = "بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ";
                    pageDiv.appendChild(bismDiv);
                    lineCountApproximation++;
                }
                const ayahSpan = document.createElement('span');
                ayahSpan.className = 'fsReaderAyah';
                ayahSpan.dataset.surah = currentS_loop_var;
                ayahSpan.dataset.ayah = currentA_loop_var;
                ayahSpan.style.fontFamily = fullScreenReaderSettings.arabicFont;
                ayahSpan.textContent = ayahData.arabic.trim();
                const s_for_click = currentS_loop_var; // Capture for closure
                const a_for_click = currentA_loop_var; // Capture for closure
                ayahSpan.addEventListener('click', () => {
                    handleAyahSpanClick(s_for_click, a_for_click);
                });
                pageDiv.appendChild(ayahSpan);
                const ayahNumSpan = document.createElement('span');
                ayahNumSpan.className = 'fsReaderAyahNumber';
                ayahNumSpan.textContent = arabicNumber(currentA_loop_var);
                pageDiv.appendChild(ayahNumSpan);
                if (fullScreenReaderSettings.showTransliteration) {
                    const translitText = await getAyahTransliteration(currentS_loop_var, currentA_loop_var);
                    if (translitText) {
                        const translitSpan = document.createElement('span');
                        translitSpan.className = 'fsReaderTransliteration';
                        translitSpan.textContent = translitText;
                        pageDiv.appendChild(translitSpan);
                    }
                }
                lineCountApproximation++;
            } else if (!ayahData) {
            }
            currentA_loop_var++;
            if (currentA_loop_var > surahAyahCounts[currentS_loop_var]) {
                currentS_loop_var++;
                currentA_loop_var = 1;
            }
            if (lineCountApproximation >= fullScreenReaderSettings.linesPerPage && pageNumber < TAJ_COMPANY_PAGES) {
                if (currentS_loop_var < pageData.endSurah || (currentS_loop_var === pageData.endSurah && currentA_loop_var <= pageData.endAyah)) {
                    break;
                }
            }
        }
        contentDiv.appendChild(pageDiv);
        contentDiv.scrollTop = 0;
        updateReaderHeaderInfo();
        updateScrubSliderRangeAndValue();
    }
    async function initializeContinuousScroll() {
        const contentDiv = document.getElementById('fsReaderContent');
        if (!contentDiv) {
            console.error("initializeContinuousScroll: fsReaderContent not found.");
            return;
        }
        contentDiv.innerHTML = '';
        contentDiv.style.alignItems = 'stretch';
        contentDiv.style.fontSize = fullScreenReaderSettings.fontSize;
        continuousScrollSurahContainer = document.createElement('div');
        continuousScrollSurahContainer.id = 'continuousScrollSurahContainer';
        contentDiv.appendChild(continuousScrollSurahContainer);
        continuousScrollNextSurahToLoad = parseInt(fullScreenReaderCurrentSurah);
        continuousScrollNextAyahToLoad = parseInt(fullScreenReaderCurrentAyah);
        if (isNaN(continuousScrollNextSurahToLoad) || continuousScrollNextSurahToLoad < 1 || continuousScrollNextSurahToLoad > 114) {
            continuousScrollNextSurahToLoad = 1;
        }
        const maxAyahsForInitS = (continuousScrollNextSurahToLoad >= 1 && continuousScrollNextSurahToLoad <= 114 && surahAyahCounts[continuousScrollNextSurahToLoad]) ? surahAyahCounts[continuousScrollNextSurahToLoad] : 0;
        if (isNaN(continuousScrollNextAyahToLoad) || continuousScrollNextAyahToLoad < 1 || (maxAyahsForInitS > 0 && continuousScrollNextAyahToLoad > maxAyahsForInitS)) {
            continuousScrollNextAyahToLoad = 1;
        }
        isLoadingMoreAyahs = false;
        await loadMoreAyahsForContinuousScroll();
        const initialTargetS = continuousScrollNextSurahToLoad; // Use the validated start values
        const initialTargetA = continuousScrollNextAyahToLoad;
        if (initialTargetS > 1 || initialTargetA > 1) {
            setTimeout(() => {
                const targetAyahEl = continuousScrollSurahContainer.querySelector(
                    `.fsReaderAyah[data-surah="${initialTargetS}"][data-ayah="${initialTargetA}"]`
                );
                if (targetAyahEl) {
                    targetAyahEl.scrollIntoView({ behavior: "auto", block: "start" });
                    highlightAyahEnhanced(initialTargetS, initialTargetA);
                }
                updateReaderHeaderInfo();
                updateScrubSliderRangeAndValue();
            }, 200); // Timeout allows DOM to render
        } else {
            updateReaderHeaderInfo();
            updateScrubSliderRangeAndValue();
        }
    }
    async function loadMoreAyahsForContinuousScroll() {
        if (!continuousScrollSurahContainer || !document.body.contains(continuousScrollSurahContainer)) {
            isLoadingMoreAyahs = false; return;
        }
        if (isLoadingMoreAyahs || continuousScrollNextSurahToLoad > 114) {
            if (continuousScrollNextSurahToLoad > 114) isLoadingMoreAyahs = false;
            return;
        }
        isLoadingMoreAyahs = true;
        let ayahsLoadedInBatch = 0;
        let currentRenderingSurah = -1;
        let surahBlockDiv = null;
        while (ayahsLoadedInBatch < CONTINUOUS_SCROLL_LOAD_COUNT && continuousScrollNextSurahToLoad <= 114) {
            if (!continuousScrollSurahContainer || !document.body.contains(continuousScrollSurahContainer)) {
                isLoadingMoreAyahs = false; return;
            }
            const s_loop = parseInt(continuousScrollNextSurahToLoad);
            const a_loop = parseInt(continuousScrollNextAyahToLoad);
            if (isNaN(s_loop) || isNaN(a_loop) || s_loop < 1 || s_loop > 114 || a_loop < 1) {
                isLoadingMoreAyahs = false; break;
            }
            if (s_loop !== currentRenderingSurah) {
                currentRenderingSurah = s_loop;
                surahBlockDiv = continuousScrollSurahContainer.querySelector(`.continuousSurahBlock[data-surah-num="${s_loop}"]`);
                if (!surahBlockDiv) {
                    surahBlockDiv = document.createElement('div');
                    surahBlockDiv.className = 'continuousSurahBlock';
                    surahBlockDiv.dataset.surahNum = s_loop;
                    const surahNameHeader = document.createElement('h2');
                    surahNameHeader.className = 'surahNameHeader';
                    surahNameHeader.style.fontFamily = fullScreenReaderSettings.arabicFont;
                    surahNameHeader.textContent = `${s_loop}. Surah ${surahNames[s_loop - 1] || `Surah ${s_loop}`}`;
                    surahBlockDiv.appendChild(surahNameHeader);
                    if (s_loop !== 1 && s_loop !== 9) {
                        const bismDiv = document.createElement('div');
                        bismDiv.className = 'bismillahText';
                        bismDiv.style.fontFamily = fullScreenReaderSettings.arabicFont;
                        bismDiv.textContent = "بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ";
                        surahBlockDiv.appendChild(bismDiv);
                    }
                    continuousScrollSurahContainer.appendChild(surahBlockDiv);
                }
            }
            if (!surahBlockDiv || !document.body.contains(surahBlockDiv)) {
                isLoadingMoreAyahs = false; return;
            }
            const ayahData = await getData(STORE_QURAN, [s_loop, a_loop]);
            if (!surahBlockDiv || !document.body.contains(surahBlockDiv) || !continuousScrollSurahContainer || !document.body.contains(continuousScrollSurahContainer)) {
                isLoadingMoreAyahs = false; return;
            }
            const ayahSpan = document.createElement('span');
            ayahSpan.className = 'fsReaderAyah';
            ayahSpan.dataset.surah = s_loop;
            ayahSpan.dataset.ayah = a_loop;
            ayahSpan.style.fontFamily = fullScreenReaderSettings.arabicFont;
            if (ayahData && ayahData.arabic && ayahData.arabic.trim() !== "") {
                ayahSpan.textContent = ayahData.arabic.trim();
            } else {
                ayahSpan.textContent = "[No Text]";
                ayahSpan.style.color = "red";
                ayahSpan.style.fontStyle = "italic";
            }
            const s_for_click = s_loop; // Capture for closure
            const a_for_click = a_loop; // Capture for closure
            ayahSpan.addEventListener('click', () => {
                handleAyahSpanClick(s_for_click, a_for_click);
            });
            surahBlockDiv.appendChild(ayahSpan);
            const ayahNumSpan = document.createElement('span');
            ayahNumSpan.className = 'fsReaderAyahNumber';
            ayahNumSpan.textContent = arabicNumber(a_loop);
            surahBlockDiv.appendChild(ayahNumSpan);
            ayahsLoadedInBatch++;
            if (fullScreenReaderSettings.showTransliteration && ayahData) {
                const translitText = await getAyahTransliteration(s_loop, a_loop);
                if (translitText) {
                    const translitSpan = document.createElement('span');
                    translitSpan.className = 'fsReaderTransliteration';
                    translitSpan.textContent = translitText;
                    surahBlockDiv.appendChild(translitSpan);
                }
            }
            continuousScrollNextAyahToLoad++;
            const maxAyahsThisSurah = (s_loop >= 1 && s_loop <= 114 && surahAyahCounts[s_loop]) ? surahAyahCounts[s_loop] : 0;
            if (maxAyahsThisSurah > 0 && continuousScrollNextAyahToLoad > maxAyahsThisSurah) {
                if (s_loop < 114) {
                    continuousScrollNextSurahToLoad = s_loop + 1; // This should be next surah
                    continuousScrollNextAyahToLoad = 1;
                } else {
                    continuousScrollNextSurahToLoad = 115;
                    break;
                }
            } else if (maxAyahsThisSurah === 0 && s_loop <= 114) {
                isLoadingMoreAyahs = false; break;
            }
        }
        isLoadingMoreAyahs = false;
    }
    function populateIndexLists() {
        const surahListEl = document.getElementById('fsIndexSurahList');
        const juzListEl = document.getElementById('fsIndexJuzList');
        if (!surahListEl || !juzListEl) return;
        surahListEl.innerHTML = '';
        juzListEl.innerHTML = '';
        for (let i = 1; i <= 114; i++) {
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = '#';
            a.dataset.surah = i;
            a.innerHTML = `<span class="index-list-item-num">${arabicNumber(i)}</span> ${surahNames[i - 1] || `Surah ${i}`}`; // Fallback
            a.addEventListener('click', handleIndexSurahClick);
            li.appendChild(a);
            surahListEl.appendChild(li);
        }
        juzBoundariesData.forEach(juzInfo => {
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = '#';
            a.dataset.juz = juzInfo.juz;
            a.dataset.startSurah = juzInfo.startSurah;
            a.dataset.startAyah = juzInfo.startAyah;
            a.innerHTML = `<span class="index-list-item-num">${arabicNumber(juzInfo.juz)}</span> ${juzInfo.name}`;
            a.addEventListener('click', handleIndexJuzClick);
            li.appendChild(a);
            juzListEl.appendChild(li);
        });
        populateThemesIndexList();
    }
    async function handleIndexSurahClick(event) {
        event.preventDefault();
        const surahNum = parseInt(event.currentTarget.dataset.surah) || 1;
        const indexPanel = document.getElementById('fsReaderIndexPanel');
        if (indexPanel) indexPanel.style.display = 'none';
        const contentDiv = document.getElementById('fsReaderContent');
        if (!contentDiv) {
            console.error("handleIndexSurahClick: fsReaderContent not found.");
            return;
        }
        stopAndClearAudio();
        fullScreenReaderCurrentSurah = surahNum;
        fullScreenReaderCurrentAyah = 1;
        if (fullScreenReaderViewMode === 'paged') {
            const page = surahToPageEnhanced(surahNum, 1);
            fullScreenReaderCurrentPage = page;
            await renderQuranPageEnhanced(page);
        } else {
            continuousScrollNextSurahToLoad = surahNum;
            continuousScrollNextAyahToLoad = 1;
            await initializeContinuousScroll();
        }
    }
    async function handleIndexJuzClick(event) {
        event.preventDefault();
        const startS = parseInt(event.currentTarget.dataset.startSurah);
        const startA = parseInt(event.currentTarget.dataset.startAyah);
        const indexPanel = document.getElementById('fsReaderIndexPanel');
        if (indexPanel) indexPanel.style.display = 'none';
        const contentDiv = document.getElementById('fsReaderContent');
        if (!contentDiv) {
            console.error("handleIndexJuzClick: fsReaderContent not found.");
            return;
        }
        stopAndClearAudio(); // Stop any currently playing audio
        fullScreenReaderCurrentSurah = startS;
        fullScreenReaderCurrentAyah = startA;
        if (fullScreenReaderViewMode === 'paged') {
            const page = surahToPageEnhanced(startS, startA);
            fullScreenReaderCurrentPage = page;
            await renderQuranPageEnhanced(page);
            setTimeout(() => highlightAndScrollToAyahInPage(startS, startA), 250);
        } else {
            if (continuousScrollSurahContainer) {
                continuousScrollSurahContainer.innerHTML = '';
            }
            continuousScrollNextSurahToLoad = startS;
            continuousScrollNextAyahToLoad = startA;
            await initializeContinuousScroll();
        }
        updateReaderHeaderInfo();
        updateScrubSliderRangeAndValue();
    }
    function highlightAndScrollToAyahInPage(surah, ayah) {
        const targetAyahEl = document.querySelector(`#fsReaderContent .fsReaderAyah[data-surah="${surah}"][data-ayah="${ayah}"]`);
        if (targetAyahEl) {
            targetAyahEl.scrollIntoView({ behavior: "smooth", block: "center" });
            highlightAyahEnhanced(surah, ayah);
        }
    }
    function updateReaderHeaderInfo() {
        const surahTitleEl = document.getElementById('fsReaderSurahTitle');
        const pageInfoEl = document.getElementById('fsReaderPageInfo');
        if (!surahTitleEl || !pageInfoEl) return;
        let displayS = parseInt(fullScreenReaderCurrentSurah);
        let displayA = parseInt(fullScreenReaderCurrentAyah);
        let displayPage = parseInt(fullScreenReaderCurrentPage);
        if (isNaN(displayS) || displayS < 1 || displayS > 114) displayS = 1;
        const maxAyahsForCurrentDisplayS = (displayS >= 1 && displayS <= 114 && surahAyahCounts[displayS]) ? surahAyahCounts[displayS] : 0;
        if (isNaN(displayA) || displayA < 1 || (maxAyahsForCurrentDisplayS > 0 && displayA > maxAyahsForCurrentDisplayS)) displayA = 1;
        if (isNaN(displayPage) || displayPage < 1) displayPage = 1;
        if (fullScreenReaderViewMode === 'continuous-scroll' && continuousScrollSurahContainer) {
            const firstVisibleAyah = findFirstVisibleAyah();
            if (firstVisibleAyah) {
                let sFromDOM = parseInt(firstVisibleAyah.dataset.surah);
                let aFromDOM = parseInt(firstVisibleAyah.dataset.ayah);
                if (!isNaN(sFromDOM) && sFromDOM >= 1 && sFromDOM <= 114) displayS = sFromDOM;
                const maxAyahsForDomS = (sFromDOM >= 1 && sFromDOM <= 114 && surahAyahCounts[sFromDOM]) ? surahAyahCounts[sFromDOM] : 0;
                if (!isNaN(aFromDOM) && aFromDOM >= 1 && (maxAyahsForDomS > 0 && aFromDOM <= maxAyahsForDomS)) displayA = aFromDOM;
            }
        } else if (fullScreenReaderViewMode === 'paged') {
            const pageData = tajMushafPageData.find(p => p.page === displayPage);
            if (pageData) {
                displayS = pageData.startSurah;
                displayA = pageData.startAyah;
            } else { // Page data not found, default gracefully
                displayS = 1; displayA = 1; displayPage = 1;
            }
        }
        let displayJuz = getJuzFromSurahAyah(displayS, displayA);
        if (isNaN(displayJuz) || displayJuz < 1 || displayJuz > 30) displayJuz = 1;
        const surahNameText = (displayS >= 1 && displayS <= 114 && surahNames[displayS - 1])
            ? surahNames[displayS - 1]
            : `Surah ${displayS}`; // Fallback if surahNames is not right
        surahTitleEl.textContent = `Surah ${displayS}: ${surahNameText}`;
        let pageText = `Juz ${displayJuz}`;
        if (fullScreenReaderViewMode === 'paged') {
            pageText = `Page ${displayPage}/${TAJ_COMPANY_PAGES} (Juz ${displayJuz})`;
        } else {
            pageText = `(S:${displayS} A:${displayA}) Juz ${displayJuz}`;
        }
        pageInfoEl.textContent = pageText;
    }
    function findFirstVisibleAyah() {
        const contentDiv = document.getElementById('fsReaderContent');
        if (!contentDiv) return null;
        const ayahs = contentDiv.querySelectorAll('.fsReaderAyah');
        for (let ayahEl of ayahs) {
            const rect = ayahEl.getBoundingClientRect();
            const contentRect = contentDiv.getBoundingClientRect();
            if (rect.top >= contentRect.top && rect.top <= contentRect.bottom - 50) { // 50px buffer
                return ayahEl;
            }
        }
        return ayahs.length > 0 ? ayahs[0] : null; // Fallback to first loaded
    }
    function updateScrubSliderRangeAndValue() {
        const slider = document.getElementById('fsReaderScrubSlider');
        if (!slider) return;
        if (fullScreenReaderViewMode === 'paged') {
            slider.min = 1;
            slider.max = TAJ_COMPANY_PAGES;
            slider.value = fullScreenReaderCurrentPage;
        } else { // continuous-scroll, slider represents Surah
            slider.min = 1;
            slider.max = 114;
            slider.value = fullScreenReaderCurrentSurah; // Or the dominant Surah on screen
        }
    }
    async function goToNextEnhanced() {
        stopAndClearAudio();
        if (fullScreenReaderViewMode === 'paged') {
            if (fullScreenReaderCurrentPage < TAJ_COMPANY_PAGES) {
                fullScreenReaderCurrentPage++;
                await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
            }
        } else { // continuous-scroll
            const contentDiv = document.getElementById('fsReaderContent');
            contentDiv.scrollTop += contentDiv.clientHeight * 0.8; // Scroll down by 80% of viewport
            if (contentDiv.scrollTop + contentDiv.clientHeight >= contentDiv.scrollHeight - 200) {
                await loadMoreAyahsForContinuousScroll();
            }
            setTimeout(updateReaderHeaderInfo, 300); // After scroll settles
        }
    }
    async function goToPrevEnhanced() {
        stopAndClearAudio();
        if (fullScreenReaderViewMode === 'paged') {
            if (fullScreenReaderCurrentPage > 1) {
                fullScreenReaderCurrentPage--;
                await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
            }
        } else { // continuous-scroll
            const contentDiv = document.getElementById('fsReaderContent');
            contentDiv.scrollTop -= contentDiv.clientHeight * 0.8;
            setTimeout(updateReaderHeaderInfo, 300);
        }
    }
    function surahToPageEnhanced(surah, ayah = 1) {
        if (!tajMushafPageData || tajMushafPageData.length === 0) return 1;
        for (const pageInfo of tajMushafPageData) {
            if (surah === pageInfo.startSurah && surah === pageInfo.endSurah) { // Single surah on page
                if (ayah >= pageInfo.startAyah && ayah <= pageInfo.endAyah) return pageInfo.page;
            } else if (surah === pageInfo.startSurah && ayah >= pageInfo.startAyah) { // Starts on this page
                return pageInfo.page;
            } else if (surah === pageInfo.endSurah && ayah <= pageInfo.endAyah) { // Ends on this page
                return pageInfo.page;
            } else if (surah > pageInfo.startSurah && surah < pageInfo.endSurah) { // Entirely within this page (multi-surah page)
                return pageInfo.page;
            }
        }
        const firstPageOfSurah = tajMushafPageData.find(p => p.startSurah === surah || p.endSurah === surah);
        return firstPageOfSurah ? firstPageOfSurah.page : 1;
    }
    function applyFullScreenReaderSettingsChanges() {
        const contentDiv = document.getElementById('fsReaderContent');
        if (contentDiv) {
            contentDiv.style.fontSize = fullScreenReaderSettings.fontSize;
        }
        if (fullScreenReaderViewMode === 'paged') {
            renderQuranPageEnhanced(fullScreenReaderCurrentPage); // Re-render page for font/lines
        } else {
            continuousScrollSurahContainer.innerHTML = ''; // Clear
            continuousScrollNextSurahToLoad = fullScreenReaderCurrentSurah; // Or first visible
            continuousScrollNextAyahToLoad = fullScreenReaderCurrentAyah; // Or first visible
            initializeContinuousScroll();
        }
        saveFullScreenReaderSettings();
    }
    function saveFullScreenReaderSettings() { // Unchanged, ensure it saves all relevant settings
        localStorage.setItem('fsReaderSettingsEnhanced', JSON.stringify(fullScreenReaderSettings));
    }
    function loadFullScreenReaderSettings() { // Revised to load into new structure
        const saved = localStorage.getItem('fsReaderSettingsEnhanced');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                for (const key in parsed) {
                    if (parsed[key] !== undefined && fullScreenReaderSettings.hasOwnProperty(key)) {
                        fullScreenReaderSettings[key] = parsed[key];
                    }
                }
            } catch (e) { console.error("Error parsing saved reader settings", e); }
        }
        const fontSelect = document.getElementById('fsArabicFontSelect');
        const sizeSlider = document.getElementById('fsFontSizeSlider');
        const sizeValueEl = document.getElementById('fsFontSizeValue');
        const linesSlider = document.getElementById('fsLinesPerPageSlider');
        const linesValueEl = document.getElementById('fsLinesPerPageValue');
        const translitCheck = document.getElementById('fsShowTransliterationCheck');
        const contAudioCheck = document.getElementById('fsContinuousAudioCheck');
        const autoScrollCheck = document.getElementById('fsAutoScrollAudioCheck');
        const highlightPicker = document.getElementById('fsHighlightColorPicker');
        const viewModeSelect = document.getElementById('fsViewModeSelect');
        if (fontSelect) fontSelect.value = fullScreenReaderSettings.arabicFont;
        if (sizeSlider && sizeValueEl) {
            sizeSlider.value = parseFloat(fullScreenReaderSettings.fontSize);
            sizeValueEl.textContent = fullScreenReaderSettings.fontSize;
        }
        if (linesSlider && linesValueEl) {
            linesSlider.value = fullScreenReaderSettings.linesPerPage;
            linesValueEl.textContent = fullScreenReaderSettings.linesPerPage;
        }
        if (translitCheck) translitCheck.checked = fullScreenReaderSettings.showTransliteration;
        if (contAudioCheck) contAudioCheck.checked = fullScreenReaderSettings.continuousAudio;
        if (autoScrollCheck) autoScrollCheck.checked = fullScreenReaderSettings.autoScrollAudio;
        if (highlightPicker) {
            highlightPicker.value = fullScreenReaderSettings.highlightColor.startsWith('rgba') ?
                rgbToHex(fullScreenReaderSettings.highlightColor) : // Convert RGBA to Hex for picker
                fullScreenReaderSettings.highlightColor;
        }
        if (viewModeSelect) viewModeSelect.value = fullScreenReaderViewMode; // From loaded last read pos
    }
    function rgbToHex(rgba) {
        if (rgba.startsWith('#')) return rgba; // Already hex
        const parts = rgba.substring(rgba.indexOf('(') + 1, rgba.lastIndexOf(')')).split(/,\s*/);
        if (parts.length < 3) return '#ffff96'; // Fallback
        const r = parseInt(parts[0]).toString(16).padStart(2, '0');
        const g = parseInt(parts[1]).toString(16).padStart(2, '0');
        const b = parseInt(parts[2]).toString(16).padStart(2, '0');
        return `#${r}${g}${b}`;
    }
    function loadLastReadPosition() {
        const saved = localStorage.getItem('fsReaderLastPosEnhanced');
        let page = 1, surah = 1, ayah = 1, viewMode = 'paged';
        if (saved) {
            try {
                const pos = JSON.parse(saved);
                page = parseInt(pos.page);
                surah = parseInt(pos.surah); // `surah` could be NaN here if pos.surah is not a number string
                ayah = parseInt(pos.ayah);
                viewMode = pos.viewMode === 'continuous-scroll' ? 'continuous-scroll' : 'paged'; // Validate viewMode
                if (isNaN(page) || page < 1 || page > TAJ_COMPANY_PAGES) page = 1;
                if (isNaN(surah) || surah < 1 || surah > 114) {
                    surah = 1; // Default surah
                }
                const maxAyahsForSurah = (surah >= 1 && surah <= 114 && surahAyahCounts[surah]) ? surahAyahCounts[surah] : 0;
                if (isNaN(ayah) || ayah < 1 || (maxAyahsForSurah > 0 && ayah > maxAyahsForSurah)) {
                    ayah = 1; // Default ayah
                }
                if (surah === 1 && ayah > 7) ayah = 1; // Max 7 for Al-Fatihah, or reset to 1 if out of bounds
            } catch (e) {
                console.error("Error parsing last read position, resetting to defaults.", e);
                page = 1; surah = 1; ayah = 1; viewMode = 'paged';
            }
        } else {
            page = 1; surah = 1; ayah = 1; viewMode = 'paged';
        }
        fullScreenReaderCurrentPage = page;
        fullScreenReaderCurrentSurah = surah;
        fullScreenReaderCurrentAyah = ayah;
        fullScreenReaderViewMode = viewMode;
        const viewModeSelect = document.getElementById('fsViewModeSelect');
        if (viewModeSelect) {
            viewModeSelect.value = fullScreenReaderViewMode;
        }
    }
    function saveLastReadPosition() { // Revised
        localStorage.setItem('fsReaderLastPosEnhanced', JSON.stringify({
            page: fullScreenReaderCurrentPage,
            surah: fullScreenReaderCurrentSurah,
            ayah: fullScreenReaderCurrentAyah,
            viewMode: fullScreenReaderViewMode
        }));
    }
    async function playAudioForAyahEnhanced(surah, ayah) {
        const sNum = parseInt(surah);
        const aNum = parseInt(ayah);
        if (isNaN(sNum) || isNaN(aNum) || sNum < 1 || sNum > 114 || aNum < 1 ||
            (surahAyahCounts[sNum] && aNum > surahAyahCounts[sNum])) {
            console.error(`playAudioForAyahEnhanced: Invalid input S:${surah} A:${ayah}. Aborting.`);
            if (fullScreenReaderIsPlayingAudio) stopAndClearAudio();
            return;
        }
        stopAndClearAudio();
        const surahPadded = String(sNum).padStart(3, '0');
        const ayahPadded = String(aNum).padStart(3, '0');
        const audioSrc = `https://everyayah.com/data/Alafasy_128kbps/${surahPadded}${ayahPadded}.mp3`;
        fullScreenReaderAudioPlayer = new Audio(audioSrc);
        fullScreenReaderAudioPlayer.currentSrcAyahS = sNum;
        fullScreenReaderAudioPlayer.currentSrcAyahA = aNum;
        try {
            await fullScreenReaderAudioPlayer.play();
            fullScreenReaderIsPlayingAudio = true;
            const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
            if (playPauseBtn) playPauseBtn.textContent = '❚❚';
            highlightAyahEnhanced(sNum, aNum);
            fullScreenReaderAudioPlayer.onended = async () => {
                fullScreenReaderIsPlayingAudio = false;
                const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
                if (playPauseBtn) playPauseBtn.textContent = '🔊';
                if (fullScreenReaderSettings.continuousAudio) {
                    let nextS = sNum; // Use sNum from the current closure
                    let nextA = aNum + 1; // Use aNum from the current closure
                    if (surahAyahCounts[nextS] && nextA > surahAyahCounts[nextS]) {
                        if (nextS < 114) {
                            nextS++;
                            nextA = 1;
                        } else {
                            removeHighlightEnhanced();
                            return;
                        }
                    } else if (!surahAyahCounts[nextS]) {
                        removeHighlightEnhanced(); return;
                    }
                    fullScreenReaderCurrentSurah = nextS; // Update global state for the *next* one
                    fullScreenReaderCurrentAyah = nextA;
                    updateReaderHeaderInfo();
                    playAudioForAyahEnhanced(nextS, nextA);
                } else {
                    removeHighlightEnhanced();
                }
            };
            fullScreenReaderAudioPlayer.onerror = (e) => {
            };
        } catch (err) {
        }
    }
    function toggleAudioPlaybackEnhanced() {
        const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
        if (!fullScreenReaderAudioPlayer || fullScreenReaderAudioPlayer.src === '' || fullScreenReaderAudioPlayer.src === window.location.href || fullScreenReaderAudioPlayer.ended) {
            let targetS = parseInt(fullScreenReaderCurrentSurah);
            let targetA = parseInt(fullScreenReaderCurrentAyah);
            if (isNaN(targetS) || targetS < 1 || targetS > 114) targetS = 1;
            const maxAyahsForGlobalS = (targetS >= 1 && targetS <= 114 && surahAyahCounts[targetS]) ? surahAyahCounts[targetS] : 0;
            if (isNaN(targetA) || targetA < 1 || (maxAyahsForGlobalS > 0 && targetA > maxAyahsForGlobalS)) targetA = 1;
            if (fullScreenReaderViewMode === 'continuous-scroll') {
                const firstVisible = findFirstVisibleAyah(); // This finds the Ayah at the top of the viewport
                if (firstVisible && firstVisible.dataset.surah && firstVisible.dataset.ayah) {
                    let sFromDOM = parseInt(firstVisible.dataset.surah);
                    let aFromDOM = parseInt(firstVisible.dataset.ayah);
                    if (!isNaN(sFromDOM) && sFromDOM >= 1 && sFromDOM <= 114) {
                        const maxAyahsForDomS = (sFromDOM >= 1 && sFromDOM <= 114 && surahAyahCounts[sFromDOM]) ? surahAyahCounts[sFromDOM] : 0;
                        if (!isNaN(aFromDOM) && aFromDOM >= 1 && (maxAyahsForDomS > 0 && aFromDOM <= maxAyahsForDomS)) {
                            targetS = sFromDOM;
                            targetA = aFromDOM;
                        } else {
                        }
                    } else {
                    }
                } else {
                }
            } else { // Paged view
            }
            fullScreenReaderCurrentSurah = targetS;
            fullScreenReaderCurrentAyah = targetA;
            updateReaderHeaderInfo(); // Reflect this in the header
            playAudioForAyahEnhanced(targetS, targetA);
        } else if (fullScreenReaderIsPlayingAudio) {
            fullScreenReaderAudioPlayer.pause();
            fullScreenReaderIsPlayingAudio = false;
            if (playPauseBtn) playPauseBtn.textContent = '🔊';
        } else {
            fullScreenReaderAudioPlayer.play().then(() => {
                fullScreenReaderIsPlayingAudio = true;
                if (playPauseBtn) playPauseBtn.textContent = '❚❚';
                highlightAyahEnhanced(parseInt(fullScreenReaderAudioPlayer.currentSrcAyahS) || fullScreenReaderCurrentSurah,
                    parseInt(fullScreenReaderAudioPlayer.currentSrcAyahA) || fullScreenReaderCurrentAyah);
            }).catch(err => {
                console.error("Error resuming audio:", err);
                if (playPauseBtn) playPauseBtn.textContent = '🔊';
            });
        }
    }
    function stopAndClearAudio() {
        if (fullScreenReaderAudioPlayer) {
            fullScreenReaderAudioPlayer.pause();
            fullScreenReaderAudioPlayer.onended = null; // Remove onended listener
            fullScreenReaderAudioPlayer.onerror = null; // Remove onerror listener
            fullScreenReaderAudioPlayer.src = '';
            fullScreenReaderAudioPlayer.load(); // Important to release resources
            fullScreenReaderAudioPlayer = null;
        }
        fullScreenReaderIsPlayingAudio = false;
        removeHighlightEnhanced();
        const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
        if (playPauseBtn) playPauseBtn.textContent = '🔊';
    }
    function highlightAyahEnhanced(surah, ayah) {
        removeHighlightEnhanced();
        const contentDiv = document.getElementById('fsReaderContent');
        const ayahEl = contentDiv.querySelector(`.fsReaderAyah[data-surah="${surah}"][data-ayah="${ayah}"]`);
        if (ayahEl) {
            ayahEl.style.backgroundColor = fullScreenReaderSettings.highlightColor;
            ayahEl.classList.add('highlighted-ayah');
            if (fullScreenReaderSettings.autoScrollAudio) {
                const rect = ayahEl.getBoundingClientRect();
                const contentRect = contentDiv.getBoundingClientRect();
                const isVisible = rect.top >= contentRect.top && rect.bottom <= contentRect.bottom;
                if (!isVisible) {
                    ayahEl.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
                }
            }
        }
    }
    function removeHighlightEnhanced() {
        const highlighted = document.querySelector('#fsReaderContent .highlighted-ayah');
        if (highlighted) {
            highlighted.style.backgroundColor = '';
            highlighted.classList.remove('highlighted-ayah');
        }
    }
    function arabicNumber(num) {
        const arabicNumerals = ['٠', '١', '٢', '٣', '٤', '٥', '٦', '٧', '٨', '٩'];
        return String(num).split('').map(digit => arabicNumerals[parseInt(digit)]).join('');
    }
    async function getAyahTransliteration(surah, ayah) { return null; }
    let isReaderChromeVisible = true; // To track visibility of header/footer/panels
    function setupEnhancedFullScreenReaderEventListeners() {
        const closeBtn = document.getElementById('fsReaderCloseBtnEnhanced');
        const nextBtn = document.getElementById('fsReaderNextBtn');
        const prevBtn = document.getElementById('fsReaderPrevBtn');
        const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
        const settingsToggleBtn = document.getElementById('fsReaderSettingsToggleBtn');
        const indexToggleBtn = document.getElementById('fsReaderIndexToggleBtn');
        const settingsPanel = document.getElementById('fsReaderSettingsPanel');
        const indexPanel = document.getElementById('fsReaderIndexPanel');
        const contentDiv = document.getElementById('fsReaderContent'); // Main content area
        const headerDiv = document.getElementById('fsReaderHeader');
        const footerDiv = document.getElementById('fsReaderFooter');
        const scrubSlider = document.getElementById('fsReaderScrubSlider'); // For enabling/disabling
        if (closeBtn) closeBtn.addEventListener('click', closeFullScreenQuranReaderEnhanced);
        if (nextBtn) nextBtn.addEventListener('click', goToNextEnhanced);
        if (prevBtn) prevBtn.addEventListener('click', goToPrevEnhanced);
        if (playPauseBtn) playPauseBtn.addEventListener('click', toggleAudioPlaybackEnhanced);
        if (settingsToggleBtn && settingsPanel && indexPanel) {
            settingsToggleBtn.addEventListener('click', () => {
                const isSettingsVisible = settingsPanel.style.display === 'block';
                settingsPanel.style.display = isSettingsVisible ? 'none' : 'block';
                indexPanel.style.display = 'none'; // Always close index panel when settings is toggled
                if (isSettingsVisible) { // i.e., settings panel was open and is now closing
                } else {
                }
            });
        }
        if (indexToggleBtn && indexPanel && settingsPanel) {
            indexToggleBtn.addEventListener('click', () => {
                const isIndexVisible = indexPanel.style.display === 'block';
                indexPanel.style.display = isIndexVisible ? 'none' : 'block';
                settingsPanel.style.display = 'none'; // Always close settings panel
            });
        }
        if (contentDiv && headerDiv && footerDiv && settingsPanel && indexPanel) {
            contentDiv.addEventListener('click', (e) => {
                if (e.target === contentDiv && settingsPanel.style.display === 'none' && indexPanel.style.display === 'none') {
                    toggleReaderChromeVisibility();
                } else if (settingsPanel.style.display === 'block' && !settingsPanel.contains(e.target) && e.target !== settingsToggleBtn) {
                    settingsPanel.style.display = 'none';
                } else if (indexPanel.style.display === 'block' && !indexPanel.contains(e.target) && e.target !== indexToggleBtn) {
                    indexPanel.style.display = 'none';
                }
            });
        }
        const arabicFontSelect = document.getElementById('fsArabicFontSelect');
        const fontSizeSlider = document.getElementById('fsFontSizeSlider');
        const fontSizeValueEl = document.getElementById('fsFontSizeValue');
        const linesPerPageSlider = document.getElementById('fsLinesPerPageSlider');
        const linesPerPageValueEl = document.getElementById('fsLinesPerPageValue');
        const showTransliterationCheck = document.getElementById('fsShowTransliterationCheck');
        const continuousAudioCheck = document.getElementById('fsContinuousAudioCheck');
        const autoScrollAudioCheck = document.getElementById('fsAutoScrollAudioCheck');
        const highlightColorPicker = document.getElementById('fsHighlightColorPicker');
        const viewModeSelect = document.getElementById('fsViewModeSelect');
        if (arabicFontSelect) arabicFontSelect.addEventListener('change', (e) => {
            fullScreenReaderSettings.arabicFont = e.target.value;
            applyFullScreenReaderSettingsChanges();
        });
        if (fontSizeSlider && fontSizeValueEl) {
            fontSizeSlider.addEventListener('input', (e) => {
                fullScreenReaderSettings.fontSize = `${e.target.value}rem`;
                fontSizeValueEl.textContent = fullScreenReaderSettings.fontSize;
                const contentDiv = document.getElementById('fsReaderContent');
                if (contentDiv) contentDiv.style.fontSize = fullScreenReaderSettings.fontSize;
            });
            fontSizeSlider.addEventListener('change', applyFullScreenReaderSettingsChanges); // Save and re-render if needed
        }
        if (linesPerPageSlider && linesPerPageValueEl) {
            linesPerPageSlider.addEventListener('input', (e) => {
                fullScreenReaderSettings.linesPerPage = parseInt(e.target.value, 10);
                linesPerPageValueEl.textContent = fullScreenReaderSettings.linesPerPage;
            });
            linesPerPageSlider.addEventListener('change', applyFullScreenReaderSettingsChanges);
        }
        if (showTransliterationCheck) showTransliterationCheck.addEventListener('change', (e) => {
            fullScreenReaderSettings.showTransliteration = e.target.checked;
            applyFullScreenReaderSettingsChanges();
        });
        if (continuousAudioCheck) continuousAudioCheck.addEventListener('change', (e) => {
            fullScreenReaderSettings.continuousAudio = e.target.checked;
            saveFullScreenReaderSettings(); // Save immediately
        });
        if (autoScrollAudioCheck) autoScrollAudioCheck.addEventListener('change', (e) => {
            fullScreenReaderSettings.autoScrollAudio = e.target.checked;
            saveFullScreenReaderSettings(); // Save immediately
        });
        if (highlightColorPicker) highlightColorPicker.addEventListener('change', (e) => {
            fullScreenReaderSettings.highlightColor = e.target.value;
            saveFullScreenReaderSettings(); // Save immediately
        });
        if (viewModeSelect) {
            viewModeSelect.addEventListener('change', async (e) => {
                fullScreenReaderViewMode = e.target.value;
                saveFullScreenReaderSettings(); // Save new view mode
                document.getElementById('fsLinesPerPageSettingDiv').style.display = (fullScreenReaderViewMode === 'paged') ? 'block' : 'none';
                stopAndClearAudio(); // Stop audio when changing view mode
                if (fullScreenReaderViewMode === 'paged') {
                    fullScreenReaderCurrentPage = surahToPageEnhanced(fullScreenReaderCurrentSurah, fullScreenReaderCurrentAyah);
                    await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
                } else {
                    continuousScrollNextSurahToLoad = fullScreenReaderCurrentSurah;
                    continuousScrollNextAyahToLoad = fullScreenReaderCurrentAyah;
                    await initializeContinuousScroll();
                }
                updateReaderHeaderInfo();
                updateScrubSliderRangeAndValue();
            });
        }
        document.querySelectorAll('#fsReaderIndexPanel .index-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                document.querySelectorAll('#fsReaderIndexPanel .index-tab').forEach(t => t.classList.remove('active-tab'));
                e.target.classList.add('active-tab');
                document.querySelectorAll('#fsReaderIndexPanel .index-content-panel').forEach(p => p.style.display = 'none');
                document.getElementById(`fsIndexContent${e.target.dataset.tab.charAt(0).toUpperCase() + e.target.dataset.tab.slice(1)}`).style.display = 'block';
            });
        });
        if (scrubSlider) {
            scrubSlider.addEventListener('input', () => {
                if (fullScreenReaderViewMode === 'paged') {
                    const page = parseInt(scrubSlider.value, 10);
                    const pageData = tajMushhafPageData.find(p => p.page === page);
                    if (pageData) {
                        document.getElementById('fsReaderSurahTitle').textContent = `Surah ${pageData.startSurah}: ${surahNames[pageData.startSurah - 1]}`;
                        document.getElementById('fsReaderPageInfo').textContent = `Page ${page}/${TAJ_COMPANY_PAGES} (Juz ${pageData.juz || getJuzFromSurahAyah(pageData.startSurah, pageData.startAyah)})`;
                    }
                } else { // Continuous scroll, slider represents Surah
                    const surah = parseInt(scrubSlider.value, 10);
                    document.getElementById('fsReaderSurahTitle').textContent = `Surah ${surah}: ${surahNames[surah - 1]}`;
                    document.getElementById('fsReaderPageInfo').textContent = `Juz ${getJuzFromSurahAyah(surah, 1)}`;
                }
            });
            scrubSlider.addEventListener('change', async () => {
                stopAndClearAudio();
                if (fullScreenReaderViewMode === 'paged') {
                    fullScreenReaderCurrentPage = parseInt(scrubSlider.value, 10);
                    await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
                } else { // Continuous scroll, jump to Surah
                    fullScreenReaderCurrentSurah = parseInt(scrubSlider.value, 10);
                    fullScreenReaderCurrentAyah = 1; // Always start from Ayah 1 of the selected Surah
                    continuousScrollNextSurahToLoad = fullScreenReaderCurrentSurah;
                    continuousScrollNextAyahToLoad = 1;
                    await initializeContinuousScroll();
                }
                updateReaderHeaderInfo(); // Ensure final update
            });
        }
        if (contentDiv) {
            contentDiv.addEventListener('scroll', async () => {
                if (fullScreenReaderViewMode === 'continuous-scroll' && !isLoadingMoreAyahs) {
                    const scrollThreshold = contentDiv.scrollHeight - contentDiv.clientHeight - 300; // 300px from bottom
                    if (contentDiv.scrollTop >= scrollThreshold) {
                        await loadMoreAyahsForContinuousScroll();
                    }
                    updateReaderHeaderInfo();
                }
            });
        }
        setupKeyboardAndTapNavigation();
    }
    function toggleReaderChromeVisibility(forceShow) {
        const headerDiv = document.getElementById('fsReaderHeader');
        const footerDiv = document.getElementById('fsReaderFooter');
        const settingsPanel = document.getElementById('fsReaderSettingsPanel');
        const indexPanel = document.getElementById('fsReaderIndexPanel');
        if (forceShow !== undefined) {
            isReaderChromeVisible = !forceShow; // Set to opposite so toggle flips it to desired state
        }
        isReaderChromeVisible = !isReaderChromeVisible; // Toggle state
        if (headerDiv) headerDiv.style.display = isReaderChromeVisible ? 'flex' : 'none';
        if (footerDiv) footerDiv.style.display = isReaderChromeVisible ? 'flex' : 'none';
        if (!isReaderChromeVisible) {
            if (settingsPanel) settingsPanel.style.display = 'none';
            if (indexPanel) indexPanel.style.display = 'none';
        }
    }
    function addEnhancedFullScreenReaderLaunchButton() {
        const quranViewerSection = document.getElementById('quran');
        if (!quranViewerSection) { console.error("Quran viewer section not found for launch button."); return; }
        const buttonId = 'launchFullScreenReaderBtnEnhanced';
        if (document.getElementById(buttonId)) return; // Already added
        const launchButton = document.createElement('button');
        launchButton.id = buttonId;
        launchButton.innerHTML = '📖 <span class="sr-only">Open Full Screen Reader</span>'; // Icon + SR text
        launchButton.title = 'Open Immersive Quran Reader';
        launchButton.style.padding = '5px 10px';
        launchButton.style.fontSize = '1.2rem';
        launchButton.style.marginLeft = '10px'; // Space from other controls
        launchButton.style.verticalAlign = 'middle';
        launchButton.addEventListener('click', () => {
            fullScreenReaderCurrentSurah = window.currentSurah || 1;
            fullScreenReaderCurrentAyah = window.currentAyah || 1;
            if (fullScreenReaderViewMode === 'paged') { // Use the reader's current view mode preference
                fullScreenReaderCurrentPage = surahToPageEnhanced(fullScreenReaderCurrentSurah, fullScreenReaderCurrentAyah);
            }
            launchFullScreenQuranReaderEnhanced();
            setTimeout(() => {
                document.getElementById('fsReaderSettingsToggleBtn').click(); // Open settings panel on launch
                setTimeout(() => {
                    document.getElementById('fsReaderSettingsToggleBtn').click(); // off settings panel on launch
                }, 200);
                document.querySelector("#fsReaderSettingsPanel").style.right = "66px"
                document.querySelector("#fsReaderSettingsPanel").style.top = "4px"
                document.querySelector("#fsReaderSettingsPanel").style.maxHeight = "100%"
            }, 200);
        });
        const quranControls = quranViewerSection.querySelector('.quran-controls:first-of-type .flex-group'); // Target the flex-group in first controls div
        if (quranControls) {
            quranControls.appendChild(launchButton); // Add to existing controls
        } else { // Fallback
            const header = quranViewerSection.querySelector('h2');
            if (header) header.insertAdjacentElement('afterend', launchButton);
            else quranViewerSection.insertBefore(launchButton, quranViewerSection.firstChild);
        }
    }
    function handleAyahSpanClick(clickedSurah, clickedAyah) {
        fullScreenReaderCurrentSurah = parseInt(clickedSurah);
        fullScreenReaderCurrentAyah = parseInt(clickedAyah);
        updateReaderHeaderInfo();
        playAudioForAyahEnhanced(fullScreenReaderCurrentSurah, fullScreenReaderCurrentAyah);
    }
    function setupKeyboardAndTapNavigation() {
        const readerOverlay = document.getElementById('fullScreenReaderOverlay');
        const contentArea = document.getElementById('fsReaderContent'); // For tap events
        if (!readerOverlay) {
            console.warn("Keyboard/Tap Nav: fullScreenReaderOverlay not found.");
            return;
        }
        const handleKeyDown = (event) => {
            if (!isFullScreenReaderActive ||
                (document.activeElement && ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName))) {
                return;
            }
            const settingsPanel = document.getElementById('fsReaderSettingsPanel');
            const indexPanel = document.getElementById('fsReaderIndexPanel');
            if ((settingsPanel && settingsPanel.style.display === 'block') ||
                (indexPanel && indexPanel.style.display === 'block')) {
                if (event.key === 'Escape') {
                    if (settingsPanel && settingsPanel.style.display === 'block') settingsPanel.style.display = 'none';
                    if (indexPanel && indexPanel.style.display === 'block') indexPanel.style.display = 'none';
                    event.preventDefault(); // Prevent other escape actions if any
                }
                return;
            }
            switch (event.key) {
                case 'ArrowLeft':
                    if (typeof goToPrevEnhanced === "function") {
                        goToPrevEnhanced();
                        event.preventDefault(); // Prevent default browser scroll
                    }
                    break;
                case 'ArrowRight':
                    if (typeof goToNextEnhanced === "function") {
                        goToNextEnhanced();
                        event.preventDefault(); // Prevent default browser scroll
                    }
                    break;
                case 'Escape': // Also allow Esc to close reader if no panels are open
                    if (typeof closeFullScreenQuranReaderEnhanced === "function") {
                        closeFullScreenQuranReaderEnhanced();
                        event.preventDefault();
                    }
                    break;
            }
        };
        document.addEventListener('keydown', handleKeyDown);
        if (contentArea) {
            let touchStartY = 0;
            let touchEndY = 0;
            const tapThreshold = 50; // Min pixels to be considered a swipe/meaningful tap movement
            const screenPortionThreshold = 0.33; // Tap in top 33% or bottom 33%
            const handleTouchStart = (event) => {
                if (event.touches.length === 1) { // Single touch
                    touchStartY = event.touches[0].clientY;
                }
            };
            const handleTouchEnd = (event) => {
                if (event.changedTouches.length === 1) { // Single touch ended
                    touchEndY = event.changedTouches[0].clientY;
                    const verticalDiff = touchEndY - touchStartY;
                    const screenHeight = window.innerHeight; // or contentArea.clientHeight
                    if (Math.abs(verticalDiff) > tapThreshold * 1.5) { // If it was a noticeable swipe
                        return;
                    }
                    const tapYPosition = touchStartY; // Where the tap initiated
                    if (tapYPosition < screenHeight * screenPortionThreshold) {
                        if (typeof goToPrevEnhanced === "function") {
                            goToPrevEnhanced();
                        }
                    } else if (tapYPosition > screenHeight * (1 - screenPortionThreshold)) {
                        if (typeof goToNextEnhanced === "function") {
                            goToNextEnhanced();
                        }
                    } else {
                    }
                }
            };
            const handleContentClickForTap = (event) => {
                if (event.target.closest('.fsReaderAyah, button, select, input, a')) {
                    return; // Don't interpret clicks on interactive elements as page turns
                }
                const settingsPanel = document.getElementById('fsReaderSettingsPanel');
                const indexPanel = document.getElementById('fsReaderIndexPanel');
                if ((settingsPanel && settingsPanel.style.display === 'block') ||
                    (indexPanel && indexPanel.style.display === 'block')) {
                    return; // Don't trigger tap navigation if a panel is open
                }
                const contentRect = contentArea.getBoundingClientRect();
                const clickYRelativeToContent = event.clientY - contentRect.top;
                const contentHeight = contentArea.clientHeight;
                if (clickYRelativeToContent < contentHeight * screenPortionThreshold) {
                    if (typeof goToPrevEnhanced === "function") {
                        goToPrevEnhanced();
                    }
                } else if (clickYRelativeToContent > contentHeight * (1 - screenPortionThreshold)) {
                    if (typeof goToNextEnhanced === "function") {
                        goToNextEnhanced();
                    }
                }
            };
            contentArea.addEventListener('touchstart', handleTouchStart, { passive: true });
            contentArea.addEventListener('touchend', handleTouchEnd, { passive: true });
            contentArea.addEventListener('click', handleContentClickForTap);
            readerOverlay.readerKeyDownHandler = handleKeyDown;
            contentArea.readerTouchStartHandler = handleTouchStart;
            contentArea.readerTouchEndHandler = handleTouchEnd;
            contentArea.readerContentClickHandler = handleContentClickForTap;
        }
    }
    let ayahTypingTargetText = "";
    let ayahTypingTargetCleanText = ""; // Target text without diacritics
    let ayahTypingTargetSpans = [];
    let ayahTypingCurrentIndex = 0; // Index in the TARGET Ayah
    let ayahTypingErrors = 0;
    let ayahTypingCorrectStrokes = 0;
    let ayahTypingTotalStrokesAttemptedByPlayer = 0; // How many chars player tried to type for current Ayah
    let ayahTypingStartTime = 0;
    let ayahTypingTimerInterval = null;
    let ayahTypingGameActive = false;
    let ayahTypingDiacriticMode = 'ignore'; // 'ignore' or 'strict'
    let ayahTypingSessionHighScoreWPM = 0;
    let ayahTypingSessionHighScoreAcc = 0;
    let ayahTypingCurrentAyahData = null; // To store {surah, ayah} for audio
    function normalizeArabicCharForTyping(char) {
        if (!char) return "";
        let nfdNormalizedChar = char.normalize('NFD');
        let marksRemovedChar = nfdNormalizedChar.replace(/\p{M}/gu, '');
        let tatweelRemovedChar = marksRemovedChar.replace(/\u0640/g, '');
        let letterNormalizedChar = tatweelRemovedChar;
        letterNormalizedChar = letterNormalizedChar.replace(/[آأإٱ]/g, 'ا');
        letterNormalizedChar = letterNormalizedChar.replace(/[ؤو]/g, 'و');
        letterNormalizedChar = letterNormalizedChar.replace(/[ىیي]/g, 'ي');
        letterNormalizedChar = letterNormalizedChar.replace(/[ہھةۃه]/g, 'ه'); // Teh Marbuta, HEH DOACHASHMEE, HEH GOAL to standard HEH
        letterNormalizedChar = letterNormalizedChar.replace(/[كک]/g, 'ك');
        letterNormalizedChar = letterNormalizedChar.replace(/[لٰل]/g, 'ل'); // Lam with Hamza to standard Lam
        letterNormalizedChar = letterNormalizedChar.replace(/[ڤ]/g, 'ف'); // V to F
        letterNormalizedChar = letterNormalizedChar.replace(/[مٰم]/g, 'م'); // V to F
        return letterNormalizedChar;
    }
    function injectAyahTypingGameCSS_Engine() {
        const cssId = "ayahTypingGameStylesEngine";
        if (document.getElementById(cssId)) return;
        const styles = `
        .ayah-typing-game-area { display: flex; flex-direction: column; align-items: center; width: 100%; padding: 10px; height: 100%; }
        .typing-options-bar { display: flex; justify-content: space-around; align-items: center; width: 100%; max-width: 600px; margin-bottom: 15px; padding: 8px; background-color: var(--color-bg-secondary); border-radius: var(--border-radius); }
        .typing-options-bar label { font-size: 0.9em; display:flex; align-items:center; gap: 5px;}
        .typing-options-bar select, .typing-options-bar button { font-size: 0.9em; padding: 5px 8px; }
        #ayahDisplayContainer_Engine {
            font-family: var(--font-arabic);
            font-size: 2.2rem; /* Will be adjusted by main reader settings */
            line-height: 2.5;
            direction: rtl;
            text-align: right;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            width: 100%;
            max-width: 90%; /* Or set a fixed max-width like 700px */
            min-height: 100px; /* Adjust based on typical ayah length */
            overflow-wrap: break-word;
        }
        #ayahDisplayContainer_Engine span {
            transition: background-color 0.1s, color 0.1s;
            padding: 0; /* === MODIFIED: Removed padding === */
            letter-spacing: normal; 
        }
        #ayahDisplayContainer_Engine .char-correct { background-color: #d4edda; color: #155724; } /* Light green */
        #ayahDisplayContainer_Engine .char-incorrect { background-color: #f8d7da; color: #721c24; } /* Light red */
        #ayahDisplayContainer_Engine .char-current { background-color: var(--color-highlight); box-shadow: 0 0 0 2px var(--color-accent); }
        #ayahDisplayContainer_Engine .char-pending { color: var(--color-text-secondary); opacity: 0.7; }
        #typingInputArea_Engine {
            font-family: var(--font-arabic);
            font-size: 2rem; /* Match display somewhat */
            direction: rtl;
            text-align: right;
            width: 100%;
            max-width: 90%; /* Match display */
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid var(--color-accent);
            border-radius: var(--border-radius);
            min-height: 60px;
            resize: none; /* Or vertical */
        }
        #typingInputArea_Engine:focus { outline: 2px solid var(--color-accent-dark); }
        .typing-stats-container { display: flex; justify-content: space-around; width: 100%; max-width: 600px; margin-bottom: 15px; font-size: 1.1rem; }
        .typing-stats-container div { background-color: var(--color-bg-secondary); padding: 8px 12px; border-radius: var(--border-radius); text-align: center; }
        .typing-stats-container strong { color: var(--color-accent-dark); display:block; font-size: 1.3em; }
        .typing-controls-area { margin-top: 15px; }
        .typing-controls-area button { margin: 0 5px; }
        .typing-results-area { text-align: center; padding: 20px; }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
    }
    async function startAyahTyping_Engine() {
        activeGame = 'ayahTyping_engine';
        injectAyahTypingGameCSS_Engine(); // Ensure CSS is injected
        const mainGameModal = document.getElementById('quranGameModal');
        const gamePlayArea = document.getElementById('gamePlayArea'); // Get the gamePlayArea
        if (!gamePlayArea) {
            console.error("Ayah Typing: gamePlayArea element not found in the modal!");
            return;
        }
        if (!mainGameModal) {
            console.error("Ayah Typing: Main game modal not found!");
            return;
        }
        mainGameModal.style.display = 'none';
        gamePlayArea.innerHTML = `
        <div class="ayah-typing-game-area">
            <div class="typing-options-bar">
                <label for="diacriticModeSelect_Engine">Diacritics:
                    <select id="diacriticModeSelect_Engine">
                        <option value="ignore">Ignore (Type Base Letters)</option>
                        <option value="strict">Strict (Match Exactly)</option>
                    </select>
                </label>
                <button id="playAyahAudioBtn_Engine" title="Play Ayah Recitation" style="display:none;">🔊</button>
            </div>
            <div id="ayahDisplayContainer_Engine">Press "Start" to load an Ayah.</div>
            <textarea id="typingInputArea_Engine" rows="2" placeholder="ابدأ الكتابة هنا..." disabled></textarea>
            <div class="typing-stats-container">
                <div>Timer: <strong id="typingTimer_Engine">0s</strong></div>
                <div>WPM: <strong id="typingWPM_Engine">0</strong></div>
                <div>Accuracy: <strong id="typingAccuracy_Engine">0%</strong></div>
            </div>
            <div class="typing-controls-area">
                <button id="startTypingGameBtn_Engine">Start</button>
                <button id="resetTypingGameBtn_Engine" style="display:none;">Next Ayah</button>
            </div>
            <div id="typingResultsArea_Engine" class="typing-results-area" style="display:none;"></div>
        </div>
    `;
        const ayahDisplay = document.getElementById('ayahDisplayContainer_Engine');
        if (isFullScreenReaderActive && fullScreenReaderSettings && fullScreenReaderSettings.fontSize) {
            ayahDisplay.style.fontSize = fullScreenReaderSettings.fontSize;
        }
        document.getElementById('startTypingGameBtn_Engine').addEventListener('click', loadNextAyahForTyping_Engine);
        document.getElementById('resetTypingGameBtn_Engine').addEventListener('click', loadNextAyahForTyping_Engine);
        document.getElementById('diacriticModeSelect_Engine').addEventListener('change', (e) => {
            ayahTypingDiacriticMode = e.target.value;
        });
        document.getElementById('playAyahAudioBtn_Engine').addEventListener('click', () => {
            if (ayahTypingCurrentAyahData && typeof playAudioForAyahEnhanced === 'function') {
                playAudioForAyahEnhanced(ayahTypingCurrentAyahData.surah, ayahTypingCurrentAyahData.ayah);
            } else {
                console.warn("Cannot play audio: Ayah data missing or audio player function not available.");
            }
        });
        document.getElementById('typingInputArea_Engine').addEventListener('input', handleTypingInput_Engine);
        ayahTypingSessionHighScoreWPM = parseInt(localStorage.getItem('ayahTypingHighScoreWPM') || '0');
        ayahTypingSessionHighScoreAcc = parseInt(localStorage.getItem('ayahTypingHighScoreAcc') || '0');
        requestAyahTypingFullscreen(gamePlayArea);
    }
    async function loadNextAyahForTyping_Engine() {
        resetTypingGameState_Engine();
        const ayahDisplay = document.getElementById('ayahDisplayContainer_Engine');
        const typingInput = document.getElementById('typingInputArea_Engine');
        ayahDisplay.innerHTML = '<p>Loading new Ayah...</p>';
        typingInput.disabled = true;
        typingInput.value = '';
        document.getElementById('startTypingGameBtn_Engine').style.display = 'none';
        document.getElementById('resetTypingGameBtn_Engine').style.display = 'inline-block';
        document.getElementById('resetTypingGameBtn_Engine').textContent = 'Loading...';
        document.getElementById('resetTypingGameBtn_Engine').disabled = true;
        document.getElementById('playAyahAudioBtn_Engine').style.display = 'none';
        document.getElementById('typingResultsArea_Engine').style.display = 'none';
        try {
            let randomAyahObj;
            let attempts = 0;
            const MIN_CHARS = 15; // Adjusted min characters slightly
            const MAX_CHARS = 180; // Adjusted max characters slightly
            do {
                const randomSurah = Math.floor(Math.random() * 114) + 1;
                const randomAyahNum = Math.floor(Math.random() * (surahAyahCounts[randomSurah] || 1)) + 1;
                console.log(`[loadNextAyahForTyping_Engine] Attempt ${attempts + 1}: Trying S${randomSurah}:A${randomAyahNum}`);
                randomAyahObj = await getData(STORE_QURAN, [randomSurah, randomAyahNum]);
                if (randomAyahObj && randomAyahObj.arabic) {
                    console.log(`[loadNextAyahForTyping_Engine] Fetched Ayah (raw): '${randomAyahObj.arabic}' (Length: ${randomAyahObj.arabic.length})`);
                } else {
                    console.log(`[loadNextAyahForTyping_Engine] Ayah S${randomSurah}:A${randomAyahNum} not found or no Arabic text.`);
                }
                attempts++;
            } while ((!randomAyahObj || !randomAyahObj.arabic || randomAyahObj.arabic.trim().length < MIN_CHARS || randomAyahObj.arabic.trim().length > MAX_CHARS) && attempts < 50);
            if (!randomAyahObj || !randomAyahObj.arabic) {
                const errorMsg = "[loadNextAyahForTyping_Engine] Could not load a suitable Ayah after 50 attempts.";
                console.error(errorMsg);
                ayahDisplay.innerHTML = `<p style="color:red;">${errorMsg}</p>`;
                document.getElementById('startTypingGameBtn_Engine').style.display = 'inline-block';
                document.getElementById('resetTypingGameBtn_Engine').style.display = 'none';
                return;
            }
            ayahTypingCurrentAyahData = { surah: randomAyahObj.surah, ayah: randomAyahObj.ayah };
            ayahTypingTargetText = randomAyahObj.arabic.trim(); // Crucial: Use the trimmed version
            console.log(`[loadNextAyahForTyping_Engine] FINAL ayahTypingTargetText for rendering: '${ayahTypingTargetText}' (Length: ${ayahTypingTargetText.length})`);
            ayahTypingTargetCleanText = normalizeArabicCharForTyping(ayahTypingTargetText); // Normalize the final target text
            console.log(`[loadNextAyahForTyping_Engine] Normalized (Clean) Target Text: '${ayahTypingTargetCleanText}'`);
            renderAyahForTyping_Engine(ayahTypingTargetText); // Render the original (trimmed) text
            typingInput.disabled = false;
            typingInput.placeholder = "ابدأ الكتابة هنا عند الجاهزية";
            setTimeout(() => typingInput.focus(), 100);
            document.getElementById('resetTypingGameBtn_Engine').textContent = 'Next Ayah';
            document.getElementById('resetTypingGameBtn_Engine').disabled = false;
            document.getElementById('playAyahAudioBtn_Engine').style.display = 'inline-block';
        } catch (error) {
            console.error("[loadNextAyahForTyping_Engine] Error loading Ayah for typing:", error);
            ayahDisplay.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
            document.getElementById('startTypingGameBtn_Engine').style.display = 'inline-block';
            document.getElementById('resetTypingGameBtn_Engine').style.display = 'none';
        }
    }
    function renderAyahForTyping_Engine(ayahText) {
        const ayahDisplay = document.getElementById('ayahDisplayContainer_Engine');
        ayahDisplay.innerHTML = '';
        ayahTypingTargetSpans = [];
        for (let i = 0; i < ayahText.length; i++) {
            const charSpan = document.createElement('span');
            charSpan.textContent = ayahText[i];
            charSpan.className = 'char-pending';
            ayahDisplay.appendChild(charSpan);
            ayahTypingTargetSpans.push(charSpan);
        }
        if (ayahTypingTargetSpans.length > 0) {
            ayahTypingTargetSpans[0].classList.add('char-current'); // Highlight first char
        }
    }
    function resetTypingGameState_Engine() {
        if (ayahTypingTimerInterval) clearInterval(ayahTypingTimerInterval);
        ayahTypingGameActive = false;
        ayahTypingCurrentIndex = 0;
        ayahTypingErrors = 0;
        ayahTypingCorrectStrokes = 0;
        ayahTypingTotalStrokesAttemptedByPlayer = 0;
        ayahTypingStartTime = 0;
        ayahTypingTimerInterval = null;
        ayahTypingCurrentAyahData = null;
        document.getElementById('typingTimer_Engine').textContent = "0s";
        document.getElementById('typingWPM_Engine').textContent = "0";
        document.getElementById('typingAccuracy_Engine').textContent = "0%";
        const resultsArea = document.getElementById('typingResultsArea_Engine');
        if (resultsArea) resultsArea.style.display = 'none';
        const typingInput = document.getElementById('typingInputArea_Engine');
        if (typingInput) {
            typingInput.value = '';
            typingInput.disabled = true; // Disable until new Ayah is loaded
        }
    }
    function handleTypingInput_Engine() {
        const typingInput = document.getElementById('typingInputArea_Engine');
        if (!typingInput) { /* ... error handling ... */ return; }
        const userInput = typingInput.value; // What the user has ACTUALLY typed so far
        if (!ayahTypingGameActive && ayahTypingTargetSpans.length > 0 && userInput.length > 0) {
            ayahTypingGameActive = true;
            ayahTypingStartTime = Date.now();
            if (ayahTypingTimerInterval) clearInterval(ayahTypingTimerInterval);
            ayahTypingTimerInterval = setInterval(updateTypingTimer_Engine, 1000);
        }
        if (ayahTypingTargetSpans.length === 0) return;
        let currentEffectiveInputIndex = 0; // Tracks position in userInput
        let MismatchEncountered = false;
        for (let targetIdx = 0; targetIdx < ayahTypingTargetSpans.length; targetIdx++) {
            const span = ayahTypingTargetSpans[targetIdx];
            const targetCharOriginal = ayahTypingTargetText[targetIdx];
            span.className = ''; // Reset classes
            if (MismatchEncountered) { // If a mismatch already happened, all subsequent are pending
                span.classList.add('char-pending');
                continue;
            }
            const normalizedTargetChar = normalizeArabicCharForTyping(targetCharOriginal);
            if (ayahTypingDiacriticMode === 'ignore' && normalizedTargetChar === '') {
                span.classList.add('char-correct'); // Visually mark it as "handled"
                if (targetIdx === userInput.length && currentEffectiveInputIndex === userInput.length) {
                }
                continue; // Move to the next target character
            }
            const userTypedCharOriginal = userInput[currentEffectiveInputIndex];
            if (currentEffectiveInputIndex < userInput.length) { // User has typed a character for this position
                const normalizedUserChar = normalizeArabicCharForTyping(userTypedCharOriginal);
                if (targetIdx === currentEffectiveInputIndex && !MismatchEncountered) { // Log for current comparison point
                    console.log(`[Compare Char TargetIdx #${targetIdx} / InputIdx #${currentEffectiveInputIndex}] TargetOrig: '${targetCharOriginal}', UserTypedOrig: '${userTypedCharOriginal}'`);
                    if (ayahTypingDiacriticMode === 'ignore') {
                        console.log(`    NormTarget: '${normalizedTargetChar}', NormUser: '${normalizedUserChar}'`);
                    }
                }
                if (normalizedUserChar === normalizedTargetChar) {
                    span.classList.add('char-correct');
                } else {
                    if (ayahTypingDiacriticMode === 'ignore' && normalizedTargetChar.trim() === '' && normalizedUserChar.trim() === '') {
                        span.classList.add('char-correct');
                    } else {
                        span.classList.add('char-incorrect');
                        MismatchEncountered = true; // Stop further correct marking
                        if (targetIdx === currentEffectiveInputIndex) {
                            console.log(`    MISMATCH. UserNorm: '${normalizedUserChar}' vs TargetNorm: '${normalizedTargetChar}'`);
                        }
                    }
                }
                currentEffectiveInputIndex++;
            } else { // User hasn't typed up to this base character yet
                if (!MismatchEncountered) { // Only mark as current if no prior mismatch
                    span.classList.add('char-current');
                    MismatchEncountered = true; // From here on, subsequent chars are pending until this 'current' is typed
                } else {
                    span.classList.add('char-pending');
                }
            }
        }
        ayahTypingCurrentIndex = currentEffectiveInputIndex; // This is now the count of BASE characters matched/attempted
        if (ayahTypingGameActive) {
            updateLiveTypingStats_Engine(userInput); // userInput still reflects raw typed data
        }
        let baseTargetLength = 0;
        for (let char of ayahTypingTargetText) {
            if (normalizeArabicCharForTyping(char) !== '') baseTargetLength++;
        }
        if (currentEffectiveInputIndex >= baseTargetLength && !MismatchEncountered && ayahTypingGameActive) {
            endTypingRound_Engine(userInput); // Pass the raw user input for stat calculation
        }
    }
    function updateLiveTypingStats_Engine(currentUserInput) {
        if (!ayahTypingGameActive) {
            document.getElementById('typingWPM_Engine').textContent = "0";
            document.getElementById('typingAccuracy_Engine').textContent = "0%";
            return;
        }
        let liveCorrectChars = 0; // Use local variable for this function's calculations
        let liveErrors = 0;       // Use local variable for this function's calculations
        const typedLength = currentUserInput.length;
        const comparisonLength = Math.min(typedLength, ayahTypingTargetText.length);
        for (let i = 0; i < comparisonLength; i++) {
            const targetOriginal = ayahTypingTargetText[i];
            const userTypedOriginal = currentUserInput[i];
            if (ayahTypingDiacriticMode === 'ignore') {
                if (normalizeArabicCharForTyping(userTypedOriginal) === normalizeArabicCharForTyping(targetOriginal)) {
                    liveCorrectChars++;
                } else {
                    if (targetOriginal.trim() === '' && userTypedOriginal && userTypedOriginal.trim() === '') { // Lenient space
                        liveCorrectChars++;
                    } else {
                        liveErrors++;
                    }
                }
            } else { // 'strict' mode
                if (userTypedOriginal === targetOriginal) {
                    liveCorrectChars++;
                } else {
                    liveErrors++;
                }
            }
        }
        if (typedLength > ayahTypingTargetText.length) {
            liveErrors += (typedLength - ayahTypingTargetText.length);
        }
        ayahTypingCorrectStrokes = liveCorrectChars;
        ayahTypingErrors = liveErrors;
        ayahTypingTotalStrokesAttemptedByPlayer = typedLength;
        const currentTime = Date.now();
        const timeElapsedSeconds = (currentTime - ayahTypingStartTime) / 1000;
        let wpm = 0;
        if (timeElapsedSeconds > 0.5) {
            const wordsTypedCorrectly = liveCorrectChars / 5;
            const minutesElapsed = timeElapsedSeconds / 60;
            wpm = minutesElapsed > 0 ? Math.round(wordsTypedCorrectly / minutesElapsed) : 0;
        }
        let accuracy = 0;
        if (typedLength > 0) {
            accuracy = Math.round((liveCorrectChars / typedLength) * 100);
        }
        if (accuracy < 0) accuracy = 0;
        document.getElementById('typingWPM_Engine').textContent = wpm;
        document.getElementById('typingAccuracy_Engine').textContent = `${accuracy}%`;
    }
    function endTypingRound_Engine(finalUserInput) { // finalUserInput is passed
        if (!ayahTypingGameActive) {
            console.warn("[endTypingRound_Engine] Called when game not active. Ignoring.");
            return;
        }
        ayahTypingGameActive = false; // Set game to inactive
        if (ayahTypingTimerInterval) {
            clearInterval(ayahTypingTimerInterval);
            ayahTypingTimerInterval = null;
        }
        const typingInputEl = document.getElementById('typingInputArea_Engine');
        if (typingInputEl) typingInputEl.disabled = true;
        const timeElapsedSeconds = (Date.now() - ayahTypingStartTime) / 1000;
        console.log(`[endTypingRound_Engine] Time elapsed: ${timeElapsedSeconds.toFixed(2)}s`);
        let finalCorrectStrokes = 0;
        let finalErrors = 0;
        const finalComparisonLength = Math.min(finalUserInput.length, ayahTypingTargetText.length);
        for (let i = 0; i < finalComparisonLength; i++) {
            const targetOriginal = ayahTypingTargetText[i];
            const userTypedOriginal = finalUserInput[i];
            if (ayahTypingDiacriticMode === 'ignore') {
                if (normalizeArabicCharForTyping(userTypedOriginal) === normalizeArabicCharForTyping(targetOriginal)) {
                    finalCorrectStrokes++;
                } else {
                    if (targetOriginal.trim() === '' && userTypedOriginal && userTypedOriginal.trim() === '') { // Lenient space
                        finalCorrectStrokes++;
                    } else {
                        finalErrors++;
                    }
                }
            } else { // 'strict' mode
                if (userTypedOriginal === targetOriginal) {
                    finalCorrectStrokes++;
                } else {
                    finalErrors++;
                }
            }
        }
        console.log(`[endTypingRound_Engine] Final Calculated Correct Strokes: ${finalCorrectStrokes}`);
        console.log(`[endTypingRound_Engine] Final Calculated Errors (within typed length): ${finalErrors}`);
        let finalAccuracy = 0;
        if (finalUserInput.length > 0) { // Avoid division by zero
            finalAccuracy = Math.round((finalCorrectStrokes / finalUserInput.length) * 100);
        }
        finalAccuracy = Math.max(0, Math.min(100, finalAccuracy)); // Clamp between 0 and 100
        console.log(`[endTypingRound_Engine] Final Accuracy: ${finalAccuracy}% (Correct: ${finalCorrectStrokes}, Typed: ${finalUserInput.length})`);
        let finalWPM = 0;
        if (timeElapsedSeconds > 0.5) { // Only calculate if some meaningful time has passed
            const correctlyTypedWords = finalCorrectStrokes / 5; // Standard 5 characters per "word" for WPM
            const minutesElapsed = timeElapsedSeconds / 60;
            finalWPM = minutesElapsed > 0 ? Math.round(correctlyTypedWords / minutesElapsed) : 0;
        }
        finalWPM = Math.max(0, finalWPM); // Ensure WPM is not negative
        console.log(`[endTypingRound_Engine] Final WPM: ${finalWPM}`);
        document.getElementById('typingWPM_Engine').textContent = finalWPM;
        document.getElementById('typingAccuracy_Engine').textContent = `${finalAccuracy}%`;
        document.getElementById('typingTimer_Engine').textContent = `${timeElapsedSeconds.toFixed(1)}s`; // Show final time
        if (finalWPM > ayahTypingSessionHighScoreWPM) {
            ayahTypingSessionHighScoreWPM = finalWPM;
            localStorage.setItem('ayahTypingHighScoreWPM', ayahTypingSessionHighScoreWPM);
        }
        if (finalAccuracy > ayahTypingSessionHighScoreAcc) {
            ayahTypingSessionHighScoreAcc = finalAccuracy;
            localStorage.setItem('ayahTypingHighScoreAcc', ayahTypingSessionHighScoreAcc);
        }
        const resultsArea = document.getElementById('typingResultsArea_Engine');
        resultsArea.innerHTML = `
        <h4>Ayah Complete!</h4>
        <p>Your WPM: ${finalWPM}</p>
        <p>Accuracy: ${finalAccuracy}%</p>
        <p>Correct Characters: ${finalCorrectStrokes} / ${finalUserInput.length} (typed)</p>
        <p>Errors (in what you typed): ${finalErrors}</p>
        <p>Time: ${timeElapsedSeconds.toFixed(1)}s</p>
        <p><em>Session High: ${ayahTypingSessionHighScoreWPM} WPM, ${ayahTypingSessionHighScoreAcc}% Acc</em></p>
    `;
        resultsArea.style.display = 'block';
        const resetButton = document.getElementById('resetTypingGameBtn_Engine');
        if (resetButton) resetButton.focus();
    }
    function updateTypingTimer_Engine() {
        if (!ayahTypingGameActive) return;
        const currentTime = Date.now();
        const timeElapsed = Math.round((currentTime - ayahTypingStartTime) / 1000);
        document.getElementById('typingTimer_Engine').textContent = `${timeElapsed}s`;
    }
    function addAyahTypingGameButtonToModal() {
        const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
        const buttonId = 'startGameAyahTypingEngineBtn';
        if (gameSelectionArea && !document.getElementById(buttonId)) {
            const typingGameButton = document.createElement('button');
            typingGameButton.id = buttonId;
            typingGameButton.className = 'game-select-btn';
            typingGameButton.textContent = 'Ayah Typing Challenge';
            typingGameButton.addEventListener('click', () => {
                const gamePlayArea = document.getElementById('gamePlayArea');
                const gameSelectionArea = document.getElementById('game-selection-area');
                if (gameSelectionArea) gameSelectionArea.style.display = 'none';
                if (gamePlayArea) gamePlayArea.style.display = 'flex';
                setTimeout(() => {
                    startAyahTyping_Engine();
                }, 50); // Small delay, e.g., 50-100ms
            });
            const existingButtons = gameSelectionArea.querySelectorAll('.game-select-btn');
            if (existingButtons.length > 0) {
                existingButtons[existingButtons.length - 1].insertAdjacentElement('afterend', typingGameButton);
            } else {
                const pElement = gameSelectionArea.querySelector('p');
                if (pElement) {
                    pElement.insertAdjacentElement('afterend', typingGameButton);
                } else {
                    gameSelectionArea.appendChild(typingGameButton);
                }
            }
        }
    }
    let ayahTypingGameOriginalParent = null; // To store where gamePlayArea was before fullscreen
    let ayahTypingGameCloseButtonFS = null; // The dedicated close button for fullscreen
    function requestAyahTypingFullscreen(gamePlayAreaElement) {
        if (!gamePlayAreaElement) {
            console.error("requestAyahTypingFullscreen: gamePlayAreaElement is null.");
            return;
        }
        const fullscreenContainer = document.createElement('div');
        fullscreenContainer.id = 'ayahTypingFullscreenContainer';
        fullscreenContainer.style.position = 'fixed';
        fullscreenContainer.style.top = '0';
        fullscreenContainer.style.left = '0';
        fullscreenContainer.style.width = '100vw';
        fullscreenContainer.style.height = '100vh';
        fullscreenContainer.style.backgroundColor = 'var(--color-bg-primary, #e8f5e9)'; // Use your theme's primary bg
        fullscreenContainer.style.zIndex = '20000'; // Very high z-index
        fullscreenContainer.style.display = 'flex';
        fullscreenContainer.style.flexDirection = 'column';
        fullscreenContainer.style.justifyContent = 'center';
        fullscreenContainer.style.alignItems = 'center';
        fullscreenContainer.style.padding = '20px'; // Some padding around the game area
        fullscreenContainer.style.boxSizing = 'border-box';
        ayahTypingGameOriginalParent = gamePlayAreaElement.parentNode;
        fullscreenContainer.appendChild(gamePlayAreaElement); // Move gamePlayArea into our new container
        gamePlayAreaElement.style.width = '100%'; // Or a specific max-width like '90vw', '1200px'
        gamePlayAreaElement.style.height = '100%'; // Or '90vh'
        gamePlayAreaElement.style.maxWidth = '1200px'; // Example constraint
        gamePlayAreaElement.style.maxHeight = '95vh';
        gamePlayAreaElement.style.overflow = 'auto'; // If content overflows
        gamePlayAreaElement.style.backgroundColor = 'var(--color-bg-secondary, #c8e6c9)'; // Content background
        gamePlayAreaElement.style.borderRadius = 'var(--border-radius, 8px)';
        gamePlayAreaElement.style.boxShadow = '0 0 20px rgba(0,0,0,0.2)';
        ayahTypingGameCloseButtonFS = document.createElement('button');
        ayahTypingGameCloseButtonFS.id = 'ayahTypingCloseFullscreenBtn';
        ayahTypingGameCloseButtonFS.textContent = '✕';
        ayahTypingGameCloseButtonFS.style.position = 'absolute';
        ayahTypingGameCloseButtonFS.style.top = '20px';
        ayahTypingGameCloseButtonFS.style.right = '20px';
        ayahTypingGameCloseButtonFS.style.fontSize = '1.8rem';
        ayahTypingGameCloseButtonFS.style.padding = '5px 12px';
        ayahTypingGameCloseButtonFS.style.backgroundColor = 'var(--color-error, #ef5350)';
        ayahTypingGameCloseButtonFS.style.color = 'white';
        ayahTypingGameCloseButtonFS.style.border = 'none';
        ayahTypingGameCloseButtonFS.style.borderRadius = '50%';
        ayahTypingGameCloseButtonFS.style.cursor = 'pointer';
        ayahTypingGameCloseButtonFS.style.zIndex = '20001'; // Above gamePlayArea
        ayahTypingGameCloseButtonFS.title = "Exit Fullscreen Typing (Esc)";
        ayahTypingGameCloseButtonFS.onclick = exitAyahTypingFullscreen;
        fullscreenContainer.appendChild(ayahTypingGameCloseButtonFS);
        document.body.appendChild(fullscreenContainer);
        document.body.style.overflow = 'hidden'; // Prevent body scroll
        if (fullscreenContainer.requestFullscreen) {
            fullscreenContainer.requestFullscreen().catch(err => {
                console.warn(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        } else if (fullscreenContainer.webkitRequestFullscreen) { /* Safari */
            fullscreenContainer.webkitRequestFullscreen();
        } else if (fullscreenContainer.msRequestFullscreen) { /* IE11 */
            fullscreenContainer.msRequestFullscreen();
        }
        document.addEventListener('fullscreenchange', handleBrowserFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleBrowserFullscreenChange); // Safari
        document.addEventListener('mozfullscreenchange', handleBrowserFullscreenChange);    // Firefox
        document.addEventListener('MSFullscreenChange', handleBrowserFullscreenChange);   // IE
    }
    function exitAyahTypingFullscreen() {
        const gamePlayAreaElement = document.getElementById('gamePlayArea');
        const fullscreenContainer = document.getElementById('ayahTypingFullscreenContainer');
        if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) { /* Firefox */
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
        }
        cleanupAyahTypingCustomFullscreenOverlay(gamePlayAreaElement, fullscreenContainer);
    }
    function cleanupAyahTypingCustomFullscreenOverlay(gamePlayAreaElement, fullscreenContainer) {
        if (fullscreenContainer && fullscreenContainer.parentNode) {
            if (gamePlayAreaElement && ayahTypingGameOriginalParent) {
                gamePlayAreaElement.style.width = '';
                gamePlayAreaElement.style.height = '';
                gamePlayAreaElement.style.maxWidth = '';
                gamePlayAreaElement.style.maxHeight = '';
                gamePlayAreaElement.style.overflow = '';
                gamePlayAreaElement.style.backgroundColor = ''; // Let original CSS take over
                gamePlayAreaElement.style.borderRadius = '';
                gamePlayAreaElement.style.boxShadow = '';
                ayahTypingGameOriginalParent.appendChild(gamePlayAreaElement);
            }
            fullscreenContainer.parentNode.removeChild(fullscreenContainer);
        }
        if (ayahTypingGameCloseButtonFS && ayahTypingGameCloseButtonFS.parentNode) {
            ayahTypingGameCloseButtonFS.parentNode.removeChild(ayahTypingGameCloseButtonFS);
            ayahTypingGameCloseButtonFS = null;
        }
        document.body.style.overflow = ''; // Restore body scroll
        document.removeEventListener('fullscreenchange', handleBrowserFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', handleBrowserFullscreenChange);
        document.removeEventListener('mozfullscreenchange', handleBrowserFullscreenChange);
        document.removeEventListener('MSFullscreenChange', handleBrowserFullscreenChange);
        activeGame = null; // Mark no game as active
        resetGameUI(); // Your existing function to show game selection
        const mainGameModal = document.getElementById('quranGameModal');
        if (mainGameModal && mainGameModal.style.display === 'none') {
            mainGameModal.style.display = 'flex'; // Or whatever its default display is
        }
    }
    function handleBrowserFullscreenChange() {
        const fullscreenContainer = document.getElementById('ayahTypingFullscreenContainer');
        if (!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
            if (fullscreenContainer) { // If our container exists, it means we initiated this
                console.log("Browser fullscreen exited, cleaning up custom overlay.");
                cleanupAyahTypingCustomFullscreenOverlay(
                    document.getElementById('gamePlayArea'),
                    fullscreenContainer
                );
            }
        }
    }
    function enterSimpleImmersiveView() {
        const gameModalTitleEl = document.getElementById('gameModalTitle');
        if (gameModalTitleEl) {
            originalTitleDisplay_SimpleImmersive = gameModalTitleEl.style.display;
            gameModalTitleEl.style.display = 'none';
        } else {
            console.warn("[SimpleImmersive] gameModalTitleEl not found for hiding.");
        }
        isSimpleImmersiveActive = true;
    }
    function exitSimpleImmersiveView() {
        if (!isSimpleImmersiveActive) return;
        const gameModalTitleEl = document.getElementById('gameModalTitle');
        if (gameModalTitleEl) {
            gameModalTitleEl.style.display = originalTitleDisplay_SimpleImmersive;
        }
        isSimpleImmersiveActive = false;
    }
    let recitationGame_UI = {
        surahSelect: null,
        ayahStartSelect: null,
        ayahEndSelect: null,
        loadAyahButton: null,
        ayahDisplayArea: null,
        referencePlayButton: null,
        recordButton: null,
        analysisFeedbackArea: null,
        recordingStatusText: null,
        currentScoreDisplay: null,
        bestScoreDisplay: null
    };
    let recitationGame_State = {
        currentSurah: 1,
        currentAyahStart: 1,
        currentAyahEnd: 1,
        targetAyahText: "", // Concatenated text if range
        targetAyahWords: [], // Array of words for highlighting
        referenceAudio: null,
        referenceAudioDuration: 0,
        referenceHighlightInterval: null,
        userAudioRecorder: null,
        userAudioChunks: [],
        isRecording: false,
        speechRecognition: null,
        currentReferenceHighlightIndex: 0,
        gameActive: false, // Is the game screen for recitation practice active
        ayahKey: "" // e.g., "s1a1" or "s1a1-a3"
    };
    const STORE_RECITATION_GAME_PROGRESS = 'recitationGameProgress_v1'; // For user scores
    function injectRecitationPracticeGameCSS_Engine() {
        const cssId = "recitationPracticeGameStylesEngine";
        if (document.getElementById(cssId)) return;
        const styles = `
        .recitation-practice-game-area { display: flex; flex-direction: column; align-items: center; width: 100%; padding: 10px; height:100%; box-sizing: border-box; }
        .recitation-controls-bar { display: flex; flex-wrap: wrap; justify-content: space-around; align-items: center; width: 100%; max-width: 700px; margin-bottom: 15px; padding: 10px; background-color: var(--color-bg-secondary); border-radius: var(--border-radius); gap: 10px; }
        .recitation-controls-bar label { font-size: 0.9em; margin-right: 5px;}
        .recitation-controls-bar select, .recitation-controls-bar button { font-size: 0.9em; padding: 6px 10px; }
        #recitationAyahDisplay_Engine {
            font-family: var(--font-arabic); /* Ensure this is your primary Arabic font */
            font-size: 2.4rem; /* Adjust as needed, can be linked to reader settings */
            line-height: 2.8; /* Generous line height for Arabic */
            direction: rtl;
            text-align: right;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            width: 100%;
            max-width: 95%;
            min-height: 150px;
            overflow-y: auto; /* If Ayah is very long */
            cursor: default; /* Indicate it's display text */
        }
        #recitationAyahDisplay_Engine .highlight-word {
            background-color: var(--color-highlight, yellow); /* Theme highlight */
            border-radius: 3px;
            padding: 0 0.1em; /* Slight padding for better visual */
            transition: background-color 0.15s ease-in-out;
        }
        #recitationAyahDisplay_Engine .diff-correct { color: var(--color-success, green); font-weight: bold; }
        #recitationAyahDisplay_Engine .diff-incorrect { color: var(--color-error, red); text-decoration: line-through; }
        #recitationAyahDisplay_Engine .diff-missing { color: var(--color-text-secondary, gray); font-style: italic; }
        .recitation-action-buttons { display: flex; justify-content: center; align-items: center; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; }
        .recitation-action-buttons button { padding: 10px 18px; font-size: 1.1rem; }
        #recordUserAyah_Engine.is-recording { background-color: var(--color-error); }
        #recordingStatus_Engine { font-size: 1em; color: var(--color-text-secondary); min-height: 1.5em; margin-bottom: 10px; text-align: center;}
        #analysisFeedbackArea_Engine { width: 100%; max-width: 95%; padding: 15px; border: 1px dashed var(--color-border); border-radius: var(--border-radius); background-color: var(--color-bg-secondary); min-height: 80px; text-align: center; margin-top:15px; }
        #analysisFeedbackArea_Engine h4 { margin-top: 0; color: var(--color-text-primary); }
        #analysisFeedbackArea_Engine p { margin-bottom: 8px; }
        .recitation-game-scores { text-align: center; margin-top: 15px; font-size: 1rem; }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
        if (db && !db.objectStoreNames.contains(STORE_RECITATION_GAME_PROGRESS)) {
        }
    }
    async function startRecitationPracticeGame_Engine() {
        activeGame = 'recitationPractice_engine';
        injectRecitationPracticeGameCSS_Engine();
        recitationGame_State.gameActive = true;
        const gamePlayArea = document.getElementById('gamePlayArea');
        if (!gamePlayArea) {
            const mainModal = document.getElementById('quranGameModal');
            if (mainModal) mainModal.innerHTML = "<p style='color:red; text-align:center; padding:20px;'>Error: Game area component missing. Cannot start recitation practice.</p>";
            return;
        }
        showGamePlayUI("Recitation Practice");
        const gameHTML = `
        <div class="recitation-practice-game-area">
            <div class="recitation-controls-bar">
                <div>
                    <label for="recitationSurahSelect_Engine">Surah:</label>
                    <select id="recitationSurahSelect_Engine"></select>
                </div>
                <div>
                    <label for="recitationAyahStartSelect_Engine">From Ayah:</label>
                    <select id="recitationAyahStartSelect_Engine"></select>
                </div>
                <div>
                    <label for="recitationAyahEndSelect_Engine">To Ayah (Optional):</label>
                    <select id="recitationAyahEndSelect_Engine"><option value="">Single Ayah</option></select>
                </div>
                <button id="loadRecitationAyah_Engine">Load Ayah(s)</button>
            </div>
            <div id="recitationAyahDisplay_Engine">Select Surah and Ayah, then click "Load Ayah(s)".</div>
            <div class="recitation-action-buttons">
                <button id="playReferenceAyah_Engine" disabled>▶️ Play Reference</button>
                <button id="recordUserAyah_Engine" disabled>🎤 Record My Recitation</button>
            </div>
            <div id="recordingStatus_Engine"></div>
            <div id="analysisFeedbackArea_Engine" style="display:none;">
                <h4>Analysis Feedback</h4>
                <p id="feedbackTextAccuracy_Engine">Accuracy: -</p>
                <p id="feedbackTiming_Engine">Timing: -</p>
                <p id="feedbackRecognizedText_Engine" style="font-family: var(--font-arabic); direction:rtl;"></p>
            </div>
            <div class="recitation-game-scores">
                Current Ayah Accuracy: <strong id="currentRecitationScore_Engine">-</strong>%<br>
                Best Accuracy for this Ayah: <strong id="bestRecitationScore_Engine">-</strong>%
            </div>
        </div>
    `;
        gamePlayArea.innerHTML = gameHTML;
        if (!document.getElementById('feedbackTextAccuracy_Engine')) {
        } else {
        }
        if (!document.getElementById('feedbackRecognizedText_Engine')) {
        }
        if (!document.getElementById('feedbackTiming_Engine')) {
        }
        recitationGame_UI.surahSelect = document.getElementById('recitationSurahSelect_Engine');
        recitationGame_UI.ayahStartSelect = document.getElementById('recitationAyahStartSelect_Engine');
        recitationGame_UI.ayahEndSelect = document.getElementById('recitationAyahEndSelect_Engine');
        recitationGame_UI.loadAyahButton = document.getElementById('loadRecitationAyah_Engine');
        recitationGame_UI.ayahDisplayArea = document.getElementById('recitationAyahDisplay_Engine');
        recitationGame_UI.referencePlayButton = document.getElementById('playReferenceAyah_Engine');
        recitationGame_UI.recordButton = document.getElementById('recordUserAyah_Engine');
        recitationGame_UI.analysisFeedbackArea = document.getElementById('analysisFeedbackArea_Engine');
        recitationGame_UI.recordingStatusText = document.getElementById('recordingStatus_Engine');
        recitationGame_UI.currentScoreDisplay = document.getElementById('currentRecitationScore_Engine');
        recitationGame_UI.bestScoreDisplay = document.getElementById('bestRecitationScore_Engine');
        if (recitationGame_UI.surahSelect) {
            for (let i = 1; i <= 114; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${i}. ${surahNames[i - 1]}`; // Ensure surahNames is globally available
                recitationGame_UI.surahSelect.appendChild(option);
            }
        } else {
        }
        if (recitationGame_UI.surahSelect) recitationGame_UI.surahSelect.addEventListener('change', updateRecitationAyahSelectors_Engine);
        if (recitationGame_UI.ayahStartSelect) recitationGame_UI.ayahStartSelect.addEventListener('change', () => {
            const startAyah = parseInt(recitationGame_UI.ayahStartSelect.value);
            const endAyahSelect = recitationGame_UI.ayahEndSelect;
            if (endAyahSelect) { // Null check
                const currentEndValue = parseInt(endAyahSelect.value);
                if (currentEndValue && currentEndValue < startAyah) {
                    endAyahSelect.value = "";
                }
                populateRecitationAyahEndSelect_Engine(parseInt(recitationGame_UI.surahSelect.value), startAyah);
            }
        });
        if (recitationGame_UI.loadAyahButton) recitationGame_UI.loadAyahButton.addEventListener('click', loadAyahForRecitationPractice_Engine);
        if (recitationGame_UI.referencePlayButton) recitationGame_UI.referencePlayButton.addEventListener('click', playReferenceAudioWithHighlighting_Engine);
        if (recitationGame_UI.recordButton) recitationGame_UI.recordButton.addEventListener('click', toggleUserRecording_Recitation_Engine);
        updateRecitationAyahSelectors_Engine();
        setupSpeechRecognition_Engine();
    }
    function updateRecitationAyahSelectors_Engine() {
        const surahNum = parseInt(recitationGame_UI.surahSelect.value);
        const totalAyahs = surahAyahCounts[surahNum] || 0;
        recitationGame_UI.ayahStartSelect.innerHTML = '';
        for (let i = 1; i <= totalAyahs; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = i;
            recitationGame_UI.ayahStartSelect.appendChild(option);
        }
        populateRecitationAyahEndSelect_Engine(surahNum, 1); // Populate end based on surah and default start ayah 1
    }
    function populateRecitationAyahEndSelect_Engine(surahNum, startAyahNum) {
        const totalAyahs = surahAyahCounts[surahNum] || 0;
        const endSelect = recitationGame_UI.ayahEndSelect;
        const currentEndValue = endSelect.value; // Preserve selection if possible
        endSelect.innerHTML = '<option value="">Single Ayah Mode</option>'; // Default
        for (let i = startAyahNum; i <= totalAyahs; i++) { // Start from the selected startAyahNum
            const option = document.createElement('option');
            option.value = i;
            option.textContent = i;
            endSelect.appendChild(option);
        }
        if (currentEndValue && parseInt(currentEndValue) >= startAyahNum && parseInt(currentEndValue) <= totalAyahs) {
            endSelect.value = currentEndValue;
        } else {
            endSelect.value = ""; // Default to single if previous selection invalid
        }
    }
    async function loadAyahForRecitationPractice_Engine() {
        recitationGame_State.currentSurah = parseInt(recitationGame_UI.surahSelect.value);
        recitationGame_State.currentAyahStart = parseInt(recitationGame_UI.ayahStartSelect.value);
        const endAyahValue = recitationGame_UI.ayahEndSelect.value;
        recitationGame_State.currentAyahEnd = endAyahValue ? parseInt(endAyahValue) : recitationGame_State.currentAyahStart;
        if (recitationGame_State.currentAyahEnd < recitationGame_State.currentAyahStart) {
            alert("End Ayah cannot be before Start Ayah.");
            recitationGame_State.currentAyahEnd = recitationGame_State.currentAyahStart; // Correct it
            recitationGame_UI.ayahEndSelect.value = ""; // Reset UI
        }
        recitationGame_State.targetAyahText = "";
        recitationGame_State.targetAyahWords = [];
        recitationGame_UI.ayahDisplayArea.innerHTML = "Loading...";
        recitationGame_UI.analysisFeedbackArea.style.display = 'none';
        recitationGame_UI.currentScoreDisplay.textContent = '-';
        recitationGame_State.ayahKey = `s${recitationGame_State.currentSurah}a${recitationGame_State.currentAyahStart}`;
        if (recitationGame_State.currentAyahStart !== recitationGame_State.currentAyahEnd) {
            recitationGame_State.ayahKey += `-a${recitationGame_State.currentAyahEnd}`;
        }
        for (let i = recitationGame_State.currentAyahStart; i <= recitationGame_State.currentAyahEnd; i++) {
            const ayahData = await getData(STORE_QURAN, [recitationGame_State.currentSurah, i]);
            if (ayahData && ayahData.arabic) {
                const ayahTextClean = ayahData.arabic.trim();
                recitationGame_State.targetAyahText += ayahTextClean + (i < recitationGame_State.currentAyahEnd ? " " : ""); // Add space if not last ayah in range
                recitationGame_State.targetAyahWords.push(...ayahTextClean.split(/\s+/).filter(w => w.length > 0));
            }
        }
        if (recitationGame_State.targetAyahText) {
            renderLoadedAyahForRecitation_Engine();
            recitationGame_UI.referencePlayButton.disabled = false;
            recitationGame_UI.recordButton.disabled = false;
        } else {
            recitationGame_UI.ayahDisplayArea.innerHTML = "Error loading Ayah text.";
            recitationGame_UI.referencePlayButton.disabled = true;
            recitationGame_UI.recordButton.disabled = true;
        }
        loadBestScore_Recitation_Engine();
    }
    function renderLoadedAyahForRecitation_Engine() {
        recitationGame_UI.ayahDisplayArea.innerHTML = '';
        recitationGame_State.targetAyahWords.forEach(word => {
            const span = document.createElement('span');
            span.textContent = word + " "; // Add space for display separation
            recitationGame_UI.ayahDisplayArea.appendChild(span);
        });
    }
    async function playReferenceAudioWithHighlighting_Engine() {
        if (recitationGame_State.isRecording) {
            alert("Please stop recording first.");
            return;
        }
        stopReferenceAudio_Engine(); // Stop any previous audio
        recitationGame_UI.referencePlayButton.textContent = "🔄 Loading...";
        recitationGame_UI.referencePlayButton.disabled = true;
        recitationGame_UI.recordButton.disabled = true;
        let combinedAudioBufferSources = [];
        let totalDuration = 0;
        try {
            for (let i = recitationGame_State.currentAyahStart; i <= recitationGame_State.currentAyahEnd; i++) {
                const surahPadded = String(recitationGame_State.currentSurah).padStart(3, '0');
                const ayahPadded = String(i).padStart(3, '0');
                const audioSrcUrl = `https://everyayah.com/data/Alafasy_128kbps/${surahPadded}${ayahPadded}.mp3`;
                const response = await fetch(audioSrcUrl);
                const arrayBuffer = await response.arrayBuffer();
                const tempAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const decodedBuffer = await tempAudioCtx.decodeAudioData(arrayBuffer);
                combinedAudioBufferSources.push({ src: audioSrcUrl, duration: decodedBuffer.duration });
                totalDuration += decodedBuffer.duration;
                await tempAudioCtx.close(); // Close temporary context
            }
        } catch (error) {
            console.error("Error fetching reference audio segment durations:", error);
            recitationGame_UI.ayahDisplayArea.innerHTML = "Error loading reference audio data.";
            recitationGame_UI.referencePlayButton.textContent = "▶️ Play Reference";
            recitationGame_UI.referencePlayButton.disabled = false;
            recitationGame_UI.recordButton.disabled = false;
            return;
        }
        recitationGame_State.referenceAudioDuration = totalDuration;
        recitationGame_State.currentReferenceHighlightIndex = 0;
        recitationGame_State.referenceAudio = new Audio();
        let currentSegmentIndex = 0;
        const playNextSegment = () => {
            if (currentSegmentIndex >= combinedAudioBufferSources.length) {
                stopReferenceAudio_Engine();
                return;
            }
            recitationGame_State.referenceAudio.src = combinedAudioBufferSources[currentSegmentIndex].src;
            recitationGame_State.referenceAudio.play().catch(e => {
                console.error("Error playing segment:", e);
                stopReferenceAudio_Engine();
            });
            currentSegmentIndex++;
        };
        recitationGame_State.referenceAudio.onended = playNextSegment;
        recitationGame_State.referenceAudio.onerror = () => {
            console.error("Error with reference audio playback.");
            stopReferenceAudio_Engine();
        };
        playNextSegment(); // Start playing the first segment
        const wordsToHighlight = recitationGame_UI.ayahDisplayArea.querySelectorAll('span');
        if (wordsToHighlight.length > 0 && totalDuration > 0) {
            const timePerWord = totalDuration / wordsToHighlight.length;
            let highlightIdx = 0;
            wordsToHighlight.forEach(s => s.classList.remove('highlight-word')); // Clear previous
            recitationGame_State.referenceHighlightInterval = setInterval(() => {
                if (highlightIdx < wordsToHighlight.length) {
                    if (highlightIdx > 0) wordsToHighlight[highlightIdx - 1].classList.remove('highlight-word');
                    wordsToHighlight[highlightIdx].classList.add('highlight-word');
                    highlightIdx++;
                } else {
                    clearInterval(recitationGame_State.referenceHighlightInterval);
                    if (wordsToHighlight.length > 0) wordsToHighlight[wordsToHighlight.length - 1].classList.remove('highlight-word');
                }
            }, timePerWord * 1000); // Convert timePerWord to ms
        }
        recitationGame_UI.referencePlayButton.textContent = "⏹️ Stop Reference";
        recitationGame_UI.referencePlayButton.disabled = false;
    }
    function stopReferenceAudio_Engine() {
        if (recitationGame_State.referenceAudio) {
            recitationGame_State.referenceAudio.pause();
            recitationGame_State.referenceAudio.src = ""; // Clear source
            recitationGame_State.referenceAudio.onended = null;
            recitationGame_State.referenceAudio.onerror = null;
            recitationGame_State.referenceAudio = null;
        }
        if (recitationGame_State.referenceHighlightInterval) {
            clearInterval(recitationGame_State.referenceHighlightInterval);
            recitationGame_State.referenceHighlightInterval = null;
        }
        recitationGame_UI.ayahDisplayArea.querySelectorAll('span.highlight-word').forEach(s => s.classList.remove('highlight-word'));
        recitationGame_UI.referencePlayButton.textContent = "▶️ Play Reference";
        if (recitationGame_State.targetAyahText) { // Only enable if an Ayah is loaded
            recitationGame_UI.referencePlayButton.disabled = false;
            recitationGame_UI.recordButton.disabled = false;
        }
    }
    async function toggleUserRecording_Recitation_Engine() {
        if (recitationGame_State.isRecording) {
            stopUserRecording_Recitation_Engine();
        } else {
            if (recitationGame_State.referenceAudio && !recitationGame_State.referenceAudio.paused) {
                stopReferenceAudio_Engine();
            }
            await startUserRecording_Recitation_Engine();
        }
    }
    async function startUserRecording_Recitation_Engine() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            alert("Your browser does not support audio recording.");
            return;
        }
        try {
            recitationGame_State.mediaRecordingStopped = false;
            recitationGame_State.speechResultReceived = false;
            recitationGame_State.userTranscript = null;
            recitationGame_State.audioBlobForAnalysis = null;
            recitationGame_State.analysisTriggeredThisRound = false;
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            recitationGame_State.userAudioRecorder = new MediaRecorder(stream);
            recitationGame_State.userAudioChunks = [];
            recitationGame_State.userAudioRecorder.ondataavailable = event => {
                recitationGame_State.userAudioChunks.push(event.data);
            };
            recitationGame_State.userAudioRecorder.onstop = async () => {
                const audioBlob = new Blob(recitationGame_State.userAudioChunks, { type: 'audio/wav' });
                recitationGame_State.audioBlobForAnalysis = audioBlob; // Store the blob
                recitationGame_State.mediaRecordingStopped = true;
                stream.getTracks().forEach(track => track.stop()); // Release microphone
                tryFinalizeAnalysis_Engine(); // Attempt to finalize
            };
            recitationGame_State.userAudioRecorder.start();
            recitationGame_State.isRecording = true;
            recitationGame_UI.recordButton.textContent = "🛑 Stop Recording";
            recitationGame_UI.recordButton.classList.add('is-recording');
            recitationGame_UI.recordingStatusText.textContent = "Recording... Speak now.";
            recitationGame_UI.referencePlayButton.disabled = true; // Disable play reference while recording
            recitationGame_UI.analysisFeedbackArea.style.display = 'none';
            if (recitationGame_State.speechRecognition) {
                try {
                    recitationGame_State.speechRecognition.start();
                } catch (e) {
                    console.warn("Speech recognition start error (possibly already started):", e.message);
                    try {
                        recitationGame_State.speechRecognition.abort(); // Try to abort if it was stuck
                        recitationGame_State.speechRecognition.start();
                    } catch (e2) {
                        console.error("Failed to restart speech recognition:", e2);
                        recitationGame_UI.recordingStatusText.textContent = "Speech recognition error. Try again.";
                    }
                }
            }
        } catch (err) {
            console.error("Error accessing microphone:", err);
            alert("Could not access microphone. Please check permissions. " + err.message);
            recitationGame_UI.recordingStatusText.textContent = "Microphone access denied or error.";
            recitationGame_State.isRecording = false;
            if (recitationGame_UI.recordButton) {
                recitationGame_UI.recordButton.textContent = "🎤 Record My Recitation";
                recitationGame_UI.recordButton.classList.remove('is-recording');
            }
            if (recitationGame_UI.referencePlayButton && recitationGame_State.targetAyahText) {
                recitationGame_UI.referencePlayButton.disabled = false;
            }
        }
    }
    function stopUserRecording_Recitation_Engine() {
        if (recitationGame_State.userAudioRecorder && recitationGame_State.isRecording) {
            recitationGame_State.userAudioRecorder.stop(); // This will trigger MediaRecorder.onstop
            if (recitationGame_State.speechRecognition) {
                recitationGame_State.speechRecognition.stop(); // Explicitly stop SR. Its onend will fire.
            }
            recitationGame_UI.recordingStatusText.textContent = "Processing your recitation...";
        } else {
            recitationGame_State.isRecording = false;
            if (recitationGame_UI.recordButton) {
                recitationGame_UI.recordButton.textContent = "🎤 Record My Recitation";
                recitationGame_UI.recordButton.classList.remove('is-recording');
            }
            if (recitationGame_UI.referencePlayButton && recitationGame_State.targetAyahText) {
                recitationGame_UI.referencePlayButton.disabled = false;
            }
        }
    }
    // Helper function to detect mobile devices
function isMobileDevice() {
    return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
}

function setupSpeechRecognition_Engine() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
        console.warn("Speech Recognition API not supported in this browser.");
        if (recitationGame_UI.recordingStatusText) { // Check if UI element exists
             recitationGame_UI.recordingStatusText.textContent = "Speech recognition not supported by your browser.";
        }
        if (recitationGame_UI.recordButton) recitationGame_UI.recordButton.disabled = true;
        return;
    }

    // Ensure recitationGame_State is initialized if it's not already
    if (typeof recitationGame_State === 'undefined') {
        window.recitationGame_State = {}; // Or initialize it as per your app's structure
    }
    // Ensure recitationGame_UI is initialized if it's not already
    if (typeof recitationGame_UI === 'undefined') {
        window.recitationGame_UI = {}; // Or initialize it as per your app's structure
    }


    recitationGame_State.speechRecognition = new SpeechRecognition();
    recitationGame_State.speechRecognition.lang = 'ar-SA';
    recitationGame_State.speechRecognition.interimResults = true;
    recitationGame_State.speechRecognition.maxAlternatives = 1;

    if (isMobileDevice()) {
        recitationGame_State.speechRecognition.continuous = false; // More stable for mobile, captures single utterance
        console.log("[RecitationPracticeGame] Mobile device detected: Continuous speech recognition OFF.");
    } else {
        recitationGame_State.speechRecognition.continuous = true;  // Keep for desktop experience
        console.log("[RecitationPracticeGame] Desktop device detected: Continuous speech recognition ON.");
    }

    let final_transcript = ''; // To accumulate final results

    recitationGame_State.speechRecognition.onstart = () => {
        final_transcript = ''; // Reset accumulated transcript on new start
        console.log("[RecitationPracticeGame] Speech recognition started.");
        if (recitationGame_UI.recordingStatusText) { // Check UI element
            recitationGame_UI.recordingStatusText.textContent = "Listening...";
        }
    };

    recitationGame_State.speechRecognition.onresult = (event) => {
        let interim_transcript = '';
        for (let i = event.resultIndex; i < event.results.length; ++i) {
            if (event.results[i].isFinal) {
                final_transcript += event.results[i][0].transcript;
            } else {
                interim_transcript += event.results[i][0].transcript;
            }
        }
        // Prioritize final transcript, fallback to interim if continuous=false and it ends quickly
        recitationGame_State.userTranscript = final_transcript.trim() || interim_transcript.trim();
        console.log("[RecitationPracticeGame] Speech interim/final result. Current accumulated transcript:", recitationGame_State.userTranscript);

        // If continuous is false (mobile), and we get a final result, the SR will stop soon.
        // The onend event will handle calling tryFinalizeAnalysis_Engine.
    };

    recitationGame_State.speechRecognition.onerror = (event) => {
        console.error("[RecitationPracticeGame] Speech Recognition Error:", event.error, event.message);
        let errorMsg = "Speech recognition error: " + event.error;
        if (event.error === 'no-speech') {
            errorMsg = "No speech was detected. Please try again.";
        } else if (event.error === 'audio-capture') {
            errorMsg = "Audio capture error. Ensure microphone is working.";
        } else if (event.error === 'not-allowed') {
            errorMsg = "Microphone access not allowed. Please check permissions.";
        } else if (event.error === 'network') {
            errorMsg = "Network error for speech recognition. Check connection.";
        }

        if (recitationGame_UI.recordingStatusText) { // Check UI element
            recitationGame_UI.recordingStatusText.textContent = errorMsg;
        }

        recitationGame_State.userTranscript = final_transcript.trim(); // Use whatever was accumulated
        recitationGame_State.speechResultReceived = true; // Mark as "resulted" (an error is a form of result)

        // If recording was active, the onend event (which fires after error too)
        // will call tryFinalizeAnalysis_Engine.
        // We don't need to call stopUserRecording_Recitation_Engine here directly as SR is already stopping.
    };

    recitationGame_State.speechRecognition.onend = () => {
        console.log("[RecitationPracticeGame] Speech recognition service ended.");
        // Ensure the latest transcript is captured
        if (recitationGame_State.userTranscript === undefined || recitationGame_State.userTranscript.trim() === "") {
             recitationGame_State.userTranscript = final_transcript.trim();
        }

        recitationGame_State.speechResultReceived = true;
        // This is crucial: tryFinalizeAnalysis_Engine will check if media recording also stopped.
        // For continuous=false, this 'onend' will typically fire right after a single 'onresult'.
        // For continuous=true, it fires when recognition.stop() is called or it times out.
        tryFinalizeAnalysis_Engine();
    };
}

    
    function tryFinalizeAnalysis_Engine() {
        console.log(`[RecitationGame] tryFinalizeAnalysis_Engine called. analysisTriggered: ${recitationGame_State.analysisTriggeredThisRound}, mediaStopped: ${recitationGame_State.mediaRecordingStopped}, speechReceived: ${recitationGame_State.speechResultReceived}`);
        if (recitationGame_State.analysisTriggeredThisRound) {
            return; // Analysis already started or completed for this round
        }
        if (recitationGame_State.mediaRecordingStopped && recitationGame_State.speechResultReceived) {
            recitationGame_State.analysisTriggeredThisRound = true;
            const blobToAnalyze = recitationGame_State.audioBlobForAnalysis;
            if (!blobToAnalyze || blobToAnalyze.size === 0) { // Check blob size as well
                console.error("[RecitationGame] tryFinalizeAnalysis_Engine: audioBlobForAnalysis is null or empty. Cannot analyze.");
                if (recitationGame_UI.recordingStatusText) {
                    recitationGame_UI.recordingStatusText.textContent = "Error: Audio data missing or empty.";
                }
                recitationGame_State.analysisTriggeredThisRound = false;
                recitationGame_State.mediaRecordingStopped = false;
                recitationGame_State.speechResultReceived = false;
                if (recitationGame_UI.recordButton) {
                    recitationGame_UI.recordButton.textContent = "🎤 Record My Recitation";
                    recitationGame_UI.recordButton.classList.remove('is-recording');
                }
                recitationGame_State.isRecording = false;
                return;
            }
            if (recitationGame_UI.recordingStatusText) {
                recitationGame_UI.recordingStatusText.textContent = "Processing your recitation...";
            }
            if (recitationGame_UI.recordButton) { // Ensure button is reset visually
                recitationGame_UI.recordButton.textContent = "🎤 Record My Recitation";
                recitationGame_UI.recordButton.classList.remove('is-recording');
            }
            recitationGame_State.isRecording = false; // Mark recording as definitively over
            analyzeUserRecitation_Engine(blobToAnalyze);
        } else {
        }
    }
    async function analyzeUserRecitation_Engine(audioBlob) {
        if (!recitationGame_State.gameActive) {
            console.warn("[RecitationGame] Analysis aborted: game state is not active.");
            if (recitationGame_UI.recordButton) {
                recitationGame_UI.recordButton.textContent = "🎤 Record My Recitation";
                recitationGame_UI.recordButton.classList.remove('is-recording');
            }
            if (recitationGame_UI.recordingStatusText) recitationGame_UI.recordingStatusText.textContent = "";
            return;
        }
        if (recitationGame_UI.recordingStatusText) {
            recitationGame_UI.recordingStatusText.textContent = "Analyzing...";
        } else {
            console.warn("[RecitationGame] analyzeUserRecitation_Engine: recordingStatusText UI element was null.");
        }
        if (recitationGame_UI.analysisFeedbackArea) {
            recitationGame_UI.analysisFeedbackArea.style.display = 'block';
            recitationGame_UI.analysisFeedbackArea.innerHTML = '<h4>Analysis Feedback</h4><p id="feedbackTextAccuracy_Engine">Accuracy: -</p><p id="feedbackTiming_Engine">Timing: -</p><p id="feedbackRecognizedText_Engine" style="font-family: var(--font-arabic); direction:rtl;"></p>';
        } else {
            console.warn("[RecitationGame] analyzeUserRecitation_Engine: analysisFeedbackArea UI element was null.");
        }
        const recognizedText = recitationGame_State.userTranscript || "";
        const targetTextNorm = normalizeArabicForComparison_Engine(recitationGame_State.targetAyahText);
        const recognizedTextNorm = normalizeArabicForComparison_Engine(recognizedText);
        const { accuracy, diffHTML } = calculateTextAccuracyAndDiff_Engine(targetTextNorm, recognizedTextNorm);
        console.log(`[RecitationGame] Calculated Accuracy: ${accuracy}%, Diff HTML generated.`);
        if (recitationGame_UI.currentScoreDisplay) {
            recitationGame_UI.currentScoreDisplay.textContent = `${accuracy.toFixed(0)}`;
        } else {
            console.warn("[RecitationGame] analyzeUserRecitation_Engine: currentScoreDisplay UI element was null.");
        }
        const feedbackTextAccuracyEl = document.getElementById('feedbackTextAccuracy_Engine');
        if (feedbackTextAccuracyEl) {
            feedbackTextAccuracyEl.textContent = `Text Accuracy: ${accuracy.toFixed(1)}%`;
        } else {
            console.error("[RecitationGame] FAILED to find feedbackTextAccuracy_Engine for update.");
        }
        const feedbackRecognizedEl = document.getElementById('feedbackRecognizedText_Engine');
        if (feedbackRecognizedEl) {
            if (recognizedTextNorm) {
                feedbackRecognizedEl.innerHTML = `Recognized (Normalized): ${recognizedTextNorm} <hr> Target (Normalized): ${targetTextNorm} <hr> Visual Diff (what you said vs target):<br>${diffHTML}`;
            } else {
                feedbackRecognizedEl.innerHTML = "Could not recognize speech clearly or speech was empty. <hr> Target (Normalized): " + targetTextNorm;
            }
        } else {
            console.error("[RecitationGame] FAILED to find feedbackRecognizedText_Engine for update.");
        }
        let timingFeedback = "Timing: N/A"; // Default
        if (recitationGame_State.referenceAudioDuration > 0 && audioBlob && audioBlob.size > 100) { // Min blob size check
            const getUserDurationPromise = new Promise((resolve, reject) => {
                const tempUserAudio = new Audio();
                const timeoutDuration = 7000; // 7 seconds timeout
                const timer = setTimeout(() => {
                    console.warn("[RecitationGame] getUserDuration: Timeout (7s) waiting for onloadedmetadata.");
                    if (tempUserAudio.src && tempUserAudio.src.startsWith('blob:')) { URL.revokeObjectURL(tempUserAudio.src); }
                    tempUserAudio.onloadedmetadata = null;
                    tempUserAudio.onerror = null;
                    reject(new Error("Timeout loading user audio metadata."));
                }, timeoutDuration);
                tempUserAudio.onloadedmetadata = () => {
                    clearTimeout(timer);
                    const duration = tempUserAudio.duration;
                    if (tempUserAudio.src && tempUserAudio.src.startsWith('blob:')) { URL.revokeObjectURL(tempUserAudio.src); }
                    if (duration === Infinity || isNaN(duration) || duration <= 0) { // also check for duration <= 0
                        reject(new Error(`Audio duration reported as ${duration}.`));
                    } else {
                        resolve(duration);
                    }
                };
                tempUserAudio.onerror = (e) => {
                    clearTimeout(timer);
                    let errorDetail = e && e.target && e.target.error ? e.target.error.message : 'Unknown audio error';
                    if (e && e.target && e.target.error && e.target.error.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED) {
                        errorDetail = "Audio format not supported by browser or corrupted.";
                    }
                    console.error("[RecitationGame] getUserDuration: Error loading user audio for duration:", errorDetail);
                    if (tempUserAudio.src && tempUserAudio.src.startsWith('blob:')) { URL.revokeObjectURL(tempUserAudio.src); }
                    reject(new Error(`Failed to load user audio metadata: ${errorDetail}`));
                };
                try {
                    if (!audioBlob || audioBlob.size === 0) {
                        clearTimeout(timer);
                        reject(new Error("Audio blob is null or empty."));
                        return;
                    }
                    const userAudioUrl = URL.createObjectURL(audioBlob);
                    tempUserAudio.src = userAudioUrl;
                } catch (urlError) {
                    clearTimeout(timer);
                    console.error("[RecitationGame] getUserDuration: Error creating object URL:", urlError);
                    reject(new Error("Error creating URL for audio blob."));
                }
            });
            try {
                const userDuration = await getUserDurationPromise;
                const diffPercent = ((userDuration - recitationGame_State.referenceAudioDuration) / recitationGame_State.referenceAudioDuration) * 100;
                timingFeedback = `Timing: Your recitation was ${userDuration.toFixed(1)}s. Reference was ${recitationGame_State.referenceAudioDuration.toFixed(1)}s. `;
                if (Math.abs(diffPercent) < 15) timingFeedback += "Very similar!";
                else if (diffPercent > 0) timingFeedback += `(${diffPercent.toFixed(0)}% slower).`;
                else timingFeedback += `(${Math.abs(diffPercent).toFixed(0)}% faster).`;
            } catch (err) {
                console.error("[RecitationGame] Error getting final user duration:", err.message);
                timingFeedback = `Timing: Error determining your audio duration. (${err.message.substring(0, 100)})`;
                if (audioBlob) {
                }
            }
        } else if (recitationGame_State.referenceAudioDuration <= 0) {
        } else {
            timingFeedback = "Timing: N/A (User audio missing or empty).";
            console.warn("[RecitationGame] User audio blob was null or too small for duration calculation. Size:", audioBlob ? audioBlob.size : 'null', "Min required > 100");
        }
        const feedbackTimingEl = document.getElementById('feedbackTiming_Engine');
        if (feedbackTimingEl) {
            feedbackTimingEl.textContent = timingFeedback;
        } else {
            console.error("[RecitationGame] FAILED to find feedbackTiming_Engine for update.");
        }
        if (recitationGame_UI.recordingStatusText) {
            recitationGame_UI.recordingStatusText.textContent = "Analysis complete.";
        }
        saveScore_Recitation_Engine(accuracy);
    }
    function normalizeArabicForComparison_Engine(text) {
        if (!text) return "";
        let str = text;
        str = str.normalize('NFD').replace(/[\u064B-\u065F\u0670\u08D4-\u08E1\u08E3-\u08FF]/g, ''); // More comprehensive diacritic removal
        str = str.replace(/\u0640/g, '');
        str = str.replace(/[إأآٱ]/g, 'ا'); // All Alifs to plain Alif
        str = str.replace(/[ؤ]/g, 'و');   // Waw with Hamza above to plain Waw
        str = str.replace(/[ئ]/g, 'ي');   // Ya with Hamza above to plain Ya (often contextually a Yaa sound)
        str = str.replace(/[ى]/g, 'ي');   // Alif Maqsurah to Yaa
        str = str.replace(/[ة]/g, 'ه');   // Teh Marbuta to Heh (common in spoken informal or for comparison)
        str = str.replace(/[كک]/g, 'ك');  // Persian Kaf to Arabic Kaf
        str = str.replace(/[.,!?:;"'()\[\]{}0-9٠-٩]/g, '');
        str = str.replace(/\s+/g, ' ').trim();
        return str;
    }
    function levenshteinDistance_Engine(s1, s2) {
        s1 = s1.toLowerCase(); s2 = s2.toLowerCase();
        const costs = [];
        for (let i = 0; i <= s1.length; i++) {
            let lastValue = i;
            for (let j = 0; j <= s2.length; j++) {
                if (i === 0) costs[j] = j;
                else if (j > 0) {
                    let newValue = costs[j - 1];
                    if (s1[i - 1] !== s2[j - 1]) newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                    costs[j - 1] = lastValue;
                    lastValue = newValue;
                }
            }
            if (i > 0) costs[s2.length] = lastValue;
        }
        return costs[s2.length];
    }
    function normalizeArabicForComparison_Engine(text) {
        if (!text) return "";
        let str = text;
        str = str.normalize('NFD').replace(/[\u064B-\u065F\u0670\u0610-\u061A\u06D6-\u06DC\u06DF-\u06E8\u06EA-\u06ED\u08E4-\u08FF]/g, '');
        str = str.replace(/[أإآٱ]/g, 'ا');
        str = str.replace(/[ى]/g, 'ي'); // Alif Maqsura to Yaa
        str = str.replace(/[ؤ]/g, 'و');
        str = str.replace(/[ة]/g, 'ه');
        str = str.replace(/[ک]/g, 'ك');
        str = str.replace(/\u0640/g, '');
        str = str.replace(/\s+/g, ' ').trim();
        return str;
    }
    function calculateTextAccuracyAndDiff_Engine(targetNormalized, recognizedNormalized) {
        if (!targetNormalized) return { accuracy: 0, diffHTML: "<p>(Target text missing or empty after normalization)</p>" };
        const targetWords = targetNormalized.split(/\s+/).filter(w => w.length > 0);
        const recognizedWords = recognizedNormalized ? recognizedNormalized.split(/\s+/).filter(w => w.length > 0) : [];
        let matches = 0;
        let diffHTML = "";
        const maxLength = Math.max(targetWords.length, recognizedWords.length);
        if (targetWords.length === 0 && recognizedWords.length > 0) {
            recognizedWords.forEach(recWord => {
                diffHTML += `<span class="diff-incorrect">${recWord}</span> `;
            });
            return { accuracy: 0, diffHTML: `(Target was empty) You said: ${diffHTML}` };
        }
        if (targetWords.length === 0 && recognizedWords.length === 0) {
            return { accuracy: 100, diffHTML: "(Both target and recognized are empty)" }; // Or 0, depends on definition
        }
        for (let i = 0; i < maxLength; i++) {
            const targetWord = targetWords[i];
            const recognizedWord = recognizedWords[i];
            if (targetWord && recognizedWord) {
                if (targetWord === recognizedWord) {
                    matches++;
                    diffHTML += `<span class="diff-correct">${recognizedWord}</span> `;
                } else {
                    diffHTML += `<span class="diff-incorrect" title="You said: ${recognizedWord}\nShould be: ${targetWord}">${recognizedWord}</span> `;
                }
            } else if (recognizedWord) { // Extra word in recognized (user said more than target)
                diffHTML += `<span class="diff-incorrect" title="Extra word: ${recognizedWord}">${recognizedWord}</span> `;
            } else if (targetWord) { // Missing word in recognized (user said less than target)
                diffHTML += `<span class="diff-missing" title="Missing: ${targetWord}">(${targetWord})</span> `;
            }
        }
        const accuracy = targetWords.length > 0 ? (matches / targetWords.length) * 100 : (recognizedWords.length === 0 ? 100 : 0);
        const finalAccuracy = Math.max(0, Math.min(100, accuracy));
        return { accuracy: finalAccuracy, diffHTML };
    }
    async function saveScore_Recitation_Engine(accuracy) {
        if (!recitationGame_State.ayahKey) {
            console.warn("saveScore_Recitation_Engine: Ayah key is not set. Cannot save score.");
            return;
        }
        try {
            const key = `recitationPractice_${recitationGame_State.ayahKey}_bestAccuracy`;
            const existingBestAccuracyText = localStorage.getItem(key);
            const existingBestAccuracy = existingBestAccuracyText ? parseFloat(existingBestAccuracyText) : 0;
            const newBestAccuracy = Math.max(existingBestAccuracy, accuracy);
            localStorage.setItem(key, newBestAccuracy.toString());
            localStorage.setItem(`recitationPractice_${recitationGame_State.ayahKey}_lastAttemptDate`, new Date().toISOString());
            localStorage.setItem(`recitationPractice_${recitationGame_State.ayahKey}_lastScore`, accuracy.toString());
            if (recitationGame_UI.bestScoreDisplay) {
                recitationGame_UI.bestScoreDisplay.textContent = `${newBestAccuracy.toFixed(0)}`;
            } else {
                console.warn("saveScore_Recitation_Engine: bestScoreDisplay UI element not found.");
            }
        } catch (error) {
            console.error("Error saving recitation game score to localStorage:", error);
        }
    }
    async function loadBestScore_Recitation_Engine() {
        if (recitationGame_UI.bestScoreDisplay) {
            recitationGame_UI.bestScoreDisplay.textContent = '-'; // Default
        } else {
            console.warn("loadBestScore_Recitation_Engine: bestScoreDisplay UI element not found, cannot set default.");
        }
        if (!recitationGame_State.ayahKey) {
            console.warn("loadBestScore_Recitation_Engine: Ayah key is not set. Cannot load score.");
            return;
        }
        try {
            const key = `recitationPractice_${recitationGame_State.ayahKey}_bestAccuracy`;
            const bestAccuracyText = localStorage.getItem(key);
            const bestAccuracy = bestAccuracyText ? parseFloat(bestAccuracyText) : 0;
            if (recitationGame_UI.bestScoreDisplay) {
                recitationGame_UI.bestScoreDisplay.textContent = `${bestAccuracy.toFixed(0)}`;
            }
        } catch (error) {
            console.error("Error loading best recitation game score from localStorage:", error);
        }
    }
    function addRecitationPracticeGameButtonToModal() {
        const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
        const buttonId = 'startRecitationPracticeGameBtn';
        if (gameSelectionArea && !document.getElementById(buttonId)) {
            const recitationGameButton = document.createElement('button');
            recitationGameButton.id = buttonId;
            recitationGameButton.className = 'game-select-btn';
            recitationGameButton.textContent = 'Recitation Practice';
            recitationGameButton.addEventListener('click', startRecitationPracticeGame_Engine);
            const existingButtons = gameSelectionArea.querySelectorAll('.game-select-btn');
            if (existingButtons.length > 0) {
                existingButtons[existingButtons.length - 1].insertAdjacentElement('afterend', recitationGameButton);
            } else {
                const pElement = gameSelectionArea.querySelector('p');
                if (pElement) pElement.insertAdjacentElement('afterend', recitationGameButton);
                else gameSelectionArea.appendChild(recitationGameButton);
            }
        }
    }
    if (document.getElementById('quranGameModal')) {
        addRecitationPracticeGameButtonToModal();
    } else {
        const observer = new MutationObserver((mutationsList, obs) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'childList') {
                    const modal = document.getElementById('quranGameModal');
                    if (modal) {
                        addRecitationPracticeGameButtonToModal();
                        obs.disconnect(); // Stop observing once added
                        return;
                    }
                }
            }
        });
        observer.observe(document.body, { childList: true, subtree: true });
    }
    const mainGameModalForRecitationCleanup = document.getElementById('quranGameModal');
    if (mainGameModalForRecitationCleanup) {
        const originalCloseHandler = () => { // Assuming you have similar logic in your main game modal
            if (recitationGame_State.gameActive) {
                stopReferenceAudio_Engine();
                if (recitationGame_State.isRecording) stopUserRecording_Recitation_Engine();
                if (recitationGame_State.speechRecognition) recitationGame_State.speechRecognition.abort();
                recitationGame_State.gameActive = false;
                console.log("Recitation practice game state reset due to modal close.");
            }
        };
        const gameModalCloseBtn = mainGameModalForRecitationCleanup.querySelector('.game-close-button');
        if (gameModalCloseBtn) {
            gameModalCloseBtn.addEventListener('click', () => {
                if (recitationGame_State.gameActive) {
                    stopReferenceAudio_Engine();
                    if (recitationGame_State.isRecording && recitationGame_State.userAudioRecorder) {
                        recitationGame_State.userAudioRecorder.stop(); // Will try to process
                    }
                    if (recitationGame_State.speechRecognition) recitationGame_State.speechRecognition.abort();
                    recitationGame_State.gameActive = false;
                    recitationGame_State.isRecording = false;
                }
            });
        }
    }
    (function () {
        const GAME_MODAL_LAUNCH_BUTTON_ID = 'openGamesModalBtn';
        const TARGET_ELEMENT_FOR_FULLSCREEN_ID = 'quranGameModal'; // The modal itself
        const INITIALIZATION_DELAY_MS = 300; // Delay after window load to find the button
        function requestFullscreenForElement(elementId) {
            const targetElement = document.getElementById(elementId);
            if (!targetElement) {
                console.error(`Fullscreen Targeter: Element with ID "${elementId}" not found. Cannot go fullscreen.`);
                return;
            }
            if (targetElement.style.display === 'none' || getComputedStyle(targetElement).display === 'none') {
            }
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                return;
            }
            if (targetElement.requestFullscreen) {
                targetElement.requestFullscreen().catch(err => console.warn("Fullscreen Targeter: Fullscreen request failed:", err.message, err.name));
            } else if (targetElement.webkitRequestFullscreen) { // Safari
                targetElement.webkitRequestFullscreen().catch(err => console.warn("Fullscreen Targeter: Fullscreen request failed (webkit):", err.message, err.name));
            } else if (targetElement.mozRequestFullScreen) { // Older Firefox
                targetElement.mozRequestFullScreen(); // Note: Older Firefox API might not return a Promise
            } else if (targetElement.msRequestFullscreen) { // IE11
                targetElement.msRequestFullscreen();
            } else {
            }
        }
        function setupLaunchButtonListenerForFullscreen() {
            const launchButton = document.getElementById(GAME_MODAL_LAUNCH_BUTTON_ID);
            if (launchButton) {
                launchButton.addEventListener('click', (event) => {
                    setTimeout(() => {
                        requestFullscreenForElement(TARGET_ELEMENT_FOR_FULLSCREEN_ID);
                    }, 200); // 50ms delay, adjust if needed for your modal's display logic
                });
            } else {
            }
        }
        window.addEventListener('load', () => {
            setTimeout(() => {
                setupLaunchButtonListenerForFullscreen();
            }, INITIALIZATION_DELAY_MS);
        });
        function logFullscreenExit(event) {
            if (!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
            }
        }
        document.addEventListener('fullscreenchange', logFullscreenExit);
        document.addEventListener('webkitfullscreenchange', logFullscreenExit);
        document.addEventListener('mozfullscreenchange', logFullscreenExit);
        document.addEventListener('MSFullscreenChange', logFullscreenExit);
    })();
    (function () { // IIFE to keep it self-contained
        const READER_LAUNCH_BUTTON_ID = 'launchFullScreenReaderBtnEnhanced';
        const READER_OVERLAY_ID = 'fullScreenReaderOverlay';
        const INITIALIZATION_DELAY_MS = 500; // Increased slightly for safety
        const FULLSCREEN_REQUEST_DELAY_MS = 200; // Delay to wait for overlay creation
        function requestFullscreenForReaderOverlay(elementId) {
            const targetElement = document.getElementById(elementId);
            if (!targetElement) {
                console.error(`Reader FS Overlay: Element with ID "${elementId}" not found. Cannot go fullscreen.`);
                return;
            }
            if (targetElement.style.display === 'none' || getComputedStyle(targetElement).display === 'none') {
                console.warn(`Reader FS Overlay: Target overlay "${elementId}" is not visible. Fullscreen might not work as expected. Ensure launchFullScreenQuranReaderEnhanced() makes it visible.`);
            }
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                console.log("Reader FS Overlay: Already in browser fullscreen mode with some element. Will not re-request for overlay.");
                return;
            }
            if (targetElement.requestFullscreen) {
                targetElement.requestFullscreen().catch(err => console.warn("Reader FS Overlay: Fullscreen request failed:", err.message, err.name));
            } else if (targetElement.webkitRequestFullscreen) { // Safari
                targetElement.webkitRequestFullscreen().catch(err => console.warn("Reader FS Overlay: Fullscreen request failed (webkit):", err.message, err.name));
            } else if (targetElement.mozRequestFullScreen) { // Older Firefox
                targetElement.mozRequestFullScreen();
            } else if (targetElement.msRequestFullscreen) { // IE11
                targetElement.msRequestFullscreen();
            } else {
                console.warn(`Reader FS Overlay: Browser Fullscreen API not supported for the element "${elementId}".`);
            }
        }
        function setupReaderFullscreenLaunchListener() {
            const launchButton = document.getElementById(READER_LAUNCH_BUTTON_ID);
            if (launchButton) {
                launchButton.addEventListener('click', () => {
                    setTimeout(() => {
                        requestFullscreenForReaderOverlay(READER_OVERLAY_ID);
                    }, FULLSCREEN_REQUEST_DELAY_MS);
                });
            } else {
            }
        }
        window.addEventListener('load', () => {
            setTimeout(() => {
                setupReaderFullscreenLaunchListener();
            }, INITIALIZATION_DELAY_MS);
        });
        function logReaderFullscreenExit(event) {
            const readerOverlayElement = document.getElementById(READER_OVERLAY_ID);
            if (!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
            }
        }
        document.addEventListener('fullscreenchange', logReaderFullscreenExit);
        document.addEventListener('webkitfullscreenchange', logReaderFullscreenExit);
        document.addEventListener('mozfullscreenchange', logReaderFullscreenExit);
        document.addEventListener('MSFullscreenChange', logReaderFullscreenExit);
    })();
    let currentReportingUserData = null; // DECLARED GLOBALLY (or top of this script block) and INITIALIZED
    function injectReportingModuleStyles_Enhanced() {
        const cssId = "reportingModuleStylesEnhanced";
        if (document.getElementById(cssId)) return;
        const styles = `
        /* Existing Reporting Styles (assumed from previous response, slightly condensed) */
        .reporting-dashboard { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 25px; padding: 15px; background-color: var(--color-bg-secondary); border-radius: var(--border-radius); }
        .dashboard-card { background-color: var(--color-bg-primary); padding: 15px; border-radius: var(--border-radius); box-shadow: 0 1px 3px var(--color-shadow); text-align: center; }
        .dashboard-card h4 { margin-top: 0; margin-bottom: 8px; color: var(--color-text-secondary); font-size: 1.1em; }
        .dashboard-card .stat-value { font-size: 1.8em; font-weight: bold; color: var(--color-accent-dark); display: block; }
        .reporting-filters-container { margin-bottom: 20px; padding: 15px; background-color: var(--color-bg-secondary); border-radius: var(--border-radius); }
        .reporting-filters-container h3 { margin-top:0; margin-bottom: 10px; }
        .reporting-filters-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px; align-items: end; }
        .reporting-filters-grid label { font-size: 0.9em; margin-bottom: 3px; }
        .reporting-filters-grid select, .reporting-filters-grid input[type="date"], .reporting-filters-grid input[type="text"] { width: 100%; max-width: none; }
        .reporting-quick-date-filters { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; margin-bottom: 10px; }
        .reporting-quick-date-filters button { padding: 6px 10px; font-size: 0.85em; background-color: var(--color-accent-dark); flex-grow:1; min-width: 80px;}
        .reporting-quick-date-filters button:hover { background-color: var(--color-accent); }
        .reporting-content-area { margin-top: 20px; }
        .report-section { margin-bottom: 25px; padding: 15px; background-color: var(--color-bg-primary); border: 1px solid var(--color-border); border-radius: var(--border-radius); }
        .report-section h4 { margin-top: 0; margin-bottom: 10px; color: var(--color-text-secondary); border-bottom: 1px solid var(--color-border); padding-bottom: 5px; }
        .report-list { list-style: none; padding: 0; }
        .report-list li { padding: 8px 0; border-bottom: 1px dotted var(--color-border); font-size: 0.95em; }
        .report-list li:last-child { border-bottom: none; }
        .report-list .item-ref { font-weight: bold; color: var(--color-accent-dark); }
        .report-list .item-date { font-size: 0.9em; color: var(--color-text-secondary); }
        .report-list .item-notes { display: block; font-style: italic; color: var(--color-text-secondary); margin-top: 3px; padding-left: 10px; font-size: 0.9em; }
        .report-list .item-surah-ayah { cursor: pointer; text-decoration: underline; }
        .report-list .item-surah-ayah:hover { color: var(--color-accent); }
        .simple-bar-chart-container { padding:10px; border: 1px solid var(--color-border); border-radius: var(--border-radius); background-color: var(--color-bg-secondary); }
        .bar-chart-title { text-align:center; font-weight:bold; margin-bottom:10px; color:var(--color-text-secondary); }
        .bar-chart { display: flex; align-items: flex-end; height: 200px; border-bottom: 1px solid var(--color-text-secondary); padding-bottom: 5px; gap: 2px; }
        .bar-chart .bar { flex-grow: 1; background-color: var(--color-accent); text-align: center; position: relative; min-width: 20px; border-radius: 3px 3px 0 0; }
        .bar-chart .bar:hover { background-color: var(--color-accent-dark); }
        .bar-chart .bar .bar-label { position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 0.7em; color: var(--color-text-primary); white-space: nowrap; }
        .bar-chart .bar .bar-value { position: absolute; top: -18px; left: 50%; transform: translateX(-50%); font-size: 0.75em; font-weight: bold; color: var(--color-text-primary); }
        #noReportDataMessage { text-align: center; padding: 20px; font-style: italic; }
        /* Fullscreen Reporting Styles */
        body.body-reporting-fullscreen { overflow: hidden !important; } /* Prevent body scroll */
        body.body-reporting-fullscreen > header,
        body.body-reporting-fullscreen > .container > .sidebar,
        body.body-reporting-fullscreen > .container > .main-content > .section:not(#reporting) {
            display: none !important;
        }
        body.body-reporting-fullscreen > .container {
            padding: 0 !important;
            margin: 0 !important;
            max-width: 100% !important;
            height: 100vh;
            display: flex; /* Ensure container takes full height */
            flex-direction: column;
        }
        body.body-reporting-fullscreen > .container > .main-content {
             padding: 0 !important; margin: 0 !important; height: 100%;
             flex-grow: 1; /* Ensure main-content fills container */
             display: flex; /* Allow reporting section to fill it */
             flex-direction: column;
        }
        #reporting.reporting-fullscreen-active {
            /* Ensure it behaves like a top-level page */
            width: 100%;
            height: 100%;
            overflow-y: auto;
            background-color: var(--color-bg-primary);
            padding: var(--padding-main); 
            box-sizing: border-box;
            display: flex; /* Use flex for internal layout if needed */
            flex-direction: column;
            flex-grow: 1;
        }
        #exitReportFullscreenBtn {
            position: absolute; /* Changed from fixed to be relative to #reporting or its container if #reporting isn't fixed */
            top: 10px; /* Adjusted for padding of #reporting */
            right: 10px; /* Adjusted for padding of #reporting */
            z-index: 1001; 
            padding: 8px 12px;
            background-color: var(--color-error);
            color: white;
            border-radius: var(--border-radius);
            border:none;
            cursor:pointer;
        }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
    }
    function createReportingSectionStructure_Enhanced() {
        const mainContent = document.querySelector('.main-content');
        if (!mainContent || document.getElementById('reporting')) return;
        const reportingSection = document.createElement('section');
        reportingSection.id = 'reporting';
        reportingSection.className = 'section';
        reportingSection.setAttribute('role', 'region');
        reportingSection.setAttribute('aria-labelledby', 'reporting-heading');
        reportingSection.innerHTML = `
        <h2 id="reporting-heading">My Contributions & Progress</h2>
        <!-- Exit button will be prepended by addExitReportFullscreenButton_Enhanced -->
        <div id="reportingDashboard" class="reporting-dashboard">
            <p>Loading dashboard...</p>
        </div>
        <div class="reporting-filters-container">
            <h3>Filter Reports</h3>
            <div class="reporting-quick-date-filters">
                <button data-period="today">Today</button>
                <button data-period="this_week">This Week</button>
                <button data-period="this_month">This Month</button>
                <button data-period="this_year">This Year</button>
                <button data-period="all_time">All Time</button>
            </div>
            <div class="reporting-filters-grid">
                <div>
                    <label for="reportTypeFilter">Report Type:</label>
                    <select id="reportTypeFilter">
                        <option value="all">All My Contributions</option>
                        <option value="tafsir">Personal Tafsir</option>
                        <option value="hifz">Memorization (Hifz)</option>
                        <option value="themes">Thematic Links</option>
                        <option value="roots">Root Word Notes</option>
                        <option value="recitations">Recitation Logs</option>
                    </select>
                </div>
                <div>
                    <label for="reportSurahFilter">Surah:</label>
                    <select id="reportSurahFilter">
                        <option value="">All Surahs</option>
                    </select>
                </div>
                <div>
                    <label for="reportDateFromFilter">Date From:</label>
                    <input type="date" id="reportDateFromFilter">
                </div>
                <div>
                    <label for="reportDateToFilter">Date To:</label>
                    <input type="date" id="reportDateToFilter">
                </div>
                <div>
                    <label for="reportKeywordSearch">Keyword Search (Notes):</label>
                    <input type="text" id="reportKeywordSearch" placeholder="Search in notes...">
                </div>
                <div>
                    <button id="applyReportFiltersBtn" style="width:100%;">Apply Filters</button>
                </div>
            </div>
        </div>
        <div id="reportingContent" class="reporting-content-area">
            <p>Select filters and apply to view reports.</p>
        </div>
    `;
        mainContent.appendChild(reportingSection);
        const surahFilterSelect = document.getElementById('reportSurahFilter');
        if (surahFilterSelect && typeof surahNames !== 'undefined' && surahNames.length > 0) {
            surahNames.forEach((name, index) => {
                const option = document.createElement('option');
                option.value = index + 1;
                option.textContent = `${index + 1}. ${name}`;
                surahFilterSelect.appendChild(option);
            });
        }
    }
    function enterReportingFullscreen() {
        document.body.classList.add('body-reporting-fullscreen');
        const reportingSection = document.getElementById('reporting');
        if (reportingSection) {
            reportingSection.classList.add('reporting-fullscreen-active');
            addExitReportFullscreenButton_Enhanced(); // Add button when entering
            reportingSection.scrollTop = 0;
        }
    }
    function exitReportingFullscreen() {
        document.body.classList.remove('body-reporting-fullscreen');
        const reportingSection = document.getElementById('reporting');
        if (reportingSection) {
            reportingSection.classList.remove('reporting-fullscreen-active');
        }
        removeExitReportFullscreenButton_Enhanced(); // Remove button when exiting
    }
    function addExitReportFullscreenButton_Enhanced() {
        removeExitReportFullscreenButton_Enhanced();
        const reportingSection = document.getElementById('reporting');
        if (!reportingSection) return;
        const btn = document.createElement('button');
        btn.id = 'exitReportFullscreenBtn';
        btn.textContent = 'Exit Fullscreen Report';
        btn.onclick = () => {
            exitReportingFullscreen();
            if (typeof window.showSection_Patched === 'function') window.showSection_Patched('quran');
            else if (typeof window.showSection === 'function') window.showSection('quran');
        };
        reportingSection.insertBefore(btn, reportingSection.firstChild); // Prepend to reporting section
    }
    function removeExitReportFullscreenButton_Enhanced() {
        const btn = document.getElementById('exitReportFullscreenBtn');
        if (btn && btn.parentNode) {
            btn.parentNode.removeChild(btn);
        }
    }
    function getISODateString(date) {
        return date.getFullYear() + '-' +
            ('0' + (date.getMonth() + 1)).slice(-2) + '-' +
            ('0' + date.getDate()).slice(-2);
    }
    function getTodayDateRange_Enhanced() {
        const today = new Date();
        return { start: getISODateString(today), end: getISODateString(today) };
    }
    function getThisWeekDateRange_Enhanced() {
        const today = new Date();
        const dayOfWeek = today.getDay(); // Sunday - 0, Monday - 1, ..., Saturday - 6
        const startDate = new Date(today);
        startDate.setDate(today.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1));
        const endDate = new Date(startDate);
        endDate.setDate(startDate.getDate() + 6); // Sunday of the current week
        return { start: getISODateString(startDate), end: getISODateString(endDate) };
    }
    function getThisMonthDateRange_Enhanced() {
        const today = new Date();
        const y = today.getFullYear();
        const m = today.getMonth();
        const startDate = new Date(y, m, 1);
        const endDate = new Date(y, m + 1, 0);
        return { start: getISODateString(startDate), end: getISODateString(endDate) };
    }
    function getThisYearDateRange_Enhanced() {
        const today = new Date();
        const y = today.getFullYear();
        const startDate = new Date(y, 0, 1);
        const endDate = new Date(y, 11, 31);
        return { start: getISODateString(startDate), end: getISODateString(endDate) };
    }
    function setupReportingFiltersEventListeners_Enhanced(userData) {
        const applyBtn = document.getElementById('applyReportFiltersBtn');
        const dateFromInput = document.getElementById('reportDateFromFilter');
        const dateToInput = document.getElementById('reportDateToFilter');
        if (applyBtn) {
            applyBtn.onclick = () => {
                const filters = {
                    reportType: document.getElementById('reportTypeFilter').value,
                    surah: document.getElementById('reportSurahFilter').value,
                    dateFrom: dateFromInput.value,
                    dateTo: dateToInput.value,
                    keyword: document.getElementById('reportKeywordSearch').value,
                };
                renderReportDetails(userData, filters);
            };
        }
        document.querySelectorAll('.reporting-quick-date-filters button').forEach(button => {
            button.addEventListener('click', () => {
                const period = button.dataset.period;
                let range;
                switch (period) {
                    case 'today': range = getTodayDateRange_Enhanced(); break;
                    case 'this_week': range = getThisWeekDateRange_Enhanced(); break;
                    case 'this_month': range = getThisMonthDateRange_Enhanced(); break;
                    case 'this_year': range = getThisYearDateRange_Enhanced(); break;
                    case 'all_time':
                        dateFromInput.value = '';
                        dateToInput.value = '';
                        if (applyBtn) applyBtn.click();
                        return;
                }
                if (range) {
                    dateFromInput.value = range.start;
                    dateToInput.value = range.end;
                }
                if (applyBtn) applyBtn.click();
            });
        });
    }
    async function loadAllUserDataForReports() {
        if (!db) {
            console.error("DB not available for loading report data.");
            currentReportingUserData = null; // Ensure it's null if DB not ready
            return null;
        }
        try {
            const [
                tafsir, themes, themeAyahs, roots,
                recitations, hifz, quran
            ] = await Promise.all([
                getAllData(STORE_TAFSIR),
                getAllData(STORE_THEMES),
                getAllData(STORE_THEME_AYAHS),
                getAllData(STORE_ROOTS),
                getAllData(STORE_RECITATIONS),
                getAllData(STORE_HIFZ),
                getAllData(STORE_QURAN)
            ]);
            const quranMap = new Map();
            if (quran) {
                quran.forEach(item => quranMap.set(`${item.surah}-${item.ayah}`, item.arabic));
            }
            currentReportingUserData = { tafsir, themes, themeAyahs, roots, recitations, hifz, quranMap };
            return currentReportingUserData;
        } catch (error) {
            console.error("Error fetching all user data for reports:", error);
            currentReportingUserData = null;
            return null;
        }
    }
    function renderReportingDashboard(userData) {
        const dashboardArea = document.getElementById('reportingDashboard');
        if (!dashboardArea || !userData) {
            if (dashboardArea) dashboardArea.innerHTML = "<p>Error loading dashboard data.</p>";
            return;
        }
        const { tafsir, themes, roots, recitations, hifz } = userData;
        const totalTafsir = tafsir ? tafsir.length : 0;
        const totalThemes = themes ? themes.length : 0;
        const totalRootNotes = roots ? roots.filter(r => r.description && r.description.trim() !== '').length : 0;
        const totalRecitations = recitations ? recitations.length : 0;
        const totalHifzAyahs = hifz ? hifz.filter(h => h.status === 'memorized').length : 0;
        const totalHifzInProgress = hifz ? hifz.filter(h => h.status === 'in-progress').length : 0;
        dashboardArea.innerHTML = `
        <div class="dashboard-card"><h4>Personal Tafsir</h4><span class="stat-value">${totalTafsir}</span><span>Ayahs with Notes</span></div>
        <div class="dashboard-card"><h4>Memorized Ayahs</h4><span class="stat-value">${totalHifzAyahs}</span><span>Status: Memorized</span></div>
        <div class="dashboard-card"><h4>Themes Created</h4><span class="stat-value">${totalThemes}</span><span>Custom Themes</span></div>
        <div class="dashboard-card"><h4>Recitation Logs</h4><span class="stat-value">${totalRecitations}</span><span>Listening Sessions</span></div>
        <div class="dashboard-card"><h4>Root Word Notes</h4><span class="stat-value">${totalRootNotes}</span><span>Roots with Descriptions</span></div>
        <div class="dashboard-card"><h4>Hifz In Progress</h4><span class="stat-value">${totalHifzInProgress}</span><span>Ayahs In Progress</span></div>`;
    }
    function renderReportDetails(userData, filters) {
        const contentArea = document.getElementById('reportingContent');
        if (!contentArea || !userData) {
            if (contentArea) contentArea.innerHTML = "<p>Error loading report details.</p>";
            return;
        }
        contentArea.innerHTML = '';
        const reportType = filters.reportType || 'all';
        const filterSurah = filters.surah ? parseInt(filters.surah) : null;
        const dateFrom = filters.dateFrom ? new Date(filters.dateFrom) : null;
        const dateTo = filters.dateTo ? new Date(filters.dateTo) : null;
        if (dateTo) dateTo.setHours(23, 59, 59, 999);
        const keyword = filters.keyword ? filters.keyword.toLowerCase() : null;
        let dataFound = false;
        const createSection = (title, items) => {
            if (items.length === 0) return '';
            dataFound = true;
            let listHTML = '<ul class="report-list">' + items.join('') + '</ul>';
            return `<div class="report-section"><h4>${title}</h4>${listHTML}</div>`;
        };
        const makeAyahClickable = (s, a, txt) => `<span class="item-surah-ayah" data-surah="${s}" data-ayah="${a}" title="Go to S${s}:A${a}">${txt}</span>`;
        if (reportType === 'all' || reportType === 'tafsir') {
            const items = (userData.tafsir || []).filter(t =>
                (!filterSurah || t.surah === filterSurah) &&
                (!keyword || (t.notes && t.notes.toLowerCase().includes(keyword)))
            ).map(t => `<li>${makeAyahClickable(t.surah, t.ayah, `S ${t.surah}:${t.ayah}`)}<span class="item-notes">${(t.notes || '').substring(0, 150)}...</span></li>`);
            contentArea.innerHTML += createSection('Personal Tafsir Notes', items);
        }
        if (reportType === 'all' || reportType === 'hifz') {
            const items = (userData.hifz || []).filter(h =>
                (!filterSurah || h.surah === filterSurah) &&
                (!keyword || (h.notes && h.notes.toLowerCase().includes(keyword)))
            ).map(h => {
                let d = `Status: <span class="hifz-ayah-status status-${h.status}">${h.status.replace('-', ' ')}</span>`;
                if (h.nextReviewDate) d += ` | Next Review: ${h.nextReviewDate}`;
                if (h.notes) d += `<span class="item-notes">${h.notes.substring(0, 100)}...</span>`;
                return `<li>${makeAyahClickable(h.surah, h.ayah, `S ${h.surah}:${h.ayah}`)} - ${d}</li>`;
            });
            contentArea.innerHTML += createSection('Memorization (Hifz) Progress', items);
            if (items.length > 0 && (reportType === 'all' || reportType === 'hifz')) {
                const chartData = Object.entries((userData.hifz || []).filter(h => h.status === 'memorized').reduce((acc, h) => { acc[h.surah] = (acc[h.surah] || 0) + 1; return acc; }, {}))
                    .map(([s, c]) => ({ label: `S${s}`, count: c, fullLabel: `${surahNames[parseInt(s) - 1] || 'S' + s}: ${c} Ayahs` }))
                    .sort((a, b) => parseInt(a.label.substring(1)) - parseInt(b.label.substring(1)));
                if (chartData.length > 0) {
                    const id = 'hifzProgressChart'; contentArea.innerHTML += `<div class="report-section"><h4>Hifz Progress (Memorized)</h4><div id="${id}"></div></div>`;
                    setTimeout(() => createSimpleBarChart(chartData, id, "Ayahs Memorized per Surah", 'count', 'label', 'var(--color-success)'), 0); dataFound = true;
                }
            }
        }
        if (reportType === 'all' || reportType === 'themes') {
            const themeNotes = (userData.themes || []).filter(th => !keyword || (th.name.toLowerCase().includes(keyword) || (th.description && th.description.toLowerCase().includes(keyword))))
                .map(th => `<li>Theme: <span class="item-ref">${th.name}</span><span class="item-notes">${th.description ? th.description.substring(0, 150) + '...' : 'No description.'}</span></li>`);
            contentArea.innerHTML += createSection('Theme Notes & Descriptions', themeNotes);
            const themeLinks = (userData.themeAyahs || []).filter(ta => {
                const theme = userData.themes.find(t => t.id === ta.themeId);
                return (!filterSurah || ta.surah === filterSurah) && (!keyword || (ta.notes && ta.notes.toLowerCase().includes(keyword)) || (theme && theme.name.toLowerCase().includes(keyword)));
            }).map(ta => {
                const theme = userData.themes.find(t => t.id === ta.themeId);
                return `<li>${makeAyahClickable(ta.surah, ta.ayah, `S ${ta.surah}:${ta.ayah}`)} linked to <span class="item-ref">${theme ? theme.name : 'Unknown'}</span>${ta.notes ? `<span class="item-notes">Note: ${ta.notes.substring(0, 100)}...</span>` : ''}</li>`;
            });
            contentArea.innerHTML += createSection('Ayahs Linked to Themes', themeLinks);
        }
        if (reportType === 'all' || reportType === 'roots') {
            const items = (userData.roots || []).filter(r => !keyword || (r.root.toLowerCase().includes(keyword) || (r.description && r.description.toLowerCase().includes(keyword))))
                .map(r => `<li>Root: <span class="item-ref" lang="ar" dir="rtl">${r.root}</span><span class="item-notes">${r.description ? r.description.substring(0, 150) + '...' : 'No notes.'}</span></li>`);
            contentArea.innerHTML += createSection('Root Word Notes', items);
        }
        if (reportType === 'all' || reportType === 'recitations') {
            const filteredRecitationItems = (userData.recitations || [])
                .filter(r => {
                    const recDate = r.date ? new Date(r.date) : null;
                    if (!recDate) return false;
                    if (filterSurah && r.surah !== filterSurah) return false;
                    if (dateFrom && recDate < dateFrom) return false;
                    if (dateTo && recDate > dateTo) return false;
                    if (keyword && ((!r.qari || !r.qari.toLowerCase().includes(keyword)) && (!r.notes || !r.notes.toLowerCase().includes(keyword)))) return false;
                    return true;
                });
            const recitationListItems = filteredRecitationItems
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .map(r => {
                    let ayahCount = 0;
                    if (r.ayahStart && r.ayahEnd) {
                        ayahCount = (r.ayahEnd - r.ayahStart) + 1;
                    } else if (r.ayahStart) { // Single ayah logged
                        ayahCount = 1;
                    } else { // Full Surah assumed if no specific ayahs
                        ayahCount = surahAyahCounts[r.surah] || 0;
                    }
                    const range = r.ayahStart && r.ayahEnd ? `Ayahs ${r.ayahStart}-${r.ayahEnd}` : r.ayahStart ? `Ayah ${r.ayahStart}` : 'Full Surah';
                    return `<li>Surah ${r.surah} (${surahNames[r.surah - 1]}) - ${range} (${ayahCount} Ayah${ayahCount !== 1 ? 's' : ''})
                            <span class="item-date"> - ${r.qari || 'N/A'} on ${r.date || 'N/A'}</span>
                            ${r.notes ? `<span class="item-notes">${r.notes.substring(0, 150)}...</span>` : ''}</li>`;
                });
            contentArea.innerHTML += createSection('Recitation Logs', recitationListItems);
            if (filteredRecitationItems.length > 0) {
                const ayahsRecitedByMonth = {};
                const ayahsRecitedByDay = {};
                filteredRecitationItems.forEach(r => {
                    if (r.date) {
                        let countOfAyahsInLog = 0;
                        if (r.ayahStart && r.ayahEnd) {
                            countOfAyahsInLog = (parseInt(r.ayahEnd) - parseInt(r.ayahStart)) + 1;
                        } else if (r.ayahStart) { // Single ayah logged
                            countOfAyahsInLog = 1;
                        } else { // Full Surah assumed
                            countOfAyahsInLog = surahAyahCounts[r.surah] || 0;
                        }
                        if (countOfAyahsInLog <= 0) return; // Skip if no ayahs calculated
                        const monthYear = new Date(r.date).toLocaleDateString(navigator.language || 'en-US', { year: 'numeric', month: 'short' });
                        ayahsRecitedByMonth[monthYear] = (ayahsRecitedByMonth[monthYear] || 0) + countOfAyahsInLog;
                        const dayKey = getISODateString(new Date(r.date));
                        ayahsRecitedByDay[dayKey] = (ayahsRecitedByDay[dayKey] || 0) + countOfAyahsInLog;
                    }
                });
                const monthlyChartData = Object.entries(ayahsRecitedByMonth)
                    .map(([month, count]) => ({
                        label: month,
                        count: count, // 'count' here means ayahs recited
                        fullLabel: `${month}: ${count} Ayahs Recited`
                    }))
                    .sort((a, b) => new Date(a.label) - new Date(b.label));
                if (monthlyChartData.length > 0) {
                    const monthlyChartContainerId = 'recitationLogsMonthlyChart';
                    let sectionEl = contentArea.querySelector('#recitationLogsMonthlyChartSection');
                    if (!sectionEl) {
                        sectionEl = document.createElement('div');
                        sectionEl.className = 'report-section';
                        sectionEl.id = 'recitationLogsMonthlyChartSection';
                        contentArea.appendChild(sectionEl);
                    }
                    sectionEl.innerHTML = `<h4>Ayahs Recited (Monthly)</h4><div id="${monthlyChartContainerId}"></div>`;
                    setTimeout(() => createSimpleBarChart(monthlyChartData, monthlyChartContainerId, null, 'count', 'label', 'var(--color-accent)'), 0);
                    dataFound = true;
                }
                const dailyChartData = Object.entries(ayahsRecitedByDay)
                    .map(([day, count]) => ({
                        label: new Date(day).toLocaleDateString(navigator.language || 'en-US', { month: 'short', day: 'numeric' }),
                        date: day,
                        count: count, // 'count' here means ayahs recited
                        fullLabel: `${new Date(day).toLocaleDateString(navigator.language || 'en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' })}: ${count} Ayahs Recited`
                    }))
                    .sort((a, b) => new Date(a.date) - new Date(b.date));
                if (dailyChartData.length > 0) {
                    let showDailyChart = true;
                    if (dateFrom && dateTo) {
                        const diffTime = Math.abs(dateTo - dateFrom);
                        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                        if (diffDays > 62) {
                            showDailyChart = false;
                        }
                    } else if (!dateFrom && !dateTo && dailyChartData.length > 62) {
                        showDailyChart = false;
                    }
                    if (showDailyChart) {
                        const dailyChartContainerId = 'recitationLogsDailyChart';
                        let sectionElDaily = contentArea.querySelector('#recitationLogsDailyChartSection');
                        if (!sectionElDaily) {
                            sectionElDaily = document.createElement('div');
                            sectionElDaily.className = 'report-section';
                            sectionElDaily.id = 'recitationLogsDailyChartSection';
                            contentArea.appendChild(sectionElDaily);
                        }
                        sectionElDaily.innerHTML = `<h4>Ayahs Recited (Daily - Filtered Period)</h4><div id="${dailyChartContainerId}"></div>`;
                        setTimeout(() => createSimpleBarChart(dailyChartData, dailyChartContainerId, null, 'count', 'label', 'var(--color-accent-dark)'), 0);
                        dataFound = true;
                    }
                }
            }
        }
        contentArea.querySelectorAll('.item-surah-ayah').forEach(el => el.addEventListener('click', e => {
            const s = parseInt(e.currentTarget.dataset.surah), a = parseInt(e.currentTarget.dataset.ayah);
            if (s && a && typeof loadAyah === 'function' && typeof window.showSection === 'function') { loadAyah(s, a); window.showSection('quran'); }
        }));
        if (!dataFound) contentArea.innerHTML = '<p id="noReportDataMessage">No data matches criteria.</p>';
    }
    function createSimpleBarChart(data, containerId, title, valueKey = 'count', labelKey = 'label', barColor = 'var(--color-accent)') {
        const container = document.getElementById(containerId);
        if (!container) {
            console.error(`Chart container #${containerId} not found.`);
            return;
        }
        container.innerHTML = ''; // Clear previous content like "No data for chart."
        if (!data || data.length === 0) {
            container.innerHTML = "<p>No data to display in chart.</p>";
            return;
        }
        if (title) {
            const titleEl = document.createElement('div');
            titleEl.className = 'bar-chart-title';
            titleEl.textContent = title;
            container.appendChild(titleEl);
        }
        const chartEl = document.createElement('div');
        chartEl.className = 'bar-chart';
        if (data.length > 15) { // Example threshold
            chartEl.style.overflowX = 'auto';
            chartEl.style.minWidth = `${data.length * 30}px`; // Estimate width
        }
        const maxValue = Math.max(...data.map(item => item[valueKey]), 0);
        if (maxValue === 0 && data.every(item => item[valueKey] === 0)) { // Check if all values are strictly zero
            container.innerHTML += "<p>All values are zero for this period.</p>";
            return;
        }
        data.forEach(item => {
            const barWrapper = document.createElement('div');
            barWrapper.className = 'bar';
            const numericValue = Number(item[valueKey]) || 0;
            const percentageHeight = maxValue > 0 ? (numericValue / maxValue) * 100 : 0;
            barWrapper.style.height = `${Math.max(percentageHeight, 5)}%`; // Min height 5% for visibility
            barWrapper.style.backgroundColor = barColor;
            barWrapper.title = item.fullLabel || `${item[labelKey]}: ${numericValue}`;
            const valueSpan = document.createElement('span');
            valueSpan.className = 'bar-value';
            valueSpan.textContent = numericValue; // Display the numeric value
            barWrapper.appendChild(valueSpan);
            const labelSpan = document.createElement('span');
            labelSpan.className = 'bar-label';
            labelSpan.textContent = item[labelKey];
            barWrapper.appendChild(labelSpan);
            chartEl.appendChild(barWrapper);
        });
        container.appendChild(chartEl);
    }
    let reportingModuleInitialized = false;
    function initializeReportingModule_Enhanced() {
        if (reportingModuleInitialized) return;
        createReportingSectionStructure_Enhanced();
        injectReportingModuleStyles_Enhanced();
        const sidebarNav = document.querySelector('.sidebar nav ul');
        const existingReportLink = document.querySelector('a[data-section="reporting"]');
        if (sidebarNav && !existingReportLink) {
            const reportLi = document.createElement('li');
            const reportLink = document.createElement('a');
            reportLink.href = "#reporting";
            reportLink.className = "nav-link";
            reportLink.dataset.section = "reporting";
            reportLink.textContent = "Reporting";
            reportLi.appendChild(reportLink);
            const dataManagementLink = sidebarNav.querySelector('a[data-section="data"]');
            if (dataManagementLink && dataManagementLink.parentElement) {
                sidebarNav.insertBefore(reportLi, dataManagementLink.parentElement);
            } else {
                sidebarNav.appendChild(reportLi);
            }
            reportLink.addEventListener('click', (event) => {
                event.preventDefault();
                if (typeof window.showSection === 'function') {
                    window.showSection('reporting');
                } else {
                    console.error("Global window.showSection function not found for reporting link.");
                }
            });
        }
        reportingModuleInitialized = true;
    }
    async function loadAndDisplayReportData_Enhanced() {
        const reportingContent = document.getElementById('reportingContent');
        const dashboardArea = document.getElementById('reportingDashboard');
        if (dashboardArea) dashboardArea.innerHTML = '<p>Loading dashboard...</p>';
        if (reportingContent) reportingContent.innerHTML = '<p>Loading report data...</p>';
        try {
            await loadAllUserDataForReports();
            if (!currentReportingUserData) {
                if (dashboardArea) dashboardArea.innerHTML = "<p>Failed to load data for dashboard.</p>";
                if (reportingContent) reportingContent.innerHTML = "<p>Failed to load report data. Check console for errors.</p>";
                return;
            }
            renderReportingDashboard(currentReportingUserData);
            renderReportDetails(currentReportingUserData, { reportType: 'all' });
            setupReportingFiltersEventListeners_Enhanced(currentReportingUserData);
        } catch (error) {
            console.error("Error loading/displaying report data:", error);
            if (dashboardArea) dashboardArea.innerHTML = "<p style='color:red;'>Error loading dashboard. See console.</p>";
            if (reportingContent) reportingContent.innerHTML = "<p style='color:red;'>Error loading reports. See console.</p>";
        }
    }
    if (!window.originalAppDOMContentLoaded && typeof window.originalDOMContentLoadedHandler === 'function') {
        window.originalAppDOMContentLoaded = window.originalDOMContentLoadedHandler;
    } else if (!window.originalAppDOMContentLoaded) {
    }
    (function () { // IIFE to manage scope and ensure patching happens correctly
        let originalDOMContentLoadedHandler = null;
        let originalShowSectionHandler = null;
        if (typeof window.originalDOMContentLoadedHandler === 'function') { // From previous attempts
            originalDOMContentLoadedHandler = window.originalDOMContentLoadedHandler;
        }
        if (typeof window.showSection === 'function') {
            originalShowSectionHandler = window.showSection;
        }
        const patchedDOMLoadHandler = async () => {
            if (typeof originalDOMContentLoadedHandler === 'function' && originalDOMContentLoadedHandler !== patchedDOMLoadHandler) {
                await originalDOMContentLoadedHandler();
            } else {
                if (typeof openDB === 'function') await openDB(); else console.error("openDB not found");
                if (typeof loadThemePreference === 'function') await loadThemePreference();
                if (typeof setupEventListeners === 'function') setupEventListeners(); else console.error("setupEventListeners not found");
                if (typeof loadQuranData === 'function') await loadQuranData();
                if (typeof displayThemesList === 'function') displayThemesList();
                if (typeof setupTafsirDocxButton === 'function') setupTafsirDocxButton();
                if (typeof document !== 'undefined' && !window.rootNodePopupEl) window.rootNodePopupEl = document.getElementById('root-node-popup');
            }
            initializeReportingModule_Enhanced(); // Initialize our reporting module AFTER original/basic setup
        };
        if (typeof window.originalDOMContentLoadedHandler === 'function') {
            document.removeEventListener('DOMContentLoaded', window.originalDOMContentLoadedHandler);
        }
        window.originalDOMContentLoadedHandler = patchedDOMLoadHandler; // Store our patched one globally
        document.addEventListener('DOMContentLoaded', window.originalDOMContentLoadedHandler);
        const patchedShowSection = function (sectionId) {
            if (typeof originalShowSectionHandler === 'function' && originalShowSectionHandler !== patchedShowSection) {
                originalShowSectionHandler(sectionId); // Call original display logic
            } else {
                if (typeof document !== 'undefined') {
                    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                    const activeS = document.getElementById(sectionId);
                    if (activeS) activeS.classList.add('active');
                    document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                    const activeL = document.querySelector(`.nav-link[data-section="${sectionId}"]`);
                    if (activeL) activeL.classList.add('active');
                }
            }
            const activeSectionElement = typeof document !== 'undefined' ? document.getElementById(sectionId) : null;
            if (sectionId === 'reporting') {
                if (activeSectionElement && activeSectionElement.classList.contains('active')) {
                    enterReportingFullscreen();
                    if (!currentReportingUserData) {
                        loadAndDisplayReportData_Enhanced();
                    } else {
                        renderReportingDashboard(currentReportingUserData); // Re-render dashboard
                        renderReportDetails(currentReportingUserData, { reportType: 'all' }); // Re-render details with default filter
                        setupReportingFiltersEventListeners_Enhanced(currentReportingUserData);
                    }
                }
            } else {
                if (typeof document !== 'undefined' && document.body.classList.contains('body-reporting-fullscreen')) {
                    exitReportingFullscreen();
                }
            }
            if (typeof document !== 'undefined') { // Ensure document is available
                if (sectionId === 'themes' && typeof populateThemeSelects === 'function' && typeof displayLinkedAyahsForCurrentTheme === 'function') {
                    populateThemeSelects(); displayLinkedAyahsForCurrentTheme();
                } else if (sectionId === 'recitation' && typeof loadRecitationLogs === 'function') {
                    loadRecitationLogs();
                } else if (sectionId === 'hifz' && typeof loadHifzForSurah === 'function') {
                    const hifzSurahSelect = document.getElementById('hifz-surah-select');
                    if (hifzSurahSelect && hifzSurahSelect.value) loadHifzForSurah(parseInt(hifzSurahSelect.value, 10));
                } else if (sectionId === 'roots' && typeof window.rootNetwork !== 'undefined' && window.rootNetwork && typeof window.rootNetwork.fit === 'function') {
                    setTimeout(() => window.rootNetwork.fit(), 100);
                }
            }
        };
        window.showSection = patchedShowSection; // This is now the global showSection
    })();
    function detectDirection(text) {
        const urduPattern = /[\u0600-\u06FF]/;
        return urduPattern.test(text) ? 'rtl' : 'ltr';
    }
    const textarea = document.getElementById('tafsir-notes');
    (function (watchTextarea) {
        let _value = watchTextarea.value;
        function updateDirection(val) {
            const dir = detectDirection(val);
            watchTextarea.setAttribute('dir', dir);
        }
        Object.defineProperty(watchTextarea, 'value', {
            get() {
                return _value;
            },
            set(val) {
                _value = val;
                watchTextarea.defaultValue = val; // optional: reflect in DOM
                updateDirection(val);
            }
        });
        watchTextarea.addEventListener('input', () => {
            _value = watchTextarea.value;
            updateDirection(_value);
        });
        updateDirection(_value);
    })(textarea);
</script>