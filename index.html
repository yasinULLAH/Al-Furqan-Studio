<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nur Al-Quran Studio Offline - By Yasin Ullah</title>
    <meta name="author" content="Yasin Ullah, Pakistani">
    <meta name="description" content="An offline-first, client-side Quranic study environment with personal Tafsir, thematic linking, root analysis, Hifz tracking, and advanced search.">

    <style>
        /* General Styles & Reset */
        :root {
            /* Default Theme: Serene Digital Mosque */
            --color-bg-primary: #e8f5e9; /* Light Green */
            --color-bg-secondary: #c8e6c9; /* Lighter Green */
            --color-text-primary: #1b5e20; /* Dark Green */
            --color-text-secondary: #388e3c; /* Medium Green */
            --color-accent: #4caf50; /* Green */
            --color-accent-dark: #388e3c; /* Darker Green */
            --color-border: #a5d6a7; /* Light Green Border */
            --color-shadow: rgba(0, 0, 0, 0.1);
            --color-highlight: #fff9c4; /* Light Yellow */
            --color-error: #ef5350; /* Red */
            --color-success: #66bb6a; /* Green */
            --font-arabic: 'Scheherazade New', 'Lateef', 'Amiri', 'Traditional Arabic', calibri; /* Preferred Arabic fonts */
            --font-urdu: 'Jameel Noori Nastaleeq', 'Noto Nastaliq Urdu', 'Pak Nastaleeq', calibri; /* Preferred Urdu fonts */
            --font-Bangali: 'Noto Sans Bangali', 'Arial', calibri; /* Bangali fonts */
            --font-english: 'Roboto', 'Segoe UI', calibri; /* English font */
            --font-general: 'Roboto', 'Segoe UI', calibri; /* General UI font */
            --border-radius: 8px;
            --padding-main: 20px;
            --transition-speed: 0.3s;
        }

        /* Ancient Illuminated Manuscript Theme */
        body.theme-manuscript {
            --color-bg-primary: #f5f5dc; /* Beige/Parchment */
            --color-bg-secondary: #fff8dc; /* Cornsilk */
            --color-text-primary: #5d4037; /* Dark Brown */
            --color-text-secondary: #795548; /* Brown */
            --color-accent: #ffb300; /* Amber */
            --color-accent-dark: #fb8c00; /* Dark Amber */
            --color-border: #d7ccc8; /* Light Brown */
            --color-shadow: rgba(0, 0, 0, 0.15);
            --color-highlight: #ffe082; /* Light Amber */
            --color-error: #c62828; /* Dark Red */
            --color-success: #388e3c; /* Dark Green */
            --font-arabic: 'Scheherazade New', calibri;
            --font-urdu: 'Jameel Noori Nastaleeq', calibri;
            --font-Bangali: 'Noto Sans Bangali', calibri;
            --font-english: 'Merriweather', calibri;
            --font-general: 'Merriweather', calibri;
        }

        /* Futuristic Holo-Quran Theme */
        body.theme-holo {
            --color-bg-primary: #0d1a2b; /* Dark Blue */
            --color-bg-secondary: #1a2b3c; /* Slightly Lighter Blue */
            --color-text-primary: #e0f7fa; /* Cyan */
            --color-text-secondary: #b2ebf2; /* Lighter Cyan */
            --color-accent: #00bcd4; /* Cyan */
            --color-accent-dark: #00838f; /* Dark Cyan */
            --color-border: #26a69a; /* Teal */
            --color-shadow: rgba(0, 188, 212, 0.2); /* Cyan shadow */
            --color-highlight: #80deea; /* Light Cyan */
            --color-error: #ff5252; /* Red */
            --color-success: #00e676; /* Green */
            --font-arabic: 'Orbitron', calibri; /* Futuristic Arabic (placeholder, needs actual font) */
            --font-urdu: 'Orbitron', calibri; /* Placeholder */
            --font-Bangali: 'Orbitron', calibri;
            --font-english: 'Orbitron', calibri;
            --font-general: 'Orbitron', calibri;
            --border-radius: 4px;
        }


        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-general);
            line-height: 1.6;
            color: var(--color-text-primary);
            background-color: var(--color-bg-primary);
            transition: background-color var(--transition-speed), color var(--transition-speed);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-y: scroll; /* Allow scrolling on body */
        }

        h1, h2, h3, h4, h5, h6 {
            color: var(--color-text-secondary);
            margin-bottom: 15px;
        }

        button, input[type="submit"], input[type="button"] {
            font-family: var(--font-general);
            background-color: var(--color-accent);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color var(--transition-speed), opacity var(--transition-speed);
            font-size: 1rem;
        }

        button:hover, input[type="submit"]:hover, input[type="button"]:hover {
            background-color: var(--color-accent-dark);
            opacity: 0.9;
        }
         button:focus, input[type="submit"]:focus, input[type="button"]:focus {
            outline: 2px solid var(--color-accent-dark);
            outline-offset: 2px;
        }

        input[type="text"], input[type="number"], textarea, select {
            font-family: var(--font-general);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
            width: 100%;
            max-width: 400px; /* Limit width for forms */
        }
         input[type="text"]:focus, input[type="number"]:focus, textarea:focus, select:focus {
            outline: 2px solid var(--color-accent);
            border-color: var(--color-accent);
         }

        textarea {
            min-height: 150px;
            resize: vertical;
            max-width: 100%;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--color-text-secondary);
        }

        a {
            color: var(--color-accent-dark);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Layout */
        .container {
            display: flex;
            flex-grow: 1; /* Allow container to take up available space */
            padding: var(--padding-main);
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .sidebar {
            width: 250px;
            margin-right: var(--padding-main);
            flex-shrink: 0;
            background-color: var(--color-bg-secondary);
            padding: var(--padding-main);
            border-radius: var(--border-radius);
            box-shadow: 0 2px 5px var(--color-shadow);
        }

        .main-content {
            flex-grow: 1;
            background-color: var(--color-bg-secondary);
            padding: var(--padding-main);
            border-radius: var(--border-radius);
            box-shadow: 0 2px 5px var(--color-shadow);
            overflow-y: auto; /* Allow main content area to scroll */
        }

        header {
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
            padding: 15px var(--padding-main);
            box-shadow: 0 2px 5px var(--color-shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        header h1 {
            margin: 0;
            font-size: 1.8rem;
            color: var(--color-text-primary);
        }

        nav ul {
            list-style: none;
            padding: 0;
        }

        nav ul li {
            margin-bottom: 10px;
        }

        nav a {
            display: block;
            padding: 10px;
            background-color: var(--color-bg-primary);
            border-radius: var(--border-radius);
            color: var(--color-text-primary);
            transition: background-color var(--transition-speed), color var(--transition-speed);
        }

        nav a:hover, nav a.active {
            background-color: var(--color-accent);
            color: white;
            text-decoration: none;
        }

        /* Specific Sections */
        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        /* Quran Section */
        .quran-viewer h2 {
            text-align: center;
            margin-bottom: 20px;
        }

        .ayah {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            transition: background-color var(--transition-speed);
        }

        .ayah:hover {
             background-color: var(--color-highlight);
        }

        .ayah-number {
            font-weight: bold;
            color: var(--color-accent-dark);
            margin-bottom: 10px;
            display: block;
            text-align: center;
        }

        .ayah-arabic {
            font-family: var(--font-arabic);
            font-size: 1.8rem;
            text-align: right;
            direction: rtl;
            margin-bottom: 10px;
            line-height: 2.5; /* Increased line height for clarity */
        }

        .ayah-arabic span {
            cursor: pointer;
            padding: 2px 4px;
            border-bottom: 1px dashed transparent;
            transition: background-color 0.2s, border-bottom-color 0.2s;
        }

        .ayah-arabic span:hover {
            background-color: rgba(var(--color-accent-dark-rgb, 56, 142, 60), 0.2); /* Use RGBA for hover */
            border-bottom-color: var(--color-accent-dark);
        }
        /* Add RGB variables for themes */
        :root { --color-accent-dark-rgb: 56, 142, 60; } /* Serene */
        body.theme-manuscript { --color-accent-dark-rgb: 251, 140, 0; } /* Manuscript */
        body.theme-holo { --color-accent-dark-rgb: 0, 131, 143; } /* Holo */


        .ayah-translation {
            /* These will be set dynamically by JS based on selected translation */
            font-size: 1.1rem;
            color: var(--color-text-secondary);
        }

        /* Tafsir Builder */
        .tafsir-editor {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--color-border);
        }

        .tafsir-editor textarea {
            width: 100%;
            max-width: 100%;
            margin-bottom: 10px;
        }

        /* Thematic Linker */
        .theme-manager, .theme-linker {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
        }

        .theme-list ul {
            list-style: none;
            padding-left: 20px;
        }
        .theme-list li {
            margin-bottom: 5px;
        }
        .theme-list li span {
             cursor: pointer;
             color: var(--color-text-secondary);
             transition: color var(--transition-speed);
        }
        .theme-list li span:hover {
             color: var(--color-accent-dark);
             text-decoration: underline;
        }
        .theme-list .theme-actions button {
            padding: 3px 8px;
            font-size: 0.8rem;
            margin-left: 5px;
        }

        /* Root Word Analyzer */
        .root-analyzer-form {
            margin-bottom: 20px;
        }
        .root-results ul {
            list-style: none;
            padding: 0;
        }
        .root-results li {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            font-size: 1.5rem;
        }

        /* Recitation Log */
        .recitation-log-form {
             margin-bottom: 20px;
        }
        .recitation-list ul {
            list-style: none;
            padding: 0;
        }
        .recitation-list li {
             margin-bottom: 10px;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
        }

        /* Memorization Hub */
        .hifz-ayah-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: var(--border-radius);
            font-size: 0.9rem;
            margin-left: 10px;
        }
        .status-not-started { background-color: #e0e0e0; color: #424242; }
        .status-in-progress { background-color: #fff59d; color: #fbc02d; }
        .status-memorized { background-color: #a5d6a7; color: #388e3c; }

        /* Advanced Search */
        .search-options label {
            display: inline-block;
            margin-right: 15px;
            font-weight: normal;
        }
        .search-results ul {
            list-style: none;
            padding: 0;
            margin-top: 20px;
        }
        .search-results li {
             margin-bottom: 10px;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            /* font-size: x-large; Removed for consistency, use result-context */
        }
        .search-results .result-context {
            font-size: large;
            color: var(--color-text-secondary);
            margin-top: 5px;
        }

        /* Data Management / Settings */
        .settings-section {
            margin-bottom: 20px;
        }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--color-bg-secondary);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 15px var(--color-shadow);
            max-width: 600px;
            width: 90%;
            position: relative;
        }

        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            color: var(--color-text-secondary);
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }

        /* Loading Indicator */
        #loading-overlay {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 1.5rem;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            display: none; /* Hidden by default */
        }

        /* Utility Classes */
        .text-center { text-align: center; }
        .mt-20 { margin-top: 20px; }
        .mb-10 { margin-bottom: 10px; }
        .mb-20 { margin-bottom: 20px; }
        .flex-group { display: flex; gap: 10px; align-items: center; } /* For buttons/inputs side-by-side */


        /* Accessibility (WCAG 2.1 AAA considerations) */
        [tabindex="0"]:focus, button:focus, input:focus, select:focus, textarea:focus, a:focus {
            outline: 3px solid var(--color-accent-dark); /* Stronger focus indicator */
            outline-offset: 2px;
        }

        /* Screen reader only class */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        /* RTL adjustments */
        [dir="rtl"] .ayah-arabic, [dir="rtl"] .ayah-translation {
            text-align: right;
        }
         [dir="rtl"] .sidebar {
            margin-right: 0;
            margin-left: var(--padding-main);
         }
         [dir="rtl"] .theme-list ul {
            padding-left: 0;
            padding-right: 20px;
         }
         [dir="rtl"] .theme-list .theme-actions button {
            margin-left: 0;
            margin-right: 5px;
         }
        [dir="rtl"] .hifz-ayah-status {
            margin-left: 0;
            margin-right: 10px;
        }
         [dir="rtl"] .search-options label {
            margin-right: 0;
            margin-left: 15px;
         }


        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                padding: 10px;
            }
            .sidebar {
                width: 100%;
                margin-right: 0;
                margin-bottom: 20px;
            }
             [dir="rtl"] .sidebar {
                margin-left: 0;
                margin-bottom: 20px;
             }
            .main-content {
                padding: 15px;
            }
            header {
                flex-direction: column;
                align-items: flex-start;
                padding: 10px;
            }
            header h1 {
                margin-bottom: 10px;
            }
            nav ul {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
            }
            nav ul li {
                margin-bottom: 0;
            }
            nav a {
                padding: 8px 12px;
                font-size: 0.9rem;
            }
             input[type="text"], input[type="number"], textarea, select {
                max-width: 100%;
            }
             .flex-group {
                flex-direction: column;
                gap: 10px;
             }
             .flex-group button, .flex-group input {
                width: 100%;
             }
        }

        /* Chronospatial/Bioluminescent Simulation (Basic) */
        body.theme-holo .ayah:hover {
             background: linear-gradient(90deg, rgba(0,188,212,0.1) 0%, rgba(0,188,212,0.05) 100%);
        }
        body.theme-holo .ayah-arabic span:hover {
             background-color: rgba(0, 188, 212, 0.3);
             border-bottom-color: var(--color-highlight);
        }
         body.theme-holo nav a.active {
            background-color: var(--color-accent);
            box-shadow: 0 0 8px var(--color-accent);
         }


                 /* Loading Indicator Enhancements */
        #loading-overlay {
            display: none; /* Hidden by default, shown by JS */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85); /* Darker overlay */
            color: white;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            text-align: center;
            padding: 20px;
        }

        .loading-content {
            background-color: var(--color-bg-secondary, #1a2b3c); /* Use theme color or fallback */
            padding: 30px 40px;
            border-radius: var(--border-radius, 8px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
        }
        body.theme-serene .loading-content { background-color: var(--color-bg-secondary); color: var(--color-text-primary);}
        body.theme-manuscript .loading-content { background-color: var(--color-bg-secondary); color: var(--color-text-primary);}
        body.theme-holo .loading-content { background-color: #1a2b3c; color: #e0f7fa; }


        #loading-message-primary {
            font-size: 1.4rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #loading-message-secondary {
            font-size: 1rem;
            margin-bottom: 20px;
            min-height: 1.6em; /* Prevent layout shift */
        }

        #loading-progress-bar-container {
            width: 100%;
            background-color: var(--color-border, #a5d6a7); /* Theme border or fallback */
            border-radius: var(--border-radius, 8px);
            overflow: hidden;
            height: 20px;
            margin-bottom: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        body.theme-holo #loading-progress-bar-container { background-color: #26a69a; }


        #loading-progress-bar {
            height: 100%;
            background-color: var(--color-accent, #4caf50); /* Theme accent or fallback */
            width: 0%; /* Initial width */
            transition: width 0.3s ease-out;
            border-radius: var(--border-radius, 8px) 0 0 var(--border-radius, 8px); /* Maintain rounded left corners */
        }
         body.theme-holo #loading-progress-bar { background-color: var(--color-accent); }


        #loading-percentage {
            font-size: 1.1rem;
            font-weight: bold;
        }
        #loading-first-time-notice {
            font-size: 0.85em;
            margin-top: 15px;
            opacity: 0.8;
        }
    </style>
    <!-- Optional: Include fonts if not available locally -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Scheherazade+New:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Jameel+Noori+Nastaleeq&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Nastaliq+Urdu&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+Bangali&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap">
</head>
<body dir="ltr"> <!-- Default direction, will be set dynamically if needed -->

        <div id="loading-overlay">
        <div class="loading-content">
            <div id="loading-message-primary">Loading Quran data...</div>
            <div id="loading-message-secondary">Initializing...</div>
            <div id="loading-progress-bar-container">
                <div id="loading-progress-bar" style="width: 0%;"></div>
            </div>
            <div id="loading-percentage">0%</div>
            <div id="loading-first-time-notice" style="font-size: 0.9em; margin-top: 10px;">
                (This intensive loading typically occurs only on the first visit or after an app update. Subsequent loads will be much faster.)
            </div>
        </div>
    </div>

    <header>
        <h1>Nur Al-Quran Studio Offline</h1>
        <div class="header-controls">
             <label for="theme-switcher" class="sr-only">Choose Theme</label>
            <select id="theme-switcher" aria-label="Choose Theme">
                <option value="serene">Serene Digital Mosque</option>
                <option value="manuscript">Ancient Illuminated Manuscript</option>
                <option value="holo">Futuristic Holo-Quran</option>
            </select>
        </div>
    </header>

    <div class="container">
        <aside class="sidebar">
            <nav>
                <ul>
                    <li><a href="#quran" class="nav-link active" data-section="quran">Quran Viewer</a></li>
                    <li><a href="#tafsir" class="nav-link" data-section="tafsir">Personal Tafsir</a></li>
                    <li><a href="#themes" class="nav-link" data-section="themes">Thematic Linker</a></li>
                    <li><a href="#roots" class="nav-link" data-section="roots">Root Word Analyzer</a></li>
                    <li><a href="#recitation" class="nav-link" data-section="recitation">Recitation Log</a></li>
                    <li><a href="#hifz" class="nav-link" data-section="hifz">Memorization Hub</a></li>
                    <li><a href="#search" class="nav-link" data-section="search">Advanced Search</a></li>
                    <li><a href="#data" class="nav-link" data-section="data">Data Management</a></li>
                </ul>
            </nav>
        </aside>

        <main class="main-content">
            <section id="quran" class="section active" role="region" aria-labelledby="quran-heading">
                <h2 id="quran-heading">Quran Viewer</h2>
                <div class="quran-controls flex-group mb-20">
                    <label for="surah-select" class="sr-only">Select Surah</label>
                    <select id="surah-select" aria-label="Select Surah"></select>
                    <label for="ayah-select" class="sr-only">Select Ayah</label>
                    <select id="ayah-select" aria-label="Select Ayah"></select>
                </div>
                 <div class="quran-controls flex-group mb-20">
                     <label for="translation-select" class="sr-only">Select Translation</label>
                     <select id="translation-select" aria-label="Select Translation">
                         <option value="urdu">Urdu (Included)</option>
                         <option value="english">English (Included)</option>
                         <option value="Bangali">Bangali (Included)</option>
                     </select>
                 </div>

                <div id="quran-display" class="quran-viewer" lang="ar" dir="rtl">
                    <!-- Quran Ayahs will be loaded here -->
                    <p class="text-center">Select a Surah and Ayah to start.</p>
                </div>
                 <div id="word-translation-area" class="mt-20">
                     <!-- Word translation or full ayah translation on word click -->
                     <p class="text-center">Click on an Arabic word to see its translation.</p>
                 </div>
            </section>

            <section id="tafsir" class="section" role="region" aria-labelledby="tafsir-heading">
                <h2 id="tafsir-heading">Personal Tafsir Builder</h2>
                <p>Write your notes and reflections for the current Ayah.</p>
                 <div id="current-ayah-tafsir" class="ayah mb-20">
                     <!-- Current Ayah will be displayed here -->
                     <p class="text-center">Navigate to an Ayah in the Quran Viewer to add Tafsir.</p>
                 </div>
                <div class="tafsir-editor">
                    <label for="tafsir-notes">Your Tafsir Notes:</label>
                    <textarea id="tafsir-notes" placeholder="Enter your personal notes, interpretations, and reflections here..."></textarea>
                    <button id="save-tafsir-btn">Save Tafsir</button>
                     <p id="tafsir-status" aria-live="polite"></p>
                </div>
            </section>

            <section id="themes" class="section" role="region" aria-labelledby="themes-heading">
                <h2 id="themes-heading">Thematic Linker Pro</h2>
                <p>Create and manage themes, and link Ayahs to them.</p>

                <div class="theme-manager mb-20">
                    <h3>Manage Themes</h3>
                    <div class="flex-group mb-10">
                        <label for="new-theme-name" class="sr-only">New Theme Name</label>
                        <input type="text" id="new-theme-name" placeholder="New Theme Name">
                        <label for="parent-theme-select" class="sr-only">Parent Theme (Optional)</label>
                        <select id="parent-theme-select" aria-label="Parent Theme (Optional)">
                            <option value="">-- No Parent --</option>
                            <!-- Options populated by JS -->
                        </select>
                        <button id="add-theme-btn">Add Theme</button>
                    </div>
                    <div class="theme-list">
                        <h4>Existing Themes</h4>
                        <ul id="themes-list">
                            <!-- Themes populated by JS -->
                            <li>No themes added yet.</li>
                        </ul>
                    </div>
                     <p id="theme-manager-status" aria-live="polite"></p>
                </div>

                <div class="theme-linker">
                    <h3>Link Current Ayah (<span id="current-ayah-theme-ref">N/A</span>)</h3>
                    <div id="current-ayah-theme-text" class="ayah mb-20">
                        <!-- Current Ayah text will be displayed here -->
                         <p class="text-center">Navigate to an Ayah in the Quran Viewer to link themes.</p>
                    </div>
                    <label for="link-theme-select">Select Theme to Link:</label>
                    <select id="link-theme-select" aria-label="Select Theme to Link">
                         <option value="">-- Select Theme --</option>
                        <!-- Options populated by JS -->
                    </select>
                    <label for="theme-link-notes">Notes for this link (Optional):</label>
                    <textarea id="theme-link-notes" placeholder="Notes on why this Ayah relates to this theme..."></textarea>
                    <button id="link-ayah-to-theme-btn">Link Ayah</button>
                     <p id="theme-linker-status" aria-live="polite"></p>

                    <h4 class="mt-20">Ayahs Linked to Selected Theme: <span id="linked-theme-name">N/A</span></h4>
                    <ul id="linked-ayahs-list">
                        <!-- Linked ayahs populated by JS -->
                        <li>Select a theme above to see linked ayahs.</li>
                    </ul>
                </div>
            </section>

            <section id="roots" class="section" role="region" aria-labelledby="roots-heading">
                <h2 id="roots-heading">Root Word Analyzer & Concordance</h2>
                <p>Input an Arabic root word to find occurrences in the Quran (simplified string search).</p>

                <div class="root-analyzer-form mb-20">
                    <div class="flex-group mb-10">
                        <label for="root-input" class="sr-only">Arabic Root Word</label>
                        <input type="text" id="root-input" placeholder="Enter Arabic Root (e.g., ق-و-ل) or (ع ل م) or (ر۔ب)" lang="ar" dir="rtl">
                        <button id="analyze-root-btn">Analyze Root</button>
                    </div>
                    <label for="root-description">Description/Notes for this Root (Optional):</label>
                    <textarea id="root-description" placeholder="Your notes on this root's meaning..."></textarea>
                    <button id="save-root-notes-btn">Save Root Notes</button>
                     <p id="root-status" aria-live="polite"></p>
                </div>

                <div class="root-results">
                    <h3>Occurrences Found for: <span id="analyzed-root-term">N/A</span></h3>
                    <ul id="root-occurrences-list">
                        <!-- Occurrences populated by JS -->
                        <li>Enter a root word and click "Analyze Root".</li>
                    </ul>
                </div>
            </section>

            <section id="recitation" class="section" role="region" aria-labelledby="recitation-heading">
                <h2 id="recitation-heading">Comparative Recitation Log</h2>
                <p>Log your listening sessions to different Qaris.</p>

                <div class="recitation-log-form mb-20">
                    <h3>Add Log Entry</h3>
                    <div class="flex-group mb-10">
                        <label for="rec-surah-select" class="sr-only">Surah</label>
                        <select id="rec-surah-select" aria-label="Surah"></select>
                        <label for="rec-ayah-start" class="sr-only">Ayah Start (Optional)</label>
                        <input type="number" id="rec-ayah-start" placeholder="Ayah Start (Optional)" min="1">
                        <label for="rec-ayah-end" class="sr-only">Ayah End (Optional)</label>
                        <input type="number" id="rec-ayah-end" placeholder="Ayah End (Optional)" min="1">
                    </div>
                     <div class="flex-group mb-10">
                        <label for="rec-qari" class="sr-only">Qari/Source</label>
                        <input type="text" id="rec-qari" placeholder="Qari or Source (e.g., Mishary Alafasy, Local Masjid Imam)">
                        <label for="rec-date" class="sr-only">Date</label>
                        <input type="date" id="rec-date" aria-label="Date">
                     </div>
                    <label for="rec-notes">Notes (Tajweed, Style, Impact):</label>
                    <textarea id="rec-notes" placeholder="Notes on Tajweed, style, emotional impact..."></textarea>
                    <button id="save-recitation-btn">Save Log Entry</button>
                     <p id="recitation-status" aria-live="polite"></p>
                </div>

                <div class="recitation-list">
                    <h3>Log Entries</h3>
                    <ul id="recitations-list">
                        <!-- Log entries populated by JS -->
                        <li>No entries logged yet.</li>
                    </ul>
                </div>
            </section>

            <section id="hifz" class="section" role="region" aria-labelledby="hifz-heading">
                <h2 id="hifz-heading">Memorization Hub</h2>
                <p>Track your Hifz progress and review schedule.</p>

                <div class="hifz-controls flex-group mb-20">
                     <label for="hifz-surah-select" class="sr-only">Select Surah for Hifz</label>
                    <select id="hifz-surah-select" aria-label="Select Surah for Hifz"></select>
                </div>

                <div id="hifz-ayahs-list">
                    <!-- List of ayahs for the selected surah with status/controls -->
                     <p class="text-center">Select a Surah to track Hifz progress.</p>
                </div>
                 <p id="hifz-status" aria-live="polite"></p>
            </section>

            <section id="search" class="section" role="region" aria-labelledby="search-heading">
                <h2 id="search-heading">Advanced Search</h2>
                <p>Search across Quran text, translations, and your personal data.</p>

                <div class="search-form mb-20">
                    <label for="search-input" class="sr-only">Search Term</label>
                    <input type="text" id="search-input" placeholder="Enter search term">
                    <div class="search-options mb-10" role="group" aria-label="Search Scope">
                        <label><input type="checkbox" class="search-scope" value="quran-arabic" checked> Quran Arabic</label>
                        <label><input type="checkbox" class="search-scope" value="quran-translation" checked> Quran Translation</label>
                        <label><input type="checkbox" class="search-scope" value="tafsir"> Personal Tafsir</label>
                        <label><input type="checkbox" class="search-scope" value="themes"> Theme Notes</label>
                        <label><input type="checkbox" class="search-scope" value="roots"> Root Notes</label>
                        <label><input type="checkbox" class="search-scope" value="recitation"> Recitation Notes</label>
                        <label><input type="checkbox" class="search-scope" value="hifz"> Hifz Notes</label>
                    </div>
                    <button id="perform-search-btn">Search</button>
                     <p id="search-status" aria-live="polite"></p>
                </div>

                <div class="search-results">
                    <h3>Search Results</h3>
                    <ul id="search-results-list">
                        <!-- Search results populated by JS -->
                        <li>Enter a search term and click "Search".</li>
                    </ul>
                </div>
            </section>

            <section id="data" class="section" role="region" aria-labelledby="data-heading">
                <h2 id="data-heading">Data Management</h2>
                <p>Manage your personal data (Tafsir, Themes, Roots, Logs, Hifz).</p>

                <div class="settings-section mb-20">
                    <h3>Backup Data</h3>
                    <p>Export your personal data as a JSON file.</p>
                    <button id="export-data-btn">Export Data</button>
                     <p id="export-status" aria-live="polite"></p>
                </div>

                <div class="settings-section mb-20">
                    <h3>Restore Data</h3>
                    <p>Import your personal data from a JSON file. This will overwrite existing data.</p>
                    <label for="import-file" class="sr-only">Choose JSON file to import</label>
                    <input type="file" id="import-file" accept="application/json">
                    <button id="import-data-btn" disabled>Import Data</button>
                     <p id="import-status" aria-live="polite"></p>
                </div>

                 <div class="settings-section">
                    <h3>Clear All Personal Data</h3>
                    <p class="mb-10" style="color: var(--color-error);">Warning: This will permanently delete ALL your personal Tafsir, Themes, Roots, Logs, and Hifz data.</p>
                     <button id="clear-data-btn" style="background-color: var(--color-error);">Clear All Data</button>
                     <p id="clear-status" aria-live="polite"></p>
                 </div>
                 <div class="settings-section mb-20">
                <h3>Export Personal Tafsir to Word (.docx)</h3>
                <p>Generates a .docx file of all your Tafsir notes (basic styling).</p>
                <button id="export-tafsir-to-docx-btn">Export Tafsir to .docx</button>
                <p id="export-tafsir-docx-status" aria-live="polite"></p>
            </div>
            </section>

        </main>
    </div>

    <!-- Modal for Theme Ayahs -->
    <div id="themeAyahsModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="themeAyahsModalTitle">
        <div class="modal-content">
            <span class="close-button" aria-label="Close Theme Ayahs Modal">&times;</span>
            <h3 id="themeAyahsModalTitle">Ayahs Linked to Theme: <span id="modal-theme-name"></span></h3>
            <ul id="modal-linked-ayahs-list">
                <!-- Linked ayahs populated here -->
            </ul>
        </div>
    </div>

    <!-- Modal for Root Occurrences -->
     <div id="rootOccurrencesModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="rootOccurrencesModalTitle">
        <div class="modal-content">
            <span class="close-button" aria-label="Close Root Occurrences Modal">&times;</span>
            <h3 id="rootOccurrencesModalTitle">Occurrences for Root: <span id="modal-root-term"></span></h3>
            <ul id="modal-root-occurrences-list">
                <!-- Root occurrences populated here -->
            </ul>
        </div>
    </div>


    <script>
        // Author: Yasin Ullah, Pakistani

        const DB_NAME = 'NurAlQuranStudioDBz';
        const DB_VERSION = 7; // << UPDATED for new word_metadata store and word_translations key
        let db;

        // Object Store Names
        const STORE_QURAN = 'quran';
        const STORE_TAFSIR = 'tafsir';
        const STORE_THEMES = 'themes';
        const STORE_THEME_AYAHS = 'theme_ayahs';
        const STORE_ROOTS = 'roots';
        const STORE_ROOT_AYAHS = 'root_ayahs';
        const STORE_RECITATIONS = 'recitations';
        const STORE_HIFZ = 'hifz';
        const STORE_SETTINGS = 'settings';
        const STORE_WORD_TRANSLATIONS = 'word_translations'; // Keyed by word_id
        const STORE_WORD_METADATA = 'word_metadata';         // Keyed by word_id, indexed by location

        let totalProgressUnits = 0;
        let completedProgressUnits = 0;
        // Data file names
        const WORD_TRANSLATION_FILE = 'data5 new.AM'; // Contains word_id, ur_meaning, en_meaning
        const WORD_METADATA_FILE = 'word2.AM';       // Contains word_id, surah, ayah, word_postion

        // Global state
        let currentSurah = 1;
        let currentAyah = 1;
        let totalAyahsInSurah = 7; // Default for Surah 1
        let quranDataLoaded = false;
        // allWordTranslationsCached is no longer the primary matching source but can be kept for other uses if needed.
        // let allWordTranslationsCached = [];

        const surahNames = [
            "Al-Fatihah", "Al-Baqarah", "Al 'Imran", "An-Nisa'", "Al-Ma'idah", "Al-An'am", "Al-A'raf", "Al-Anfal", "At-Tawbah", "Yunus",
            "Hud", "Yusuf", "Ar-Ra'd", "Ibrahim", "Al-Hijr", "An-Nahl", "Al-Isra'", "Al-Kahf", "Maryam", "Taha",
            "Al-Anbya'", "Al-Hajj", "Al-Mu'minun", "An-Nur", "Al-Furqan", "Ash-Shu'ara'", "An-Naml", "Al-Qasas", "Al-'Ankabut", "Ar-Rum",
            "Luqman", "As-Sajdah", "Al-Ahzab", "Saba'", "Fatir", "Ya-Sin", "As-Saffat", "Sad", "Az-Zumar", "Ghafir",
            "Fussilat", "Ash-Shura", "Az-Zukhruf", "Ad-Dukhan", "Al-Jathiyah", "Al-Ahqaf", "Muhammad", "Al-Fath", "Al-Hujurat", "Qaf",
            "Adh-Dhariyat", "At-Tur", "An-Najm", "Al-Qamar", "Ar-Rahman", "Al-Waqi'ah", "Al-Hadid", "Al-Mujadilah", "Al-Hashr", "Al-Mumtahanah",
            "As-Saff", "Al-Jumu'ah", "Al-Munafiqun", "At-Taghabun", "At-Talaq", "At-Tahrim", "Al-Mulk", "Al-Qalam", "Al-Haqqah", "Al-Ma'arij",
            "Nuh", "Al-Jinn", "Al-Muzzammil", "Al-Muddaththir", "Al-Qiyamah", "Al-Insan", "Al-Mursalat", "An-Naba'", "An-Nazi'at", "'Abasa",
            "At-Takwir", "Al-Infitar", "Al-Mutaffifin", "Al-Inshiqaq", "Al-Buruj", "At-Tariq", "Al-A'la", "Al-Ghashiyah", "Al-Fajr", "Al-Balad",
            "Ash-Shams", "Al-Layl", "Ad-Duha", "Ash-Sharh", "At-Tin", "Al-'Alaq", "Al-Qadr", "Al-Bayyinah", "Az-Zalzalah", "Al-'Adiyat",
            "Al-Qari'ah", "At-Takathur", "Al-'Asr", "Al-Humazah", "Al-Fil", "Quraysh", "Al-Ma'un", "Al-Kawthar", "Al-Kafirun", "An-Nasr",
            "Al-Masad", "Al-Ikhlas", "Al-Falaq", "An-Nas"
        ];
        const surahAyahCounts = [
            0, 7, 286, 200, 176, 120, 165, 206, 75, 129, 109, 123, 111, 43, 52, 99, 128, 111, 110, 98, 135, 112, 78, 118, 64, 77, 227, 93, 88, 69,
            60, 34, 30, 73, 54, 45, 83, 182, 88, 75, 85, 54, 53, 89, 59, 37, 35, 38, 29, 18, 45, 60, 49, 62, 55, 78, 96, 29, 22, 24,
            13, 14, 11, 11, 18, 12, 12, 30, 52, 52, 44, 28, 28, 20, 56, 40, 31, 50, 40, 46, 42, 29, 19, 36, 25, 22, 17, 19, 26, 30,
            20, 15, 21, 11, 8, 5, 19, 5, 8, 8, 11, 11, 8, 3, 9, 5, 4, 7, 3, 6, 3, 5, 4, 5, 6
        ];

        const TRANSLATION_CONFIG = {
            urdu: { file: 'data new.AM', lang: 'ur', dir: 'rtl', label: 'Urdu' },
            english: { file: 'dataENG.AM', lang: 'en', dir: 'ltr', label: 'English' },
            Bangali: { file: 'dataBNG.AM', lang: 'bn', dir: 'ltr', label: 'Bangali' }
        };


        // --- IndexedDB Functions ---
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    const oldVersion = event.oldVersion;
                    console.log(`IndexedDB upgrade needed from version ${oldVersion} to ${DB_VERSION}.`);

                    // Quran Store
                    if (!db.objectStoreNames.contains(STORE_QURAN)) {
                        db.createObjectStore(STORE_QURAN, { keyPath: ['surah', 'ayah'] });
                    } else if (oldVersion < 2) { // Example for multi-translation support (adjust version if needed)
                        console.log(`Upgrading ${STORE_QURAN} store schema. Clearing existing data for re-population.`);
                        db.deleteObjectStore(STORE_QURAN);
                        db.createObjectStore(STORE_QURAN, { keyPath: ['surah', 'ayah'] });
                    }

                    // Tafsir Store
                    if (!db.objectStoreNames.contains(STORE_TAFSIR)) {
                        db.createObjectStore(STORE_TAFSIR, { keyPath: ['surah', 'ayah'] });
                    }

                    // Themes Store
                    if (!db.objectStoreNames.contains(STORE_THEMES)) {
                        db.createObjectStore(STORE_THEMES, { keyPath: 'id', autoIncrement: true });
                    }

                    // Theme Ayahs Store
                    if (!db.objectStoreNames.contains(STORE_THEME_AYAHS)) {
                        const themeAyahsStore = db.createObjectStore(STORE_THEME_AYAHS, { keyPath: 'id', autoIncrement: true });
                        themeAyahsStore.createIndex('themeId', 'themeId', { unique: false });
                        themeAyahsStore.createIndex('surahAyah', ['surah', 'ayah'], { unique: false });
                    }

                    // Roots Store
                    if (!db.objectStoreNames.contains(STORE_ROOTS)) {
                        db.createObjectStore(STORE_ROOTS, { keyPath: 'id', autoIncrement: true });
                        // You might add an index for 'root' if you search by it often
                        // rootsStore.createIndex('rootTerm', 'root', { unique: true }); // If root terms are unique
                    }

                    // Root Ayahs Store (currently not used for linking in provided code, but good to have)
                    if (!db.objectStoreNames.contains(STORE_ROOT_AYAHS)) {
                        const rootAyahsStore = db.createObjectStore(STORE_ROOT_AYAHS, { keyPath: 'id', autoIncrement: true });
                        rootAyahsStore.createIndex('rootId', 'rootId', { unique: false });
                        rootAyahsStore.createIndex('surahAyah', ['surah', 'ayah'], { unique: false });
                        rootAyahsStore.createIndex('word', 'word', { unique: false });
                    }

                    // Recitations Store
                    if (!db.objectStoreNames.contains(STORE_RECITATIONS)) {
                        const recitationStore = db.createObjectStore(STORE_RECITATIONS, { keyPath: 'id', autoIncrement: true });
                        recitationStore.createIndex('surah', 'surah', { unique: false });
                        recitationStore.createIndex('date', 'date', { unique: false });
                    }

                    // Hifz Store
                    if (!db.objectStoreNames.contains(STORE_HIFZ)) {
                        const hifzStore = db.createObjectStore(STORE_HIFZ, { keyPath: ['surah', 'ayah'] });
                        hifzStore.createIndex('status', 'status', { unique: false });
                        hifzStore.createIndex('nextReviewDate', 'nextReviewDate', { unique: false });
                    }

                    // Settings Store
                    if (!db.objectStoreNames.contains(STORE_SETTINGS)) {
                         db.createObjectStore(STORE_SETTINGS, { keyPath: 'name' });
                    }

                    // Word Translations Store (data5 new.AM) - Keyed by word_id
                    if (db.objectStoreNames.contains(STORE_WORD_TRANSLATIONS)) {
                        if (oldVersion < 7) { // Version 7 introduced word_id keying
                            console.log(`Re-creating '${STORE_WORD_TRANSLATIONS}' for DB_VERSION ${DB_VERSION} to be keyed by 'word_id'.`);
                            db.deleteObjectStore(STORE_WORD_TRANSLATIONS);
                            db.createObjectStore(STORE_WORD_TRANSLATIONS, { keyPath: 'word_id' });
                        }
                    } else {
                        console.log(`Creating new '${STORE_WORD_TRANSLATIONS}' store, keyed by 'word_id'.`);
                        db.createObjectStore(STORE_WORD_TRANSLATIONS, { keyPath: 'word_id' });
                    }

                    // Word Metadata Store (data2.AM) - Keyed by word_id, indexed by location
                    if (!db.objectStoreNames.contains(STORE_WORD_METADATA)) {
                        console.log(`Creating new '${STORE_WORD_METADATA}' store for DB_VERSION ${DB_VERSION}.`);
                        const wordMetadataStore = db.createObjectStore(STORE_WORD_METADATA, { keyPath: 'word_id' });
                        wordMetadataStore.createIndex('location_idx', ['surah', 'ayah', 'word_position'], { unique: true });
                    } else if (oldVersion < 7) { // Version 7 introduced this store
                        console.log(`Re-creating '${STORE_WORD_METADATA}' for DB_VERSION ${DB_VERSION}.`);
                        db.deleteObjectStore(STORE_WORD_METADATA);
                        const wordMetadataStore = db.createObjectStore(STORE_WORD_METADATA, { keyPath: 'word_id' });
                        wordMetadataStore.createIndex('location_idx', ['surah', 'ayah', 'word_position'], { unique: true });
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("IndexedDB opened successfully.");
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.errorCode, event.target.error);
                    reject("Failed to open IndexedDB: " + event.target.error.message);
                };
            });
        }

        function getObjectStore(storeName, mode) {
            if (!db) {
                console.error("getObjectStore called but DB is not initialized.");
                throw new Error("Database not initialized.");
            }
            const transaction = db.transaction(storeName, mode);
            return transaction.objectStore(storeName);
        }

        function addData(storeName, data) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.add(data);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error adding data to ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

         function putData(storeName, data) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.put(data);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error putting data to ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function getData(storeName, key) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readonly');
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                     console.error(`Error getting data from ${storeName} with key ${key}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function getAllData(storeName) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readonly');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error getting all data from ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function deleteData(storeName, key) {
             return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.delete(key);
                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error(`Error deleting data from ${storeName} with key ${key}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

         function clearStore(storeName) {
             return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error(`Error clearing store ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
         }


        // --- Data Loading and Parsing ---
                async function loadQuranData() {
            // Reset progress counters
            completedProgressUnits = 0;
            totalProgressUnits = 0;

            // Define weights for different loading stages
            const WEIGHT_CHECK_SETTINGS = 1;
            const WEIGHT_FETCH_FILE = 2;
            const WEIGHT_PARSE_QURAN_FILE = 8; // Per full Quran text file
            const WEIGHT_PARSE_WORD_FILE = 12; // Per word data file (translations or metadata)
            const WEIGHT_DB_TRANSACTION_SETUP = 2;
            const WEIGHT_DB_TRANSACTION_ITEM = 0.01; // Small weight per item stored
            const WEIGHT_DB_TRANSACTION_COMPLETE = 5;


            try {
                const settingsLoadedQuran = await getData(STORE_SETTINGS, 'quranDataLoaded').catch(() => null);
                const settingsLoadedWordTranslations = await getData(STORE_SETTINGS, 'wordTranslationsLoaded').catch(() => null);
                const settingsLoadedWordMetadata = await getData(STORE_SETTINGS, 'wordMetadataLoaded').catch(() => null);
                const lastLoadedVersionEntry = await getData(STORE_SETTINGS, 'lastLoadedDBVersion').catch(() => null);
                const lastLoadedVersion = lastLoadedVersionEntry ? lastLoadedVersionEntry.value : 0;

                const currentDBVersionForCheck = DB_VERSION; // Use the global DB_VERSION
                const needsUpdateDueToVersion = DB_VERSION > lastLoadedVersion;

                // Determine if data needs to be reloaded/updated
                const shouldLoadQuran = !(settingsLoadedQuran && settingsLoadedQuran.value === true && !needsUpdateDueToVersion && DB_VERSION >= 2);
                const shouldLoadWordTranslations = !(settingsLoadedWordTranslations && settingsLoadedWordTranslations.value === true && !needsUpdateDueToVersion && DB_VERSION >= currentDBVersionForCheck);
                const shouldLoadWordMetadata = !(settingsLoadedWordMetadata && settingsLoadedWordMetadata.value === true && !needsUpdateDueToVersion && DB_VERSION >= currentDBVersionForCheck);

                // Calculate totalProgressUnits based on what *will* be loaded
                totalProgressUnits += WEIGHT_CHECK_SETTINGS;

                if (shouldLoadQuran) {
                    totalProgressUnits += Object.keys(TRANSLATION_CONFIG).length * (WEIGHT_FETCH_FILE + WEIGHT_PARSE_QURAN_FILE);
                    // Estimate items for DB transaction progress (approx 6236 ayahs)
                    totalProgressUnits += 6236 * WEIGHT_DB_TRANSACTION_ITEM;
                }
                if (shouldLoadWordTranslations) {
                    totalProgressUnits += WEIGHT_FETCH_FILE + WEIGHT_PARSE_WORD_FILE;
                     // Estimate items for word translations (e.g., 80k words) - adjust if you have a count
                    totalProgressUnits += 80000 * WEIGHT_DB_TRANSACTION_ITEM;
                }
                if (shouldLoadWordMetadata) {
                    totalProgressUnits += WEIGHT_FETCH_FILE + WEIGHT_PARSE_WORD_FILE;
                    // Estimate items for word metadata (e.g., 80k words)
                    totalProgressUnits += 80000 * WEIGHT_DB_TRANSACTION_ITEM;
                }

                if (shouldLoadQuran || shouldLoadWordTranslations || shouldLoadWordMetadata) {
                    totalProgressUnits += WEIGHT_DB_TRANSACTION_SETUP + WEIGHT_DB_TRANSACTION_COMPLETE;
                }
                
                // If totalProgressUnits is effectively just for checking settings, it means nothing else to load
                if (totalProgressUnits <= WEIGHT_CHECK_SETTINGS && !shouldLoadQuran && !shouldLoadWordTranslations && !shouldLoadWordMetadata) {
                    console.log("All necessary Quran, word translation, and word metadata already loaded and up-to-date.");
                    quranDataLoaded = true;
                    await populateSurahAyahSelects();
                    await loadAyah(currentSurah, currentAyah);
                    // No showLoading/hideLoading here if we skip intensive loading
                    return;
                }

                let primaryLoadingMessage = "Setting up Quran Studio for the first time...";
                if (lastLoadedVersion > 0) { // Not the very first time
                    if (needsUpdateDueToVersion) {
                        primaryLoadingMessage = "Updating Quran Studio data for a new version...";
                    } else {
                        // This case should ideally be caught by the early return above,
                        // but as a fallback if logic leads here.
                        primaryLoadingMessage = "Verifying Quran Studio data...";
                    }
                }
                showLoading(primaryLoadingMessage, "Checking existing data...", 0);
                updateLoadingProgress(WEIGHT_CHECK_SETTINGS, "Checked local data status.");

                if (!shouldLoadQuran && !shouldLoadWordTranslations && !shouldLoadWordMetadata) {
                    console.log("All necessary Quran, word translation, and word metadata already loaded.");
                    quranDataLoaded = true;
                    await populateSurahAyahSelects();
                    await loadAyah(currentSurah, currentAyah);
                    updateLoadingProgress(totalProgressUnits - completedProgressUnits, "Data verified. Launching Studio..."); // Complete progress
                    setTimeout(hideLoading, 500); // Brief pause before hiding
                    return;
                }

                const storesToAccessInTransaction = [STORE_SETTINGS];
                if (shouldLoadQuran) storesToAccessInTransaction.push(STORE_QURAN);
                if (shouldLoadWordTranslations) storesToAccessInTransaction.push(STORE_WORD_TRANSLATIONS);
                if (shouldLoadWordMetadata) storesToAccessInTransaction.push(STORE_WORD_METADATA);

                const allQuranDataMap = new Map();
                let wordTranslationEntries = [];
                let wordMetadataEntries = [];

                // --- 1. Load Full Quran Ayah Texts & Translations ---
                if (shouldLoadQuran) {
                    console.log("Fetching full Quran ayah texts and translations...");
                    for (const key in TRANSLATION_CONFIG) {
                        const config = TRANSLATION_CONFIG[key];
                        try {
                            updateLoadingProgress(0, `Fetching ${config.label} text (${config.file.substring(0,15)})...`);
                            const response = await fetch(config.file);
                            updateLoadingProgress(WEIGHT_FETCH_FILE, `Processing ${config.label} (${config.file.substring(0,15)})...`);
                            if (!response.ok) {
                                console.warn(`HTTP error! status: ${response.status} for ${config.file}. Skipping.`);
                                updateLoadingProgress(WEIGHT_PARSE_QURAN_FILE, `Skipped ${config.label} due to error.`);
                                continue;
                            }
                            const text = await response.text();
                            console.log(`${config.label} data fetched (${config.file}). Parsing...`);

                            const lines = text.split('\n').filter(line => line.trim() !== '');
                            for (const line of lines) {
                                const parts = line.split(' ترجمہ: ');
                                if (parts.length < 2) continue;
                                const arabicPart = parts[0].trim();
                                const rest = parts[1];
                                const metaMatch = rest.match(/<br\/>\s*(?:s|س)\s*\.?\s*(\d{1,3})\s*(?:a|آ)\s*\.?\s*(\d{1,3})\s*$/i);
                                if (!metaMatch) continue;

                                const translationPart = rest.substring(0, metaMatch.index).trim();
                                const surahNum = parseInt(metaMatch[1], 10);
                                const ayahNum = parseInt(metaMatch[2], 10);

                                if (isNaN(surahNum) || isNaN(ayahNum) || surahNum < 1 || surahNum > 114 || ayahNum < 1) continue;

                                const mapKey = `${surahNum}-${ayahNum}`;
                                let entry = allQuranDataMap.get(mapKey);
                                if (!entry) {
                                    entry = { surah: surahNum, ayah: ayahNum, arabic: arabicPart, urdu: '', english: '', Bangali: '' };
                                    allQuranDataMap.set(mapKey, entry);
                                }
                                entry[key] = translationPart;
                            }
                            updateLoadingProgress(WEIGHT_PARSE_QURAN_FILE, `Processed ${config.label} data.`);
                        } catch (fetchError) {
                             console.error(`Error fetching/parsing ${config.file}:`, fetchError);
                             updateLoadingProgress(WEIGHT_PARSE_QURAN_FILE, `Error with ${config.label}.`);
                        }
                    }
                    console.log(`Parsed ${allQuranDataMap.size} unique full ayahs.`);
                }

                // --- 2. Load Word Translations (from data5 new.AM) ---
                if (shouldLoadWordTranslations) {
                    console.log(`Fetching word translations from ${WORD_TRANSLATION_FILE}...`);
                    try {
                        updateLoadingProgress(0, `Fetching word translations (${WORD_TRANSLATION_FILE.substring(0,15)})...`);
                        const response = await fetch(WORD_TRANSLATION_FILE);
                        updateLoadingProgress(WEIGHT_FETCH_FILE, `Processing word translations (${WORD_TRANSLATION_FILE.substring(0,15)})...`);
                        if (!response.ok) {
                            console.warn(`Failed to fetch ${WORD_TRANSLATION_FILE}: ${response.status}`);
                            updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Skipped word translations due to error.`);
                        } else {
                            const csvText = await response.text();
                            const lines = csvText.split('\n').filter(line => line.trim() !== '');
                            if (lines.length > 0) {
                                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                                const wordIdIndex = headers.indexOf('word_id');
                                const urMeaningIndex = headers.indexOf('ur_meaning');
                                const enMeaningIndex = headers.indexOf('en_meaning');

                                if (wordIdIndex === -1) {
                                    console.error(`'word_id' header not found in ${WORD_TRANSLATION_FILE}. Cannot process word translations.`);
                                } else {
                                    for (let i = 1; i < lines.length; i++) {
                                        const values = lines[i].split(',');
                                        const word_id_val = values[wordIdIndex] ? values[wordIdIndex].trim() : null;
                                        if (!word_id_val) continue;

                                        const entry = {
                                            word_id: parseInt(word_id_val, 10),
                                            ur_meaning: urMeaningIndex > -1 && values[urMeaningIndex] ? values[urMeaningIndex].trim() : '',
                                            en_meaning: enMeaningIndex > -1 && values[enMeaningIndex] ? values[enMeaningIndex].trim() : '',
                                        };
                                        if (!isNaN(entry.word_id)) {
                                            wordTranslationEntries.push(entry);
                                        }
                                    }
                                    console.log(`Parsed ${wordTranslationEntries.length} word translation entries from ${WORD_TRANSLATION_FILE}.`);
                                }
                            }
                             updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Processed ${wordTranslationEntries.length} word translations.`);
                        }
                    } catch (fetchError) {
                        console.error(`Error fetching/parsing ${WORD_TRANSLATION_FILE}:`, fetchError);
                        updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Error with word translations.`);
                    }
                }

                // --- 3. Load Word Metadata (from data2.AM) ---
                if (shouldLoadWordMetadata) {
                    console.log(`Fetching word metadata from ${WORD_METADATA_FILE}...`);
                    try {
                        updateLoadingProgress(0, `Fetching word metadata (${WORD_METADATA_FILE.substring(0,15)})...`);
                        const response = await fetch(WORD_METADATA_FILE);
                        updateLoadingProgress(WEIGHT_FETCH_FILE, `Processing word metadata (${WORD_METADATA_FILE.substring(0,15)})...`);
                        if (!response.ok) {
                            console.warn(`Failed to fetch ${WORD_METADATA_FILE}: ${response.status}`);
                             updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Skipped word metadata due to error.`);
                        } else {
                            const csvText = await response.text();
                            const lines = csvText.split('\n').filter(line => line.trim() !== '');
                            if (lines.length > 0) {
                                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                                const wordIdIndex = headers.indexOf('word_id');
                                const surahIndex = headers.indexOf('surah');
                                const ayahIndex = headers.indexOf('ayah');
                                const positionIndex = headers.indexOf('word_postion');

                                if (wordIdIndex === -1 || surahIndex === -1 || ayahIndex === -1 || positionIndex === -1) {
                                    console.error(`One or more required headers not found in ${WORD_METADATA_FILE}.`);
                                } else {
                                    for (let i = 1; i < lines.length; i++) {
                                        const values = lines[i].split(',');
                                        const entry = {
                                            word_id: parseInt(values[wordIdIndex] ? values[wordIdIndex].trim() : '', 10),
                                            surah: parseInt(values[surahIndex] ? values[surahIndex].trim() : '', 10),
                                            ayah: parseInt(values[ayahIndex] ? values[ayahIndex].trim() : '', 10),
                                            word_position: parseInt(values[positionIndex] ? values[positionIndex].trim() : '', 10)
                                        };
                                        if (!isNaN(entry.word_id) && !isNaN(entry.surah) && !isNaN(entry.ayah) && !isNaN(entry.word_position)) {
                                            wordMetadataEntries.push(entry);
                                        }
                                    }
                                    console.log(`Parsed ${wordMetadataEntries.length} word metadata entries from ${WORD_METADATA_FILE}.`);
                                }
                            }
                            updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Processed ${wordMetadataEntries.length} word metadata entries.`);
                        }
                    } catch (fetchError) {
                         console.error(`Error fetching/parsing ${WORD_METADATA_FILE}:`, fetchError);
                         updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Error with word metadata.`);
                    }
                }

                // --- Transaction to Store Data ---
                if (storesToAccessInTransaction.length > 1 && (shouldLoadQuran || shouldLoadWordTranslations || shouldLoadWordMetadata)) {
                    updateLoadingProgress(WEIGHT_DB_TRANSACTION_SETUP, "Preparing to save data to local database...");
                    const transaction = db.transaction(storesToAccessInTransaction, 'readwrite');
                    
                    transaction.oncomplete = async () => {
                        console.log("Data loading/storing transaction complete.");
                        if (shouldLoadQuran) await putData(STORE_SETTINGS, { name: 'quranDataLoaded', value: true }).catch(console.error);
                        if (shouldLoadWordTranslations) await putData(STORE_SETTINGS, { name: 'wordTranslationsLoaded', value: true }).catch(console.error);
                        if (shouldLoadWordMetadata) await putData(STORE_SETTINGS, { name: 'wordMetadataLoaded', value: true }).catch(console.error);
                        await putData(STORE_SETTINGS, { name: 'lastLoadedDBVersion', value: DB_VERSION }).catch(console.error);

                        updateLoadingProgress(WEIGHT_DB_TRANSACTION_COMPLETE, "All data saved locally!");
                        
                        // Ensure progress reaches 100% if there are minor rounding/estimation issues
                        const finalRemaining = totalProgressUnits - completedProgressUnits;
                        if (finalRemaining > 0) updateLoadingProgress(finalRemaining, "Finalizing setup...");
                        
                        quranDataLoaded = true;
                        await populateSurahAyahSelects();
                        await loadAyah(currentSurah, currentAyah);
                        setTimeout(hideLoading, 500); // Give a moment for user to see "complete"
                    };
                    transaction.onerror = (event) => {
                        console.error("Transaction failed during initial data load:", event.target.error);
                        updateLoadingProgress(WEIGHT_DB_TRANSACTION_COMPLETE, "Error saving data. Please try refreshing.");
                        // Do not hide loading immediately on error, let user see message
                        // setTimeout(hideLoading, 3000);
                        alert("Failed to store initial data: " + event.target.error.message + "\nPlease clear website data (cache and site data for this page) and refresh.");
                    };

                    if (shouldLoadQuran && allQuranDataMap.size > 0) {
                        updateLoadingProgress(0, `Saving ${allQuranDataMap.size} Ayahs to database...`);
                        const quranStore = transaction.objectStore(STORE_QURAN);
                        if (needsUpdateDueToVersion || !(settingsLoadedQuran && settingsLoadedQuran.value === true)) { // Clear only if new load or version update
                           await new Promise(resolve => quranStore.clear().onsuccess = resolve); // Clear before repopulating
                        }
                        let count = 0;
                        for (const entry of allQuranDataMap.values()) {
                             quranStore.put(entry);
                             count++;
                             if (count % 500 === 0) updateLoadingProgress(500 * WEIGHT_DB_TRANSACTION_ITEM, `Saved ${count} Ayahs...`);
                        }
                        updateLoadingProgress((allQuranDataMap.size % 500) * WEIGHT_DB_TRANSACTION_ITEM, `Finished saving Ayahs.`);
                    }
                    if (shouldLoadWordTranslations && wordTranslationEntries.length > 0) {
                        updateLoadingProgress(0, `Saving ${wordTranslationEntries.length} word translations...`);
                        const store = transaction.objectStore(STORE_WORD_TRANSLATIONS);
                        if (needsUpdateDueToVersion || !(settingsLoadedWordTranslations && settingsLoadedWordTranslations.value === true)) {
                            await new Promise(resolve => store.clear().onsuccess = resolve);
                        }
                        let count = 0;
                        for (const entry of wordTranslationEntries) {
                             store.put(entry);
                             count++;
                             if (count % 2000 === 0) updateLoadingProgress(2000 * WEIGHT_DB_TRANSACTION_ITEM, `Saved ${count} word translations...`);
                        }
                        updateLoadingProgress((wordTranslationEntries.length % 2000) * WEIGHT_DB_TRANSACTION_ITEM, `Finished saving word translations.`);
                    }
                    if (shouldLoadWordMetadata && wordMetadataEntries.length > 0) {
                         updateLoadingProgress(0, `Saving ${wordMetadataEntries.length} word metadata entries...`);
                        const store = transaction.objectStore(STORE_WORD_METADATA);
                        if (needsUpdateDueToVersion || !(settingsLoadedWordMetadata && settingsLoadedWordMetadata.value === true)) {
                            await new Promise(resolve => store.clear().onsuccess = resolve);
                        }
                        let count = 0;
                        for (const entry of wordMetadataEntries) {
                             store.put(entry);
                             count++;
                             if (count % 2000 === 0) updateLoadingProgress(2000 * WEIGHT_DB_TRANSACTION_ITEM, `Saved ${count} word metadata entries...`);
                        }
                        updateLoadingProgress((wordMetadataEntries.length % 2000) * WEIGHT_DB_TRANSACTION_ITEM, `Finished saving word metadata.`);
                    }
                } else {
                     console.log("No new data needed to be fetched and stored. Initializing UI.");
                     quranDataLoaded = true;
                     await populateSurahAyahSelects();
                     await loadAyah(currentSurah, currentAyah);
                     // Ensure progress is marked as complete if we reached here.
                     const remainingUnits = totalProgressUnits - completedProgressUnits;
                     if (remainingUnits > 0) updateLoadingProgress(remainingUnits, "Data verification complete.");
                     setTimeout(hideLoading, 500);
                }

            } catch (error) {
                console.error("Error in loadQuranData:", error);
                // Make sure loading screen is shown with error if it wasn't already
                if (document.getElementById('loading-overlay').style.display === 'none') {
                     showLoading("Application Error", "An error occurred during initialization.", 100);
                } else {
                     updateLoadingProgress(0, "Critical error during setup.");
                }
                document.getElementById('loading-message-secondary').textContent = `Error: ${error.message}. Please try refreshing.`;
                document.getElementById('loading-message-secondary').style.color = 'var(--color-error, red)';
                // Do not hide loading immediately on critical error
                // setTimeout(hideLoading, 5000); // Or keep it shown
                alert("Failed to load application data: " + error.message + "\nIf the problem persists, try clearing website data for this page and then refresh.");
            }
            // The `finally` block is removed as hideLoading is now called conditionally
            // within the try or on transaction.oncomplete.
        }
        // --- UI Rendering and Navigation ---

        function populateSurahAyahSelects() {
            const surahSelect = document.getElementById('surah-select');
            const ayahSelect = document.getElementById('ayah-select');
            const recSurahSelect = document.getElementById('rec-surah-select');
            const hifzSurahSelect = document.getElementById('hifz-surah-select');

            if (surahSelect.options.length === 0) {
                for (let i = 1; i <= 114; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `${i}. ${surahNames[i - 1]}`;
                    surahSelect.appendChild(option.cloneNode(true));
                    recSurahSelect.appendChild(option.cloneNode(true));
                    hifzSurahSelect.appendChild(option.cloneNode(true));
                }
            }
            surahSelect.value = currentSurah;
            recSurahSelect.value = currentSurah;
            hifzSurahSelect.value = currentSurah;
            updateAyahSelect(currentSurah);
            ayahSelect.value = currentAyah;
        }

        function updateAyahSelect(surahNum) {
            const ayahSelect = document.getElementById('ayah-select');
            ayahSelect.innerHTML = '';
            totalAyahsInSurah = surahAyahCounts[surahNum];
            for (let i = 1; i <= totalAyahsInSurah; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                ayahSelect.appendChild(option);
            }
            if (currentAyah > totalAyahsInSurah) {
                currentAyah = 1;
            }
            ayahSelect.value = currentAyah;
        }

        async function loadAyah(surah, ayah) {
            if (!db) {
                console.error("Database not open for loadAyah.");
                document.getElementById('quran-display').innerHTML = `<p class="text-center" style="color: var(--color-error);">Database not ready. Please try again later.</p>`;
                return;
            }
            showLoading(`Loading Ayah ${surah}:${ayah}...`);
            try {
                const quran = await getData(STORE_QURAN, [surah, ayah]);
                const tafsir = await getData(STORE_TAFSIR, [surah, ayah]);

                const displayArea = document.getElementById('quran-display');
                const tafsirAyahDisplay = document.getElementById('current-ayah-tafsir');
                const themeAyahDisplay = document.getElementById('current-ayah-theme-text');
                const tafsirNotes = document.getElementById('tafsir-notes');

                displayArea.innerHTML = '';
                tafsirAyahDisplay.innerHTML = '';
                themeAyahDisplay.innerHTML = '';
                tafsirNotes.value = '';

                if (quran) {
                    currentSurah = surah;
                    currentAyah = ayah;
                    document.getElementById('surah-select').value = surah;
                    document.getElementById('ayah-select').value = ayah;
                    document.getElementById('rec-surah-select').value = surah;
                    document.getElementById('hifz-surah-select').value = surah;
                    updateAyahSelect(surah);

                    const ayahElement = document.createElement('div');
                    ayahElement.classList.add('ayah');
                    ayahElement.setAttribute('data-surah', surah);
                    ayahElement.setAttribute('data-ayah', ayah);

                    const ayahNumber = document.createElement('div');
                    ayahNumber.classList.add('ayah-number');
                    ayahNumber.textContent = `Surah ${surah}:${ayah} (${surahNames[surah-1]})`;
                    ayahElement.appendChild(ayahNumber);

                    const arabicTextElement = document.createElement('div');
                    arabicTextElement.classList.add('ayah-arabic');
                    arabicTextElement.setAttribute('lang', 'ar');
                    arabicTextElement.setAttribute('dir', 'rtl');

                    const words = quran.arabic.split(/\s+/).filter(w => w.trim() !== '');
                    words.forEach((wordText, index) => {
                        const span = document.createElement('span');
                        span.textContent = wordText + ' ';
                        span.setAttribute('data-word-text', wordText.trim());
                        span.setAttribute('data-word-position', index);
                        span.setAttribute('data-surah', surah);
                        span.setAttribute('data-ayah', ayah);
                        span.setAttribute('tabindex', '0');
                        span.setAttribute('role', 'button');
                        arabicTextElement.appendChild(span);
                    });
                    ayahElement.appendChild(arabicTextElement);

                    const translationText = document.createElement('div');
                    translationText.classList.add('ayah-translation');
                    const selectedTranslationKey = document.getElementById('translation-select').value;
                    const translationInfo = TRANSLATION_CONFIG[selectedTranslationKey];
                    if (translationInfo) {
                        translationText.setAttribute('lang', translationInfo.lang);
                        translationText.setAttribute('dir', translationInfo.dir);
                        translationText.style.fontFamily = `var(--font-${selectedTranslationKey})`;
                        translationText.style.textAlign = translationInfo.dir === 'rtl' ? 'right' : 'left';
                        translationText.textContent = quran[selectedTranslationKey] || "Translation not available.";
                    } else {
                        translationText.textContent = "Translation configuration error.";
                    }
                    ayahElement.appendChild(translationText);
                    displayArea.appendChild(ayahElement);

                    const tafsirAyahElement = ayahElement.cloneNode(true);
                    tafsirAyahElement.querySelector('.ayah-number').textContent = `Tafsir for Surah ${surah}:${ayah}`;
                    tafsirAyahElement.querySelectorAll('.ayah-arabic span').forEach(span => span.outerHTML = span.textContent);
                    tafsirAyahDisplay.innerHTML = '';
                    tafsirAyahDisplay.appendChild(tafsirAyahElement);
                    tafsirNotes.value = tafsir ? tafsir.notes : '';

                    const themeAyahElement = ayahElement.cloneNode(true);
                    themeAyahElement.querySelector('.ayah-number').textContent = `Ayah for Linking: Surah ${surah}:${ayah}`;
                    themeAyahElement.querySelectorAll('.ayah-arabic span').forEach(span => span.outerHTML = span.textContent);
                    themeAyahDisplay.innerHTML = '';
                    themeAyahDisplay.appendChild(themeAyahElement);
                    document.getElementById('current-ayah-theme-ref').textContent = `${surah}:${ayah}`;
                    await populateThemeSelects();
                    await displayLinkedAyahsForCurrentTheme();

                    addWordClickListeners();
                } else {
                    displayArea.innerHTML = `<p class="text-center" style="color: var(--color-error);">Ayah ${surah}:${ayah} not found in data.</p>`;
                    tafsirAyahDisplay.innerHTML = `<p class="text-center">Navigate to a valid Ayah to add Tafsir.</p>`;
                    themeAyahDisplay.innerHTML = `<p class="text-center">Navigate to a valid Ayah to link themes.</p>`;
                    document.getElementById('current-ayah-theme-ref').textContent = 'N/A';
                    tafsirNotes.value = '';
                }
                document.getElementById('word-translation-area').innerHTML = '<p class="text-center">Click on an Arabic word to see its translation.</p>';
            } catch (error) {
                console.error("Error loading ayah:", error);
                document.getElementById('quran-display').innerHTML = `<p class="text-center" style="color: var(--color-error);">Error loading Ayah: ${error.message}</p>`;
            } finally {
                hideLoading();
            }
        }

        function addWordClickListeners() {
            document.querySelectorAll('.ayah-arabic span').forEach(wordSpan => {
                wordSpan.removeEventListener('click', handleWordClick);
                wordSpan.addEventListener('click', handleWordClick);
                wordSpan.removeEventListener('focus', handleWordFocus);
                wordSpan.addEventListener('focus', handleWordFocus);
                wordSpan.removeEventListener('blur', handleWordBlur);
                wordSpan.addEventListener('blur', handleWordBlur);
            });
        }

        async function handleWordClick(event) {
            const wordSpan = event.target;
            const clickedWordActualText = wordSpan.getAttribute('data-word-text');
            const surahNum = parseInt(wordSpan.getAttribute('data-surah'), 10);
            const ayahNum = parseInt(wordSpan.getAttribute('data-ayah'), 10);
            const wordPosition = parseInt(wordSpan.getAttribute('data-word-position'), 10);

            if (!clickedWordActualText || isNaN(surahNum) || isNaN(ayahNum) || isNaN(wordPosition)) {
                console.warn("[handleWordClick] Clicked word span is missing required data attributes.", wordSpan.dataset);
                document.getElementById('word-translation-area').innerHTML = `<p style="color: var(--color-error);">Error: Could not identify clicked word's metadata.</p>`;
                return;
            }
            console.log(`[handleWordClick] Clicked: "${clickedWordActualText}" (S:${surahNum}, A:${ayahNum}, Pos:${wordPosition})`);

            const ayahElement = wordSpan.closest('.ayah');
            const fullAyahTranslationDiv = ayahElement.querySelector('.ayah-translation');
            const fullAyahTranslationText = fullAyahTranslationDiv ? fullAyahTranslationDiv.textContent : 'Full ayah translation not found.';

            const selectedFullTranslationKey = document.getElementById('translation-select').value;
            const fullTranslationInfo = TRANSLATION_CONFIG[selectedFullTranslationKey];
            const fullTranslationLabel = fullTranslationInfo ? fullTranslationInfo.label : 'Selected Translation';
            const fullTranslationLang = fullTranslationInfo ? fullTranslationInfo.lang : 'en';
            const fullTranslationDir = fullTranslationInfo ? fullTranslationInfo.dir : 'ltr';
            const fullTranslationFont = fullTranslationInfo ? `var(--font-${selectedFullTranslationKey})` : `var(--font-general)`;
            const fullTranslationTextAlign = fullTranslationInfo && fullTranslationInfo.dir === 'rtl' ? 'right' : 'left';

            let wordUrduMeaning = "N/A";
            let wordEnglishMeaning = "N/A";

            try {
                const metadataStore = getObjectStore(STORE_WORD_METADATA, 'readonly');
                const locationIndex = metadataStore.index('location_idx');
                const metadataRequest = locationIndex.get([surahNum, ayahNum, wordPosition]);

                const wordMetadataEntry = await new Promise((resolve, reject) => {
                    metadataRequest.onsuccess = () => resolve(metadataRequest.result);
                    metadataRequest.onerror = (e) => {
                        console.error("Error fetching from word_metadata:", e.target.error);
                        reject(e.target.error);
                    };
                });

                if (wordMetadataEntry && typeof wordMetadataEntry.word_id !== 'undefined') {
                    const word_id = wordMetadataEntry.word_id;
                    console.log(`[handleWordClick] Found word_id: ${word_id}`);
                    const translationEntry = await getData(STORE_WORD_TRANSLATIONS, word_id);
                    if (translationEntry) {
                        console.log(`[handleWordClick] Translation data for word_id ${word_id}:`, translationEntry);
                        wordUrduMeaning = translationEntry.ur_meaning || "N/A";
                        wordEnglishMeaning = translationEntry.en_meaning || "N/A";
                        if (translationEntry.ur_meaning === "") wordUrduMeaning = "N/A (empty)";
                        if (translationEntry.en_meaning === "") wordEnglishMeaning = "N/A (empty)";
                    } else {
                        console.warn(`[handleWordClick] No translation entry in '${STORE_WORD_TRANSLATIONS}' for word_id: ${word_id}.`);
                    }
                } else {
                    console.warn(`[handleWordClick] No metadata entry in '${STORE_WORD_METADATA}' for S${surahNum}:A${ayahNum}, Pos:${wordPosition}. Word: "${clickedWordActualText}"`);
                }
            } catch (error) {
                console.error("[handleWordClick] Error during word data lookup:", error);
                wordUrduMeaning = "Lookup Error";
                wordEnglishMeaning = "Lookup Error";
            }

            const translationArea = document.getElementById('word-translation-area');
            translationArea.innerHTML = `
                <p><strong>Selected Word:</strong> <span lang="ar" dir="rtl" style="font-family: var(--font-arabic); font-size: 1.2rem;">${clickedWordActualText}</span></p>
                <p><strong>Urdu Meaning:</strong> <span lang="ur" dir="rtl" style="font-family: var(--font-urdu);">${wordUrduMeaning}</span></p>
                <p><strong>English Meaning:</strong> <span lang="en" dir="ltr" style="font-family: var(--font-english);">${wordEnglishMeaning}</span></p>
                <p><strong>Full Ayah Translation (${surahNum}:${ayahNum}) - ${fullTranslationLabel}:</strong> <span lang="${fullTranslationLang}" dir="${fullTranslationDir}" style="font-family: ${fullTranslationFont}; text-align: ${fullTranslationTextAlign};">${fullAyahTranslationText}</span></p>
            `;
            document.querySelectorAll('.ayah-arabic span').forEach(span => {
                span.style.backgroundColor = 'transparent';
            });
            wordSpan.style.backgroundColor = 'var(--color-highlight)';
        }

        function handleWordFocus(event) {
             handleWordClick(event);
        }
        function handleWordBlur(event) {
             event.target.style.backgroundColor = 'transparent';
        }

        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
                section.setAttribute('aria-hidden', 'true');
            });
            const activeSection = document.getElementById(sectionId);
            if (activeSection) {
                activeSection.classList.add('active');
                activeSection.setAttribute('aria-hidden', 'false');
                activeSection.focus(); // For accessibility, focus the new section
            }

            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                link.setAttribute('aria-current', 'false');
            });
            const activeLink = document.querySelector(`.nav-link[data-section="${sectionId}"]`);
            if (activeLink) {
                activeLink.classList.add('active');
                activeLink.setAttribute('aria-current', 'page');
            }

             if (sectionId === 'themes') {
                 populateThemeSelects();
                 displayLinkedAyahsForCurrentTheme();
             } else if (sectionId === 'recitation') {
                 loadRecitationLogs();
             } else if (sectionId === 'hifz') {
                 const hifzSurahSelect = document.getElementById('hifz-surah-select');
                 if (hifzSurahSelect.value) {
                    loadHifzForSurah(parseInt(hifzSurahSelect.value, 10));
                 }
             }
        }

                function showLoading(primaryMessage, secondaryMessage = "Initializing...", initialPercentage = 0) {
            const loadingOverlay = document.getElementById('loading-overlay');
            const primaryMsgEl = document.getElementById('loading-message-primary');
            const secondaryMsgEl = document.getElementById('loading-message-secondary');
            const progressBarEl = document.getElementById('loading-progress-bar');
            const percentageEl = document.getElementById('loading-percentage');
            const firstTimeNoticeEl = document.getElementById('loading-first-time-notice');

            if (primaryMsgEl) primaryMsgEl.textContent = primaryMessage;
            if (secondaryMsgEl) secondaryMsgEl.textContent = secondaryMessage;
            if (progressBarEl) progressBarEl.style.width = `${initialPercentage}%`;
            if (percentageEl) percentageEl.textContent = `${initialPercentage}%`;
            
            // Update loading content colors based on current theme
            const currentTheme = document.body.className.includes('theme-manuscript') ? 'manuscript' :
                                 document.body.className.includes('theme-holo') ? 'holo' : 'serene';
            const loadingContent = loadingOverlay.querySelector('.loading-content');
            if (loadingContent) {
                if (currentTheme === 'holo') {
                    loadingContent.style.backgroundColor = 'var(--color-bg-secondary)'; // From holo theme
                    loadingContent.style.color = 'var(--color-text-primary)'; // From holo theme
                    if(document.getElementById('loading-progress-bar-container')) document.getElementById('loading-progress-bar-container').style.backgroundColor = '#26a69a';
                    if(progressBarEl) progressBarEl.style.backgroundColor = 'var(--color-accent)'; // From holo theme
                } else if (currentTheme === 'manuscript') {
                    loadingContent.style.backgroundColor = 'var(--color-bg-secondary)'; // From manuscript theme
                    loadingContent.style.color = 'var(--color-text-primary)'; // From manuscript theme
                     if(document.getElementById('loading-progress-bar-container')) document.getElementById('loading-progress-bar-container').style.backgroundColor = 'var(--color-border)';
                    if(progressBarEl) progressBarEl.style.backgroundColor = 'var(--color-accent)';
                } else { // Serene (default)
                    loadingContent.style.backgroundColor = 'var(--color-bg-secondary)';
                    loadingContent.style.color = 'var(--color-text-primary)';
                    if(document.getElementById('loading-progress-bar-container')) document.getElementById('loading-progress-bar-container').style.backgroundColor = 'var(--color-border)';
                    if(progressBarEl) progressBarEl.style.backgroundColor = 'var(--color-accent)';
                }
            }


            loadingOverlay.style.display = 'flex';
            document.body.setAttribute('aria-busy', 'true');
        }

        function updateLoadingProgress(unitsIncrement, secondaryMessage) {
            if (totalProgressUnits === 0) return; // Avoid division by zero if not set

            completedProgressUnits += unitsIncrement;
            const percentage = Math.min(100, Math.round((completedProgressUnits / totalProgressUnits) * 100));

            const secondaryMsgEl = document.getElementById('loading-message-secondary');
            const progressBarEl = document.getElementById('loading-progress-bar');
            const percentageEl = document.getElementById('loading-percentage');

            if (secondaryMsgEl) secondaryMsgEl.textContent = secondaryMessage;
            if (progressBarEl) progressBarEl.style.width = `${percentage}%`;
            if (percentageEl) percentageEl.textContent = `${percentage}%`;
            // console.log(`Progress: ${percentage}% - ${secondaryMessage}`); // For debugging
        }

        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
            document.body.setAttribute('aria-busy', 'false');
            // Reset progress for next time it might be shown (though typically one-time)
            completedProgressUnits = 0;
            totalProgressUnits = 0; // Reset this as well
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
            document.body.setAttribute('aria-busy', 'false');
        }

        function setStatusMessage(elementId, message, isError = false) {
            const statusElement = document.getElementById(elementId);
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.style.color = isError ? 'var(--color-error)' : 'var(--color-success)';
                statusElement.style.fontWeight = 'bold';
                setTimeout(() => {
                    statusElement.textContent = '';
                    statusElement.style.color = '';
                    statusElement.style.fontWeight = '';
                }, 7000);
            }
        }

        // --- Tafsir Functions ---
        async function saveTafsir() {
            if (!db) return;
            const notes = document.getElementById('tafsir-notes').value.trim();
            if (!notes) {
                setStatusMessage('tafsir-status', 'Tafsir notes cannot be empty.', true);
                return;
            }
            if (currentSurah === 0 || currentAyah === 0) {
                 setStatusMessage('tafsir-status', 'Navigate to an Ayah first.', true);
                 return;
            }
            showLoading(`Saving Tafsir for ${currentSurah}:${currentAyah}...`);
            try {
                await putData(STORE_TAFSIR, { surah: currentSurah, ayah: currentAyah, notes: notes });
                setStatusMessage('tafsir-status', `Tafsir saved for ${currentSurah}:${currentAyah}.`, false);
            } catch (error) {
                setStatusMessage('tafsir-status', 'Failed to save Tafsir.', true);
            } finally {
                hideLoading();
            }
        }

        // --- Thematic Linker Functions ---
        async function populateThemeSelects() {
            if (!db) return;
            const themeSelectElements = [
                document.getElementById('parent-theme-select'),
                document.getElementById('link-theme-select')
            ];
            try {
                const themes = await getAllData(STORE_THEMES);
                themeSelectElements.forEach(select => {
                    const preservedValue = select.value;
                    select.innerHTML = '';
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.textContent = select.id === 'parent-theme-select' ? "-- No Parent --" : "-- Select Theme --";
                    select.appendChild(defaultOption);
                    themes.forEach(theme => {
                        const option = document.createElement('option');
                        option.value = theme.id;
                        option.textContent = theme.name;
                        select.appendChild(option);
                    });
                    if (select.querySelector(`option[value="${preservedValue}"]`)) {
                        select.value = preservedValue;
                    } else {
                        select.value = "";
                    }
                });
            } catch (error) {
                setStatusMessage('theme-manager-status', 'Failed to load themes.', true);
            }
        }

        async function displayThemesList() {
             if (!db) return;
             const themesListElement = document.getElementById('themes-list');
             themesListElement.innerHTML = '';
             try {
                 const themes = await getAllData(STORE_THEMES);
                 if (themes.length === 0) {
                     themesListElement.innerHTML = '<li>No themes added yet.</li>';
                     return;
                 }
                 themes.forEach(theme => {
                     const li = document.createElement('li');
                     li.innerHTML = `
                         <span data-theme-id="${theme.id}" class="view-theme-ayahs" tabindex="0" role="button">${theme.name}</span>
                         <div class="theme-actions" style="display: inline-block;">
                             <button data-theme-id="${theme.id}" class="delete-theme-btn">Delete</button>
                         </div>
                     `;
                      themesListElement.appendChild(li);
                 });
                 themesListElement.querySelectorAll('.view-theme-ayahs').forEach(span => {
                     span.addEventListener('click', handleViewThemeAyahs);
                     span.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') handleViewThemeAyahs(e); });
                 });
                 themesListElement.querySelectorAll('.delete-theme-btn').forEach(button => {
                     button.addEventListener('click', handleDeleteTheme);
                 });
             } catch (error) {
                 themesListElement.innerHTML = `<li>Error loading themes: ${error.message}</li>`;
             }
        }

        async function addTheme() {
            if (!db) return;
            const nameInput = document.getElementById('new-theme-name');
            const parentSelect = document.getElementById('parent-theme-select');
            const name = nameInput.value.trim();
            const parentId = parentSelect.value ? parseInt(parentSelect.value, 10) : null;

            if (!name) {
                setStatusMessage('theme-manager-status', 'Theme name cannot be empty.', true);
                return;
            }
            showLoading("Adding theme...");
            try {
                await addData(STORE_THEMES, { name: name, parentId: parentId, description: '' }); // Add description field
                setStatusMessage('theme-manager-status', `Theme "${name}" added.`, false);
                nameInput.value = '';
                parentSelect.value = '';
                await populateThemeSelects();
                await displayThemesList();
            } catch (error) {
                 setStatusMessage('theme-manager-status', 'Failed to add theme.', true);
            } finally {
                hideLoading();
            }
        }

         async function handleDeleteTheme(event) {
             if (!db) return;
             const themeId = parseInt(event.target.getAttribute('data-theme-id'), 10);
             if (isNaN(themeId) || !confirm("Delete this theme and all its linked ayahs?")) return;

             showLoading("Deleting theme...");
             try {
                 await deleteData(STORE_THEMES, themeId);
                 const store = getObjectStore(STORE_THEME_AYAHS, 'readwrite');
                 const index = store.index('themeId');
                 const request = index.openCursor(IDBKeyRange.only(themeId));
                 request.onsuccess = (e) => {
                     const cursor = e.target.result;
                     if (cursor) {
                         cursor.delete();
                         cursor.continue();
                     } else {
                         setStatusMessage('theme-manager-status', 'Theme and linked ayahs deleted.', false);
                         populateThemeSelects();
                         displayThemesList();
                         hideLoading();
                     }
                 };
                 request.onerror = () => {
                     setStatusMessage('theme-manager-status', 'Theme deleted, but failed to delete all linked ayahs.', true);
                     hideLoading();
                 };
             } catch (error) {
                 setStatusMessage('theme-manager-status', 'Failed to delete theme.', true);
                 hideLoading();
             }
         }

        async function linkAyahToTheme() {
            if (!db) return;
            const themeSelect = document.getElementById('link-theme-select');
            const notesInput = document.getElementById('theme-link-notes');
            const themeId = themeSelect.value ? parseInt(themeSelect.value, 10) : null;
            const notes = notesInput.value.trim();

            if (!themeId) {
                setStatusMessage('theme-linker-status', 'Please select a theme.', true);
                return;
            }
            if (currentSurah === 0 || currentAyah === 0) {
                 setStatusMessage('theme-linker-status', 'Navigate to an Ayah first.', true);
                 return;
            }
            showLoading(`Linking Ayah ${currentSurah}:${currentAyah}...`);
            try {
                 const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                 const index = store.index('surahAyah');
                 const request = index.getAll(IDBKeyRange.only([currentSurah, currentAyah]));
                 const existingLinks = await new Promise(r => { request.onsuccess = () => r(request.result); });
                 if (existingLinks.some(link => link.themeId === themeId)) {
                     setStatusMessage('theme-linker-status', 'Ayah already linked to this theme.', true);
                 } else {
                    await addData(STORE_THEME_AYAHS, { themeId: themeId, surah: currentSurah, ayah: currentAyah, notes: notes });
                    setStatusMessage('theme-linker-status', `Ayah ${currentSurah}:${currentAyah} linked.`, false);
                    notesInput.value = '';
                    await displayLinkedAyahsForCurrentTheme();
                 }
            } catch (error) {
                 setStatusMessage('theme-linker-status', 'Failed to link Ayah.', true);
            } finally {
                hideLoading();
            }
        }

        async function handleViewThemeAyahs(event) {
             if (!db) return;
             const themeId = parseInt(event.target.getAttribute('data-theme-id'), 10);
             if (isNaN(themeId)) return;
             showLoading("Loading linked ayahs...");
             try {
                 const theme = await getData(STORE_THEMES, themeId);
                 if (!theme) {
                     setStatusMessage('theme-manager-status', 'Theme not found.', true); hideLoading(); return;
                 }
                 document.getElementById('modal-theme-name').textContent = theme.name;
                 const listEl = document.getElementById('modal-linked-ayahs-list');
                 listEl.innerHTML = '';
                 const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                 const index = store.index('themeId');
                 const request = index.openCursor(IDBKeyRange.only(themeId));
                 const linkedAyahs = [];
                 request.onsuccess = (e) => {
                     const cursor = e.target.result;
                     if (cursor) {
                         linkedAyahs.push(cursor.value);
                         cursor.continue();
                     } else {
                         if (linkedAyahs.length === 0) {
                             listEl.innerHTML = '<li>No ayahs linked yet.</li>';
                         } else {
                             linkedAyahs.sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                             linkedAyahs.forEach(link => {
                                 const li = document.createElement('li');
                                 li.innerHTML = `
                                     <strong>Surah ${link.surah}:${link.ayah}</strong>
                                     ${link.notes ? ` - <em>${link.notes}</em>` : ''}
                                     <button data-link-id="${link.id}" class="delete-theme-link-btn" style="margin-left: 10px;">Unlink</button>
                                 `;
                                 listEl.appendChild(li);
                             });
                             listEl.querySelectorAll('.delete-theme-link-btn').forEach(button => {
                                 button.addEventListener('click', handleDeleteThemeLink);
                             });
                         }
                         hideLoading();
                         document.getElementById('themeAyahsModal').style.display = 'flex';
                         document.getElementById('themeAyahsModal').querySelector('.modal-content').setAttribute('data-current-theme-id', themeId);
                         document.getElementById('themeAyahsModalTitle').focus();
                     }
                 };
                 request.onerror = () => { listEl.innerHTML = `<li>Error loading.</li>`; hideLoading(); };
             } catch (error) {
                 setStatusMessage('theme-manager-status', 'Failed to load theme details.', true); hideLoading();
             }
        }

         async function handleDeleteThemeLink(event) {
             if (!db) return;
             const linkId = parseInt(event.target.getAttribute('data-link-id'), 10);
             if (isNaN(linkId) || !confirm("Unlink this Ayah?")) return;
             showLoading("Unlinking Ayah...");
             try {
                 await deleteData(STORE_THEME_AYAHS, linkId);
                 setStatusMessage('theme-linker-status', 'Ayah unlinked.', false);
                 const modalContent = event.target.closest('.modal-content');
                 const currentModalThemeId = parseInt(modalContent.getAttribute('data-current-theme-id'), 10);
                 if (!isNaN(currentModalThemeId)) {
                     await displayLinkedAyahsForThemeInModal(currentModalThemeId);
                 } else {
                      document.getElementById('themeAyahsModal').style.display = 'none';
                      displayThemesList();
                 }
             } catch (error) {
                 setStatusMessage('theme-linker-status', 'Failed to unlink Ayah.', true);
             } finally {
                 hideLoading();
             }
         }

         async function displayLinkedAyahsForThemeInModal(themeId) {
             if (!db) return;
             const listEl = document.getElementById('modal-linked-ayahs-list');
             listEl.innerHTML = '';
             try {
                 const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                 const index = store.index('themeId');
                 const request = index.openCursor(IDBKeyRange.only(themeId));
                 const linkedAyahs = [];
                 request.onsuccess = (e) => {
                     const cursor = e.target.result;
                     if (cursor) {
                         linkedAyahs.push(cursor.value);
                         cursor.continue();
                     } else {
                         if (linkedAyahs.length === 0) { listEl.innerHTML = '<li>No ayahs linked.</li>'; }
                         else {
                             linkedAyahs.sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                             linkedAyahs.forEach(link => {
                                 const li = document.createElement('li');
                                 li.innerHTML = `
                                     <strong>Surah ${link.surah}:${link.ayah}</strong>
                                     ${link.notes ? ` - <em>${link.notes}</em>` : ''}
                                     <button data-link-id="${link.id}" class="delete-theme-link-btn">Unlink</button>
                                 `;
                                 listEl.appendChild(li);
                             });
                             listEl.querySelectorAll('.delete-theme-link-btn').forEach(b => b.addEventListener('click', handleDeleteThemeLink));
                         }
                     }
                 };
                 request.onerror = () => { listEl.innerHTML = `<li>Error refreshing list.</li>`; };
             } catch (error) { listEl.innerHTML = `<li>Error: ${error.message}</li>`; }
         }

         async function displayLinkedAyahsForCurrentTheme() {
             if (!db) return;
             const themeSelect = document.getElementById('link-theme-select');
             const themeId = themeSelect.value ? parseInt(themeSelect.value, 10) : null;
             const listEl = document.getElementById('linked-ayahs-list');
             const nameEl = document.getElementById('linked-theme-name');
             listEl.innerHTML = '';

             if (!themeId) {
                 nameEl.textContent = 'N/A';
                 listEl.innerHTML = '<li>Select a theme to see linked ayahs.</li>';
                 return;
             }
             showLoading("Loading linked ayahs...");
             try {
                 const theme = await getData(STORE_THEMES, themeId);
                 nameEl.textContent = theme ? theme.name : 'Unknown';
                 const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                 const index = store.index('themeId');
                 const request = index.openCursor(IDBKeyRange.only(themeId));
                 const linkedAyahs = [];
                 request.onsuccess = (e) => {
                     const cursor = e.target.result;
                     if (cursor) {
                         linkedAyahs.push(cursor.value);
                         cursor.continue();
                     } else {
                         if (linkedAyahs.length === 0) { listEl.innerHTML = '<li>No ayahs linked.</li>'; }
                         else {
                             linkedAyahs.sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                             linkedAyahs.forEach(link => {
                                 const li = document.createElement('li');
                                 li.innerHTML = `<strong>S ${link.surah}:${link.ayah}</strong> ${link.notes ? `- <em>${link.notes}</em>` : ''}`;
                                 listEl.appendChild(li);
                             });
                         }
                         hideLoading();
                     }
                 };
                 request.onerror = () => { listEl.innerHTML = `<li>Error loading.</li>`; hideLoading(); };
             } catch (error) {
                 nameEl.textContent = 'Error'; listEl.innerHTML = `<li>Error: ${error.message}</li>`; hideLoading();
             }
         }


        // --- Root Word Analyzer Functions --- (Simplified: String Search)
         async function analyzeRoot() {
             if (!db) return;
             const rootInput = document.getElementById('root-input');
             const rootTerm = rootInput.value.trim();
             const analyzedRootTermElement = document.getElementById('analyzed-root-term');
             const occurrencesListElement = document.getElementById('root-occurrences-list');

             analyzedRootTermElement.textContent = rootTerm || 'N/A';
             occurrencesListElement.innerHTML = ''; // Clear previous results

             if (!rootTerm) {
                 setStatusMessage('root-status', 'Please enter an Arabic root word.', true);
                 return;
             }
             if (rootTerm.length < 2) {
                 setStatusMessage('root-status', 'Root term should be at least 2 characters.', true);
                 return;
             }

             showLoading(`Analyzing root "${rootTerm}"...`);
             try {
                 const allAyahs = await getAllData(STORE_QURAN);
                 const foundOccurrences = [];

                 // Perform a simple string search in Arabic text
                 // This is a simplified approach, not a true morphological analysis
                 const searchRegex = new RegExp(rootTerm, 'g'); // 'g' for global search

                 allAyahs.forEach(ayahData => {
                     // Split words and check each word individually
                     const words = ayahData.arabic.split(/\s+/);
                     words.forEach(word => {
                         wordan = word.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").replace(/ؤ|و/g, "(و|ؤ)").replace(/ك|ک/g, "(ك|ک)").replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)").replace(/ى|ی|ي/g, "(ى|ی|ي)").replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)").replace(/ے/g, "(ے|ی)").replace(/م/g, "(مٰ|م)");
                        wordan2 = word.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"")

                         

                         rootTerma1 = rootTerm.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").replace(/ؤ|و/g, "(و|ؤ)").replace(/ك|ک/g, "(ك|ک)").replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)").replace(/ى|ی|ي/g, "(ى|ی|ي)").replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)").replace(/ے/g, "(ے|ی)").replace(/م/g, "(مٰ|م)").replaceAll(" ",".{0,1}").replaceAll("-",".{0,1}").replaceAll("-",".{0,1}");
                         
                         rootTerma = rootTerm.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").replace(/ؤ|و/g, "(و|ؤ)").replace(/ك|ک/g, "(ك|ک)").replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)").replace(/ى|ی|ي/g, "(ى|ی|ي)").replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)").replace(/ے/g, "(ے|ی)").replace(/م/g, "(مٰ|م)").replaceAll(" ","").replaceAll("-","").replaceAll("-","");
                        
                         //console.log(wordan.match(/rootTerma/)!=undefined);
                         rootTerma1 = new RegExp(rootTerma1)
                         //console.log(rootTerma1 +"\n"+ wordan2)
                         if (wordan2.match(rootTerma1)!=undefined || wordan.includes(rootTerma)) {
                             foundOccurrences.push({
                                 surah: ayahData.surah,
                                 ayah: ayahData.ayah,
                                 word: word, // The specific word found
                                 context: ayahData.arabic // Full ayah context
                             });
                         }
                     });
                 });

                 if (foundOccurrences.length === 0) {
                     occurrencesListElement.innerHTML = '<li>No occurrences found.</li>';
                     setStatusMessage('root-status', `No occurrences found for "${rootTerm}".`, false);
                 } else {
                     setStatusMessage('root-status', `Found ${foundOccurrences.length} occurrences for "${rootTerm}".`, false);
                     foundOccurrences.forEach(occ => {
                         const li = document.createElement('li');
                         li.innerHTML = `
                             <strong>Surah ${occ.surah}:${occ.ayah}</strong> - Word: <span lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.word}</span>
                             <div class="result-context" lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.context}</div>
                         `;
                         occurrencesListElement.appendChild(li);
                     });
                 }

             } catch (error) {
                 console.error("Error analyzing root:", error);
                 setStatusMessage('root-status', 'Failed to analyze root.', true);
                 occurrencesListElement.innerHTML = `<li>Error analyzing root: ${error.message}</li>`;
             } finally {
                 hideLoading();
             }
        }

        async function saveRootNotes() {
             if (!db) return;
             const rootInput = document.getElementById('root-input');
             const descriptionInput = document.getElementById('root-description');
             const rootTerm = rootInput.value.trim();
             const description = descriptionInput.value.trim();

             if (!rootTerm) {
                 setStatusMessage('root-status', 'Enter root word to save notes.', true);
                 return;
             }
             showLoading("Saving root notes...");
             try {
                 const allRoots = await getAllData(STORE_ROOTS);
                 let existingRoot = allRoots.find(r => r.root === rootTerm);
                 if (existingRoot) {
                     existingRoot.description = description;
                     await putData(STORE_ROOTS, existingRoot);
                     setStatusMessage('root-status', `Notes updated for "${rootTerm}".`, false);
                 } else {
                     await addData(STORE_ROOTS, { root: rootTerm, description: description });
                     setStatusMessage('root-status', `Root "${rootTerm}" and notes saved.`, false);
                 }
             } catch (error) {
                 setStatusMessage('root-status', 'Failed to save root notes.', true);
             } finally {
                 hideLoading();
             }
        }


        // --- Recitation Log Functions ---
        async function loadRecitationLogs() {
             if (!db) return;
             const listEl = document.getElementById('recitations-list');
             listEl.innerHTML = '';
             showLoading("Loading recitation logs...");
             try {
                 const logs = await getAllData(STORE_RECITATIONS);
                 if (logs.length === 0) {
                     listEl.innerHTML = '<li>No entries logged yet.</li>'; hideLoading(); return;
                 }
                 logs.sort((a, b) => new Date(b.date) - new Date(a.date));
                 logs.forEach(log => {
                     const li = document.createElement('li');
                     const range = log.ayahStart && log.ayahEnd ? `Ayahs ${log.ayahStart}-${log.ayahEnd}` :
                                   log.ayahStart ? `Ayah ${log.ayahStart}` : 'Full Surah';
                     li.innerHTML = `
                         <strong>S ${log.surah} (${surahNames[log.surah-1]})</strong> - ${range} <br>
                         Qari: ${log.qari || 'N/A'} | Date: ${log.date || 'N/A'}
                         ${log.notes ? `<br>Notes: <em>${log.notes}</em>` : ''}
                         <div style="margin-top: 5px;">
                             <button data-log-id="${log.id}" class="delete-recitation-btn">Delete</button>
                         </div>
                     `;
                     listEl.appendChild(li);
                 });
                 listEl.querySelectorAll('.delete-recitation-btn').forEach(b => b.addEventListener('click', handleDeleteRecitationLog));
             } catch (error) {
                 listEl.innerHTML = `<li>Error: ${error.message}</li>`;
             } finally {
                 hideLoading();
             }
        }

        async function saveRecitationLog() {
            if (!db) return;
            const surah = parseInt(document.getElementById('rec-surah-select').value, 10);
            const ayahStart = document.getElementById('rec-ayah-start').value ? parseInt(document.getElementById('rec-ayah-start').value, 10) : null;
            const ayahEnd = document.getElementById('rec-ayah-end').value ? parseInt(document.getElementById('rec-ayah-end').value, 10) : null;
            const qari = document.getElementById('rec-qari').value.trim();
            const date = document.getElementById('rec-date').value;
            const notes = document.getElementById('rec-notes').value.trim();

            if (isNaN(surah)) { setStatusMessage('recitation-status', 'Select Surah.', true); return; }
            if (!date) { setStatusMessage('recitation-status', 'Select date.', true); return; }
            if (ayahStart && (isNaN(ayahStart) || ayahStart < 1 || ayahStart > surahAyahCounts[surah])) {
                setStatusMessage('recitation-status', `Invalid Ayah Start.`, true); return;
            }
            if (ayahEnd && (isNaN(ayahEnd) || ayahEnd < 1 || ayahEnd > surahAyahCounts[surah])) {
                setStatusMessage('recitation-status', `Invalid Ayah End.`, true); return;
            }
            if (ayahStart && ayahEnd && ayahStart > ayahEnd) {
                setStatusMessage('recitation-status', 'Start Ayah > End Ayah.', true); return;
            }

            showLoading("Saving recitation log...");
            try {
                await addData(STORE_RECITATIONS, { surah, ayahStart, ayahEnd, qari, date, notes });
                setStatusMessage('recitation-status', 'Log entry saved.', false);
                ['rec-ayah-start', 'rec-ayah-end', 'rec-qari', 'rec-date', 'rec-notes'].forEach(id => document.getElementById(id).value = '');
                loadRecitationLogs();
            } catch (error) {
                setStatusMessage('recitation-status', 'Failed to save log.', true);
            } finally {
                hideLoading();
            }
        }

         async function handleDeleteRecitationLog(event) {
             if (!db) return;
             const logId = parseInt(event.target.getAttribute('data-log-id'), 10);
             if (isNaN(logId) || !confirm("Delete this log entry?")) return;
             showLoading("Deleting log entry...");
             try {
                 await deleteData(STORE_RECITATIONS, logId);
                 setStatusMessage('recitation-status', 'Log entry deleted.', false);
                 loadRecitationLogs();
             } catch (error) {
                 setStatusMessage('recitation-status', 'Failed to delete log.', true);
             } finally {
                 hideLoading();
             }
         }

        // --- Memorization Hub Functions ---
        async function loadHifzForSurah(surah) {
             if (!db) return;
             const listEl = document.getElementById('hifz-ayahs-list');
             listEl.innerHTML = '';
             if (isNaN(surah) || surah < 1 || surah > 114) {
                 listEl.innerHTML = '<p class="text-center">Select a valid Surah.</p>'; return;
             }
             showLoading(`Loading Hifz for Surah ${surah}...`);
             try {
                 const totalAyahs = surahAyahCounts[surah];
                 const store = getObjectStore(STORE_HIFZ, 'readonly');
                 const request = store.getAll(IDBKeyRange.bound([surah, 1], [surah, totalAyahs]));
                 const hifzEntries = await new Promise(r => { request.onsuccess = () => r(request.result); });
                 const hifzMap = new Map(hifzEntries.map(e => [e.ayah, e]));

                 for (let i = 1; i <= totalAyahs; i++) {
                     const ayahData = hifzMap.get(i) || { surah, ayah: i, status: 'not-started', lastReviewDate: null, nextReviewDate: null, reviewCount: 0, notes: '' };
                     const li = document.createElement('div');
                     li.classList.add('ayah');
                     li.innerHTML = `
                         <div class="ayah-number">S ${surah}:${i}</div>
                         <div class="hifz-ayah-controls">
                             Status: <span class="hifz-ayah-status status-${ayahData.status}">${ayahData.status.replace('-', ' ')}</span>
                             ${ayahData.nextReviewDate ? ` | Next Review: ${ayahData.nextReviewDate}` : ''} <br>
                             <button data-surah="${surah}" data-ayah="${i}" data-status="in-progress" class="set-hifz-status-btn">In Progress</button>
                             <button data-surah="${surah}" data-ayah="${i}" data-status="memorized" class="set-hifz-status-btn">Memorized</button>
                             ${ayahData.status === 'memorized' ? `<button data-surah="${surah}" data-ayah="${i}" class="record-review-btn">Record Review</button>` : ''}
                             <button data-surah="${surah}" data-ayah="${i}" class="view-hifz-notes-btn">Notes</button>
                         </div>
                     `;
                     listEl.appendChild(li);
                 }
                 listEl.querySelectorAll('.set-hifz-status-btn').forEach(b => b.addEventListener('click', handleSetHifzStatus));
                 listEl.querySelectorAll('.record-review-btn').forEach(b => b.addEventListener('click', handleRecordReview));
                 listEl.querySelectorAll('.view-hifz-notes-btn').forEach(b => b.addEventListener('click', handleViewHifzNotes));
             } catch (error) {
                 listEl.innerHTML = `<li>Error: ${error.message}</li>`;
             } finally {
                 hideLoading();
             }
        }

        async function handleSetHifzStatus(event) {
             if (!db) return;
             const surah = parseInt(event.target.getAttribute('data-surah'), 10);
             const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
             const status = event.target.getAttribute('data-status');
             showLoading(`Setting status for ${surah}:${ayah}...`);
             try {
                 const existing = await getData(STORE_HIFZ, [surah, ayah]) || { surah, ayah, status: 'not-started', lastReviewDate: null, nextReviewDate: null, reviewCount: 0, notes: '' };
                 existing.status = status;
                 if (status !== 'memorized') {
                     existing.lastReviewDate = null; existing.nextReviewDate = null; existing.reviewCount = 0;
                 } else if (!existing.lastReviewDate) {
                     existing.lastReviewDate = new Date().toISOString().split('T')[0];
                     existing.reviewCount = 0;
                     existing.nextReviewDate = calculateNextReview(existing.lastReviewDate, existing.reviewCount);
                 }
                 await putData(STORE_HIFZ, existing);
                 setStatusMessage('hifz-status', `Status updated for ${surah}:${ayah}.`, false);
                 loadHifzForSurah(surah);
             } catch (error) {
                 setStatusMessage('hifz-status', 'Failed to update status.', true);
             } finally {
                 hideLoading();
             }
        }

        async function handleRecordReview(event) {
             if (!db) return;
             const surah = parseInt(event.target.getAttribute('data-surah'), 10);
             const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
             showLoading(`Recording review for ${surah}:${ayah}...`);
             try {
                 const existing = await getData(STORE_HIFZ, [surah, ayah]);
                 if (!existing || existing.status !== 'memorized') {
                     setStatusMessage('hifz-status', 'Ayah not memorized.', true); hideLoading(); return;
                 }
                 existing.lastReviewDate = new Date().toISOString().split('T')[0];
                 existing.reviewCount = (existing.reviewCount || 0) + 1;
                 existing.nextReviewDate = calculateNextReview(existing.lastReviewDate, existing.reviewCount);
                 await putData(STORE_HIFZ, existing);
                 setStatusMessage('hifz-status', `Review recorded. Next: ${existing.nextReviewDate}`, false);
                 loadHifzForSurah(surah);
             } catch (error) {
                 setStatusMessage('hifz-status', 'Failed to record review.', true);
             } finally {
                 hideLoading();
             }
        }

        function calculateNextReview(lastReviewDate, reviewCount) {
            const date = new Date(lastReviewDate);
            let daysToAdd = [1, 3, 7, 15, 30, 60, 90][Math.min(reviewCount, 6)] || 120; // Cap at 120 or extend
            date.setDate(date.getDate() + daysToAdd);
            return date.toISOString().split('T')[0];
        }

         async function handleViewHifzNotes(event) {
             if (!db) return;
             const surah = parseInt(event.target.getAttribute('data-surah'), 10);
             const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
             showLoading(`Loading notes for ${surah}:${ayah}...`);
             try {
                 const existing = await getData(STORE_HIFZ, [surah, ayah]) || { surah, ayah, status: 'not-started', notes: '' };
                 const notes = prompt(`Notes for Surah ${surah}:${ayah}:\n${existing.notes}\nEdit notes:`, existing.notes || '');
                 if (notes !== null && notes !== existing.notes) {
                     existing.notes = notes;
                     await putData(STORE_HIFZ, existing);
                     setStatusMessage('hifz-status', `Notes updated.`, false);
                     loadHifzForSurah(surah);
                 } else {
                      setStatusMessage('hifz-status', 'Notes unchanged.', false);
                 }
             } catch (error) {
                 setStatusMessage('hifz-status', 'Failed to load/save notes.', true);
             } finally {
                 hideLoading();
             }
         }


        // --- Advanced Search Functions ---
         async function performSearch() {
             if (!db) return;
             const searchTerm = document.getElementById('search-input').value.trim().toLowerCase();
             const searchScopes = Array.from(document.querySelectorAll('.search-scope:checked')).map(cb => cb.value);
             const searchResultsList = document.getElementById('search-results-list');
             searchResultsList.innerHTML = '';

             if (!searchTerm) {
                 setStatusMessage('search-status', 'Please enter a search term.', true);
                 return;
             }
             if (searchScopes.length === 0) {
                 setStatusMessage('search-status', 'Please select at least one search scope.', true);
                 return;
             }

             showLoading(`Searching for "${searchTerm}"...`);
             try {
                 const results = [];

                 // Search Quran text and translation
                 if (searchScopes.includes('quran-arabic') || searchScopes.includes('quran-translation')) {
                     const allAyahs = await getAllData(STORE_QURAN);
                     allAyahs.forEach(ayah => {
                         const normalizedSearchTerm = searchTerm.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").replace(/ؤ|و/g, "(و|ؤ)").replace(/ك|ک/g, "(ك|ک)").replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)").replace(/ى|ی|ي/g, "(ى|ی|ي)").replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)").replace(/ے/g, "(ے|ی)").replace(/م/g, "(مٰ|م)");

                         const matchArabic = searchScopes.includes('quran-arabic') &&
                                             ayah.arabic.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").replace(/ؤ|و/g, "(و|ؤ)").replace(/ك|ک/g, "(ك|ک)").replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)").replace(/ى|ی|ي/g, "(ى|ی|ي)").replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)").replace(/ے/g, "(ے|ی)").replace(/م/g, "(مٰ|م)").includes(normalizedSearchTerm);

                         let matchTranslation = false;
                         let translationSource = '';
                         let allTranslationsContext = [];

                         if (searchScopes.includes('quran-translation')) {
                             for (const langKey in TRANSLATION_CONFIG) {
                                 // Check if the ayah object has this translation field and if it matches
                                 if (ayah[langKey] && ayah[langKey].toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").includes(normalizedSearchTerm)) {
                                     matchTranslation = true;
                                     translationSource = TRANSLATION_CONFIG[langKey].label; // Get human-readable label
                                 }
                                 // Add all available translations to context string regardless of match
                                 if (ayah[langKey]) {
                                     allTranslationsContext.push(`${TRANSLATION_CONFIG[langKey].label}: ${ayah[langKey]}`);
                                 }
                             }
                         }

                         if (matchArabic || matchTranslation) {
                             results.push({
                                 type: 'Quran',
                                 ref: `Surah ${ayah.surah}:${ayah.ayah}`,
                                 surah: ayah.surah,
                                 ayah: ayah.ayah,
                                 context: `${ayah.arabic}${allTranslationsContext.length > 0 ? ' - ' + allTranslationsContext.join(' - ') : ''}`,
                                 source: matchArabic && matchTranslation ? `Arabic & Translation (${translationSource})` : matchArabic ? 'Arabic' : `Translation (${translationSource})`
                             });
                         }
                     });
                 }

                 // Search Personal Tafsir
                 if (searchScopes.includes('tafsir')) {
                     const allTafsir = await getAllData(STORE_TAFSIR);
                     allTafsir.forEach(tafsir => {
                         if (tafsir.notes && tafsir.notes.toLowerCase().includes(searchTerm)) {
                             results.push({
                                 type: 'Tafsir',
                                 ref: `Surah ${tafsir.surah}:${tafsir.ayah}`,
                                 surah: tafsir.surah,
                                 ayah: tafsir.ayah,
                                 context: tafsir.notes,
                                 source: 'Personal Tafsir'
                             });
                         }
                     });
                 }

                 // Search Theme Notes (assuming theme description/notes field exists)
                 if (searchScopes.includes('themes')) {
                     const allThemes = await getAllData(STORE_THEMES);
                     allThemes.forEach(theme => {
                         if (theme.description && theme.description.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").includes(searchTerm)) {
                              results.push({
                                 type: 'Theme',
                                 ref: `Theme: ${theme.name}`,
                                 context: theme.description,
                                 source: 'Theme Description'
                             });
                         }
                     });
                     // Also search notes on theme-ayah links
                     const allThemeAyahLinks = await getAllData(STORE_THEME_AYAHS);
                      const themesMap = new Map((await getAllData(STORE_THEMES)).map(t => [t.id, t.name]));
                     allThemeAyahLinks.forEach(link => {
                         if (link.notes && link.notes.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").includes(searchTerm)) {
                              results.push({
                                 type: 'Theme Link',
                                 ref: `Surah ${link.surah}:${link.ayah} (Theme: ${themesMap.get(link.themeId) || 'Unknown'})`,
                                 surah: link.surah,
                                 ayah: link.ayah,
                                 context: link.notes,
                                 source: 'Theme Link Notes'
                             });
                         }
                     });
                 }

                 // Search Root Notes (assuming root description/notes field exists)
                 if (searchScopes.includes('roots')) {
                     const allRoots = await getAllData(STORE_ROOTS);
                     allRoots.forEach(root => {
                         if (root.description && root.description.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").includes(searchTerm)) { // Assuming 'description' is the notes field
                             results.push({
                                 type: 'Root',
                                 ref: `Root: ${root.root}`,
                                 context: root.description,
                                 source: 'Root Notes'
                             });
                         }
                     });
                      // Could also list specific ayah occurrences if needed, but the main root analysis section does this.
                 }

                 // Search Recitation Notes
                 if (searchScopes.includes('recitation')) {
                     const allRecitations = await getAllData(STORE_RECITATIONS);
                     allRecitations.forEach(log => {
                         if (log.notes && log.notes.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").includes(searchTerm)) {
                              const range = log.ayahStart && log.ayahEnd ? `${log.ayahStart}-${log.ayahEnd}` :
                                   log.ayahStart ? `${log.ayahStart}` :
                                   log.ayahEnd ? `Up to ${log.ayahEnd}` : 'Full Surah';
                             results.push({
                                 type: 'Recitation Log',
                                 ref: `Surah ${log.surah} (${range})`,
                                 context: log.notes,
                                 source: 'Recitation Notes'
                             });
                         }
                     });
                 }

                 // Search Hifz Notes
                 if (searchScopes.includes('hifz')) {
                     const allHifz = await getAllData(STORE_HIFZ);
                     allHifz.forEach(hifz => {
                         if (hifz.notes && hifz.notes.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").includes(searchTerm)) {
                             results.push({
                                 type: 'Hifz',
                                 ref: `Surah ${hifz.surah}:${hifz.ayah}`,
                                  surah: hifz.surah,
                                  ayah: hifz.ayah,
                                 context: hifz.notes,
                                 source: 'Hifz Notes'
                             });
                         }
                     });
                 }


                 if (results.length === 0) {
                     searchResultsList.innerHTML = '<li>No results found.</li>';
                     setStatusMessage('search-status', `No results found for "${searchTerm}".`, false);
                 } else {
                     setStatusMessage('search-status', `Found ${results.length} results for "${searchTerm}".`, false);
                      // Sort Quran/Hifz results by Surah/Ayah
                     results.sort((a, b) => {
                         if (a.surah && b.surah && a.surah !== b.surah) return a.surah - b.surah;
                         if (a.ayah && b.ayah) return a.ayah - b.ayah;
                         return 0; // Don't sort other types
                     });

                     results.forEach(result => {
                         const li = document.createElement('li');
                         li.innerHTML = `
                             <strong>${result.type}: ${result.ref}</strong> (${result.source})
                             <div class="result-context">${highlightMatch(result.context, searchTerm)}</div>
                             ${(result.type === 'Quran' || result.type === 'Tafsir' || result.type === 'Hifz') ?
                                `<button data-surah="${result.surah}" data-ayah="${result.ayah}" class="go-to-ayah-btn" style="margin-top: 5px; padding: 3px 8px; font-size: 0.8rem;">Go to Ayah</button>` : ''}
                         `;
                         searchResultsList.appendChild(li);
                     });

                     // Add listeners for "Go to Ayah" buttons
                     searchResultsList.querySelectorAll('.go-to-ayah-btn').forEach(button => {
                         button.addEventListener('click', handleGoToAyahFromSearch);
                     });
                 }

             } catch (error) {
                 console.error("Error during search:", error);
                 setStatusMessage('search-status', 'Failed to perform search.', true);
                 searchResultsList.innerHTML = `<li>Error during search: ${error.message}</li>`;
             } finally {
                 hideLoading();
             }
        }


        function highlightMatch(text, searchTerm) {
            if (!text || !searchTerm) return text;
            const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        async function handleGoToAyahFromSearch(event) {
             const surah = parseInt(event.target.getAttribute('data-surah'), 10);
             const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
             if (!isNaN(surah) && !isNaN(ayah)) {
                 await loadAyah(surah, ayah);
                 showSection('quran');
             }
        }


        // --- Data Export/Import ---
        async function exportData() {
             if (!db) return;
             showLoading("Exporting data...");
             try {
                 const data = {};
                 const userStores = [STORE_TAFSIR, STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS, STORE_HIFZ];
                 for (const storeName of userStores) {
                     data[storeName] = await getAllData(storeName);
                 }
                 const jsonString = JSON.stringify(data, null, 2);
                 const blob = new Blob([jsonString], { type: 'application/json' });
                 const url = URL.createObjectURL(blob);
                 const a = document.createElement('a');
                 a.href = url;
                 a.download = `nur-al-quran-studio-backup-${new Date().toISOString().split('T')[0]}.json`;
                 document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                 setStatusMessage('export-status', 'Data exported.', false);
             } catch (error) {
                 setStatusMessage('export-status', 'Export failed.', true);
             } finally {
                 hideLoading();
             }
        }

        async function importData(file) {
             if (!db || !file || !confirm("Importing will overwrite existing data. Continue?")) return;
             showLoading("Importing data...");
             try {
                 const reader = new FileReader();
                 reader.onload = async (event) => {
                     try {
                         const data = JSON.parse(event.target.result);
                         const userStores = [STORE_TAFSIR, STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS, STORE_HIFZ];
                         for (const storeName of userStores) {
                             if (!Array.isArray(data[storeName])) throw new Error(`Invalid data for ${storeName}`);
                         }
                         const transaction = db.transaction(userStores, 'readwrite');
                         transaction.oncomplete = async () => {
                             setStatusMessage('import-status', 'Data imported.', false);
                             await loadAyah(currentSurah, currentAyah); // Refresh UI
                             displayThemesList(); loadRecitationLogs();
                             if(document.getElementById('hifz-surah-select').value) loadHifzForSurah(parseInt(document.getElementById('hifz-surah-select').value,10));
                             hideLoading();
                         };
                         transaction.onerror = () => { setStatusMessage('import-status', 'Import transaction failed.', true); hideLoading(); };
                         for (const storeName of userStores) {
                             const store = transaction.objectStore(storeName);
                             store.clear();
                             if (data[storeName]) {
                                data[storeName].forEach(item => {
                                    // For auto-increment stores, remove old ID if present to let DB assign new.
                                    // This simplified import might break ID-based relationships if IDs aren't managed carefully.
                                    if ([STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS].includes(storeName)) {
                                        const newItem = {...item};
                                        delete newItem.id; // Let DB assign new ID
                                        store.add(newItem).catch(e => console.warn(`Could not add item to ${storeName} during import: `, item, e));
                                    } else {
                                        store.put(item).catch(e => console.warn(`Could not put item to ${storeName} during import: `, item, e));
                                    }
                                });
                             }
                         }
                     } catch (parseError) {
                         setStatusMessage('import-status', 'Invalid import file format.', true); hideLoading();
                     }
                 };
                 reader.onerror = () => { setStatusMessage('import-status', 'Failed to read file.', true); hideLoading(); };
                 reader.readAsText(file);
             } catch (error) {
                 setStatusMessage('import-status', 'Import initiation failed.', true); hideLoading();
             }
        }

         async function clearAllPersonalData() {
             if (!db || !confirm("DELETE ALL personal data? This cannot be undone.")) return;
             showLoading("Clearing all personal data...");
             try {
                 const userStores = [STORE_TAFSIR, STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS, STORE_HIFZ];
                 const transaction = db.transaction(userStores, 'readwrite');
                 transaction.oncomplete = () => {
                     setStatusMessage('clear-status', 'All personal data cleared.', false);
                     // Reset UI elements
                     document.getElementById('tafsir-notes').value = '';
                     document.getElementById('themes-list').innerHTML = '<li>No themes added yet.</li>';
                     document.getElementById('root-occurrences-list').innerHTML = '<li>Enter a root word and click "Analyze Root".</li>';
                     document.getElementById('recitations-list').innerHTML = '<li>No entries logged yet.</li>';
                     document.getElementById('hifz-ayahs-list').innerHTML = '<p class="text-center">Select a Surah to track Hifz progress.</p>';
                     populateThemeSelects();
                     hideLoading();
                 };
                 transaction.onerror = () => { setStatusMessage('clear-status', 'Failed to clear data.', true); hideLoading(); };
                 userStores.forEach(storeName => transaction.objectStore(storeName).clear());
             } catch (error) {
                 setStatusMessage('clear-status', 'Data clear failed.', true); hideLoading();
             }
         }

        // --- Settings Functions ---
        function applyTheme(themeName) {
            document.body.className = '';
            if (themeName !== 'serene') document.body.classList.add(`theme-${themeName}`);
            if (db) putData(STORE_SETTINGS, { name: 'theme', value: themeName }).catch(console.error);
        }
        async function loadThemePreference() {
             if (!db) return;
             try {
                 const settings = await getData(STORE_SETTINGS, 'theme');
                 const theme = settings ? settings.value : 'serene';
                 document.getElementById('theme-switcher').value = theme;
                 applyTheme(theme);
             } catch (error) { // Fallback to default
                 document.getElementById('theme-switcher').value = 'serene'; applyTheme('serene');
             }
        }


        // --- Event Listeners Setup ---
        function setupEventListeners() {
            document.getElementById('surah-select').addEventListener('change', (event) => {
                currentSurah = parseInt(event.target.value, 10);
                updateAyahSelect(currentSurah);
                loadAyah(currentSurah, currentAyah);
            });
            document.getElementById('ayah-select').addEventListener('change', (event) => {
                currentAyah = parseInt(event.target.value, 10);
                loadAyah(currentSurah, currentAyah);
            });
            document.getElementById('translation-select').addEventListener('change', () => loadAyah(currentSurah, currentAyah));

            document.querySelectorAll('.nav-link').forEach(link => {
                link.addEventListener('click', (event) => {
                    event.preventDefault();
                    showSection(event.target.getAttribute('data-section'));
                });
            });

            document.getElementById('save-tafsir-btn').addEventListener('click', saveTafsir);
            document.getElementById('add-theme-btn').addEventListener('click', addTheme);
            document.getElementById('link-ayah-to-theme-btn').addEventListener('click', linkAyahToTheme);
            document.getElementById('link-theme-select').addEventListener('change', displayLinkedAyahsForCurrentTheme);
            document.getElementById('analyze-root-btn').addEventListener('click', analyzeRoot);
            document.getElementById('save-root-notes-btn').addEventListener('click', saveRootNotes);
            document.getElementById('save-recitation-btn').addEventListener('click', saveRecitationLog);
            document.getElementById('rec-surah-select').addEventListener('change', (event) => {
                 const surah = parseInt(event.target.value, 10);
                 const totalAyahs = surahAyahCounts[surah];
                 document.getElementById('rec-ayah-start').max = totalAyahs;
                 document.getElementById('rec-ayah-end').max = totalAyahs;
            });
            document.getElementById('hifz-surah-select').addEventListener('change', (event) => {
                 loadHifzForSurah(parseInt(event.target.value, 10));
            });
            document.getElementById('perform-search-btn').addEventListener('click', performSearch);
            document.getElementById('export-data-btn').addEventListener('click', exportData);
            document.getElementById('import-file').addEventListener('change', (event) => {
                 document.getElementById('import-data-btn').disabled = !event.target.files[0];
            });
            document.getElementById('import-data-btn').addEventListener('click', () => {
                 const fileInput = document.getElementById('import-file');
                 if (fileInput.files.length > 0) importData(fileInput.files[0]);
                 else setStatusMessage('import-status', 'Select file to import.', true);
            });
            document.getElementById('clear-data-btn').addEventListener('click', clearAllPersonalData);
            document.getElementById('theme-switcher').addEventListener('change', (event) => applyTheme(event.target.value));

            document.querySelectorAll('.modal .close-button').forEach(button => {
                button.addEventListener('click', (event) => event.target.closest('.modal').style.display = 'none');
            });
            window.addEventListener('click', (event) => {
                 document.querySelectorAll('.modal').forEach(modal => { if (event.target === modal) modal.style.display = 'none'; });
            });
            window.addEventListener('keydown', (event) => { // Close modals with Escape key
                if (event.key === 'Escape') {
                    document.querySelectorAll('.modal').forEach(modal => modal.style.display = 'none');
                }
            });
            setupTafsirDocxButton();
        }

        // --- App Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await openDB();
                await loadThemePreference();
                setupEventListeners(); // Setup listeners after DB is open
                await loadQuranData(); // This populates selects and loads initial ayah
                displayThemesList();
                // loadRecitationLogs(); // Called when section is shown
                // loadHifzForSurah(); // Called when section is shown and surah selected
            } catch (error) {
                console.error("App initialization failed:", error);
                hideLoading();
                alert("Failed to initialize: " + error.message + "\nPlease clear website data and refresh. Check console for details.");
            }
        });
    </script>
</body>
</html>
<script>
        // --- Tafsir Export to DOCX Functions ---

        async function loadDocxJs() {
            return new Promise((resolve, reject) => {
                if (window.docx) { // Check if already loaded
                    console.log("docx.js already loaded.");
                    resolve(window.docx);
                    return;
                }
                console.log("Loading docx.js library...");
                const script = document.createElement('script');
                // Using jsDelivr CDN - always check for the latest stable version
                script.src = 'https://cdn.jsdelivr.net/npm/docx@9.5.0/dist/index.iife.min.js';
                script.onload = () => {
                    console.log("docx.js loaded successfully.");
                    resolve(window.docx); // The library attaches itself to window.docx
                };
                script.onerror = (err) => {
                    console.error("Failed to load docx.js library:", err);
                    reject("Failed to load DOCX library. Please check your internet connection.");
                };
                document.head.appendChild(script);
            });
        }


        async function exportTafsirToDocx() {
            setStatusMessage('export-tafsir-docx-status', 'Initializing DOCX export...', false);
            showLoading("Preparing Tafsir for DOCX export...");

            let docx;
            try {
                docx = await loadDocxJs();
                if (!docx || !docx.Document || !docx.Packer || !docx.Paragraph || !docx.TextRun || !docx.HeadingLevel) {
                    throw new Error("DOCX library not loaded correctly or is an incompatible version.");
                }
            } catch (error) {
                console.error("Error loading DOCX library:", error);
                setStatusMessage('export-tafsir-docx-status', typeof error === 'string' ? error : 'Failed to load DOCX library.', true);
                hideLoading();
                return;
            }

            if (!db) {
                setStatusMessage('export-tafsir-docx-status', 'Database not ready.', true);
                hideLoading();
                return;
            }

            try {
                const allTafsirEntries = await getAllData(STORE_TAFSIR);
                if (!allTafsirEntries || allTafsirEntries.length === 0) {
                    setStatusMessage('export-tafsir-docx-status', 'No Tafsir notes found to export.', false);
                    hideLoading();
                    return;
                }

                allTafsirEntries.sort((a, b) => {
                    if (a.surah !== b.surah) return a.surah - b.surah;
                    return a.ayah - b.ayah;
                });

                const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, ShadingType, convertInchesToTwip } = docx;

                const children = [];

                // Document Title
                children.push(
                    new Paragraph({
                        text: "My Personal Quran Tafsir",
                        heading: HeadingLevel.TITLE,
                        alignment: AlignmentType.CENTER,
                    })
                );
                children.push(new Paragraph(" ")); // Spacer

                let currentProcessingSurah = -1;

                for (const tafsirEntry of allTafsirEntries) {
                    if (tafsirEntry.surah !== currentProcessingSurah) {
                        currentProcessingSurah = tafsirEntry.surah;
                        const surahNameStr = surahNames[currentProcessingSurah - 1] || `Surah ${currentProcessingSurah}`;

                        // Surah Title
                        children.push(
                            new Paragraph({
                                children: [
                                    new TextRun({
                                        text: `Surah ${currentProcessingSurah}: ${surahNameStr}`,
                                        bold: true,
                                        size: 32, // 16pt font size (2 * 16)
                                        color: "2E74B5", // A blue color
                                    }),
                                ],
                                heading: HeadingLevel.HEADING_1,
                                spacing: { before: convertInchesToTwip(0.2), after: convertInchesToTwip(0.1) },
                            })
                        );
                    }

                    // Fetch Arabic text for the Ayah
                    const quranAyahData = await getData(STORE_QURAN, [tafsirEntry.surah, tafsirEntry.ayah]);
                    const arabicText = quranAyahData ? quranAyahData.arabic : "Arabic text not found.";

                    // Ayah Reference
                    children.push(
                        new Paragraph({
                            children: [
                                new TextRun({
                                    text: `Ayah ${tafsirEntry.ayah}`,
                                    bold: true,
                                    size: 28, // 14pt
                                    color: "1F4E79", // Darker blue
                                }),
                            ],
                            spacing: { before: convertInchesToTwip(0.15), after: convertInchesToTwip(0.05) },
                        })
                    );

                    // Arabic Text Paragraph
                    // Note: RTL text handling in docx.js might require specific paragraph properties.
                    // Fonts also need to be available on the system opening the DOCX.
                    children.push(
                        new Paragraph({
                            children: [
                                new TextRun({
                                    text: arabicText,
                                    font: "Scheherazade New", // Specify an Arabic font
                                    size: 36, // 18pt
                                    rightToLeft: true, // Crucial for Arabic
                                }),
                            ],
                            alignment: AlignmentType.RIGHT,
                            bidirectional: true, // Important for mixed LTR/RTL content handling in Word
                            shading: { // Basic background color
                                type: ShadingType.SOLID,
                                color: "E8F5E9", // Light green (hex without #)
                                fill: "E8F5E9",
                            },
                            spacing: { after: convertInchesToTwip(0.1) },
                        })
                    );

                    // Tafsir Notes Paragraph
                    // Split notes by newline and create separate TextRuns or Paragraphs for proper line breaks
                    const notesLines = tafsirEntry.notes.split('\n');
                    notesLines.forEach((line, index) => {
                        children.push(
                            new Paragraph({
                                children: [
                                    new TextRun({
                                        text: line,
                                        size: 24, // 12pt
                                    }),
                                ],
                                indentation: { left: convertInchesToTwip(0.25) }, // Indent Tafsir notes
                                spacing: { after: (index === notesLines.length - 1) ? convertInchesToTwip(0.15) : convertInchesToTwip(0.02) },
                            })
                        );
                    });
                     children.push(new Paragraph(" ")); // Spacer after each tafsir entry
                }

                const doc = new Document({
                    sections: [{
                        properties: {
                            page: {
                                margin: {
                                    top: convertInchesToTwip(0.75),
                                    right: convertInchesToTwip(0.75),
                                    bottom: convertInchesToTwip(0.75),
                                    left: convertInchesToTwip(0.75),
                                },
                            },
                        },
                        children: children,
                    }],
                    // Define default fonts if possible, though this is more for the document's meta
                    // Actual font rendering depends on the user's system.
                    styles: {
                        default: {
                            document: {
                                run: {
                                    font: "Calibri", // Default LTR font
                                    size: 22, // 11pt default
                                },
                                paragraph: {
                                    spacing: { line: 276 } // approx 1.15 line spacing
                                }
                            },
                        },
                        paragraphStyles: [
                            {
                                id: "arabicStyle",
                                name: "Arabic Text",
                                basedOn: "Normal",
                                next: "Normal",
                                run: {
                                    font: "Scheherazade New",
                                    size: 36,
                                    rightToLeft: true,
                                },
                                paragraph: {
                                    alignment: AlignmentType.RIGHT,
                                    bidirectional: true,
                                }
                            }
                        ]
                    }
                });

                // Packer to generate the .docx file
                Packer.toBlob(doc).then(blob => {
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(blob);
                    link.download = `Personal-Tafsir-${new Date().toISOString().split('T')[0]}.docx`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);
                    setStatusMessage('export-tafsir-docx-status', 'Tafsir DOCX file generated.', false);
                }).catch(packError => {
                    console.error("Error packing DOCX:", packError);
                    setStatusMessage('export-tafsir-docx-status', 'Failed to generate DOCX file.', true);
                });

            } catch (error) {
                console.error("Error exporting Tafsir to DOCX:", error);
                setStatusMessage('export-tafsir-docx-status', 'Failed to export Tafsir to DOCX.', true);
            } finally {
                hideLoading();
            }
        }


        // Add this to your setupEventListeners function
        function setupTafsirDocxButton() {
            const exportDocxBtn = document.getElementById('export-tafsir-to-docx-btn');
            if (exportDocxBtn) {
                exportDocxBtn.addEventListener('click', exportTafsirToDocx);
            } else {
                console.warn("Export Tafsir to DOCX button not found.");
            }
        }






///////////// Games

// === GAME LOGIC AND UI - PASTE THIS AT THE END OF YOUR EXISTING <script> TAG ===
// === Make sure this is *inside* the main <script> tag, before its closing 

function setupGameModal() {
const gameModalHTML = `
    <div id="quranGameModal" class="modal game-modal" role="dialog" aria-modal="true" aria-labelledby="gameModalTitle" style="display: none;">
        <div class="modal-content game-modal-content">
            <span class="close-button game-close-button" aria-label="Close Game">×</span>
            <h2 id="gameModalTitle">Quranic Games</h2>
            <div class="game-selection-area">
                <p>Choose a game to play:</p>
                <button id="startGameWordWhiz" class="game-select-btn">Word Whiz (Vocabulary)</button>
                <button id="startGameAyahJumble" class="game-select-btn">Ayah Jumble (Order)</button>
            </div>
            <div id="gamePlayArea" class="game-play-area" style="display: none;">
                <!-- Game content will be loaded here -->
            </div>
                <div id="gameScoreArea" class="game-score-area" style="display: none;">
                    <p>Score: <span id="gameCurrentScore">0</span></p>
                    <p>High Score: <span id="gameHighScore">0</span> (for this session)</p>
                </div>
                <div class="game-controls">
                     <button id="quitGameButton" style="display:none; background-color: var(--color-error); margin-top:15px;">Quit Current Game</button>
                </div>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', gameModalHTML);

    // Add CSS for the game modal and elements
    const gameModalCSS = `
        .game-modal .modal-content {
            max-width: 90%;
            width: 700px; /* Adjust as needed */
            max-height: 90vh;
            overflow-y: auto;
            background-color: var(--color-bg-primary); /* Use theme colors */
            color: var(--color-text-primary);
        }
        .game-modal-content h2 {
            text-align: center;
            color: var(--color-text-secondary);
            margin-bottom: 20px;
        }
        .game-selection-area {
            text-align: center;
            margin-bottom: 20px;
        }
        .game-select-btn {
            margin: 10px;
            padding: 12px 20px;
            font-size: 1.1rem;
        }
        .game-play-area {
            padding: 20px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-secondary);
            min-height: fit-content;
            text-align: center;
        }
        .game-question-arabic {
            font-family: var(--font-arabic);
            font-size: 2rem;
            margin-bottom: 20px;
            direction: rtl;
        }
        .game-options-list {
            list-style: none;
            padding: 0;
            margin: 0 auto;
            max-width: 400px; /* Or adjust based on content */
        }
        .game-options-list li button {
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 12px;
            background-color: var(--color-accent);
            border: 1px solid var(--color-accent-dark);
            color: white;
            font-family: var(--font-general); /* Or specific language font */
        }
        .game-options-list li button:hover {
            background-color: var(--color-accent-dark);
        }
        .game-options-list li button.correct {
            background-color: var(--color-success) !important;
        }
        .game-options-list li button.incorrect {
            background-color: var(--color-error) !important;
        }
        .game-feedback {
            margin-top: 15px;
            font-weight: bold;
        }
        .game-score-area {
            text-align: center;
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid var(--color-border);
        }
        .game-controls {
            text-align: center;
            margin-top: 20px;
        }

        /* Ayah Jumble Specific */
        .jumble-word-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            min-height: 50px; /* So it doesn't collapse */
            padding: 10px;
            border: 1px dashed var(--color-border);
            border-radius: var(--border-radius);
        }
        .jumble-word {
            font-family: var(--font-arabic);
            font-size: 1.8rem;
            padding: 8px 12px;
            background-color: var(--color-bg-primary);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            cursor: grab;
            user-select: none; /* Prevent text selection during drag */
            direction: rtl;
        }
        .jumble-word.dragging {
            opacity: 0.5;
            background-color: var(--color-highlight);
        }
        .jumble-target-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-end; /* RTL friendly start */
            gap: 5px; /* Small gap for visual separation */
            padding: 10px;
            border: 2px solid var(--color-accent);
            border-radius: var(--border-radius);
            min-height: 70px;
            background-color: var(--color-bg-secondary);
            direction: rtl; /* Important for correct ordering display */
        }
        .jumble-target-area .jumble-word {
             cursor: default; /* No longer grabbable once placed */
        }
        #jumbleSubmitAnswer { margin-top: 15px; }
        .game-modal.fullscreen {
            padding: 0;
        }
        .game-modal.fullscreen .modal-content {
            width: 100%;
            max-width: 100%;
            height: 100vh;
            max-height: 100vh;
            border-radius: 0;
            display: flex;
            flex-direction: column;
        }
        .game-modal.fullscreen .game-play-area {
            flex-grow: 1;
            overflow-y: auto;
        }
    `;
    const styleSheet = document.createElement("style");
    styleSheet.type = "text/css";
    styleSheet.innerText = gameModalCSS;
    document.head.appendChild(styleSheet);

    // Event Listeners for Modal
    const gameModal = document.getElementById('quranGameModal');
    const closeButton = gameModal.querySelector('.game-close-button');
    const startGameWordWhizBtn = document.getElementById('startGameWordWhiz');
    const startGameAyahJumbleBtn = document.getElementById('startGameAyahJumble');
    const quitGameButton = document.getElementById('quitGameButton');


    closeButton.addEventListener('click', () => {
        gameModal.style.display = 'none';
        resetGameUI(); // Ensure game state is reset when closing
    });
    window.addEventListener('click', (event) => {
        if (event.target === gameModal) {
            gameModal.style.display = 'none';
            resetGameUI();
        }
    });
     window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && gameModal.style.display === 'flex') {
            gameModal.style.display = 'none';
            resetGameUI();
        }
    });

    startGameWordWhizBtn.addEventListener('click', () => startWordWhizGame());
    startGameAyahJumbleBtn.addEventListener('click', () => startAyahJumbleGame());
    quitGameButton.addEventListener('click', () => {
        activeGame = null;
        resetGameUI();
    });


    // Add a button to the main UI to open the game modal
    const sidebarNav = document.querySelector('.sidebar nav ul');
    if (sidebarNav) {
        const gameLi = document.createElement('li');
        const gameLink = document.createElement('a');
        gameLink.href = "#games";
        gameLink.textContent = "Quranic Games";
        gameLink.id = "openGamesModalBtn";
        gameLi.appendChild(gameLink);
        sidebarNav.appendChild(gameLi);

        gameLink.addEventListener('click', (e) => {
            e.preventDefault();
            // Ensure other sections are not "active" visually if needed
            document.querySelectorAll('.nav-link.active').forEach(l => l.classList.remove('active'));
            gameLink.classList.add('active'); // Visually activate game link
            gameModal.style.display = 'flex';
            gameModal.classList.add('fullscreen'); // Make it fullscreen
            resetGameUI(); // Show selection screen first
        });
    }
}

let activeGame = null; // To track which game is running
let gameScore = 0;
let gameHighScore = 0; // Session high score
let wordWhizQuestions = [];
let currentWordWhizQuestionIndex = 0;
let ayahJumbleQuestion = null;

function resetGameUI() {
    const gamePlayArea = document.getElementById('gamePlayArea');
    const gameSelectionArea = document.getElementById('game-selection-area');
    const gameScoreArea = document.getElementById('gameScoreArea');
    const quitGameButton = document.getElementById('quitGameButton');
    const gameModalTitle = document.getElementById('gameModalTitle');

    if (gamePlayArea) {
        gamePlayArea.style.display = 'none';
        gamePlayArea.innerHTML = '';
    } else {
        console.error("resetGameUI: gamePlayArea not found");
    }

    if (gameSelectionArea) {
        gameSelectionArea.style.display = 'block';
    } else {
        console.error("resetGameUI: gameSelectionArea not found");
    }

    if (gameScoreArea) {
        gameScoreArea.style.display = 'none';
    } else {
        console.error("resetGameUI: gameScoreArea not found");
    }

    if (quitGameButton) {
        quitGameButton.style.display = 'none';
    } else {
        console.error("resetGameUI: quitGameButton not found");
    }

    if (gameModalTitle) {
        gameModalTitle.textContent = "Quranic Games";
    } else {
        console.error("resetGameUI: gameModalTitle not found");
    }
}

function showGamePlayUI(gameTitle) {
    const gameSelectionArea = document.getElementById('game-selection-area');
    const gamePlayArea = document.getElementById('gamePlayArea');
    const gameScoreArea = document.getElementById('gameScoreArea');
    const quitGameButton = document.getElementById('quitGameButton');
    const gameModalTitle = document.getElementById('gameModalTitle');

    if (gameSelectionArea) {
        gameSelectionArea.style.display = 'none';
    } else {
        console.error("showGamePlayUI: gameSelectionArea not found");
    }

    if (gamePlayArea) {
        gamePlayArea.style.display = 'block';
    } else {
        console.error("showGamePlayUI: gamePlayArea not found");
    }

    if (gameScoreArea) {
        gameScoreArea.style.display = 'block';
        updateScoreDisplay(); // Call this only if gameScoreArea exists
    } else {
        console.error("showGamePlayUI: gameScoreArea not found");
    }

    if (quitGameButton) {
        quitGameButton.style.display = 'block';
    } else {
        console.error("showGamePlayUI: quitGameButton not found");
    }

    if (gameModalTitle) {
        gameModalTitle.textContent = gameTitle;
    } else {
        console.error("showGamePlayUI: gameModalTitle not found");
    }
}

// Also, ensure updateScoreDisplay has checks:
function updateScoreDisplay() {
    const gameCurrentScoreEl = document.getElementById('gameCurrentScore');
    const gameHighScoreEl = document.getElementById('gameHighScore');

    if (gameCurrentScoreEl) {
        gameCurrentScoreEl.textContent = gameScore;
    } else {
        console.error("updateScoreDisplay: gameCurrentScore element not found");
    }

    if (gameHighScoreEl) {
        gameHighScoreEl.textContent = gameHighScore;
    } else {
        console.error("updateScoreDisplay: gameHighScore element not found");
    }
}

function updateScoreDisplay() {
    document.getElementById('gameCurrentScore').textContent = gameScore;
    document.getElementById('gameHighScore').textContent = gameHighScore;
}

// --- WORD WHIZ GAME ---
async function startWordWhizGame() {
    activeGame = 'wordWhiz';
    gameScore = 0;
    updateScoreDisplay();
    showGamePlayUI("Word Whiz Challenge");
    document.getElementById('gamePlayArea').innerHTML = '<p>Loading questions...</p>';

    try {
        // Fetch a pool of words. For simplicity, let's fetch some random words.
        // In a real scenario, you might want to fetch words from recently viewed ayahs or specific surahs.
        const allWordMetadata = await getAllData(STORE_WORD_METADATA);
        const allWordTranslations = await getAllData(STORE_WORD_TRANSLATIONS);

        if (allWordMetadata.length < 10 || allWordTranslations.length < 10) {
            document.getElementById('gamePlayArea').innerHTML = '<p>Not enough word data to start the game. Please load Quran data first.</p>';
            return;
        }

        // Create a map for quick translation lookup by word_id
        const translationMap = new Map();
        allWordTranslations.forEach(wt => translationMap.set(wt.word_id, wt));

        wordWhizQuestions = [];
        const selectedWordIds = new Set(); // To avoid duplicate questions with same word_id

        for (let i = 0; i < 10; i++) { // Generate 10 questions
            let attempt = 0;
            let randomMetaEntry, quranAyah, wordText, translationEntry;

            // Find a word that has a translation and its corresponding Quran text
            while(attempt < 50) { // Try to find a valid word
                randomMetaEntry = allWordMetadata[Math.floor(Math.random() * allWordMetadata.length)];
                if (selectedWordIds.has(randomMetaEntry.word_id)) {
                    attempt++;
                    continue;
                }

                translationEntry = translationMap.get(randomMetaEntry.word_id);
                if (!translationEntry || (!translationEntry.en_meaning && !translationEntry.ur_meaning && !translationEntry.bn_meaning)) { // Check if any translation exists
                     attempt++;
                     continue;
                }

                quranAyah = await getData(STORE_QURAN, [randomMetaEntry.surah, randomMetaEntry.ayah]);
                if (!quranAyah) {
                     attempt++;
                     continue;
                }

                const wordsInAyah = quranAyah.arabic.split(/\s+/);
                if (randomMetaEntry.word_position < wordsInAyah.length) {
                    wordText = wordsInAyah[randomMetaEntry.word_position];
                    if(wordText && wordText.trim() !== "") break; // Found a valid word
                }
                attempt++;
            }

            if (!wordText) continue; // Skip if no valid word found after attempts

            selectedWordIds.add(randomMetaEntry.word_id);

            const selectedTranslationLang = document.getElementById('translation-select').value; // urdu, english, Bangali
            let correctAnswerText;
            let fontPreference;

            if (selectedTranslationLang === 'urdu' && translationEntry.ur_meaning) {
                correctAnswerText = translationEntry.ur_meaning;
                fontPreference = 'var(--font-urdu)';
            } else if (selectedTranslationLang === 'english' && translationEntry.en_meaning) {
                correctAnswerText = translationEntry.en_meaning;
                fontPreference = 'var(--font-english)';
            } else if (selectedTranslationLang === 'Bangali' && translationEntry.bn_meaning) { // Assuming you add bn_meaning to data5
                correctAnswerText = translationEntry.bn_meaning || (translationMap.get(randomMetaEntry.word_id).en_meaning || "No Bengali Translation"); // Fallback
                fontPreference = 'var(--font-Bangali)';
            } else { // Fallback to English or whatever is available
                correctAnswerText = translationEntry.en_meaning || translationEntry.ur_meaning || "Meaning N/A";
                fontPreference = 'var(--font-english)';
            }

            if (correctAnswerText === "Meaning N/A" || correctAnswerText.trim() === "") continue; // Skip if no good answer

            const options = [correctAnswerText];
            // Get 3 distractor options
            let distractorCount = 0;
            while (distractorCount < 3 && options.length < allWordTranslations.length) {
                const randomDistractorTrans = allWordTranslations[Math.floor(Math.random() * allWordTranslations.length)];
                let distractorText;
                 if (selectedTranslationLang === 'urdu' && randomDistractorTrans.ur_meaning) {
                    distractorText = randomDistractorTrans.ur_meaning;
                } else if (selectedTranslationLang === 'english' && randomDistractorTrans.en_meaning) {
                    distractorText = randomDistractorTrans.en_meaning;
                } else if (selectedTranslationLang === 'Bangali' && randomDistractorTrans.bn_meaning) {
                    distractorText = randomDistractorTrans.bn_meaning || randomDistractorTrans.en_meaning;
                } else {
                    distractorText = randomDistractorTrans.en_meaning || randomDistractorTrans.ur_meaning;
                }

                if (distractorText && distractorText.trim() !== "" && !options.includes(distractorText) && distractorText !== correctAnswerText) {
                    options.push(distractorText);
                    distractorCount++;
                }
            }
            shuffleArray(options); // Randomize options order

            wordWhizQuestions.push({
                word_id: randomMetaEntry.word_id,
                arabicWord: wordText,
                options: options,
                correctAnswer: correctAnswerText,
                fontPreference: fontPreference,
                translationLangDir: selectedTranslationLang === 'urdu' ? 'rtl' : 'ltr'
            });
        }

        if (wordWhizQuestions.length === 0) {
             document.getElementById('gamePlayArea').innerHTML = '<p>Could not generate questions. Try again or check data.</p>';
             return;
        }
        currentWordWhizQuestionIndex = 0;
        displayWordWhizQuestion();

    } catch (error) {
        console.error("Error starting WordWhiz game:", error);
        document.getElementById('gamePlayArea').innerHTML = `<p>Error loading game: ${error.message}</p>`;
    }
}

function displayWordWhizQuestion() {
    if (currentWordWhizQuestionIndex >= wordWhizQuestions.length) {
        endWordWhizGame();
        return;
    }
    const q = wordWhizQuestions[currentWordWhizQuestionIndex];
    let optionsHTML = '<ul class="game-options-list">';
    q.options.forEach(option => {
        optionsHTML += `<li><button data-answer="${option}" style="font-family: ${q.fontPreference}; direction: ${q.translationLangDir}; text-align: ${q.translationLangDir === 'rtl' ? 'right' : 'left'};">${option}</button></li>`;
    });
    optionsHTML += '</ul>';

    const gamePlayArea = document.getElementById('gamePlayArea');
    gamePlayArea.innerHTML = `
        <p>What is the meaning of this word?</p>
        <div class="game-question-arabic">${q.arabicWord}</div>
        ${optionsHTML}
        <div class="game-feedback" id="wordWhizFeedback"></div>
        <button id="nextWordWhizQuestion" style="display:none; margin-top: 10px;">Next Question</button>
    `;

    gamePlayArea.querySelectorAll('.game-options-list button').forEach(button => {
        button.addEventListener('click', handleWordWhizAnswer);
    });
    document.getElementById('nextWordWhizQuestion').addEventListener('click', () => {
        currentWordWhizQuestionIndex++;
        displayWordWhizQuestion();
    });
}

function handleWordWhizAnswer(event) {
    const selectedButton = event.target;
    const selectedAnswer = selectedButton.dataset.answer;
    const q = wordWhizQuestions[currentWordWhizQuestionIndex];
    const feedbackEl = document.getElementById('wordWhizFeedback');
    const nextButton = document.getElementById('nextWordWhizQuestion');

    document.querySelectorAll('.game-options-list button').forEach(btn => {
        btn.disabled = true; // Disable all options
        if (btn.dataset.answer === q.correctAnswer) {
            btn.classList.add('correct');
        }
    });

    if (selectedAnswer === q.correctAnswer) {
        feedbackEl.textContent = "Correct!";
        feedbackEl.style.color = 'var(--color-success)';
        gameScore += 10;
        if (gameScore > gameHighScore) gameHighScore = gameScore;
        updateScoreDisplay();
    } else {
        feedbackEl.textContent = `Incorrect. The correct answer is: ${q.correctAnswer}`;
        feedbackEl.style.color = 'var(--color-error)';
        selectedButton.classList.add('incorrect'); // Mark the specific wrong choice
    }
    nextButton.style.display = 'inline-block';
}

function endWordWhizGame() {
    document.getElementById('gamePlayArea').innerHTML = `
        <h3>Game Over!</h3>
        <p>Your final score: ${gameScore}</p>
        <button id="playWordWhizAgain">Play Again</button>
    `;
    document.getElementById('playWordWhizAgain').addEventListener('click', startWordWhizGame);
    activeGame = null;
}

// --- AYAH JUMBLE GAME ---
let jumbledWords = [];
let correctOrderWords = [];
let draggedItem = null;

async function startAyahJumbleGame() {
    activeGame = 'ayahJumble';
    gameScore = 0; // Reset score for this game type
    updateScoreDisplay();
    showGamePlayUI("Ayah Jumble Challenge");
    document.getElementById('gamePlayArea').innerHTML = '<p>Loading Ayah...</p>';

    try {
        let randomAyahData, words;
        let attempts = 0;
        const MAX_ATTEMPTS = 20;
        const MIN_WORDS = 4;
        const MAX_WORDS = 10; // Keep ayahs relatively short for jumbling

        while(attempts < MAX_ATTEMPTS) {
            const randomSurah = Math.floor(Math.random() * 114) + 1;
            const randomAyahNum = Math.floor(Math.random() * surahAyahCounts[randomSurah]) + 1;
            randomAyahData = await getData(STORE_QURAN, [randomSurah, randomAyahNum]);

            if (randomAyahData && randomAyahData.arabic) {
                words = randomAyahData.arabic.trim().split(/\s+/).filter(w => w.length > 0);
                if (words.length >= MIN_WORDS && words.length <= MAX_WORDS) {
                    break; // Found a suitable Ayah
                }
            }
            attempts++;
        }

        if (!words || words.length < MIN_WORDS) {
            document.getElementById('gamePlayArea').innerHTML = '<p>Could not find a suitable Ayah for the game. Please try again.</p>';
            return;
        }

        correctOrderWords = [...words]; // Store the correct order
        jumbledWords = shuffleArray([...words]); // Shuffle a copy for display

        ayahJumbleQuestion = {
            originalAyah: randomAyahData.arabic,
            words: words,
            surah: randomAyahData.surah,
            ayah: randomAyahData.ayah
        };

        displayAyahJumbleQuestion();

    } catch (error) {
        console.error("Error starting AyahJumble game:", error);
        document.getElementById('gamePlayArea').innerHTML = `<p>Error loading game: ${error.message}</p>`;
    }
}

function displayAyahJumbleQuestion() {
    const gamePlayArea = document.getElementById('gamePlayArea');
    let jumbledWordsHTML = '';
    jumbledWords.forEach((word, index) => {
        jumbledWordsHTML += `<div class="jumble-word" draggable="true" data-index="${index}">${word}</div>`;
    });

    gamePlayArea.innerHTML = `
        <p>Arrange the words to form the correct Ayah:</p>
        <div id="jumbleSourceContainer" class="jumble-word-container">
            ${jumbledWordsHTML}
        </div>
        <p style="margin-top: 20px;">Your arrangement:</p>
        <div id="jumbleTargetContainer" class="jumble-target-area">
            <!-- Dropped words will appear here -->
        </div>
        <button id="jumbleSubmitAnswer">Check Answer</button>
        <button id="jumbleResetArrangement" style="margin-left:10px;">Reset</button>
        <div class="game-feedback" id="ayahJumbleFeedback"></div>
        <button id="nextAyahJumbleQuestion" style="display:none; margin-top: 10px;">Next Ayah</button>
    `;

    addJumbleDragDropListeners();
    document.getElementById('jumbleSubmitAnswer').addEventListener('click', handleAyahJumbleSubmit);
    document.getElementById('jumbleResetArrangement').addEventListener('click', resetJumbleArrangement);
    document.getElementById('nextAyahJumbleQuestion').addEventListener('click', startAyahJumbleGame); // Get a new Ayah
}

function addJumbleDragDropListeners() {
    const sourceContainer = document.getElementById('jumbleSourceContainer');
    const targetContainer = document.getElementById('jumbleTargetContainer');
    const draggables = document.querySelectorAll('#jumbleSourceContainer .jumble-word, #jumbleTargetContainer .jumble-word');

    draggables.forEach(draggable => {
        draggable.addEventListener('dragstart', (e) => {
            draggedItem = draggable;
            setTimeout(() => draggable.classList.add('dragging'), 0);
            // e.dataTransfer.setData('text/plain', draggable.textContent); // Optional, not strictly needed for this logic
        });

        draggable.addEventListener('dragend', () => {
            if (draggedItem) draggedItem.classList.remove('dragging');
            draggedItem = null;
        });
    });

    [sourceContainer, targetContainer].forEach(container => {
        container.addEventListener('dragover', (e) => {
            e.preventDefault(); // Allow drop
            const afterElement = getDragAfterElement(container, e.clientY, e.clientX, container === targetContainer);
            if (draggedItem && draggedItem.parentNode !== container) { // Only add if moving to a new container
                // Visual cue for dropping, not strictly necessary for functionality
            }
        });

        container.addEventListener('drop', (e) => {
            e.preventDefault();
            if (draggedItem) {
                const afterElement = getDragAfterElement(container, e.clientY, e.clientX, container === targetContainer);
                if (afterElement == null) {
                    container.appendChild(draggedItem);
                } else {
                    container.insertBefore(draggedItem, afterElement);
                }
                draggedItem.classList.remove('dragging'); // Ensure dragging class is removed
                draggedItem = null;
            }
        });
    });
}

function getDragAfterElement(container, y, x, isTargetArea) {
    const draggableElements = [...container.querySelectorAll('.jumble-word:not(.dragging)')];

    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        // For RTL target area, we compare X positions differently.
        // We want to insert *before* an element if our X is to its right (larger X in LTR terms for RTL).
        // For LTR source area, or if not caring about precise horizontal placement, Y is primary.
        const offsetY = y - box.top - box.height / 2;
        let offsetX;
        if (isTargetArea && document.body.dir === 'rtl') { // If main page is RTL
            offsetX = box.left + box.width / 2 - x; // Target is to the left of cursor (dragged item right of target)
        } else if (isTargetArea) { // Target area is LTR or main page is LTR
             offsetX = x - box.left - box.width / 2; // Target is to the right of cursor
        } else { // Source area, Y is primary
            offsetX = 0; // effectively ignore X for source, only care about Y
        }


        // Prioritize Y offset, then X if relevant for target area
        if (offsetY < 0 && offsetY > closest.offsetY) { // Above and closer
            return { offsetY: offsetY, offsetX: offsetX, element: child };
        } else if (isTargetArea && offsetY >= -10 && offsetY <= 10 && offsetX < 0 && offsetX > closest.offsetX) { // Roughly same line, and cursor is to the left of child (meaning child should be after)
            return { offsetY: offsetY, offsetX: offsetX, element: child };
        } else {
            return closest;
        }
    }, { offsetY: Number.NEGATIVE_INFINITY, offsetX: Number.NEGATIVE_INFINITY }).element;
}


function resetJumbleArrangement() {
    // Move all words from target back to source
    const targetContainer = document.getElementById('jumbleTargetContainer');
    const sourceContainer = document.getElementById('jumbleSourceContainer');
    [...targetContainer.children].forEach(child => sourceContainer.appendChild(child));

    // Re-sort words in source container based on their original jumbled order data-index
    const wordsInSource = [...sourceContainer.children];
    wordsInSource.sort((a,b) => parseInt(a.dataset.index) - parseInt(b.dataset.index));
    wordsInSource.forEach(word => sourceContainer.appendChild(word)); // Re-append in sorted order

    document.getElementById('ayahJumbleFeedback').textContent = '';
    document.getElementById('jumbleSubmitAnswer').disabled = false;
}


function handleAyahJumbleSubmit() {
    const targetContainer = document.getElementById('jumbleTargetContainer');
    const userAnswerWords = [...targetContainer.children].map(el => el.textContent.trim());
    const feedbackEl = document.getElementById('ayahJumbleFeedback');
    const nextButton = document.getElementById('nextAyahJumbleQuestion');
    const submitButton = document.getElementById('jumbleSubmitAnswer');


    if (userAnswerWords.join(' ') === correctOrderWords.join(' ')) {
        feedbackEl.textContent = "Correct! Masha'Allah!";
        feedbackEl.style.color = 'var(--color-success)';
        gameScore += 20; // Jumble might be harder
        if (gameScore > gameHighScore) gameHighScore = gameScore;
        updateScoreDisplay();
        nextButton.style.display = 'inline-block';
        submitButton.disabled = true;
         // Highlight target words green
        [...targetContainer.children].forEach(child => child.style.backgroundColor = 'var(--color-success)');


    } else {
        feedbackEl.textContent = `Not quite. Try again or reset. The correct Ayah is: ${ayahJumbleQuestion.originalAyah}`;
        feedbackEl.style.color = 'var(--color-error)';
        // Optionally show correct order or give hints, for now just this.
        nextButton.style.display = 'none'; // Don't show next if wrong, encourage retry
         // Highlight target words red
        [...targetContainer.children].forEach(child => child.style.backgroundColor = 'var(--color-error)');
        setTimeout(() => { // Reset color after a bit
            [...targetContainer.children].forEach(child => child.style.backgroundColor = '');
        }, 2000);
    }
}


// Helper function
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}



// setTimeout(setupGameModal, 0); // Slight delay to ensure main UI is set up

// Modify your main DOMContentLoaded listener
document.addEventListener('DOMContentLoaded', async () => {
    try {
        await openDB();
        await loadThemePreference();
        setupEventListeners(); // Your existing listeners
        await loadQuranData();
        displayThemesList();
        setupTafsirDocxButton(); // Your existing function for docx
        setTimeout(setupGameModal, 200);
        //setupGameModal(); // ***** ADD THIS LINE HERE *****

    } catch (error) {
        console.error("App initialization failed:", error);
        // Your existing error handling for app init
        const loadingOverlay = document.getElementById('loading-overlay');
        if (loadingOverlay && loadingOverlay.style.display !== 'none') {
            document.getElementById('loading-message-primary').textContent = "Initialization Error";
            document.getElementById('loading-message-secondary').textContent = `Critical error: ${error.message}. Please refresh or clear site data.`;
        } else {
            alert("Failed to initialize: " + error.message + "\nPlease clear website data and refresh. Check console for details.");
        }
    }
});
</script>