<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nur Al-Quran Studio Offline - By Yasin Ullah</title>
    <meta name="author" content="Yasin Ullah, Pakistani">
    <meta name="description" content="An offline-first, client-side Quranic study environment with personal Tafsir, thematic linking, root analysis, Hifz tracking, and advanced search.">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/vis-network@latest/dist/vis-network.min.js"></script>
    <style>
        /* General Styles & Reset */
        :root {
            /* Default Theme: Serene Digital Mosque */
            --color-bg-primary: #e8f5e9; /* Light Green */
            --color-bg-secondary: #c8e6c9; /* Lighter Green */
            --color-text-primary: #1b5e20; /* Dark Green */
            --color-text-secondary: #388e3c; /* Medium Green */
            --color-accent: #4caf50; /* Green */
            --color-accent-dark: #388e3c; /* Darker Green */
            --color-border: #a5d6a7; /* Light Green Border */
            --color-shadow: rgba(0, 0, 0, 0.1);
            --color-highlight: #fff9c4; /* Light Yellow */
            --color-error: #ef5350; /* Red */
            --color-success: #66bb6a; /* Green */
            --font-arabic: 'Scheherazade New', 'Lateef', 'Amiri', 'Traditional Arabic', calibri; /* Preferred Arabic fonts */
            --font-urdu: 'Jameel Noori Nastaleeq', 'Noto Nastaliq Urdu', 'Pak Nastaleeq', calibri; /* Preferred Urdu fonts */
            --font-Bangali: 'Noto Sans Bangali', 'Arial', calibri; /* Bangali fonts */
            --font-english: 'Roboto', 'Segoe UI', calibri; /* English font */
            --font-general: 'Roboto', 'Segoe UI', calibri; /* General UI font */
            --border-radius: 8px;
            --padding-main: 20px;
            --transition-speed: 0.3s;
        }

        /* Ancient Illuminated Manuscript Theme */
        body.theme-manuscript {
            --color-bg-primary: #f5f5dc; /* Beige/Parchment */
            --color-bg-secondary: #fff8dc; /* Cornsilk */
            --color-text-primary: #5d4037; /* Dark Brown */
            --color-text-secondary: #795548; /* Brown */
            --color-accent: #ffb300; /* Amber */
            --color-accent-dark: #fb8c00; /* Dark Amber */
            --color-border: #d7ccc8; /* Light Brown */
            --color-shadow: rgba(0, 0, 0, 0.15);
            --color-highlight: #ffe082; /* Light Amber */
            --color-error: #c62828; /* Dark Red */
            --color-success: #388e3c; /* Dark Green */
            --font-arabic: 'Scheherazade New', calibri;
            --font-urdu: 'Jameel Noori Nastaleeq', calibri;
            --font-Bangali: 'Noto Sans Bangali', calibri;
            --font-english: 'Merriweather', calibri;
            --font-general: 'Merriweather', calibri;
        }

        /* Futuristic Holo-Quran Theme */
        body.theme-holo {
            --color-bg-primary: #0d1a2b; /* Dark Blue */
            --color-bg-secondary: #1a2b3c; /* Slightly Lighter Blue */
            --color-text-primary: #e0f7fa; /* Cyan */
            --color-text-secondary: #b2ebf2; /* Lighter Cyan */
            --color-accent: #00bcd4; /* Cyan */
            --color-accent-dark: #00838f; /* Dark Cyan */
            --color-border: #26a69a; /* Teal */
            --color-shadow: rgba(0, 188, 212, 0.2); /* Cyan shadow */
            --color-highlight: #80deea; /* Light Cyan */
            --color-error: #ff5252; /* Red */
            --color-success: #00e676; /* Green */
            --font-arabic: 'Orbitron', calibri; /* Futuristic Arabic (placeholder, needs actual font) */
            --font-urdu: 'Orbitron', calibri; /* Placeholder */
            --font-Bangali: 'Orbitron', calibri;
            --font-english: 'Orbitron', calibri;
            --font-general: 'Orbitron', calibri;
            --border-radius: 4px;
        }


        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-general);
            line-height: 1.6;
            color: var(--color-text-primary);
            background-color: var(--color-bg-primary);
            transition: background-color var(--transition-speed), color var(--transition-speed);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-y: scroll; /* Allow scrolling on body */
        }

        h1, h2, h3, h4, h5, h6 {
            color: var(--color-text-secondary);
            margin-bottom: 15px;
        }

        button, input[type="submit"], input[type="button"] {
            font-family: var(--font-general);
            background-color: var(--color-accent);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color var(--transition-speed), opacity var(--transition-speed);
            font-size: 1rem;
        }

        button:hover, input[type="submit"]:hover, input[type="button"]:hover {
            background-color: var(--color-accent-dark);
            opacity: 0.9;
        }
         button:focus, input[type="submit"]:focus, input[type="button"]:focus {
            outline: 2px solid var(--color-accent-dark);
            outline-offset: 2px;
        }

        input[type="text"], input[type="number"], textarea, select {
            font-family: var(--font-general);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
            width: 100%;
            max-width: 400px; /* Limit width for forms */
        }
         input[type="text"]:focus, input[type="number"]:focus, textarea:focus, select:focus {
            outline: 2px solid var(--color-accent);
            border-color: var(--color-accent);
         }

        textarea {
            min-height: 150px;
            resize: vertical;
            max-width: 100%;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--color-text-secondary);
        }

        a {
            color: var(--color-accent-dark);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Layout */
        .container {
            display: flex;
            flex-grow: 1; /* Allow container to take up available space */
            padding: 6px 0px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .sidebar {
            width: 250px;
            margin-right: var(--padding-main);
            flex-shrink: 0;
            background-color: var(--color-bg-secondary);
            padding: var(--padding-main);
            border-radius: var(--border-radius);
            box-shadow: 0 2px 5px var(--color-shadow);
        }

        .main-content {
            flex-grow: 1;
            background-color: var(--color-bg-secondary);
            padding: var(--padding-main);
            border-radius: var(--border-radius);
            box-shadow: 0 2px 5px var(--color-shadow);
            overflow-y: auto; /* Allow main content area to scroll */
        }

        header {
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
            padding: 5px var(--padding-main);
            box-shadow: 0 2px 5px var(--color-shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        header h1 {
            margin: 0;
            font-size: 1.8rem;
            color: var(--color-text-primary);
        }

        nav ul {
            list-style: none;
            padding: 0;
        }

        nav ul li {
            margin-bottom: 10px;
        }

        nav a {
            display: block;
            padding: 10px;
            background-color: var(--color-bg-primary);
            border-radius: var(--border-radius);
            color: var(--color-text-primary);
            transition: background-color var(--transition-speed), color var(--transition-speed);
        }

        nav a:hover, nav a.active {
            background-color: var(--color-accent);
            color: white;
            text-decoration: none;
        }

        /* Specific Sections */
        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        /* Quran Section */
        .quran-viewer h2 {
            text-align: center;
            margin-bottom: 20px;
        }

        .ayah {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            transition: background-color var(--transition-speed);
        }

        .ayah:hover {
             background-color: var(--color-highlight);
        }

        .ayah-number {
            font-weight: bold;
            color: var(--color-accent-dark);
            margin-bottom: 10px;
            display: block;
            text-align: center;
        }

        .ayah-arabic {
            font-family: var(--font-arabic);
            font-size: 1.8rem;
            text-align: right;
            direction: rtl;
            margin-bottom: 10px;
            line-height: 2.5; /* Increased line height for clarity */
        }

        .ayah-arabic span {
            cursor: pointer;
            padding: 2px 4px;
            border-bottom: 1px dashed transparent;
            transition: background-color 0.2s, border-bottom-color 0.2s;
        }

        .ayah-arabic span:hover {
            background-color: rgba(var(--color-accent-dark-rgb, 56, 142, 60), 0.2); /* Use RGBA for hover */
            border-bottom-color: var(--color-accent-dark);
        }
        /* Add RGB variables for themes */
        :root { --color-accent-dark-rgb: 56, 142, 60; } /* Serene */
        body.theme-manuscript { --color-accent-dark-rgb: 251, 140, 0; } /* Manuscript */
        body.theme-holo { --color-accent-dark-rgb: 0, 131, 143; } /* Holo */


        .ayah-translation {
            /* These will be set dynamically by JS based on selected translation */
            font-size: 1.1rem;
            color: var(--color-text-secondary);
        }

        /* Tafsir Builder */
        .tafsir-editor {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--color-border);
        }

        .tafsir-editor textarea {
            width: 100%;
            max-width: 100%;
            margin-bottom: 10px;
        }

        /* Thematic Linker */
        .theme-manager, .theme-linker {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
        }

        .theme-list ul {
            list-style: none;
            padding-left: 20px;
        }
        .theme-list li {
            margin-bottom: 5px;
        }
        .theme-list li span {
             cursor: pointer;
             color: var(--color-text-secondary);
             transition: color var(--transition-speed);
        }
        .theme-list li span:hover {
             color: var(--color-accent-dark);
             text-decoration: underline;
        }
        .theme-list .theme-actions button {
            padding: 3px 8px;
            font-size: 0.8rem;
            margin-left: 5px;
        }

        /* Root Word Analyzer */
        .root-analyzer-form {
            margin-bottom: 20px;
        }
        .root-results ul {
            list-style: none;
            padding: 0;
        }
        .root-results li {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            font-size: 1.5rem;
        }

        /* Recitation Log */
        .recitation-log-form {
             margin-bottom: 20px;
        }
        .recitation-list ul {
            list-style: none;
            padding: 0;
        }
        .recitation-list li {
             margin-bottom: 10px;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
        }

        /* Memorization Hub */
        .hifz-ayah-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: var(--border-radius);
            font-size: 0.9rem;
            margin-left: 10px;
        }
        .status-not-started { background-color: #e0e0e0; color: #424242; }
        .status-in-progress { background-color: #fff59d; color: #fbc02d; }
        .status-memorized { background-color: #a5d6a7; color: #388e3c; }

        /* Advanced Search */
        .search-options label {
            display: inline-block;
            margin-right: 15px;
            font-weight: normal;
        }
        .search-results ul {
            list-style: none;
            padding: 0;
            margin-top: 20px;
        }
        .search-results li {
             margin-bottom: 10px;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            /* font-size: x-large; Removed for consistency, use result-context */
        }
        .search-results .result-context {
            font-size: large;
            color: var(--color-text-secondary);
            margin-top: 5px;
        }

        /* Data Management / Settings */
        .settings-section {
            margin-bottom: 20px;
        }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--color-bg-secondary);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 15px var(--color-shadow);
            max-width: 600px;
            width: 90%;
            position: relative;
        }

        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            color: var(--color-text-secondary);
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }

        /* Loading Indicator */
        #loading-overlay {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 1.5rem;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            display: none; /* Hidden by default */
        }

        /* Utility Classes */
        .text-center { text-align: center; }
        .mt-20 { margin-top: 20px; }
        .mb-10 { margin-bottom: 10px; }
        .mb-20 { margin-bottom: 20px; }
        .flex-group { display: flex; gap: 10px; align-items: center; } /* For buttons/inputs side-by-side */


        /* Accessibility (WCAG 2.1 AAA considerations) */
        [tabindex="0"]:focus, button:focus, input:focus, select:focus, textarea:focus, a:focus {
            outline: 3px solid var(--color-accent-dark); /* Stronger focus indicator */
            outline-offset: 2px;
        }

        /* Screen reader only class */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        /* RTL adjustments */
        [dir="rtl"] .ayah-arabic, [dir="rtl"] .ayah-translation {
            text-align: right;
        }
         [dir="rtl"] .sidebar {
            margin-right: 0;
            margin-left: var(--padding-main);
         }
         [dir="rtl"] .theme-list ul {
            padding-left: 0;
            padding-right: 20px;
         }
         [dir="rtl"] .theme-list .theme-actions button {
            margin-left: 0;
            margin-right: 5px;
         }
        [dir="rtl"] .hifz-ayah-status {
            margin-left: 0;
            margin-right: 10px;
        }
         [dir="rtl"] .search-options label {
            margin-right: 0;
            margin-left: 15px;
         }


        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                padding: 10px;
            }
            .sidebar {
                width: 100%;
                margin-right: 0;
                margin-bottom: 20px;
            }
             [dir="rtl"] .sidebar {
                margin-left: 0;
                margin-bottom: 20px;
             }
            .main-content {
                padding: 15px;
            }
            header {
                flex-direction: column;
                align-items: flex-start;
                padding: 10px;
            }
            header h1 {
                margin-bottom: 10px;
            }
            nav ul {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
            }
            nav ul li {
                margin-bottom: 0;
            }
            nav a {
                padding: 8px 12px;
                font-size: 0.9rem;
            }
             input[type="text"], input[type="number"], textarea, select {
                max-width: 100%;
            }
             .flex-group {
                flex-direction: column;
                gap: 10px;
             }
             .flex-group button, .flex-group input {
                width: 100%;
             }
        }

        /* Chronospatial/Bioluminescent Simulation (Basic) */
        body.theme-holo .ayah:hover {
             background: linear-gradient(90deg, rgba(0,188,212,0.1) 0%, rgba(0,188,212,0.05) 100%);
        }
        body.theme-holo .ayah-arabic span:hover {
             background-color: rgba(0, 188, 212, 0.3);
             border-bottom-color: var(--color-highlight);
        }
         body.theme-holo nav a.active {
            background-color: var(--color-accent);
            box-shadow: 0 0 8px var(--color-accent);
         }


                 /* Loading Indicator Enhancements */
        #loading-overlay {
            display: none; /* Hidden by default, shown by JS */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85); /* Darker overlay */
            color: white;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            text-align: center;
            padding: 20px;
        }

        .loading-content {
            background-color: var(--color-bg-secondary, #1a2b3c); /* Use theme color or fallback */
            padding: 30px 40px;
            border-radius: var(--border-radius, 8px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
        }
        body.theme-serene .loading-content { background-color: var(--color-bg-secondary); color: var(--color-text-primary);}
        body.theme-manuscript .loading-content { background-color: var(--color-bg-secondary); color: var(--color-text-primary);}
        body.theme-holo .loading-content { background-color: #1a2b3c; color: #e0f7fa; }


        #loading-message-primary {
            font-size: 1.4rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #loading-message-secondary {
            font-size: 1rem;
            margin-bottom: 20px;
            min-height: 1.6em; /* Prevent layout shift */
        }

        #loading-progress-bar-container {
            width: 100%;
            background-color: var(--color-border, #a5d6a7); /* Theme border or fallback */
            border-radius: var(--border-radius, 8px);
            overflow: hidden;
            height: 20px;
            margin-bottom: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        body.theme-holo #loading-progress-bar-container { background-color: #26a69a; }


        #loading-progress-bar {
            height: 100%;
            background-color: var(--color-accent, #4caf50); /* Theme accent or fallback */
            width: 0%; /* Initial width */
            transition: width 0.3s ease-out;
            border-radius: var(--border-radius, 8px) 0 0 var(--border-radius, 8px); /* Maintain rounded left corners */
        }
         body.theme-holo #loading-progress-bar { background-color: var(--color-accent); }


        #loading-percentage {
            font-size: 1.1rem;
            font-weight: bold;
        }
        #loading-first-time-notice {
            font-size: 0.85em;
            margin-top: 15px;
            opacity: 0.8;
        }

                /* Root Analyzer View Switcher & Graph */
        .view-switcher label { /* General label styling */
            display: inline-block;
            margin-bottom: 0; /* Override default label margin */
        }
        .view-switcher div > label { /* Specific label for radio option */
            margin-left: 3px;
        }
        .root-view-content {
            display: none; /* Hide by default */
        }
        .root-view-content.active-view {
            display: block; /* Show active view */
        }
        #root-network-graph-container {
            margin-top: 20px;
        }
        /* Root Analyzer View Switcher & Graph */
        .view-switcher label { /* General label styling */
            display: inline-block;
            margin-bottom: 0; /* Override default label margin */
        }
        .view-switcher div > label { /* Specific label for radio option */
            margin-left: 3px;
        }
        .root-view-content {
            display: none; /* Hide by default */
        }
        .root-view-content.active-view {
            display: block; /* Show active view */
        }
        #root-network-graph-container {
            margin-top: 20px;
        }
        /* Style for the custom popup window for root graph */
       .custom-popup#root-node-popup {
                position: absolute;
                background-color: var(--color-bg-secondary);
                border: 1px solid var(--color-border);
                padding: 15px;
                box-shadow: 0 8px 36px black;
                display: none;
                border-radius: var(--border-radius);
                word-wrap: break-word;
                font-size: 1.1rem !important;
            }
        .custom-popup#root-node-popup h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--color-accent-dark);
            font-family: var(--font-arabic);
            font-size: 1.5rem;
        }
        .custom-popup#root-node-popup p {
            margin: 0;
            line-height: 2; /* Increased for Arabic readability */
            font-size: 1.3rem; /* Increased for Arabic readability */
        }
        /* In your main <style> block */
#root-graph-placeholder {
    /* display: none !important; /* Default, JS will override with 'block !important' if needed */
    text-align: center;
    margin: 20px 0;
}
        /* Fullscreen Graph Styles */
        body.graph-fullscreen-active {
            overflow: hidden; /* Prevent scrolling of the body */
        }
        #root-network-graph-container.fullscreen-graph {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw; /* Full viewport width */
            height: 100vh; /* Full viewport height */
            z-index: 1500; /* Ensure it's above other content, but below popups if needed */
            background-color: var(--color-bg-primary); /* Use a theme background */
            padding: 0; /* Remove padding for fullscreen */
            margin: 0; /* Remove margin */
            display: flex; /* To help center the graph div if it's not 100% */
            flex-direction: column; /* For close button */
            align-items: stretch;
            justify-content: stretch;
        }
        #root-network-graph-container.fullscreen-graph #root-network-graph {
            flex-grow: 1; /* Make the graph div take available space */
            border: none; /* Remove border in fullscreen */
            width: 100%;
            height: 100%; /* Ensure vis.js has height */
        }
        .graph-fullscreen-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 1501; /* Above the graph container */
            padding: 8px 15px;
            font-size: 1.2rem;
            background-color: var(--color-error); /* Or another distinct color */
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
        }
        #root-network-graph-container.fullscreen-graph #root-graph-pagination-controls {
            position: absolute; /* Position pagination within fullscreen */
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(var(--color-bg-secondary-rgb, 200, 230, 201), 0.9); /* Theme aware with opacity */
            padding: 5px 10px;
            border-radius: var(--border-radius);
            z-index: 1501;
        }
        /* Add RGB version of bg-secondary for themes if not present */
        :root { --color-bg-secondary-rgb: 200, 230, 201; } /* Serene */
        body.theme-manuscript { --color-bg-secondary-rgb: 255, 248, 220; } /* Manuscript */
        body.theme-holo { --color-bg-secondary-rgb: 26, 43, 60; } /* Holo */
        div#root-node-popup {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            font-family: var(--font-arabic) !important;
            direction: rtl !important;
            text-align: right !important;
            z-index: 2147483647 !important;
            }
button#launchFullScreenReaderBtnEnhanced {
    position: absolute;
    right: 101px;
    top: 115px;
}
button#quitGameButton {
    position: fixed;
    bottom: 1px;
    left: 3px;
}
#fsReaderSettingsPanel > div:nth-child(2) > label:nth-child(7) {
    display: none;
}
    </style>
    <!-- Optional: Include fonts if not available locally -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Scheherazade+New:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Jameel+Noori+Nastaleeq&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Nastaliq+Urdu&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+Bangali&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap">
</head>
<body dir="ltr"> <!-- Default direction, will be set dynamically if needed -->

        <div id="loading-overlay">
        <div class="loading-content">
            <div id="loading-message-primary">Loading Quran data...</div>
            <div id="loading-message-secondary">Initializing...</div>
            <div id="loading-progress-bar-container">
                <div id="loading-progress-bar" style="width: 0%;"></div>
            </div>
            <div id="loading-percentage">0%</div>
            <div id="loading-first-time-notice" style="font-size: 0.9em; margin-top: 10px;">
                (This intensive loading typically occurs only on the first visit or after an app update. Subsequent loads will be much faster.)
            </div>
        </div>
    </div>

    <header>
        <h1>Nur Al-Quran Studio Offline</h1>
        <div class="header-controls">
             <label for="theme-switcher" class="sr-only">Choose Theme</label>
            <select id="theme-switcher" aria-label="Choose Theme">
                <option value="serene">Serene Digital Mosque</option>
                <option value="manuscript">Ancient Illuminated Manuscript</option>
                <option value="holo">Futuristic Holo-Quran</option>
            </select>
        </div>
    </header>

    <div class="container">
        <aside class="sidebar">
            <nav>
                <ul>
                    <li><a href="#quran" class="nav-link active" data-section="quran">Quran Viewer</a></li>
                    <li><a href="#tafsir" class="nav-link" data-section="tafsir">Personal Tafsir</a></li>
                    <li><a href="#themes" class="nav-link" data-section="themes">Thematic Linker</a></li>
                    <li><a href="#roots" class="nav-link" data-section="roots">Root Word Analyzer</a></li>
                    <li><a href="#recitation" class="nav-link" data-section="recitation">Recitation Log</a></li>
                    <li><a href="#hifz" class="nav-link" data-section="hifz">Memorization Hub</a></li>
                    <li><a href="#search" class="nav-link" data-section="search">Advanced Search</a></li>
                    <li><a href="#data" class="nav-link" data-section="data">Data Management</a></li>
                </ul>
            </nav>
        </aside>

        <main class="main-content">
            <section id="quran" class="section active" role="region" aria-labelledby="quran-heading">
                <h2 id="quran-heading">Quran Viewer</h2>
                <div class="quran-controls flex-group mb-20">
                    <label for="surah-select" class="sr-only">Select Surah</label>
                    <select id="surah-select" aria-label="Select Surah"></select>
                    <label for="ayah-select" class="sr-only">Select Ayah</label>
                    <select id="ayah-select" aria-label="Select Ayah"></select>
                </div>
                 <div class="quran-controls flex-group mb-20">
                     <label for="translation-select" class="sr-only">Select Translation</label>
                     <select id="translation-select" aria-label="Select Translation">
                         <option value="urdu">Urdu (Included)</option>
                         <option value="english">English (Included)</option>
                         <option value="Bangali">Bangali (Included)</option>
                     </select>
                 </div>

                <div id="quran-display" class="quran-viewer" lang="ar" dir="rtl">
                    <!-- Quran Ayahs will be loaded here -->
                    <p class="text-center">Select a Surah and Ayah to start.</p>
                </div>
                 <div id="word-translation-area" class="mt-20">
                     <!-- Word translation or full ayah translation on word click -->
                     <p class="text-center">Click on an Arabic word to see its translation.</p>
                 </div>
            </section>

            <section id="tafsir" class="section" role="region" aria-labelledby="tafsir-heading">
                <h2 id="tafsir-heading">Personal Tafsir Builder</h2>
                <p>Write your notes and reflections for the current Ayah.</p>
                 <div id="current-ayah-tafsir" class="ayah mb-20">
                     <!-- Current Ayah will be displayed here -->
                     <p class="text-center">Navigate to an Ayah in the Quran Viewer to add Tafsir.</p>
                 </div>
                <div class="tafsir-editor">
                    <label for="tafsir-notes">Your Tafsir Notes:</label>
                    <textarea id="tafsir-notes" placeholder="Enter your personal notes, interpretations, and reflections here..."></textarea>
                    <button id="save-tafsir-btn">Save Tafsir</button>
                     <p id="tafsir-status" aria-live="polite"></p>
                </div>
            </section>

            <section id="themes" class="section" role="region" aria-labelledby="themes-heading">
                <h2 id="themes-heading">Thematic Linker Pro</h2>
                <p>Create and manage themes, and link Ayahs to them.</p>

                <div class="theme-manager mb-20">
                    <h3>Manage Themes</h3>
                    <div class="flex-group mb-10">
                        <label for="new-theme-name" class="sr-only">New Theme Name</label>
                        <input type="text" id="new-theme-name" placeholder="New Theme Name">
                        <label for="parent-theme-select" class="sr-only">Parent Theme (Optional)</label>
                        <select id="parent-theme-select" aria-label="Parent Theme (Optional)">
                            <option value="">-- No Parent --</option>
                            <!-- Options populated by JS -->
                        </select>
                        <button id="add-theme-btn">Add Theme</button>
                    </div>
                    <div class="theme-list">
                        <h4>Existing Themes</h4>
                        <ul id="themes-list">
                            <!-- Themes populated by JS -->
                            <li>No themes added yet.</li>
                        </ul>
                    </div>
                     <p id="theme-manager-status" aria-live="polite"></p>
                </div>

                <div class="theme-linker">
                    <h3>Link Current Ayah (<span id="current-ayah-theme-ref">N/A</span>)</h3>
                    <div id="current-ayah-theme-text" class="ayah mb-20">
                        <!-- Current Ayah text will be displayed here -->
                         <p class="text-center">Navigate to an Ayah in the Quran Viewer to link themes.</p>
                    </div>
                    <label for="link-theme-select">Select Theme to Link:</label>
                    <select id="link-theme-select" aria-label="Select Theme to Link">
                         <option value="">-- Select Theme --</option>
                        <!-- Options populated by JS -->
                    </select>
                    <label for="theme-link-notes">Notes for this link (Optional):</label>
                    <textarea id="theme-link-notes" placeholder="Notes on why this Ayah relates to this theme..."></textarea>
                    <button id="link-ayah-to-theme-btn">Link Ayah</button>
                     <p id="theme-linker-status" aria-live="polite"></p>

                    <h4 class="mt-20">Ayahs Linked to Selected Theme: <span id="linked-theme-name">N/A</span></h4>
                    <ul id="linked-ayahs-list">
                        <!-- Linked ayahs populated by JS -->
                        <li>Select a theme above to see linked ayahs.</li>
                    </ul>
                </div>
            </section>

                         <section id="roots" class="section" role="region" aria-labelledby="roots-heading">
                <h2 id="roots-heading">Root Word Analyzer & Concordance</h2>
                <p>Input an Arabic root word to find occurrences in the Quran.</p>

                <div class="root-analyzer-form mb-20">
                    <div class="flex-group mb-10">
                        <label for="root-input" class="sr-only">Arabic Root Word</label>
                        <input type="text" id="root-input" placeholder="Enter Arabic Root (e.g., ق-و-ل) or (ع ل م) or (ر۔ب)" lang="ar" dir="rtl">
                        <button id="analyze-root-btn">Analyze Root</button>
                    </div>
                    <label for="root-description">Description/Notes for this Root (Optional):</label>
                    <textarea id="root-description" placeholder="Your notes on this root's meaning..."></textarea>
                    <button id="save-root-notes-btn">Save Root Notes</button>
                     <p id="root-status" aria-live="polite"></p>
                </div>

                <!-- View Switcher -->
                <div class="view-switcher mb-10 flex-group" style="justify-content: flex-start;">
                    <label style="margin-bottom:0;">View Mode: </label>
                    <div>
                        <input type="radio" id="root-view-list" name="root-view-mode" value="list" checked>
                        <label for="root-view-list" style="margin-right: 10px; font-weight:normal;">List</label>
                    </div>
                    <div>
                        <input type="radio" id="root-view-tree" name="root-view-mode" value="tree">
                        <label for="root-view-tree" style="font-weight:normal;">Tree Graph</label>
                    </div>
                </div>

                <div class="root-results">
                    <h3>Occurrences Found for: <span id="analyzed-root-term">N/A</span></h3>

                    <!-- List View Container -->
                    <ul id="root-occurrences-list" class="root-view-content active-view">
                        <li>Enter a root word and click "Analyze Root".</li>
                    </ul>

                    <!-- Tree View Container -->
                    <div id="root-network-graph-container" class="root-view-content" style="display: none;">
                        <p id="root-graph-placeholder" class="text-center" style="display:none; margin: 20px 0;">Graph will appear here after analysis.</p>
                        <div id="root-network-graph" style="width: 100%; height: 500px; border: 1px solid var(--color-border);"></div>
                        <!-- Pagination Controls for Graph -->
                        <div id="root-graph-pagination-controls" class="flex-group mt-10" style="justify-content: center; display: none;">
                            <button id="prev-root-graph-page-btn" disabled>« Previous</button>
                            <span id="root-graph-page-info" style="margin: 0 15px; font-weight: normal;">Page 1 of 1</span>
                            <button id="next-root-graph-page-btn" disabled>Next »</button>
                        </div>
                    </div>
                </div>
                <!-- Custom Popup for Vis.js Graph Nodes -->
                 <div id="root-node-popup" class="custom-popup" style="font-family: var(--font-arabic); direction: rtl; text-align: right;">
                    <!-- Popup content will be injected here by JavaScript -->
                </div>
            </section>

            <section id="recitation" class="section" role="region" aria-labelledby="recitation-heading">
                <h2 id="recitation-heading">Comparative Recitation Log</h2>
                <p>Log your listening sessions to different Qaris.</p>

                <div class="recitation-log-form mb-20">
                    <h3>Add Log Entry</h3>
                    <div class="flex-group mb-10">
                        <label for="rec-surah-select" class="sr-only">Surah</label>
                        <select id="rec-surah-select" aria-label="Surah"></select>
                        <label for="rec-ayah-start" class="sr-only">Ayah Start (Optional)</label>
                        <input type="number" id="rec-ayah-start" placeholder="Ayah Start (Optional)" min="1">
                        <label for="rec-ayah-end" class="sr-only">Ayah End (Optional)</label>
                        <input type="number" id="rec-ayah-end" placeholder="Ayah End (Optional)" min="1">
                    </div>
                     <div class="flex-group mb-10">
                        <label for="rec-qari" class="sr-only">Qari/Source</label>
                        <input type="text" id="rec-qari" placeholder="Qari or Source (e.g., Mishary Alafasy, Local Masjid Imam)">
                        <label for="rec-date" class="sr-only">Date</label>
                        <input type="date" id="rec-date" aria-label="Date">
                     </div>
                    <label for="rec-notes">Notes (Tajweed, Style, Impact):</label>
                    <textarea id="rec-notes" placeholder="Notes on Tajweed, style, emotional impact..."></textarea>
                    <button id="save-recitation-btn">Save Log Entry</button>
                     <p id="recitation-status" aria-live="polite"></p>
                </div>

                <div class="recitation-list">
                    <h3>Log Entries</h3>
                    <ul id="recitations-list">
                        <!-- Log entries populated by JS -->
                        <li>No entries logged yet.</li>
                    </ul>
                </div>
            </section>

            <section id="hifz" class="section" role="region" aria-labelledby="hifz-heading">
                <h2 id="hifz-heading">Memorization Hub</h2>
                <p>Track your Hifz progress and review schedule.</p>

                <div class="hifz-controls flex-group mb-20">
                     <label for="hifz-surah-select" class="sr-only">Select Surah for Hifz</label>
                    <select id="hifz-surah-select" aria-label="Select Surah for Hifz"></select>
                </div>

                <div id="hifz-ayahs-list">
                    <!-- List of ayahs for the selected surah with status/controls -->
                     <p class="text-center">Select a Surah to track Hifz progress.</p>
                </div>
                 <p id="hifz-status" aria-live="polite"></p>
            </section>

            <section id="search" class="section" role="region" aria-labelledby="search-heading">
                <h2 id="search-heading">Advanced Search</h2>
                <p>Search across Quran text, translations, and your personal data.</p>

                <div class="search-form mb-20">
                    <label for="search-input" class="sr-only">Search Term</label>
                    <input type="text" id="search-input" placeholder="Enter search term">
                    <div class="search-options mb-10" role="group" aria-label="Search Scope">
                        <label><input type="checkbox" class="search-scope" value="quran-arabic" checked> Quran Arabic</label>
                        <label><input type="checkbox" class="search-scope" value="quran-translation" checked> Quran Translation</label>
                        <label><input type="checkbox" class="search-scope" value="tafsir"> Personal Tafsir</label>
                        <label><input type="checkbox" class="search-scope" value="themes"> Theme Notes</label>
                        <label><input type="checkbox" class="search-scope" value="roots"> Root Notes</label>
                        <label><input type="checkbox" class="search-scope" value="recitation"> Recitation Notes</label>
                        <label><input type="checkbox" class="search-scope" value="hifz"> Hifz Notes</label>
                    </div>
                    <button id="perform-search-btn">Search</button>
                     <p id="search-status" aria-live="polite"></p>
                </div>

                <div class="search-results">
                    <h3>Search Results</h3>
                    <ul id="search-results-list">
                        <!-- Search results populated by JS -->
                        <li>Enter a search term and click "Search".</li>
                    </ul>
                </div>
            </section>

            <section id="data" class="section" role="region" aria-labelledby="data-heading">
                <h2 id="data-heading">Data Management</h2>
                <p>Manage your personal data (Tafsir, Themes, Roots, Logs, Hifz).</p>

                <div class="settings-section mb-20">
                    <h3>Backup Data</h3>
                    <p>Export your personal data as a JSON file.</p>
                    <button id="export-data-btn">Export Data</button>
                     <p id="export-status" aria-live="polite"></p>
                </div>

                <div class="settings-section mb-20">
                    <h3>Restore Data</h3>
                    <p>Import your personal data from a JSON file. This will overwrite existing data.</p>
                    <label for="import-file" class="sr-only">Choose JSON file to import</label>
                    <input type="file" id="import-file" accept="application/json">
                    <button id="import-data-btn" disabled>Import Data</button>
                     <p id="import-status" aria-live="polite"></p>
                </div>

                 <div class="settings-section">
                    <h3>Clear All Personal Data</h3>
                    <p class="mb-10" style="color: var(--color-error);">Warning: This will permanently delete ALL your personal Tafsir, Themes, Roots, Logs, and Hifz data.</p>
                     <button id="clear-data-btn" style="background-color: var(--color-error);">Clear All Data</button>
                     <p id="clear-status" aria-live="polite"></p>
                 </div>
                 <div class="settings-section mb-20">
                <h3>Export Personal Tafsir to Word (.docx)</h3>
                <p>Generates a .docx file of all your Tafsir notes (basic styling).</p>
                <button id="export-tafsir-to-docx-btn">Export Tafsir to .docx</button>
                <p id="export-tafsir-docx-status" aria-live="polite"></p>
            </div>
            </section>

        </main>
    </div>

    <!-- Modal for Theme Ayahs -->
    <div id="themeAyahsModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="themeAyahsModalTitle">
        <div class="modal-content">
            <span class="close-button" aria-label="Close Theme Ayahs Modal">&times;</span>
            <h3 id="themeAyahsModalTitle">Ayahs Linked to Theme: <span id="modal-theme-name"></span></h3>
            <ul id="modal-linked-ayahs-list">
                <!-- Linked ayahs populated here -->
            </ul>
        </div>
    </div>

    <!-- Modal for Root Occurrences -->
     <div id="rootOccurrencesModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="rootOccurrencesModalTitle">
        <div class="modal-content">
            <span class="close-button" aria-label="Close Root Occurrences Modal">&times;</span>
            <h3 id="rootOccurrencesModalTitle">Occurrences for Root: <span id="modal-root-term"></span></h3>
            <ul id="modal-root-occurrences-list">
                <!-- Root occurrences populated here -->
            </ul>
        </div>
    </div>


    <script>
        // Author: Yasin Ullah, Pakistani

        const DB_NAME = 'NurAlQuranStudioDBz';
        const DB_VERSION = 7; // << UPDATED for new word_metadata store and word_translations key
        let db;

        // Object Store Names
        let rootNetwork = null; // To hold the vis.js network instance
        let rootNodePopupEl = null; // To hold the popup DOM element
        let activeRootNodeIdForPopup = null; // Track which node's popup is open
        let allRootOccurrencesCache = []; // To store all occurrences for the current analyzed root
        let currentRootGraphPage = 1;
        const rootGraphItemsPerPage = 20; // Number of occurrence nodes per page


        const STORE_QURAN = 'quran';
        const STORE_TAFSIR = 'tafsir';
        const STORE_THEMES = 'themes';
        const STORE_THEME_AYAHS = 'theme_ayahs';
        const STORE_ROOTS = 'roots';
        const STORE_ROOT_AYAHS = 'root_ayahs';
        const STORE_RECITATIONS = 'recitations';
        const STORE_HIFZ = 'hifz';
        const STORE_SETTINGS = 'settings';
        const STORE_WORD_TRANSLATIONS = 'word_translations'; // Keyed by word_id
        const STORE_WORD_METADATA = 'word_metadata';         // Keyed by word_id, indexed by location

        let totalProgressUnits = 0;
        let completedProgressUnits = 0;
        // Data file names
        const WORD_TRANSLATION_FILE = 'data5 new.AM'; // Contains word_id, ur_meaning, en_meaning
        const WORD_METADATA_FILE = 'word2.AM';       // Contains word_id, surah, ayah, word_postion

        // Global state
        let currentSurah = 1;
        let currentAyah = 1;
        let totalAyahsInSurah = 7; // Default for Surah 1
        let quranDataLoaded = false;
        // allWordTranslationsCached is no longer the primary matching source but can be kept for other uses if needed.
        // let allWordTranslationsCached = [];
        // Place this function definition within your 
// === ENHANCED FULL-SCREEN TAJ QURAN READER === block,
// but OUTSIDE any other function.

// Placeholder - Implement accurate Juz calculation based on standard divisions
// This is non-trivial. For now, a rough estimate or fixed data.
// For a real solution, you need a mapping of Surah:Ayah to Juz.
const juzStartSurahs = [0, 1, 2, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 20, 21, 22, 23, 25, 26, 27, 29, 33, 36, 39, 41, 46, 51, 58, 67, 78]; // Example: Surah where Juz N+1 starts
const juzStartAyahs = [0, 1, 142, 253, 93, 24, 148, 82, 111, 41, 88, 93, 6, 53, 1, 1, 75, 1, 1, 56, 47, 31, 28, 36, 46, 60, 31, 1, 31, 28, 22, 47, 1, 31, 1, 1, 1]; // Example: Ayah where Juz N+1 starts (for the surah above)
// This ^ is a very simplified example for how you might store Juz boundaries.
// A more common way is to map each of the 604 pages of a TajCo mushaf to its Juz.
// Or have a detailed list like: {juz: 1, startSurah: 1, startAyah: 1, endSurah: 2, endAyah: 141}, ...
// === PLACE THIS AT THE TOP OF YOUR SCRIPT, WITH OTHER GLOBAL DATA LIKE surahNames ===
const juzBoundariesData = [
    { juz: 1, name: "Alif laam meem (آلم)", startSurah: 1, startAyah: 1 },
    { juz: 2, name: "Sayaqulu (سَيَقُولُ)", startSurah: 2, startAyah: 142 },
    { juz: 3, name: "Tilka r Rusulu (تِلْكَ الرُّسُلُ)", startSurah: 2, startAyah: 253 },
    { juz: 4, name: "Lan Tana Loo (لَنْ تَنَالُوا)", startSurah: 3, startAyah: 93 }, // 92 in some, 93 in others. Using 93 as per some common divisions.
    { juz: 5, name: "Wal Mohsanat (وَالْمُحْصَنَاتُ)", startSurah: 4, startAyah: 24 },
    { juz: 6, name: "La Yahubbullah (لَا يُحِبُّ اللَّهُ)", startSurah: 4, startAyah: 148 },
    { juz: 7, name: "Wa Iza Samiu (وَإِذَا سَمِعُوا)", startSurah: 5, startAyah: 82 }, // some say 83
    { juz: 8, name: "Wa Lau Annana (وَلَوْ أَنَّنَا)", startSurah: 6, startAyah: 111 },
    { juz: 9, name: "Qalal Malao (قَالَ الْمَلَأُ)", startSurah: 7, startAyah: 88 },
    { juz: 10, name: "Wa A'lamu (وَاعْلَمُوا)", startSurah: 8, startAyah: 41 },
    { juz: 11, name: "Yatazeroon (يَعْتَذِرُونَ)", startSurah: 9, startAyah: 93 }, // some say 94
    { juz: 12, name: "Wa Mamin Da'abat (وَمَا مِنْ دَابَّةٍ)", startSurah: 11, startAyah: 6 },
    { juz: 13, name: "Wa Ma Ubiroo (وَمَا أُبَرِّئُ)", startSurah: 12, startAyah: 53 },
    { juz: 14, name: "Rubama (رُبَمَا)", startSurah: 15, startAyah: 1 }, // Al-Hijr
    { juz: 15, name: "Subhanallazi (سُبْحَانَ الَّذِي)", startSurah: 17, startAyah: 1 }, // Al-Isra
    { juz: 16, name: "Qal Alam (قَالَ أَلَمْ)", startSurah: 18, startAyah: 75 }, // Al-Kahf
    { juz: 17, name: "Aqtarabo (اقْتَرَبَ لِلنَّاسِ)", startSurah: 21, startAyah: 1 }, // Al-Anbiya
    { juz: 18, name: "Qadd Aflaha (قَدْ أَفْلَحَ)", startSurah: 23, startAyah: 1 }, // Al-Mu'minun
    { juz: 19, name: "Wa Qalallazina (وَقَالَ الَّذِينَ)", startSurah: 25, startAyah: 21 }, // Al-Furqan
    { juz: 20, name: "A'man Khalaq (أَمَّنْ خَلَقَ)", startSurah: 27, startAyah: 56 }, // An-Naml (some 60)
    { juz: 21, name: "Utlu Ma Oohi (اتْلُ مَا أُوحِيَ)", startSurah: 29, startAyah: 46 }, // Al-'Ankabut
    { juz: 22, name: "Wa Manyaqnut (وَمَنْ يَقْنُتْ)", startSurah: 33, startAyah: 31 }, // Al-Ahzab
    { juz: 23, name: "Wa Mali (وَمَا لِيَ)", startSurah: 36, startAyah: 28 }, // Ya-Sin (some 22)
    { juz: 24, name: "Faman Azlam (فَمَنْ أَظْلَمُ)", startSurah: 39, startAyah: 32 }, // Az-Zumar
    { juz: 25, name: "Elahe Yuruddo (إِلَيْهِ يُرَدُّ)", startSurah: 41, startAyah: 47 }, // Fussilat
    { juz: 26, name: "Ha'a Meem (حم)", startSurah: 46, startAyah: 1 }, // Al-Ahqaf
    { juz: 27, name: "Qala Fama Khatbukum (قَالَ فَمَا خَطْبُكُمْ)", startSurah: 51, startAyah: 31 }, // Adh-Dhariyat
    { juz: 28, name: "Qadd Sami Allah (قَدْ سَمِعَ اللَّهُ)", startSurah: 58, startAyah: 1 }, // Al-Mujadila
    { juz: 29, name: "Tabarakallazi (تَبَارَكَ الَّذِي)", startSurah: 67, startAyah: 1 }, // Al-Mulk
    { juz: 30, name: "Amma Yatasa'aloon (عَمَّ يَتَسَاءَلُونَ)", startSurah: 78, startAyah: 1 } // An-Naba
];
// === PLACE THIS AT THE TOP OF YOUR SCRIPT, WITH OTHER GLOBAL DATA ===

const staticQuranicThemes = [
    // Virtues & Specific Ayahs/Surahs
    { id: 'static_01', name: "Ayat al-Kursi (Verse of the Throne)", exampleSurah: 2, exampleAyah: 255, description: "Greatest verse, protection, affirmation of Allah's sovereignty." },
    { id: 'static_02', name: "Surah Al-Fatihah (The Opening)", exampleSurah: 1, exampleAyah: 1, description: "Essence of the Quran, recited in every prayer." },
    { id: 'static_03', name: "Surah Yasin (Heart of the Quran)", exampleSurah: 36, exampleAyah: 1, description: "Recited for blessings, ease, and for the deceased." },
    { id: 'static_04', name: "Surah Al-Mulk (The Dominion - Protector from Grave)", exampleSurah: 67, exampleAyah: 1, description: "Recited for protection from torment of the grave." },
    { id: 'static_05', name: "Surah Al-Waqi'ah (The Inevitable - Sustenance)", exampleSurah: 56, exampleAyah: 1, description: "Recited for protection against poverty and for sustenance." },
    { id: 'static_06', name: "Surah Ar-Rahman (The Most Merciful - Bride of Quran)", exampleSurah: 55, exampleAyah: 1, description: "Highlights Allah's bounties and mercy." },
    { id: 'static_07', name: "Surah Al-Kahf (The Cave - Protection from Dajjal)", exampleSurah: 18, exampleAyah: 1, description: "Recited on Fridays, protection from Dajjal, stories of guidance." },
    { id: 'static_08', name: "Last two Ayahs of Surah Al-Baqarah", exampleSurah: 2, exampleAyah: 285, description: "Sufficient for protection and blessings if recited at night." },
    { id: 'static_09', name: "Surah Al-Ikhlas (Sincerity - Equals 1/3rd Quran)", exampleSurah: 112, exampleAyah: 1, description: "Pure monotheism, immense reward." },
    { id: 'static_10', name: "Surah Al-Falaq (The Daybreak - Protection)", exampleSurah: 113, exampleAyah: 1, description: "Seeking refuge from evil." },
    { id: 'static_11', name: "Surah An-Nas (Mankind - Protection)", exampleSurah: 114, exampleAyah: 1, description: "Seeking refuge from whispers of Shaytan." },
    { id: 'static_12', name: "Ayah for seeking Forgiveness (Syed-ul-Istighfar concept)", exampleSurah: 3, exampleAyah: 135, description: "Verses encouraging repentance and seeking forgiveness." }, // Rabbana zalamna anfusana
    { id: 'static_13', name: "Dua of Yunus (AS) / Ayat-e-Karima", exampleSurah: 21, exampleAyah: 87, description: "For relief from distress: La ilaha illa anta subhanaka inni kuntu minaz-zalimin." },
    { id: 'static_14', name: "Verse of Light (Ayat an-Nur)", exampleSurah: 24, exampleAyah: 35, description: "Metaphorical description of Allah's light and guidance." },
    { id: 'static_15', name: "Four Quls (Al-Kafirun, Al-Ikhlas, Al-Falaq, An-Nas)", exampleSurah: 109, exampleAyah: 1, description: "Collective term for these four protective Surahs." }, // Starts with Al-Kafirun

    // Daily Life Themes & Guidance
    { id: 'static_16', name: "Guidance in Decision Making (Istikhara concept)", exampleSurah: 2, exampleAyah: 216, description: "Trusting Allah's knowledge in what is good/bad for us." },
    { id: 'static_17', name: "Marriage and Family", exampleSurah: 30, exampleAyah: 21, description: "Signs of Allah in creating spouses for tranquility and affection." },
    { id: 'static_18', name: "Dealing with Grief and Loss", exampleSurah: 2, exampleAyah: 156, description: "Inna lillahi wa inna ilayhi raji'un - Turning to Allah in times of calamity." },
    { id: 'static_19', name: "Financial Dealings & Charity", exampleSurah: 2, exampleAyah: 261, description: "Parable of those who spend in Allah's way." },
    { id: 'static_20', name: "Good Conduct and Speech", exampleSurah: 17, exampleAyah: 53, description: "Speak that which is best." },
    { id: 'static_21', name: "Patience in Adversity", exampleSurah: 39, exampleAyah: 10, description: "The patient will be given their reward without account." },
    { id: 'static_22', name: "Seeking Knowledge", exampleSurah: 20, exampleAyah: 114, description: "Rabbi zidni ilma - My Lord, increase me in knowledge." },
    { id: 'static_23', name: "Respect for Parents", exampleSurah: 17, exampleAyah: 23, description: "Decree to not worship except Him, and to parents, good treatment." },
    { id: 'static_24', name: "Maintaining Ties of Kinship", exampleSurah: 4, exampleAyah: 1, description: "Fear Allah through whom you demand your mutual rights, and reverence the wombs." },
    { id: 'static_25', name: "Trust in Allah (Tawakkul)", exampleSurah: 65, exampleAyah: 3, description: "And whoever relies upon Allah - then He is sufficient for him." },
    { id: 'static_26', name: "Prohibition of Backbiting & Slander", exampleSurah: 49, exampleAyah: 12, description: "Avoid suspicion, do not spy or backbite each other." },
    { id: 'static_27', name: "Importance of Justice", exampleSurah: 5, exampleAyah: 8, description: "Be just; that is nearer to righteousness." },
    { id: 'static_28', name: "Humility", exampleSurah: 25, exampleAyah: 63, description: "Servants of the Most Merciful are those who walk upon the earth easily..." },
    { id: 'static_29', name: "Gratitude for Blessings", exampleSurah: 16, exampleAyah: 114, description: "So eat of what Allah has provided you lawful and good and be grateful for the favor of Allah." },
    { id: 'static_30', name: "Remembrance of Allah (Dhikr)", exampleSurah: 13, exampleAyah: 28, description: "Unquestionably, by the remembrance of Allah hearts are assured." },
    { id: 'static_31', name: "Overcoming Anxiety & Stress", exampleSurah: 94, exampleAyah: 5, description: "For indeed, with hardship [will be] ease." }, // Surah Ash-Sharh
    { id: 'static_32', name: "The Power of Dua (Supplication)", exampleSurah: 40, exampleAyah: 60, description: "And your Lord says, 'Call upon Me; I will respond to you.'" },
    { id: 'static_33', name: "Warning Against Arrogance", exampleSurah: 31, exampleAyah: 18, description: "And do not turn your cheek [in contempt] toward people..." },
    { id: 'static_34', name: "Importance of Consultation (Shura)", exampleSurah: 42, exampleAyah: 38, description: "...and whose affair is [determined by] consultation among themselves..." },
    { id: 'static_35', name: "Forgiving Others", exampleSurah: 64, exampleAyah: 14, description: "...but if you pardon and overlook and forgive - then indeed, Allah is Forgiving and Merciful." },
    { id: 'static_36', name: "Unity of the Ummah", exampleSurah: 3, exampleAyah: 103, description: "And hold firmly to the rope of Allah all together and do not become divided." },
    { id: 'static_37', name: "The Brevity of Worldly Life", exampleSurah: 57, exampleAyah: 20, description: "Know that the life of this world is but amusement and diversion..." },
    { id: 'static_38', name: "Reward for Good Deeds", exampleSurah: 99, exampleAyah: 7, description: "So whoever does an atom's weight of good will see it." },
    { id: 'static_39', name: "Call to Reflection (Tadabbur)", exampleSurah: 47, exampleAyah: 24, description: "Then do they not reflect upon the Qur'an, or are there locks upon [their] hearts?" },
    { id: 'static_40', name: "Friday Prayer (Jumu'ah)", exampleSurah: 62, exampleAyah: 9, description: "O you who have believed, when the adhan is called for the prayer on the day of Jumu'ah..." }
];

function getJuzFromSurahAyah(surah, ayah) {
    if (isNaN(surah) || isNaN(ayah) || surah < 1 || ayah < 1) return 1; // Default for invalid input

    for (let i = juzBoundariesData.length - 1; i >= 0; i--) {
        const boundary = juzBoundariesData[i];
        if (surah > boundary.startSurah || (surah === boundary.startSurah && ayah >= boundary.startAyah)) {
            return boundary.juz;
        }
    }
    return 1; // Should not happen if data is correct and input is valid Quran range
}

        const surahNames = [
            "Al-Fatihah", "Al-Baqarah", "Al 'Imran", "An-Nisa'", "Al-Ma'idah", "Al-An'am", "Al-A'raf", "Al-Anfal", "At-Tawbah", "Yunus",
            "Hud", "Yusuf", "Ar-Ra'd", "Ibrahim", "Al-Hijr", "An-Nahl", "Al-Isra'", "Al-Kahf", "Maryam", "Taha",
            "Al-Anbya'", "Al-Hajj", "Al-Mu'minun", "An-Nur", "Al-Furqan", "Ash-Shu'ara'", "An-Naml", "Al-Qasas", "Al-'Ankabut", "Ar-Rum",
            "Luqman", "As-Sajdah", "Al-Ahzab", "Saba'", "Fatir", "Ya-Sin", "As-Saffat", "Sad", "Az-Zumar", "Ghafir",
            "Fussilat", "Ash-Shura", "Az-Zukhruf", "Ad-Dukhan", "Al-Jathiyah", "Al-Ahqaf", "Muhammad", "Al-Fath", "Al-Hujurat", "Qaf",
            "Adh-Dhariyat", "At-Tur", "An-Najm", "Al-Qamar", "Ar-Rahman", "Al-Waqi'ah", "Al-Hadid", "Al-Mujadilah", "Al-Hashr", "Al-Mumtahanah",
            "As-Saff", "Al-Jumu'ah", "Al-Munafiqun", "At-Taghabun", "At-Talaq", "At-Tahrim", "Al-Mulk", "Al-Qalam", "Al-Haqqah", "Al-Ma'arij",
            "Nuh", "Al-Jinn", "Al-Muzzammil", "Al-Muddaththir", "Al-Qiyamah", "Al-Insan", "Al-Mursalat", "An-Naba'", "An-Nazi'at", "'Abasa",
            "At-Takwir", "Al-Infitar", "Al-Mutaffifin", "Al-Inshiqaq", "Al-Buruj", "At-Tariq", "Al-A'la", "Al-Ghashiyah", "Al-Fajr", "Al-Balad",
            "Ash-Shams", "Al-Layl", "Ad-Duha", "Ash-Sharh", "At-Tin", "Al-'Alaq", "Al-Qadr", "Al-Bayyinah", "Az-Zalzalah", "Al-'Adiyat",
            "Al-Qari'ah", "At-Takathur", "Al-'Asr", "Al-Humazah", "Al-Fil", "Quraysh", "Al-Ma'un", "Al-Kawthar", "Al-Kafirun", "An-Nasr",
            "Al-Masad", "Al-Ikhlas", "Al-Falaq", "An-Nas"
        ];
        const surahAyahCounts = [
            0, 7, 286, 200, 176, 120, 165, 206, 75, 129, 109, 123, 111, 43, 52, 99, 128, 111, 110, 98, 135, 112, 78, 118, 64, 77, 227, 93, 88, 69,
            60, 34, 30, 73, 54, 45, 83, 182, 88, 75, 85, 54, 53, 89, 59, 37, 35, 38, 29, 18, 45, 60, 49, 62, 55, 78, 96, 29, 22, 24,
            13, 14, 11, 11, 18, 12, 12, 30, 52, 52, 44, 28, 28, 20, 56, 40, 31, 50, 40, 46, 42, 29, 19, 36, 25, 22, 17, 19, 26, 30,
            20, 15, 21, 11, 8, 5, 19, 5, 8, 8, 11, 11, 8, 3, 9, 5, 4, 7, 3, 6, 3, 5, 4, 5, 6
        ];

        const TRANSLATION_CONFIG = {
            urdu: { file: 'data new.AM', lang: 'ur', dir: 'rtl', label: 'Urdu' },
            english: { file: 'dataENG.AM', lang: 'en', dir: 'ltr', label: 'English' },
            Bangali: { file: 'dataBNG.AM', lang: 'bn', dir: 'ltr', label: 'Bangali' }
        };


        // --- IndexedDB Functions ---
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    const oldVersion = event.oldVersion;
                    console.log(`IndexedDB upgrade needed from version ${oldVersion} to ${DB_VERSION}.`);

                    // Quran Store
                    if (!db.objectStoreNames.contains(STORE_QURAN)) {
                        db.createObjectStore(STORE_QURAN, { keyPath: ['surah', 'ayah'] });
                    } else if (oldVersion < 2) { // Example for multi-translation support (adjust version if needed)
                        console.log(`Upgrading ${STORE_QURAN} store schema. Clearing existing data for re-population.`);
                        db.deleteObjectStore(STORE_QURAN);
                        db.createObjectStore(STORE_QURAN, { keyPath: ['surah', 'ayah'] });
                    }

                    // Tafsir Store
                    if (!db.objectStoreNames.contains(STORE_TAFSIR)) {
                        db.createObjectStore(STORE_TAFSIR, { keyPath: ['surah', 'ayah'] });
                    }

                    // Themes Store
                    if (!db.objectStoreNames.contains(STORE_THEMES)) {
                        db.createObjectStore(STORE_THEMES, { keyPath: 'id', autoIncrement: true });
                    }

                    // Theme Ayahs Store
                    if (!db.objectStoreNames.contains(STORE_THEME_AYAHS)) {
                        const themeAyahsStore = db.createObjectStore(STORE_THEME_AYAHS, { keyPath: 'id', autoIncrement: true });
                        themeAyahsStore.createIndex('themeId', 'themeId', { unique: false });
                        themeAyahsStore.createIndex('surahAyah', ['surah', 'ayah'], { unique: false });
                    }

                    // Roots Store
                    if (!db.objectStoreNames.contains(STORE_ROOTS)) {
                        db.createObjectStore(STORE_ROOTS, { keyPath: 'id', autoIncrement: true });
                        // You might add an index for 'root' if you search by it often
                        // rootsStore.createIndex('rootTerm', 'root', { unique: true }); // If root terms are unique
                    }

                    // Root Ayahs Store (currently not used for linking in provided code, but good to have)
                    if (!db.objectStoreNames.contains(STORE_ROOT_AYAHS)) {
                        const rootAyahsStore = db.createObjectStore(STORE_ROOT_AYAHS, { keyPath: 'id', autoIncrement: true });
                        rootAyahsStore.createIndex('rootId', 'rootId', { unique: false });
                        rootAyahsStore.createIndex('surahAyah', ['surah', 'ayah'], { unique: false });
                        rootAyahsStore.createIndex('word', 'word', { unique: false });
                    }

                    // Recitations Store
                    if (!db.objectStoreNames.contains(STORE_RECITATIONS)) {
                        const recitationStore = db.createObjectStore(STORE_RECITATIONS, { keyPath: 'id', autoIncrement: true });
                        recitationStore.createIndex('surah', 'surah', { unique: false });
                        recitationStore.createIndex('date', 'date', { unique: false });
                    }

                    // Hifz Store
                    if (!db.objectStoreNames.contains(STORE_HIFZ)) {
                        const hifzStore = db.createObjectStore(STORE_HIFZ, { keyPath: ['surah', 'ayah'] });
                        hifzStore.createIndex('status', 'status', { unique: false });
                        hifzStore.createIndex('nextReviewDate', 'nextReviewDate', { unique: false });
                    }

                    // Settings Store
                    if (!db.objectStoreNames.contains(STORE_SETTINGS)) {
                         db.createObjectStore(STORE_SETTINGS, { keyPath: 'name' });
                    }

                    // Word Translations Store (data5 new.AM) - Keyed by word_id
                    if (db.objectStoreNames.contains(STORE_WORD_TRANSLATIONS)) {
                        if (oldVersion < 7) { // Version 7 introduced word_id keying
                            console.log(`Re-creating '${STORE_WORD_TRANSLATIONS}' for DB_VERSION ${DB_VERSION} to be keyed by 'word_id'.`);
                            db.deleteObjectStore(STORE_WORD_TRANSLATIONS);
                            db.createObjectStore(STORE_WORD_TRANSLATIONS, { keyPath: 'word_id' });
                        }
                    } else {
                        console.log(`Creating new '${STORE_WORD_TRANSLATIONS}' store, keyed by 'word_id'.`);
                        db.createObjectStore(STORE_WORD_TRANSLATIONS, { keyPath: 'word_id' });
                    }

                    // Word Metadata Store (data2.AM) - Keyed by word_id, indexed by location
                    if (!db.objectStoreNames.contains(STORE_WORD_METADATA)) {
                        console.log(`Creating new '${STORE_WORD_METADATA}' store for DB_VERSION ${DB_VERSION}.`);
                        const wordMetadataStore = db.createObjectStore(STORE_WORD_METADATA, { keyPath: 'word_id' });
                        wordMetadataStore.createIndex('location_idx', ['surah', 'ayah', 'word_position'], { unique: true });
                    } else if (oldVersion < 7) { // Version 7 introduced this store
                        console.log(`Re-creating '${STORE_WORD_METADATA}' for DB_VERSION ${DB_VERSION}.`);
                        db.deleteObjectStore(STORE_WORD_METADATA);
                        const wordMetadataStore = db.createObjectStore(STORE_WORD_METADATA, { keyPath: 'word_id' });
                        wordMetadataStore.createIndex('location_idx', ['surah', 'ayah', 'word_position'], { unique: true });
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("IndexedDB opened successfully.");
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.errorCode, event.target.error);
                    reject("Failed to open IndexedDB: " + event.target.error.message);
                };
            });
        }
        // --- Thematic Linker Functions ---
        async function populateThemeSelects() {
            if (!db) return;
            const themeSelectElements = [
                document.getElementById('parent-theme-select'),
                document.getElementById('link-theme-select')
            ];
            try {
                const themes = await getAllData(STORE_THEMES);
                themeSelectElements.forEach(select => {
                    // Guard against null select elements if the "Themes" section isn't active/visible
                    if (!select) return; 
                    
                    const preservedValue = select.value;
                    select.innerHTML = ''; // Clear existing options
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.textContent = select.id === 'parent-theme-select' ? "-- No Parent --" : "-- Select Theme --";
                    select.appendChild(defaultOption);

                    themes.forEach(theme => {
                        const option = document.createElement('option');
                        option.value = theme.id;
                        option.textContent = theme.name;
                        select.appendChild(option);
                    });

                    // Try to restore previous selection if possible
                    if (select.querySelector(`option[value="${preservedValue}"]`)) {
                        select.value = preservedValue;
                    } else {
                        select.value = ""; // Default to the "-- Select --" or "-- No Parent --" option
                    }
                });
            } catch (error) {
                 console.error("Error populating theme selects:", error);
                 // If setStatusMessage is available and relevant context exists
                 if (typeof setStatusMessage === "function" && document.getElementById('theme-manager-status')) {
                     setStatusMessage('theme-manager-status', 'Failed to load themes for dropdowns.', true);
                 }
            }
        }
        function getObjectStore(storeName, mode) {
            if (!db) {
                console.error("getObjectStore called but DB is not initialized.");
                throw new Error("Database not initialized.");
            }
            const transaction = db.transaction(storeName, mode);
            return transaction.objectStore(storeName);
        }

        
async function populateThemesIndexList() {
    console.log("populateThemesIndexList: Function called."); // Log function entry

    const themeListEl = document.getElementById('fsIndexThemeList');
    const searchInput = document.getElementById('fsThematicIndexSearchInput');

    if (!themeListEl) {
        console.error("populateThemesIndexList: CRITICAL - Theme list element '#fsIndexThemeList' not found in DOM!");
        // Attempt to show an error directly in a fallback location if reader is active
        const contentDiv = document.getElementById('fsReaderContent');
        if (contentDiv) contentDiv.innerHTML = "<p style='color:red; text-align:center;'>Error: Theme list UI element missing.</p>";
        return;
    }
    if (!searchInput) {
        console.warn("populateThemesIndexList: Theme search input '#fsThematicIndexSearchInput' not found. Search will not work.");
        // Proceed without search if input is missing, but list should still populate
    }

    themeListEl.innerHTML = '<li>Loading themes...</li>'; // Initial message

    let dbThemes = [];
    try {
        if (db && typeof getAllData === "function") { // Ensure DB is open and function exists
            dbThemes = await getAllData(STORE_THEMES);
            console.log("populateThemesIndexList: Fetched DB themes:", dbThemes ? dbThemes.length : 'null/undefined');
        } else {
            console.warn("populateThemesIndexList: Database not ready or getAllData not available. Proceeding with static themes only.");
        }
    } catch (dbError) {
        console.error("populateThemesIndexList: Error fetching DB themes:", dbError);
        // Continue with static themes even if DB themes fail
    }

    // Ensure staticQuranicThemes is defined and has content
    if (typeof staticQuranicThemes === 'undefined' || !Array.isArray(staticQuranicThemes)) {
        console.error("populateThemesIndexList: CRITICAL - staticQuranicThemes array is not defined!");
        themeListEl.innerHTML = '<li>Error: Static theme data is missing.</li>';
        return;
    }
    // console.log("populateThemesIndexList: Static themes count:", staticQuranicThemes.length);


    const combinedThemes = [
        ...staticQuranicThemes.map(st => ({
            id: st.id, 
            name: st.name, 
            isStatic: true, 
            exampleSurah: st.exampleSurah, 
            exampleAyah: st.exampleAyah,
            description: st.description || "" // Add description for search
        })),
        ...(dbThemes || []).map(dbt => ({ // Handle if dbThemes is null/undefined
            id: dbt.id, 
            name: dbt.name, 
            isStatic: false,
            description: dbt.description || "" // Assuming DB themes might have a description
        }))
    ];
    // console.log("populateThemesIndexList: Combined themes count:", combinedThemes.length);


    let themesToDisplay = [...combinedThemes];

    const renderList = (themes) => {
        // console.log("populateThemesIndexList - renderList: Rendering with themes:", themes.length);
        themeListEl.innerHTML = ''; // Clear previous items (like "Loading themes...")
        if (themes.length === 0) {
            themeListEl.innerHTML = '<li>No themes found.</li>'; // This is the message you are seeing
            return;
        }
        themes.sort((a, b) => a.name.localeCompare(b.name));

        themes.forEach(theme => {
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = '#';
            a.dataset.themeId = theme.id;
            a.dataset.isStatic = theme.isStatic;
            if (theme.isStatic) {
                a.dataset.exampleSurah = theme.exampleSurah;
                a.dataset.exampleAyah = theme.exampleAyah;
            }
            a.textContent = theme.name;
            a.addEventListener('click', handleIndexThemeClick);
            li.appendChild(a);
            themeListEl.appendChild(li);
        });
    };
    
    renderList(themesToDisplay); // Render the combined list

    if (searchInput) { // Only add listener if searchInput exists
        searchInput.removeEventListener('input', themeSearchHandler); // Remove previous listener
        searchInput.addEventListener('input', themeSearchHandler);
    }
}

// Separate handler for theme search to easily remove/add listener
function themeSearchHandler(e) {
    const themeListEl = document.getElementById('fsIndexThemeList'); // Re-fetch in handler scope
    if (!themeListEl) return;

    // Re-fetch combinedThemes or pass it appropriately if not global
    // For simplicity, assuming staticQuranicThemes is global and dbThemes can be re-fetched or cached briefly
    // This part might need refinement if dbThemes is large and frequently re-fetched.
    // For now, let's assume combinedThemes is re-calculated if search input is used.
    
    const searchTerm = e.target.value.toLowerCase().trim();
    
    // Re-calculate combinedThemes for filtering
    // This is not ideal for performance if dbThemes is large.
    // A better approach would be to have combinedThemes available in a wider scope
    // or pass it to this handler. For now, quick recalculation:
    let currentDbThemes = [];
    if (db && typeof getAllData === "function") {
        getAllData(STORE_THEMES).then(fetchedDbThemes => { // Asynchronous, this logic flow for live search needs care
            currentDbThemes = fetchedDbThemes || [];
            filterAndRender(currentDbThemes);
        }).catch(() => filterAndRender([])); // Handle error by filtering static only
    } else {
        filterAndRender([]);
    }

    function filterAndRender(dbThemesForFilter) {
        const allCombinedForSearch = [
             ...staticQuranicThemes.map(st => ({id: st.id, name: st.name, isStatic: true, exampleSurah: st.exampleSurah, exampleAyah: st.exampleAyah, description: st.description || ""})),
             ...(dbThemesForFilter).map(dbt => ({id: dbt.id, name: dbt.name, isStatic: false, description: dbt.description || ""}))
        ];

        let filteredThemes;
        if (!searchTerm) {
            filteredThemes = [...allCombinedForSearch];
        } else {
            filteredThemes = allCombinedForSearch.filter(theme => 
                theme.name.toLowerCase().includes(searchTerm) ||
                (theme.description && theme.description.toLowerCase().includes(searchTerm)) // Also search description
            );
        }
        
        // Re-use the inner renderList logic - might need to extract renderList to be accessible here
        // For now, quick re-implementation of list rendering for search:
        themeListEl.innerHTML = '';
        if (filteredThemes.length === 0) {
            themeListEl.innerHTML = '<li>No themes match your search.</li>';
            return;
        }
        filteredThemes.sort((a,b) => a.name.localeCompare(b.name));
        filteredThemes.forEach(theme => {
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = '#';
            a.dataset.themeId = theme.id;
            a.dataset.isStatic = theme.isStatic;
            if (theme.isStatic) {
                a.dataset.exampleSurah = theme.exampleSurah;
                a.dataset.exampleAyah = theme.exampleAyah;
            }
            a.textContent = theme.name;
            a.addEventListener('click', handleIndexThemeClick);
            li.appendChild(a);
            themeListEl.appendChild(li);
        });
    }
}

        function addData(storeName, data) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.add(data);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error adding data to ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

         function putData(storeName, data) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.put(data);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error putting data to ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function getData(storeName, key) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readonly');
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                     console.error(`Error getting data from ${storeName} with key ${key}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function getAllData(storeName) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readonly');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error getting all data from ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function deleteData(storeName, key) {
             return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.delete(key);
                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error(`Error deleting data from ${storeName} with key ${key}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

         function clearStore(storeName) {
             return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error(`Error clearing store ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
         }


        // --- Data Loading and Parsing ---
                async function loadQuranData() {
            // Reset progress counters
            completedProgressUnits = 0;
            totalProgressUnits = 0;

            // Define weights for different loading stages
            const WEIGHT_CHECK_SETTINGS = 1;
            const WEIGHT_FETCH_FILE = 2;
            const WEIGHT_PARSE_QURAN_FILE = 8; // Per full Quran text file
            const WEIGHT_PARSE_WORD_FILE = 12; // Per word data file (translations or metadata)
            const WEIGHT_DB_TRANSACTION_SETUP = 2;
            const WEIGHT_DB_TRANSACTION_ITEM = 0.01; // Small weight per item stored
            const WEIGHT_DB_TRANSACTION_COMPLETE = 5;


            try {
                const settingsLoadedQuran = await getData(STORE_SETTINGS, 'quranDataLoaded').catch(() => null);
                const settingsLoadedWordTranslations = await getData(STORE_SETTINGS, 'wordTranslationsLoaded').catch(() => null);
                const settingsLoadedWordMetadata = await getData(STORE_SETTINGS, 'wordMetadataLoaded').catch(() => null);
                const lastLoadedVersionEntry = await getData(STORE_SETTINGS, 'lastLoadedDBVersion').catch(() => null);
                const lastLoadedVersion = lastLoadedVersionEntry ? lastLoadedVersionEntry.value : 0;

                const currentDBVersionForCheck = DB_VERSION; // Use the global DB_VERSION
                const needsUpdateDueToVersion = DB_VERSION > lastLoadedVersion;

                // Determine if data needs to be reloaded/updated
                const shouldLoadQuran = !(settingsLoadedQuran && settingsLoadedQuran.value === true && !needsUpdateDueToVersion && DB_VERSION >= 2);
                const shouldLoadWordTranslations = !(settingsLoadedWordTranslations && settingsLoadedWordTranslations.value === true && !needsUpdateDueToVersion && DB_VERSION >= currentDBVersionForCheck);
                const shouldLoadWordMetadata = !(settingsLoadedWordMetadata && settingsLoadedWordMetadata.value === true && !needsUpdateDueToVersion && DB_VERSION >= currentDBVersionForCheck);

                // Calculate totalProgressUnits based on what *will* be loaded
                totalProgressUnits += WEIGHT_CHECK_SETTINGS;

                if (shouldLoadQuran) {
                    totalProgressUnits += Object.keys(TRANSLATION_CONFIG).length * (WEIGHT_FETCH_FILE + WEIGHT_PARSE_QURAN_FILE);
                    // Estimate items for DB transaction progress (approx 6236 ayahs)
                    totalProgressUnits += 6236 * WEIGHT_DB_TRANSACTION_ITEM;
                }
                if (shouldLoadWordTranslations) {
                    totalProgressUnits += WEIGHT_FETCH_FILE + WEIGHT_PARSE_WORD_FILE;
                     // Estimate items for word translations (e.g., 80k words) - adjust if you have a count
                    totalProgressUnits += 80000 * WEIGHT_DB_TRANSACTION_ITEM;
                }
                if (shouldLoadWordMetadata) {
                    totalProgressUnits += WEIGHT_FETCH_FILE + WEIGHT_PARSE_WORD_FILE;
                    // Estimate items for word metadata (e.g., 80k words)
                    totalProgressUnits += 80000 * WEIGHT_DB_TRANSACTION_ITEM;
                }

                if (shouldLoadQuran || shouldLoadWordTranslations || shouldLoadWordMetadata) {
                    totalProgressUnits += WEIGHT_DB_TRANSACTION_SETUP + WEIGHT_DB_TRANSACTION_COMPLETE;
                }
                
                // If totalProgressUnits is effectively just for checking settings, it means nothing else to load
                if (totalProgressUnits <= WEIGHT_CHECK_SETTINGS && !shouldLoadQuran && !shouldLoadWordTranslations && !shouldLoadWordMetadata) {
                    console.log("All necessary Quran, word translation, and word metadata already loaded and up-to-date.");
                    quranDataLoaded = true;
                    await populateSurahAyahSelects();
                    await loadAyah(currentSurah, currentAyah);
                    // No showLoading/hideLoading here if we skip intensive loading
                    return;
                }

                let primaryLoadingMessage = "Setting up Quran Studio for the first time...";
                if (lastLoadedVersion > 0) { // Not the very first time
                    if (needsUpdateDueToVersion) {
                        primaryLoadingMessage = "Updating Quran Studio data for a new version...";
                    } else {
                        // This case should ideally be caught by the early return above,
                        // but as a fallback if logic leads here.
                        primaryLoadingMessage = "Verifying Quran Studio data...";
                    }
                }
                showLoading(primaryLoadingMessage, "Checking existing data...", 0);
                updateLoadingProgress(WEIGHT_CHECK_SETTINGS, "Checked local data status.");

                if (!shouldLoadQuran && !shouldLoadWordTranslations && !shouldLoadWordMetadata) {
                    console.log("All necessary Quran, word translation, and word metadata already loaded.");
                    quranDataLoaded = true;
                    await populateSurahAyahSelects();
                    await loadAyah(currentSurah, currentAyah);
                    updateLoadingProgress(totalProgressUnits - completedProgressUnits, "Data verified. Launching Studio..."); // Complete progress
                    setTimeout(hideLoading, 500); // Brief pause before hiding
                    return;
                }

                const storesToAccessInTransaction = [STORE_SETTINGS];
                if (shouldLoadQuran) storesToAccessInTransaction.push(STORE_QURAN);
                if (shouldLoadWordTranslations) storesToAccessInTransaction.push(STORE_WORD_TRANSLATIONS);
                if (shouldLoadWordMetadata) storesToAccessInTransaction.push(STORE_WORD_METADATA);

                const allQuranDataMap = new Map();
                let wordTranslationEntries = [];
                let wordMetadataEntries = [];

                // --- 1. Load Full Quran Ayah Texts & Translations ---
                if (shouldLoadQuran) {
                    console.log("Fetching full Quran ayah texts and translations...");
                    for (const key in TRANSLATION_CONFIG) {
                        const config = TRANSLATION_CONFIG[key];
                        try {
                            updateLoadingProgress(0, `Fetching ${config.label} text (${config.file.substring(0,15)})...`);
                            const response = await fetch(config.file);
                            updateLoadingProgress(WEIGHT_FETCH_FILE, `Processing ${config.label} (${config.file.substring(0,15)})...`);
                            if (!response.ok) {
                                console.warn(`HTTP error! status: ${response.status} for ${config.file}. Skipping.`);
                                updateLoadingProgress(WEIGHT_PARSE_QURAN_FILE, `Skipped ${config.label} due to error.`);
                                continue;
                            }
                            const text = await response.text();
                            console.log(`${config.label} data fetched (${config.file}). Parsing...`);

                            const lines = text.split('\n').filter(line => line.trim() !== '');
                            for (const line of lines) {
                                const parts = line.split(' ترجمہ: ');
                                if (parts.length < 2) continue;
                                const arabicPart = parts[0].trim();
                                const rest = parts[1];
                                const metaMatch = rest.match(/<br\/>\s*(?:s|س)\s*\.?\s*(\d{1,3})\s*(?:a|آ)\s*\.?\s*(\d{1,3})\s*$/i);
                                if (!metaMatch) continue;

                                const translationPart = rest.substring(0, metaMatch.index).trim();
                                const surahNum = parseInt(metaMatch[1], 10);
                                const ayahNum = parseInt(metaMatch[2], 10);

                                if (isNaN(surahNum) || isNaN(ayahNum) || surahNum < 1 || surahNum > 114 || ayahNum < 1) continue;

                                const mapKey = `${surahNum}-${ayahNum}`;
                                let entry = allQuranDataMap.get(mapKey);
                                if (!entry) {
                                    entry = { surah: surahNum, ayah: ayahNum, arabic: arabicPart, urdu: '', english: '', Bangali: '' };
                                    allQuranDataMap.set(mapKey, entry);
                                }
                                entry[key] = translationPart;
                            }
                            updateLoadingProgress(WEIGHT_PARSE_QURAN_FILE, `Processed ${config.label} data.`);
                        } catch (fetchError) {
                             console.error(`Error fetching/parsing ${config.file}:`, fetchError);
                             updateLoadingProgress(WEIGHT_PARSE_QURAN_FILE, `Error with ${config.label}.`);
                        }
                    }
                    console.log(`Parsed ${allQuranDataMap.size} unique full ayahs.`);
                }

                // --- 2. Load Word Translations (from data5 new.AM) ---
                if (shouldLoadWordTranslations) {
                    console.log(`Fetching word translations from ${WORD_TRANSLATION_FILE}...`);
                    try {
                        updateLoadingProgress(0, `Fetching word translations (${WORD_TRANSLATION_FILE.substring(0,15)})...`);
                        const response = await fetch(WORD_TRANSLATION_FILE);
                        updateLoadingProgress(WEIGHT_FETCH_FILE, `Processing word translations (${WORD_TRANSLATION_FILE.substring(0,15)})...`);
                        if (!response.ok) {
                            console.warn(`Failed to fetch ${WORD_TRANSLATION_FILE}: ${response.status}`);
                            updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Skipped word translations due to error.`);
                        } else {
                            const csvText = await response.text();
                            const lines = csvText.split('\n').filter(line => line.trim() !== '');
                            if (lines.length > 0) {
                                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                                const wordIdIndex = headers.indexOf('word_id');
                                const urMeaningIndex = headers.indexOf('ur_meaning');
                                const enMeaningIndex = headers.indexOf('en_meaning');

                                if (wordIdIndex === -1) {
                                    console.error(`'word_id' header not found in ${WORD_TRANSLATION_FILE}. Cannot process word translations.`);
                                } else {
                                    for (let i = 1; i < lines.length; i++) {
                                        const values = lines[i].split(',');
                                        const word_id_val = values[wordIdIndex] ? values[wordIdIndex].trim() : null;
                                        if (!word_id_val) continue;

                                        const entry = {
                                            word_id: parseInt(word_id_val, 10),
                                            ur_meaning: urMeaningIndex > -1 && values[urMeaningIndex] ? values[urMeaningIndex].trim() : '',
                                            en_meaning: enMeaningIndex > -1 && values[enMeaningIndex] ? values[enMeaningIndex].trim() : '',
                                        };
                                        if (!isNaN(entry.word_id)) {
                                            wordTranslationEntries.push(entry);
                                        }
                                    }
                                    console.log(`Parsed ${wordTranslationEntries.length} word translation entries from ${WORD_TRANSLATION_FILE}.`);
                                }
                            }
                             updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Processed ${wordTranslationEntries.length} word translations.`);
                        }
                    } catch (fetchError) {
                        console.error(`Error fetching/parsing ${WORD_TRANSLATION_FILE}:`, fetchError);
                        updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Error with word translations.`);
                    }
                }

                // --- 3. Load Word Metadata (from data2.AM) ---
                if (shouldLoadWordMetadata) {
                    console.log(`Fetching word metadata from ${WORD_METADATA_FILE}...`);
                    try {
                        updateLoadingProgress(0, `Fetching word metadata (${WORD_METADATA_FILE.substring(0,15)})...`);
                        const response = await fetch(WORD_METADATA_FILE);
                        updateLoadingProgress(WEIGHT_FETCH_FILE, `Processing word metadata (${WORD_METADATA_FILE.substring(0,15)})...`);
                        if (!response.ok) {
                            console.warn(`Failed to fetch ${WORD_METADATA_FILE}: ${response.status}`);
                             updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Skipped word metadata due to error.`);
                        } else {
                            const csvText = await response.text();
                            const lines = csvText.split('\n').filter(line => line.trim() !== '');
                            if (lines.length > 0) {
                                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                                const wordIdIndex = headers.indexOf('word_id');
                                const surahIndex = headers.indexOf('surah');
                                const ayahIndex = headers.indexOf('ayah');
                                const positionIndex = headers.indexOf('word_postion');

                                if (wordIdIndex === -1 || surahIndex === -1 || ayahIndex === -1 || positionIndex === -1) {
                                    console.error(`One or more required headers not found in ${WORD_METADATA_FILE}.`);
                                } else {
                                    for (let i = 1; i < lines.length; i++) {
                                        const values = lines[i].split(',');
                                        const entry = {
                                            word_id: parseInt(values[wordIdIndex] ? values[wordIdIndex].trim() : '', 10),
                                            surah: parseInt(values[surahIndex] ? values[surahIndex].trim() : '', 10),
                                            ayah: parseInt(values[ayahIndex] ? values[ayahIndex].trim() : '', 10),
                                            word_position: parseInt(values[positionIndex] ? values[positionIndex].trim() : '', 10)
                                        };
                                        if (!isNaN(entry.word_id) && !isNaN(entry.surah) && !isNaN(entry.ayah) && !isNaN(entry.word_position)) {
                                            wordMetadataEntries.push(entry);
                                        }
                                    }
                                    console.log(`Parsed ${wordMetadataEntries.length} word metadata entries from ${WORD_METADATA_FILE}.`);
                                }
                            }
                            updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Processed ${wordMetadataEntries.length} word metadata entries.`);
                        }
                    } catch (fetchError) {
                         console.error(`Error fetching/parsing ${WORD_METADATA_FILE}:`, fetchError);
                         updateLoadingProgress(WEIGHT_PARSE_WORD_FILE, `Error with word metadata.`);
                    }
                }

                // --- Transaction to Store Data ---
                if (storesToAccessInTransaction.length > 1 && (shouldLoadQuran || shouldLoadWordTranslations || shouldLoadWordMetadata)) {
                    updateLoadingProgress(WEIGHT_DB_TRANSACTION_SETUP, "Preparing to save data to local database...");
                    const transaction = db.transaction(storesToAccessInTransaction, 'readwrite');
                    
                    transaction.oncomplete = async () => {
                        console.log("Data loading/storing transaction complete.");
                        if (shouldLoadQuran) await putData(STORE_SETTINGS, { name: 'quranDataLoaded', value: true }).catch(console.error);
                        if (shouldLoadWordTranslations) await putData(STORE_SETTINGS, { name: 'wordTranslationsLoaded', value: true }).catch(console.error);
                        if (shouldLoadWordMetadata) await putData(STORE_SETTINGS, { name: 'wordMetadataLoaded', value: true }).catch(console.error);
                        await putData(STORE_SETTINGS, { name: 'lastLoadedDBVersion', value: DB_VERSION }).catch(console.error);

                        updateLoadingProgress(WEIGHT_DB_TRANSACTION_COMPLETE, "All data saved locally!");
                        
                        // Ensure progress reaches 100% if there are minor rounding/estimation issues
                        const finalRemaining = totalProgressUnits - completedProgressUnits;
                        if (finalRemaining > 0) updateLoadingProgress(finalRemaining, "Finalizing setup...");
                        
                        quranDataLoaded = true;
                        await populateSurahAyahSelects();
                        await loadAyah(currentSurah, currentAyah);
                        setTimeout(hideLoading, 500); // Give a moment for user to see "complete"
                    };
                    transaction.onerror = (event) => {
                        console.error("Transaction failed during initial data load:", event.target.error);
                        updateLoadingProgress(WEIGHT_DB_TRANSACTION_COMPLETE, "Error saving data. Please try refreshing.");
                        // Do not hide loading immediately on error, let user see message
                        // setTimeout(hideLoading, 3000);
                        alert("Failed to store initial data: " + event.target.error.message + "\nPlease clear website data (cache and site data for this page) and refresh.");
                    };

                    if (shouldLoadQuran && allQuranDataMap.size > 0) {
                        updateLoadingProgress(0, `Saving ${allQuranDataMap.size} Ayahs to database...`);
                        const quranStore = transaction.objectStore(STORE_QURAN);
                        if (needsUpdateDueToVersion || !(settingsLoadedQuran && settingsLoadedQuran.value === true)) { // Clear only if new load or version update
                           await new Promise(resolve => quranStore.clear().onsuccess = resolve); // Clear before repopulating
                        }
                        let count = 0;
                        for (const entry of allQuranDataMap.values()) {
                             quranStore.put(entry);
                             count++;
                             if (count % 500 === 0) updateLoadingProgress(500 * WEIGHT_DB_TRANSACTION_ITEM, `Saved ${count} Ayahs...`);
                        }
                        updateLoadingProgress((allQuranDataMap.size % 500) * WEIGHT_DB_TRANSACTION_ITEM, `Finished saving Ayahs.`);
                    }
                    if (shouldLoadWordTranslations && wordTranslationEntries.length > 0) {
                        updateLoadingProgress(0, `Saving ${wordTranslationEntries.length} word translations...`);
                        const store = transaction.objectStore(STORE_WORD_TRANSLATIONS);
                        if (needsUpdateDueToVersion || !(settingsLoadedWordTranslations && settingsLoadedWordTranslations.value === true)) {
                            await new Promise(resolve => store.clear().onsuccess = resolve);
                        }
                        let count = 0;
                        for (const entry of wordTranslationEntries) {
                             store.put(entry);
                             count++;
                             if (count % 2000 === 0) updateLoadingProgress(2000 * WEIGHT_DB_TRANSACTION_ITEM, `Saved ${count} word translations...`);
                        }
                        updateLoadingProgress((wordTranslationEntries.length % 2000) * WEIGHT_DB_TRANSACTION_ITEM, `Finished saving word translations.`);
                    }
                    if (shouldLoadWordMetadata && wordMetadataEntries.length > 0) {
                         updateLoadingProgress(0, `Saving ${wordMetadataEntries.length} word metadata entries...`);
                        const store = transaction.objectStore(STORE_WORD_METADATA);
                        if (needsUpdateDueToVersion || !(settingsLoadedWordMetadata && settingsLoadedWordMetadata.value === true)) {
                            await new Promise(resolve => store.clear().onsuccess = resolve);
                        }
                        let count = 0;
                        for (const entry of wordMetadataEntries) {
                             store.put(entry);
                             count++;
                             if (count % 2000 === 0) updateLoadingProgress(2000 * WEIGHT_DB_TRANSACTION_ITEM, `Saved ${count} word metadata entries...`);
                        }
                        updateLoadingProgress((wordMetadataEntries.length % 2000) * WEIGHT_DB_TRANSACTION_ITEM, `Finished saving word metadata.`);
                    }
                } else {
                     console.log("No new data needed to be fetched and stored. Initializing UI.");
                     quranDataLoaded = true;
                     await populateSurahAyahSelects();
                     await loadAyah(currentSurah, currentAyah);
                     // Ensure progress is marked as complete if we reached here.
                     const remainingUnits = totalProgressUnits - completedProgressUnits;
                     if (remainingUnits > 0) updateLoadingProgress(remainingUnits, "Data verification complete.");
                     setTimeout(hideLoading, 500);
                }

            } catch (error) {
                console.error("Error in loadQuranData:", error);
                // Make sure loading screen is shown with error if it wasn't already
                if (document.getElementById('loading-overlay').style.display === 'none') {
                     showLoading("Application Error", "An error occurred during initialization.", 100);
                } else {
                     updateLoadingProgress(0, "Critical error during setup.");
                }
                document.getElementById('loading-message-secondary').textContent = `Error: ${error.message}. Please try refreshing.`;
                document.getElementById('loading-message-secondary').style.color = 'var(--color-error, red)';
                // Do not hide loading immediately on critical error
                // setTimeout(hideLoading, 5000); // Or keep it shown
                alert("Failed to load application data: " + error.message + "\nIf the problem persists, try clearing website data for this page and then refresh.");
            }
            // The `finally` block is removed as hideLoading is now called conditionally
            // within the try or on transaction.oncomplete.
        }
        // --- UI Rendering and Navigation ---

        function populateSurahAyahSelects() {
            const surahSelect = document.getElementById('surah-select');
            const ayahSelect = document.getElementById('ayah-select');
            const recSurahSelect = document.getElementById('rec-surah-select');
            const hifzSurahSelect = document.getElementById('hifz-surah-select');

            if (surahSelect.options.length === 0) {
                for (let i = 1; i <= 114; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `${i}. ${surahNames[i - 1]}`;
                    surahSelect.appendChild(option.cloneNode(true));
                    recSurahSelect.appendChild(option.cloneNode(true));
                    hifzSurahSelect.appendChild(option.cloneNode(true));
                }
            }
            surahSelect.value = currentSurah;
            recSurahSelect.value = currentSurah;
            hifzSurahSelect.value = currentSurah;
            updateAyahSelect(currentSurah);
            ayahSelect.value = currentAyah;
        }

        function updateAyahSelect(surahNum) {
            const ayahSelect = document.getElementById('ayah-select');
            ayahSelect.innerHTML = '';
            totalAyahsInSurah = surahAyahCounts[surahNum];
            for (let i = 1; i <= totalAyahsInSurah; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                ayahSelect.appendChild(option);
            }
            if (currentAyah > totalAyahsInSurah) {
                currentAyah = 1;
            }
            ayahSelect.value = currentAyah;
        }

        async function loadAyah(surah, ayah) {
            if (!db) {
                console.error("Database not open for loadAyah.");
                document.getElementById('quran-display').innerHTML = `<p class="text-center" style="color: var(--color-error);">Database not ready. Please try again later.</p>`;
                return;
            }
            showLoading(`Loading Ayah ${surah}:${ayah}...`);
            try {
                const quran = await getData(STORE_QURAN, [surah, ayah]);
                const tafsir = await getData(STORE_TAFSIR, [surah, ayah]);

                const displayArea = document.getElementById('quran-display');
                const tafsirAyahDisplay = document.getElementById('current-ayah-tafsir');
                const themeAyahDisplay = document.getElementById('current-ayah-theme-text');
                const tafsirNotes = document.getElementById('tafsir-notes');

                displayArea.innerHTML = '';
                tafsirAyahDisplay.innerHTML = '';
                themeAyahDisplay.innerHTML = '';
                tafsirNotes.value = '';

                if (quran) {
                    currentSurah = surah;
                    currentAyah = ayah;
                    document.getElementById('surah-select').value = surah;
                    document.getElementById('ayah-select').value = ayah;
                    document.getElementById('rec-surah-select').value = surah;
                    document.getElementById('hifz-surah-select').value = surah;
                    updateAyahSelect(surah);

                    const ayahElement = document.createElement('div');
                    ayahElement.classList.add('ayah');
                    ayahElement.setAttribute('data-surah', surah);
                    ayahElement.setAttribute('data-ayah', ayah);

                    const ayahNumber = document.createElement('div');
                    ayahNumber.classList.add('ayah-number');
                    ayahNumber.textContent = `Surah ${surah}:${ayah} (${surahNames[surah-1]})`;
                    ayahElement.appendChild(ayahNumber);

                    const arabicTextElement = document.createElement('div');
                    arabicTextElement.classList.add('ayah-arabic');
                    arabicTextElement.setAttribute('lang', 'ar');
                    arabicTextElement.setAttribute('dir', 'rtl');

                    const words = quran.arabic.split(/\s+/).filter(w => w.trim() !== '');
                    words.forEach((wordText, index) => {
                        const span = document.createElement('span');
                        span.textContent = wordText + ' ';
                        span.setAttribute('data-word-text', wordText.trim());
                        span.setAttribute('data-word-position', index);
                        span.setAttribute('data-surah', surah);
                        span.setAttribute('data-ayah', ayah);
                        span.setAttribute('tabindex', '0');
                        span.setAttribute('role', 'button');
                        arabicTextElement.appendChild(span);
                    });
                    ayahElement.appendChild(arabicTextElement);

                    const translationText = document.createElement('div');
                    translationText.classList.add('ayah-translation');
                    const selectedTranslationKey = document.getElementById('translation-select').value;
                    const translationInfo = TRANSLATION_CONFIG[selectedTranslationKey];
                    if (translationInfo) {
                        translationText.setAttribute('lang', translationInfo.lang);
                        translationText.setAttribute('dir', translationInfo.dir);
                        translationText.style.fontFamily = `var(--font-${selectedTranslationKey})`;
                        translationText.style.textAlign = translationInfo.dir === 'rtl' ? 'right' : 'left';
                        translationText.textContent = quran[selectedTranslationKey] || "Translation not available.";
                    } else {
                        translationText.textContent = "Translation configuration error.";
                    }
                    ayahElement.appendChild(translationText);
                    displayArea.appendChild(ayahElement);

                    const tafsirAyahElement = ayahElement.cloneNode(true);
                    tafsirAyahElement.querySelector('.ayah-number').textContent = `Tafsir for Surah ${surah}:${ayah}`;
                    tafsirAyahElement.querySelectorAll('.ayah-arabic span').forEach(span => span.outerHTML = span.textContent);
                    tafsirAyahDisplay.innerHTML = '';
                    tafsirAyahDisplay.appendChild(tafsirAyahElement);
                    tafsirNotes.value = tafsir ? tafsir.notes : '';

                    const themeAyahElement = ayahElement.cloneNode(true);
                    themeAyahElement.querySelector('.ayah-number').textContent = `Ayah for Linking: Surah ${surah}:${ayah}`;
                    themeAyahElement.querySelectorAll('.ayah-arabic span').forEach(span => span.outerHTML = span.textContent);
                    themeAyahDisplay.innerHTML = '';
                    themeAyahDisplay.appendChild(themeAyahElement);
                    document.getElementById('current-ayah-theme-ref').textContent = `${surah}:${ayah}`;
                    await populateThemeSelects();
                    await displayLinkedAyahsForCurrentTheme();

                    addWordClickListeners();
                } else {
                    displayArea.innerHTML = `<p class="text-center" style="color: var(--color-error);">Ayah ${surah}:${ayah} not found in data.</p>`;
                    tafsirAyahDisplay.innerHTML = `<p class="text-center">Navigate to a valid Ayah to add Tafsir.</p>`;
                    themeAyahDisplay.innerHTML = `<p class="text-center">Navigate to a valid Ayah to link themes.</p>`;
                    document.getElementById('current-ayah-theme-ref').textContent = 'N/A';
                    tafsirNotes.value = '';
                }
                document.getElementById('word-translation-area').innerHTML = '<p class="text-center">Click on an Arabic word to see its translation.</p>';
            } catch (error) {
                console.error("Error loading ayah:", error);
                document.getElementById('quran-display').innerHTML = `<p class="text-center" style="color: var(--color-error);">Error loading Ayah: ${error.message}</p>`;
            } finally {
                hideLoading();
            }
        }

        function addWordClickListeners() {
            document.querySelectorAll('.ayah-arabic span').forEach(wordSpan => {
                wordSpan.removeEventListener('click', handleWordClick);
                wordSpan.addEventListener('click', handleWordClick);
                wordSpan.removeEventListener('focus', handleWordFocus);
                wordSpan.addEventListener('focus', handleWordFocus);
                wordSpan.removeEventListener('blur', handleWordBlur);
                wordSpan.addEventListener('blur', handleWordBlur);
            });
        }

        async function handleWordClick(event) {
            const wordSpan = event.target;
            const clickedWordActualText = wordSpan.getAttribute('data-word-text');
            const surahNum = parseInt(wordSpan.getAttribute('data-surah'), 10);
            const ayahNum = parseInt(wordSpan.getAttribute('data-ayah'), 10);
            const wordPosition = parseInt(wordSpan.getAttribute('data-word-position'), 10);

            if (!clickedWordActualText || isNaN(surahNum) || isNaN(ayahNum) || isNaN(wordPosition)) {
                console.warn("[handleWordClick] Clicked word span is missing required data attributes.", wordSpan.dataset);
                document.getElementById('word-translation-area').innerHTML = `<p style="color: var(--color-error);">Error: Could not identify clicked word's metadata.</p>`;
                return;
            }
            console.log(`[handleWordClick] Clicked: "${clickedWordActualText}" (S:${surahNum}, A:${ayahNum}, Pos:${wordPosition})`);

            const ayahElement = wordSpan.closest('.ayah');
            const fullAyahTranslationDiv = ayahElement.querySelector('.ayah-translation');
            const fullAyahTranslationText = fullAyahTranslationDiv ? fullAyahTranslationDiv.textContent : 'Full ayah translation not found.';

            const selectedFullTranslationKey = document.getElementById('translation-select').value;
            const fullTranslationInfo = TRANSLATION_CONFIG[selectedFullTranslationKey];
            const fullTranslationLabel = fullTranslationInfo ? fullTranslationInfo.label : 'Selected Translation';
            const fullTranslationLang = fullTranslationInfo ? fullTranslationInfo.lang : 'en';
            const fullTranslationDir = fullTranslationInfo ? fullTranslationInfo.dir : 'ltr';
            const fullTranslationFont = fullTranslationInfo ? `var(--font-${selectedFullTranslationKey})` : `var(--font-general)`;
            const fullTranslationTextAlign = fullTranslationInfo && fullTranslationInfo.dir === 'rtl' ? 'right' : 'left';

            let wordUrduMeaning = "N/A";
            let wordEnglishMeaning = "N/A";

            try {
                const metadataStore = getObjectStore(STORE_WORD_METADATA, 'readonly');
                const locationIndex = metadataStore.index('location_idx');
                const metadataRequest = locationIndex.get([surahNum, ayahNum, wordPosition]);

                const wordMetadataEntry = await new Promise((resolve, reject) => {
                    metadataRequest.onsuccess = () => resolve(metadataRequest.result);
                    metadataRequest.onerror = (e) => {
                        console.error("Error fetching from word_metadata:", e.target.error);
                        reject(e.target.error);
                    };
                });

                if (wordMetadataEntry && typeof wordMetadataEntry.word_id !== 'undefined') {
                    const word_id = wordMetadataEntry.word_id;
                    console.log(`[handleWordClick] Found word_id: ${word_id}`);
                    const translationEntry = await getData(STORE_WORD_TRANSLATIONS, word_id);
                    if (translationEntry) {
                        console.log(`[handleWordClick] Translation data for word_id ${word_id}:`, translationEntry);
                        wordUrduMeaning = translationEntry.ur_meaning || "N/A";
                        wordEnglishMeaning = translationEntry.en_meaning || "N/A";
                        if (translationEntry.ur_meaning === "") wordUrduMeaning = "N/A (empty)";
                        if (translationEntry.en_meaning === "") wordEnglishMeaning = "N/A (empty)";
                    } else {
                        console.warn(`[handleWordClick] No translation entry in '${STORE_WORD_TRANSLATIONS}' for word_id: ${word_id}.`);
                    }
                } else {
                    console.warn(`[handleWordClick] No metadata entry in '${STORE_WORD_METADATA}' for S${surahNum}:A${ayahNum}, Pos:${wordPosition}. Word: "${clickedWordActualText}"`);
                }
            } catch (error) {
                console.error("[handleWordClick] Error during word data lookup:", error);
                wordUrduMeaning = "Lookup Error";
                wordEnglishMeaning = "Lookup Error";
            }

            const translationArea = document.getElementById('word-translation-area');
            translationArea.innerHTML = `
                <p><strong>Selected Word:</strong> <span lang="ar" dir="rtl" style="font-family: var(--font-arabic); font-size: 1.2rem;">${clickedWordActualText}</span></p>
                <p><strong>Urdu Meaning:</strong> <span lang="ur" dir="rtl" style="font-family: var(--font-urdu);">${wordUrduMeaning}</span></p>
                <p><strong>English Meaning:</strong> <span lang="en" dir="ltr" style="font-family: var(--font-english);">${wordEnglishMeaning}</span></p>
                <p><strong>Full Ayah Translation (${surahNum}:${ayahNum}) - ${fullTranslationLabel}:</strong> <span lang="${fullTranslationLang}" dir="${fullTranslationDir}" style="font-family: ${fullTranslationFont}; text-align: ${fullTranslationTextAlign};">${fullAyahTranslationText}</span></p>
            `;
            document.querySelectorAll('.ayah-arabic span').forEach(span => {
                span.style.backgroundColor = 'transparent';
            });
            wordSpan.style.backgroundColor = 'var(--color-highlight)';
        }

        function handleWordFocus(event) {
             handleWordClick(event);
        }
        function handleWordBlur(event) {
             event.target.style.backgroundColor = 'transparent';
        }

        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
                section.setAttribute('aria-hidden', 'true');
            });
            const activeSection = document.getElementById(sectionId);
            if (activeSection) {
                activeSection.classList.add('active');
                activeSection.setAttribute('aria-hidden', 'false');
                activeSection.focus(); // For accessibility, focus the new section
            }

            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                link.setAttribute('aria-current', 'false');
            });
            const activeLink = document.querySelector(`.nav-link[data-section="${sectionId}"]`);
            if (activeLink) {
                activeLink.classList.add('active');
                activeLink.setAttribute('aria-current', 'page');
            }

             if (sectionId === 'themes') {
                 populateThemeSelects();
                 displayLinkedAyahsForCurrentTheme();
             } else if (sectionId === 'recitation') {
                 loadRecitationLogs();
             } else if (sectionId === 'hifz') {
                 const hifzSurahSelect = document.getElementById('hifz-surah-select');
                 if (hifzSurahSelect.value) {
                    loadHifzForSurah(parseInt(hifzSurahSelect.value, 10));
                 }
             }
        }

                function showLoading(primaryMessage, secondaryMessage = "Initializing...", initialPercentage = 0) {
            const loadingOverlay = document.getElementById('loading-overlay');
            const primaryMsgEl = document.getElementById('loading-message-primary');
            const secondaryMsgEl = document.getElementById('loading-message-secondary');
            const progressBarEl = document.getElementById('loading-progress-bar');
            const percentageEl = document.getElementById('loading-percentage');
            const firstTimeNoticeEl = document.getElementById('loading-first-time-notice');

            if (primaryMsgEl) primaryMsgEl.textContent = primaryMessage;
            if (secondaryMsgEl) secondaryMsgEl.textContent = secondaryMessage;
            if (progressBarEl) progressBarEl.style.width = `${initialPercentage}%`;
            if (percentageEl) percentageEl.textContent = `${initialPercentage}%`;
            
            // Update loading content colors based on current theme
            const currentTheme = document.body.className.includes('theme-manuscript') ? 'manuscript' :
                                 document.body.className.includes('theme-holo') ? 'holo' : 'serene';
            const loadingContent = loadingOverlay.querySelector('.loading-content');
            if (loadingContent) {
                if (currentTheme === 'holo') {
                    loadingContent.style.backgroundColor = 'var(--color-bg-secondary)'; // From holo theme
                    loadingContent.style.color = 'var(--color-text-primary)'; // From holo theme
                    if(document.getElementById('loading-progress-bar-container')) document.getElementById('loading-progress-bar-container').style.backgroundColor = '#26a69a';
                    if(progressBarEl) progressBarEl.style.backgroundColor = 'var(--color-accent)'; // From holo theme
                } else if (currentTheme === 'manuscript') {
                    loadingContent.style.backgroundColor = 'var(--color-bg-secondary)'; // From manuscript theme
                    loadingContent.style.color = 'var(--color-text-primary)'; // From manuscript theme
                     if(document.getElementById('loading-progress-bar-container')) document.getElementById('loading-progress-bar-container').style.backgroundColor = 'var(--color-border)';
                    if(progressBarEl) progressBarEl.style.backgroundColor = 'var(--color-accent)';
                } else { // Serene (default)
                    loadingContent.style.backgroundColor = 'var(--color-bg-secondary)';
                    loadingContent.style.color = 'var(--color-text-primary)';
                    if(document.getElementById('loading-progress-bar-container')) document.getElementById('loading-progress-bar-container').style.backgroundColor = 'var(--color-border)';
                    if(progressBarEl) progressBarEl.style.backgroundColor = 'var(--color-accent)';
                }
            }


            loadingOverlay.style.display = 'flex';
            document.body.setAttribute('aria-busy', 'true');
        }

        function updateLoadingProgress(unitsIncrement, secondaryMessage) {
            if (totalProgressUnits === 0) return; // Avoid division by zero if not set

            completedProgressUnits += unitsIncrement;
            const percentage = Math.min(100, Math.round((completedProgressUnits / totalProgressUnits) * 100));

            const secondaryMsgEl = document.getElementById('loading-message-secondary');
            const progressBarEl = document.getElementById('loading-progress-bar');
            const percentageEl = document.getElementById('loading-percentage');

            if (secondaryMsgEl) secondaryMsgEl.textContent = secondaryMessage;
            if (progressBarEl) progressBarEl.style.width = `${percentage}%`;
            if (percentageEl) percentageEl.textContent = `${percentage}%`;
            // console.log(`Progress: ${percentage}% - ${secondaryMessage}`); // For debugging
        }

        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
            document.body.setAttribute('aria-busy', 'false');
            // Reset progress for next time it might be shown (though typically one-time)
            completedProgressUnits = 0;
            totalProgressUnits = 0; // Reset this as well
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
            document.body.setAttribute('aria-busy', 'false');
        }

        function setStatusMessage(elementId, message, isError = false) {
            const statusElement = document.getElementById(elementId);
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.style.color = isError ? 'var(--color-error)' : 'var(--color-success)';
                statusElement.style.fontWeight = 'bold';
                setTimeout(() => {
                    statusElement.textContent = '';
                    statusElement.style.color = '';
                    statusElement.style.fontWeight = '';
                }, 7000);
            }
        }

        // --- Tafsir Functions ---
        async function saveTafsir() {
            if (!db) return;
            const notes = document.getElementById('tafsir-notes').value.trim();
            if (!notes) {
                setStatusMessage('tafsir-status', 'Tafsir notes cannot be empty.', true);
                return;
            }
            if (currentSurah === 0 || currentAyah === 0) {
                 setStatusMessage('tafsir-status', 'Navigate to an Ayah first.', true);
                 return;
            }
            showLoading(`Saving Tafsir for ${currentSurah}:${currentAyah}...`);
            try {
                await putData(STORE_TAFSIR, { surah: currentSurah, ayah: currentAyah, notes: notes });
                setStatusMessage('tafsir-status', `Tafsir saved for ${currentSurah}:${currentAyah}.`, false);
            } catch (error) {
                setStatusMessage('tafsir-status', 'Failed to save Tafsir.', true);
            } finally {
                hideLoading();
            }
        }

        // --- Thematic Linker Functions ---
        

// New handler for clicking a theme in the index
async function handleIndexThemeClick(event) {
    event.preventDefault();
    // const targetElement = event.currentTarget; // THIS IS THE LIKELY CULPRIT
    const clickedAnchorElement = event.currentTarget; // Use a more descriptive name

    // console.log('Clicked Theme Element:', clickedAnchorElement); // For debugging
    // console.log('Clicked Theme Element Dataset:', clickedAnchorElement.dataset);

    if (!clickedAnchorElement || !clickedAnchorElement.dataset) {
        console.error("handleIndexThemeClick: clickedAnchorElement or its dataset is invalid.", clickedAnchorElement);
        return;
    }

    const themeId = clickedAnchorElement.dataset.themeId;
    const isStatic = clickedAnchorElement.dataset.isStatic === 'true'; 
    // Check if exampleSurah/Ayah exist before parsing, especially for DB themes
    const exampleSurahStr = clickedAnchorElement.dataset.exampleSurah;
    const exampleAyahStr = clickedAnchorElement.dataset.exampleAyah;
    
    if (!themeId) {
        console.error("Theme ID missing from clicked element's dataset.");
        return;
    }

    const indexPanel = document.getElementById('fsReaderIndexPanel');
    if(indexPanel) indexPanel.style.display = 'none';

    stopAndClearAudio();

    let targetSurah, targetAyah;

    if (isStatic) {
        // console.log("Static theme clicked:", themeId);
        targetSurah = exampleSurahStr ? parseInt(exampleSurahStr) : NaN;
        targetAyah = exampleAyahStr ? parseInt(exampleAyahStr) : NaN;
        
        const staticTheme = staticQuranicThemes.find(st => st.id === themeId);
        if (staticTheme) {
            const surahTitleEl = document.getElementById('fsReaderSurahTitle');
            const pageInfoEl = document.getElementById('fsReaderPageInfo');
            if (surahTitleEl) surahTitleEl.textContent = `Theme: ${staticTheme.name}`;
            if (pageInfoEl) {
                if (isNaN(targetSurah) || isNaN(targetAyah)) {
                    pageInfoEl.textContent = "(Example Ayah not set or invalid)";
                } else {
                    pageInfoEl.textContent = `(Example: S${targetSurah}:A${targetAyah})`;
                }
            }
        }
    } else {
        // console.log("DB theme clicked:", themeId);
        try {
            const dbThemeId = parseInt(themeId);
            if (isNaN(dbThemeId)) {
                console.error("Invalid DB Theme ID:", themeId);
                return;
            }
            const allThemeAyahLinks = await getAllData(STORE_THEME_AYAHS);
            const linksForThisTheme = allThemeAyahLinks
                .filter(link => link.themeId === dbThemeId)
                .sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);

            if (linksForThisTheme.length > 0) {
                const firstLink = linksForThisTheme[0];
                targetSurah = firstLink.surah;
                targetAyah = firstLink.ayah;
            } else {
                alert("No Ayahs are currently linked to this user-defined theme.");
                const themeData = await getData(STORE_THEMES, dbThemeId);
                const surahTitleEl = document.getElementById('fsReaderSurahTitle');
                const pageInfoEl = document.getElementById('fsReaderPageInfo');
                if (themeData && surahTitleEl) surahTitleEl.textContent = `Theme: ${themeData.name}`;
                if (pageInfoEl) pageInfoEl.textContent = "(No linked Ayahs)";
                return; 
            }
        } catch (error) {
            console.error("Error fetching links for DB theme:", error);
            alert("Could not retrieve linked Ayahs for this theme.");
            return;
        }
    }

    // Validate targetSurah and targetAyah before navigation
    if (!isNaN(targetSurah) && !isNaN(targetAyah) && targetSurah >= 1 && targetSurah <= 114 && targetAyah >= 1) {
        // Further validation against surahAyahCounts
        const maxAyahs = (surahAyahCounts[targetSurah]) ? surahAyahCounts[targetSurah] : 0;
        if (maxAyahs > 0 && targetAyah <= maxAyahs) {
            fullScreenReaderCurrentSurah = targetSurah;
            fullScreenReaderCurrentAyah = targetAyah;

            if (fullScreenReaderViewMode === 'paged') {
                fullScreenReaderCurrentPage = surahToPageEnhanced(targetSurah, targetAyah);
                await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
                setTimeout(() => highlightAndScrollToAyahInPage(targetSurah, targetAyah), 300); // slight increase
            } else {
                continuousScrollNextSurahToLoad = targetSurah;
                continuousScrollNextAyahToLoad = targetAyah;
                await initializeContinuousScroll(); 
            }
        } else {
            console.warn(`Invalid Ayah number ${targetAyah} for Surah ${targetSurah}. Max is ${maxAyahs}. Cannot navigate.`);
            if (isStatic) alert(`The example Ayah (S${targetSurah}:A${targetAyah}) for this static theme is invalid.`);
        }
    } else if (isStatic) {
        // console.log(`Static theme "${themeId}" clicked, but no valid example Ayah to navigate to, or exampleAyah was not set.`);
        // Header might have already been updated for static themes if no valid S/A.
    } else {
        console.warn(`Navigation aborted for theme "${themeId}" due to invalid targetSurah/Ayah.`);
    }
}

        async function displayThemesList() {
             if (!db) return;
             const themesListElement = document.getElementById('themes-list');
             themesListElement.innerHTML = '';
             try {
                 const themes = await getAllData(STORE_THEMES);
                 if (themes.length === 0) {
                     themesListElement.innerHTML = '<li>No themes added yet.</li>';
                     return;
                 }
                 themes.forEach(theme => {
                     const li = document.createElement('li');
                     li.innerHTML = `
                         <span data-theme-id="${theme.id}" class="view-theme-ayahs" tabindex="0" role="button">${theme.name}</span>
                         <div class="theme-actions" style="display: inline-block;">
                             <button data-theme-id="${theme.id}" class="delete-theme-btn">Delete</button>
                         </div>
                     `;
                      themesListElement.appendChild(li);
                 });
                 themesListElement.querySelectorAll('.view-theme-ayahs').forEach(span => {
                     span.addEventListener('click', handleViewThemeAyahs);
                     span.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') handleViewThemeAyahs(e); });
                 });
                 themesListElement.querySelectorAll('.delete-theme-btn').forEach(button => {
                     button.addEventListener('click', handleDeleteTheme);
                 });
             } catch (error) {
                 themesListElement.innerHTML = `<li>Error loading themes: ${error.message}</li>`;
             }
        }

        async function addTheme() {
            if (!db) return;
            const nameInput = document.getElementById('new-theme-name');
            const parentSelect = document.getElementById('parent-theme-select');
            const name = nameInput.value.trim();
            const parentId = parentSelect.value ? parseInt(parentSelect.value, 10) : null;

            if (!name) {
                setStatusMessage('theme-manager-status', 'Theme name cannot be empty.', true);
                return;
            }
            showLoading("Adding theme...");
            try {
                await addData(STORE_THEMES, { name: name, parentId: parentId, description: '' }); // Add description field
                setStatusMessage('theme-manager-status', `Theme "${name}" added.`, false);
                nameInput.value = '';
                parentSelect.value = '';
                await populateThemeSelects();
                await displayThemesList();
            } catch (error) {
                 setStatusMessage('theme-manager-status', 'Failed to add theme.', true);
            } finally {
                hideLoading();
            }
        }

         async function handleDeleteTheme(event) {
             if (!db) return;
             const themeId = parseInt(event.target.getAttribute('data-theme-id'), 10);
             if (isNaN(themeId) || !confirm("Delete this theme and all its linked ayahs?")) return;

             showLoading("Deleting theme...");
             try {
                 await deleteData(STORE_THEMES, themeId);
                 const store = getObjectStore(STORE_THEME_AYAHS, 'readwrite');
                 const index = store.index('themeId');
                 const request = index.openCursor(IDBKeyRange.only(themeId));
                 request.onsuccess = (e) => {
                     const cursor = e.target.result;
                     if (cursor) {
                         cursor.delete();
                         cursor.continue();
                     } else {
                         setStatusMessage('theme-manager-status', 'Theme and linked ayahs deleted.', false);
                         populateThemeSelects();
                         displayThemesList();
                         hideLoading();
                     }
                 };
                 request.onerror = () => {
                     setStatusMessage('theme-manager-status', 'Theme deleted, but failed to delete all linked ayahs.', true);
                     hideLoading();
                 };
             } catch (error) {
                 setStatusMessage('theme-manager-status', 'Failed to delete theme.', true);
                 hideLoading();
             }
         }

        async function linkAyahToTheme() {
            if (!db) return;
            const themeSelect = document.getElementById('link-theme-select');
            const notesInput = document.getElementById('theme-link-notes');
            const themeId = themeSelect.value ? parseInt(themeSelect.value, 10) : null;
            const notes = notesInput.value.trim();

            if (!themeId) {
                setStatusMessage('theme-linker-status', 'Please select a theme.', true);
                return;
            }
            if (currentSurah === 0 || currentAyah === 0) {
                 setStatusMessage('theme-linker-status', 'Navigate to an Ayah first.', true);
                 return;
            }
            showLoading(`Linking Ayah ${currentSurah}:${currentAyah}...`);
            try {
                 const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                 const index = store.index('surahAyah');
                 const request = index.getAll(IDBKeyRange.only([currentSurah, currentAyah]));
                 const existingLinks = await new Promise(r => { request.onsuccess = () => r(request.result); });
                 if (existingLinks.some(link => link.themeId === themeId)) {
                     setStatusMessage('theme-linker-status', 'Ayah already linked to this theme.', true);
                 } else {
                    await addData(STORE_THEME_AYAHS, { themeId: themeId, surah: currentSurah, ayah: currentAyah, notes: notes });
                    setStatusMessage('theme-linker-status', `Ayah ${currentSurah}:${currentAyah} linked.`, false);
                    notesInput.value = '';
                    await displayLinkedAyahsForCurrentTheme();
                 }
            } catch (error) {
                 setStatusMessage('theme-linker-status', 'Failed to link Ayah.', true);
            } finally {
                hideLoading();
            }
        }

        async function handleViewThemeAyahs(event) {
             if (!db) return;
             const themeId = parseInt(event.target.getAttribute('data-theme-id'), 10);
             if (isNaN(themeId)) return;
             showLoading("Loading linked ayahs...");
             try {
                 const theme = await getData(STORE_THEMES, themeId);
                 if (!theme) {
                     setStatusMessage('theme-manager-status', 'Theme not found.', true); hideLoading(); return;
                 }
                 document.getElementById('modal-theme-name').textContent = theme.name;
                 const listEl = document.getElementById('modal-linked-ayahs-list');
                 listEl.innerHTML = '';
                 const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                 const index = store.index('themeId');
                 const request = index.openCursor(IDBKeyRange.only(themeId));
                 const linkedAyahs = [];
                 request.onsuccess = (e) => {
                     const cursor = e.target.result;
                     if (cursor) {
                         linkedAyahs.push(cursor.value);
                         cursor.continue();
                     } else {
                         if (linkedAyahs.length === 0) {
                             listEl.innerHTML = '<li>No ayahs linked yet.</li>';
                         } else {
                             linkedAyahs.sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                             linkedAyahs.forEach(link => {
                                 const li = document.createElement('li');
                                 li.innerHTML = `
                                     <strong>Surah ${link.surah}:${link.ayah}</strong>
                                     ${link.notes ? ` - <em>${link.notes}</em>` : ''}
                                     <button data-link-id="${link.id}" class="delete-theme-link-btn" style="margin-left: 10px;">Unlink</button>
                                 `;
                                 listEl.appendChild(li);
                             });
                             listEl.querySelectorAll('.delete-theme-link-btn').forEach(button => {
                                 button.addEventListener('click', handleDeleteThemeLink);
                             });
                         }
                         hideLoading();
                         document.getElementById('themeAyahsModal').style.display = 'flex';
                         document.getElementById('themeAyahsModal').querySelector('.modal-content').setAttribute('data-current-theme-id', themeId);
                         document.getElementById('themeAyahsModalTitle').focus();
                     }
                 };
                 request.onerror = () => { listEl.innerHTML = `<li>Error loading.</li>`; hideLoading(); };
             } catch (error) {
                 setStatusMessage('theme-manager-status', 'Failed to load theme details.', true); hideLoading();
             }
        }

         async function handleDeleteThemeLink(event) {
             if (!db) return;
             const linkId = parseInt(event.target.getAttribute('data-link-id'), 10);
             if (isNaN(linkId) || !confirm("Unlink this Ayah?")) return;
             showLoading("Unlinking Ayah...");
             try {
                 await deleteData(STORE_THEME_AYAHS, linkId);
                 setStatusMessage('theme-linker-status', 'Ayah unlinked.', false);
                 const modalContent = event.target.closest('.modal-content');
                 const currentModalThemeId = parseInt(modalContent.getAttribute('data-current-theme-id'), 10);
                 if (!isNaN(currentModalThemeId)) {
                     await displayLinkedAyahsForThemeInModal(currentModalThemeId);
                 } else {
                      document.getElementById('themeAyahsModal').style.display = 'none';
                      displayThemesList();
                 }
             } catch (error) {
                 setStatusMessage('theme-linker-status', 'Failed to unlink Ayah.', true);
             } finally {
                 hideLoading();
             }
         }

         async function displayLinkedAyahsForThemeInModal(themeId) {
             if (!db) return;
             const listEl = document.getElementById('modal-linked-ayahs-list');
             listEl.innerHTML = '';
             try {
                 const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                 const index = store.index('themeId');
                 const request = index.openCursor(IDBKeyRange.only(themeId));
                 const linkedAyahs = [];
                 request.onsuccess = (e) => {
                     const cursor = e.target.result;
                     if (cursor) {
                         linkedAyahs.push(cursor.value);
                         cursor.continue();
                     } else {
                         if (linkedAyahs.length === 0) { listEl.innerHTML = '<li>No ayahs linked.</li>'; }
                         else {
                             linkedAyahs.sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                             linkedAyahs.forEach(link => {
                                 const li = document.createElement('li');
                                 li.innerHTML = `
                                     <strong>Surah ${link.surah}:${link.ayah}</strong>
                                     ${link.notes ? ` - <em>${link.notes}</em>` : ''}
                                     <button data-link-id="${link.id}" class="delete-theme-link-btn">Unlink</button>
                                 `;
                                 listEl.appendChild(li);
                             });
                             listEl.querySelectorAll('.delete-theme-link-btn').forEach(b => b.addEventListener('click', handleDeleteThemeLink));
                         }
                     }
                 };
                 request.onerror = () => { listEl.innerHTML = `<li>Error refreshing list.</li>`; };
             } catch (error) { listEl.innerHTML = `<li>Error: ${error.message}</li>`; }
         }

         async function displayLinkedAyahsForCurrentTheme() {
             if (!db) return;
             const themeSelect = document.getElementById('link-theme-select');
             const themeId = themeSelect.value ? parseInt(themeSelect.value, 10) : null;
             const listEl = document.getElementById('linked-ayahs-list');
             const nameEl = document.getElementById('linked-theme-name');
             listEl.innerHTML = '';

             if (!themeId) {
                 nameEl.textContent = 'N/A';
                 listEl.innerHTML = '<li>Select a theme to see linked ayahs.</li>';
                 return;
             }
             showLoading("Loading linked ayahs...");
             try {
                 const theme = await getData(STORE_THEMES, themeId);
                 nameEl.textContent = theme ? theme.name : 'Unknown';
                 const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                 const index = store.index('themeId');
                 const request = index.openCursor(IDBKeyRange.only(themeId));
                 const linkedAyahs = [];
                 request.onsuccess = (e) => {
                     const cursor = e.target.result;
                     if (cursor) {
                         linkedAyahs.push(cursor.value);
                         cursor.continue();
                     } else {
                         if (linkedAyahs.length === 0) { listEl.innerHTML = '<li>No ayahs linked.</li>'; }
                         else {
                             linkedAyahs.sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                             linkedAyahs.forEach(link => {
                                 const li = document.createElement('li');
                                 li.innerHTML = `<strong>S ${link.surah}:${link.ayah}</strong> ${link.notes ? `- <em>${link.notes}</em>` : ''}`;
                                 listEl.appendChild(li);
                             });
                         }
                         hideLoading();
                     }
                 };
                 request.onerror = () => { listEl.innerHTML = `<li>Error loading.</li>`; hideLoading(); };
             } catch (error) {
                 nameEl.textContent = 'Error'; listEl.innerHTML = `<li>Error: ${error.message}</li>`; hideLoading();
             }
         }


                async function analyzeRoot() {
             if (!db) return;
             const rootInput = document.getElementById('root-input');
             const rootTerm = rootInput.value.trim();
             const analyzedRootTermElement = document.getElementById('analyzed-root-term');

             const currentViewMode = document.querySelector('input[name="root-view-mode"]:checked').value; // Get current view mode at the start
             const occurrencesListElement = document.getElementById('root-occurrences-list');
             const graphContainer = document.getElementById('root-network-graph');
             const graphPlaceholder = document.getElementById('root-graph-placeholder');
             const paginationControls = document.getElementById('root-graph-pagination-controls');

             analyzedRootTermElement.textContent = rootTerm || 'N/A';
             allRootOccurrencesCache = [];
             currentRootGraphPage = 1;

             // Clear all previous results regardless of current view, as we are re-analyzing
             occurrencesListElement.innerHTML = '';
             graphContainer.innerHTML = '';
             if (rootNetwork) {
                rootNetwork.destroy();
                rootNetwork = null;
             }
             graphPlaceholder.style.display = 'none';
             paginationControls.style.display = 'none';


             if (!rootTerm) {
                 setStatusMessage('root-status', 'Please enter an Arabic root word.', true);
                 if (currentViewMode === 'list') occurrencesListElement.innerHTML = '<li>Please enter an Arabic root word.</li>';
                 else { graphPlaceholder.textContent = 'Please enter an Arabic root word.'; graphPlaceholder.style.display = 'block'; }
                 return;
             }
             if (rootTerm.length < 2) {
                 setStatusMessage('root-status', 'Root term should be at least 2 characters.', true);
                 if (currentViewMode === 'list') occurrencesListElement.innerHTML = '<li>Root term too short.</li>';
                 else { graphPlaceholder.textContent = 'Root term too short.'; graphPlaceholder.style.display = 'block'; }
                 return;
             }

             showLoading(`Analyzing root "${rootTerm}"...`);
             try {
                 const allAyahs = await getAllData(STORE_QURAN);
                 const foundOccurrences = []; // Temp array for this analysis run

                 // --- YOUR EXISTING WORD MATCHING LOGIC to populate 'foundOccurrences' ---
                 allAyahs.forEach(ayahData => {
                     const words = ayahData.arabic.split(/\s+/);
                     words.forEach(word => {
                         let wordanClean = word.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"");
                         let wordanNormalized = wordanClean
                            .replace(/ؤ|و/g, "(و|ؤ)")
                            .replace(/ك|ک/g, "(ك|ک)")
                            .replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)")
                            .replace(/ى|ی|ي/g, "(ى|ی|ي)")
                            .replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)")
                            .replace(/ے/g, "(ے|ی)")
                            .replace(/م/g, "(مٰ|م)");

                         let rootTermPatternPart = rootTerm.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"")
                            .replace(/ؤ|و/g, "(و|ؤ)")
                            .replace(/ك|ک/g, "(ك|ک)")
                            .replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)")
                            .replace(/ى|ی|ي/g, "(ى|ی|ي)")
                            .replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)")
                            .replace(/ے/g, "(ے|ی)")
                            .replace(/م/g, "(مٰ|م)");

                         let flexibleRootPatternStr = rootTermPatternPart
                            .replace(/ /g, ".{0,1}")
                            .replace(/-/g, ".{0,1}")
                            .replace(/۔/g, ".{0,1}");
                         let flexibleRegex = new RegExp(flexibleRootPatternStr);
                         let strictRootPatternStr = rootTermPatternPart.replace(/[ \-۔]/g, "");

                         if (flexibleRegex.test(wordanClean) || wordanClean.includes(strictRootPatternStr)) {
                             foundOccurrences.push({
                                 surah: ayahData.surah,
                                 ayah: ayahData.ayah,
                                 word: word,
                                 context: ayahData.arabic
                             });
                         }
                     });
                 });
                 // --- END OF WORD MATCHING LOGIC ---

                 allRootOccurrencesCache = [...foundOccurrences]; // Update the global cache

                 if (allRootOccurrencesCache.length === 0) {
                     setStatusMessage('root-status', `No occurrences found for "${rootTerm}".`, false);
                     if (currentViewMode === 'list') {
                         occurrencesListElement.innerHTML = '<li>No occurrences found.</li>';
                     } else {
                         graphPlaceholder.textContent = 'No occurrences found to display in graph.';
                         graphPlaceholder.style.display = 'block';
                     }
                 } else {
                     setStatusMessage('root-status', `Found ${allRootOccurrencesCache.length} occurrences for "${rootTerm}".`, false);
                     // Now, based on the currentViewMode determined at the START of this function, display the results.
                     if (currentViewMode === 'list') {
                         occurrencesListElement.innerHTML = ''; // Clear any "graph active" message
                         allRootOccurrencesCache.forEach(occ => {
                             const li = document.createElement('li');
                             li.innerHTML = `
                                 <strong>Surah ${occ.surah}:${occ.ayah}</strong> - Word: <span lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.word}</span>
                                 <div class="result-context" lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.context}</div>
                             `;
                             occurrencesListElement.appendChild(li);
                         });
                     } else if (currentViewMode === 'tree') {
                         // If tree view is active, the list area should just show a placeholder
                         occurrencesListElement.innerHTML = '<li>Graph view active. Results may be paginated below.</li>';
                         graphPlaceholder.style.display = 'none';
                         updateRootGraphView(); // This will render the first page of the graph
                         paginationControls.style.display = (allRootOccurrencesCache.length > rootGraphItemsPerPage) ? 'flex' : 'none';
                     }
                 }

             } catch (error) {
                 console.error("Error analyzing root:", error);
                 setStatusMessage('root-status', 'Failed to analyze root.', true);
                 if (currentViewMode === 'list') occurrencesListElement.innerHTML = `<li>Error analyzing root: ${error.message}</li>`;
                 else { graphPlaceholder.textContent = `Error analyzing root: ${error.message}`; graphPlaceholder.style.display = 'block';}
             } finally {
                 hideLoading();
             }
        }

        async function saveRootNotes() { // This function remains largely the same
             if (!db) return;
             const rootInput = document.getElementById('root-input');
             const descriptionInput = document.getElementById('root-description');
             const rootTerm = rootInput.value.trim();
             const description = descriptionInput.value.trim();

             if (!rootTerm) {
                 setStatusMessage('root-status', 'Enter root word to save notes.', true);
                 return;
             }
             showLoading("Saving root notes...");
             try {
                 const allRoots = await getAllData(STORE_ROOTS);
                 let existingRoot = allRoots.find(r => r.root === rootTerm);
                 if (existingRoot) {
                     existingRoot.description = description;
                     await putData(STORE_ROOTS, existingRoot);
                     setStatusMessage('root-status', `Notes updated for "${rootTerm}".`, false);
                 } else {
                     await addData(STORE_ROOTS, { root: rootTerm, description: description });
                     setStatusMessage('root-status', `Root "${rootTerm}" and notes saved.`, false);
                 }
             } catch (error) {
                 setStatusMessage('root-status', 'Failed to save root notes.', true);
             } finally {
                 hideLoading();
             }
        }
                        function updateRootGraphView() {
            const graphContainerWrapper = document.getElementById('root-network-graph-container');
            const graphContainer = document.getElementById('root-network-graph');
            const graphPlaceholder = document.getElementById('root-graph-placeholder');
            const paginationControls = document.getElementById('root-graph-pagination-controls');
            const analyzedRootTermElement = document.getElementById('analyzed-root-term');
            const rootTermForRender = analyzedRootTermElement ? analyzedRootTermElement.textContent : 'N/A'; // Defensive read

            // Ensure the graph container's wrapper is visible if this function is called
            // (though view switcher should primarily handle this)
            if (graphContainerWrapper && !graphContainerWrapper.classList.contains('active-view')) {
                // This situation implies updateRootGraphView was called when its view wasn't active.
                // Forcing it visible here might be a workaround but indicates a logic flow issue elsewhere.
                console.warn("updateRootGraphView called while graph view wrapper was not active. Forcing visible.");
                document.querySelectorAll('.root-view-content').forEach(el => {
                    el.classList.remove('active-view');
                    el.style.display = 'none';
                });
                graphContainerWrapper.classList.add('active-view');
                graphContainerWrapper.style.display = 'block';
            }


            if (rootTermForRender === 'N/A' || rootTermForRender.trim() === '') {
                if (graphContainer) graphContainer.innerHTML = '';
                if (rootNetwork) { rootNetwork.destroy(); rootNetwork = null; }
                if (graphPlaceholder) {
                    graphPlaceholder.textContent = 'Please analyze a root term first.';
                    graphPlaceholder.style.display = 'block';
                }
                if (paginationControls) paginationControls.style.display = 'none';
                console.log("updateRootGraphView: No root term analyzed.");
                return;
            }

            if (allRootOccurrencesCache.length === 0) {
                if (graphContainer) graphContainer.innerHTML = '';
                if (rootNetwork) { rootNetwork.destroy(); rootNetwork = null; }
                if (graphPlaceholder) {
                    graphPlaceholder.textContent = `No occurrences found for "${rootTermForRender}" to display in graph.`;
                    graphPlaceholder.style.display = 'block';
                }
                if (paginationControls) paginationControls.style.display = 'none';
                console.log("updateRootGraphView: allRootOccurrencesCache is empty.");
                return;
            }

            if (graphPlaceholder) graphPlaceholder.style.display = 'none';

            const startIndex = (currentRootGraphPage - 1) * rootGraphItemsPerPage;
            const endIndex = startIndex + rootGraphItemsPerPage;
            const occurrencesForPage = allRootOccurrencesCache.slice(startIndex, endIndex);

            console.log(`updateRootGraphView: Rendering page ${currentRootGraphPage} for root "${rootTermForRender}" with ${occurrencesForPage.length} items (from index ${startIndex} to ${endIndex-1}).`);

            // Call renderRootTreeGraph, which handles its own container checks and clearing.
            renderRootTreeGraph(rootTermForRender, occurrencesForPage);

            // Update pagination controls UI
            const totalPages = Math.ceil(allRootOccurrencesCache.length / rootGraphItemsPerPage);
            const pageInfoEl = document.getElementById('root-graph-page-info');
            const prevButton = document.getElementById('prev-root-graph-page-btn');
            const nextButton = document.getElementById('next-root-graph-page-btn');

            if (pageInfoEl) pageInfoEl.textContent = `Page ${currentRootGraphPage} of ${totalPages}`;
            if (prevButton) prevButton.disabled = (currentRootGraphPage === 1);
            if (nextButton) nextButton.disabled = (currentRootGraphPage >= totalPages);

            if (paginationControls) {
                if (totalPages > 1) {
                    paginationControls.style.display = 'flex';
                } else {
                    paginationControls.style.display = 'none';
                }
            }
            console.log(`Pagination updated: Page ${currentRootGraphPage}/${totalPages}. Prev disabled: ${prevButton ? prevButton.disabled : 'N/A'}, Next disabled: ${nextButton ? nextButton.disabled : 'N/A'}`);
        }
        

        function renderRootTreeGraph(rootTerm, occurrences) {
    if (typeof vis === 'undefined') {
        console.error("vis.js library is not loaded!");
        const errContainer = document.getElementById('root-network-graph');
        if (errContainer) errContainer.innerHTML = '<p style="color:red; text-align:center; padding:20px;">Error: Visualization library not loaded.</p>';
        return;
    }

    const container = document.getElementById('root-network-graph');
    if (!container) {
        console.error("Graph container #root-network-graph not found!");
        return;
    }
    container.innerHTML = ''; // Clear previous graph or placeholder

    if (rootNetwork) {
        rootNetwork.destroy();
        rootNetwork = null;
    }

    // Hide popup if it was open from a previous graph
    if (rootNodePopupEl) rootNodePopupEl.style.display = 'none';
    activeRootNodeIdForPopup = null;

    if (occurrences.length === 0 && rootTerm !== 'N/A' && rootTerm.trim() !== '') {
        container.innerHTML = `<p class="text-center" style="padding:20px;">No occurrences for "${rootTerm}" on this page.</p>`;
        return;
    } else if (rootTerm === 'N/A' || rootTerm.trim() === '') {
        container.innerHTML = `<p class="text-center" style="padding:20px;">Please analyze a root term.</p>`;
        return;
    }

    // Get resolved CSS variable values
    const arabicFontFamily = getCssVar('--font-arabic');
    const textPrimaryColor = getCssVar('--color-text-primary');
    const textSecondaryColor = getCssVar('--color-text-secondary');
    const bgSecondaryColor = getCssVar('--color-bg-secondary');
    const highlightBgColor = getCssVar('--color-highlight');
    const accentColorVar = getCssVar('--color-accent');
    const accentDarkColor = getCssVar('--color-accent-dark');
    const shadowColor = getCssVar('--color-shadow');

    const visNodes = new vis.DataSet();
    const visEdges = new vis.DataSet();

    const centralRootNodeId = 'ROOT_TERM_ID';
    visNodes.add({
        id: centralRootNodeId,
        label: rootTerm,
        font: { size: 22, face: arabicFontFamily, color: '#ffffff', strokeWidth: 0 },
        color: { background: accentDarkColor, border: accentColorVar, highlight: { background: accentColorVar, border: accentDarkColor } },
        shape: 'ellipse', size: 35, margin: {top:15, right:15, bottom:15, left:15},
        fixed: false, 
        isCentralRoot: true // Custom property
    });

    occurrences.forEach((occ, index) => {
        const pageSpecificIndex = ((currentRootGraphPage - 1) * rootGraphItemsPerPage) + index;
        const nodeId = `occ_${occ.surah}_${occ.ayah}_${pageSpecificIndex}_${occ.word.replace(/[^a-zA-Z0-9א-آء-ي]/g, '')}`;
        visNodes.add({
            id: nodeId, 
            label: `${occ.word} (S${occ.surah}:A${occ.ayah})`,
            details_context: occ.context, // CRITICAL: For popup content
            details_surah: occ.surah,
            details_ayah: occ.ayah,
            details_word: occ.word,
            font: { face: arabicFontFamily, size: 16, color: textPrimaryColor, multi: true },
            color: { background: bgSecondaryColor, border: accentColorVar, highlight: { background: highlightBgColor, border: accentDarkColor } },
            margin: {top:8, right:8, bottom:8, left:8}, widthConstraint: { maximum: 300 }, heightConstraint: { minimum: 40 },
            shape: 'box', 
            isCentralRoot: false // Custom property
        });
        visEdges.add({
            from: centralRootNodeId, to: nodeId, arrows: 'to',
            length: 180 + (occurrences.length > 10 ? occurrences.length * 2.5 : 0),
            color: { color: textSecondaryColor, highlight: accentDarkColor, hover: accentColorVar }
        });
    });
    
    const data = { nodes: visNodes, edges: visEdges };
    const options = {
        layout: { hierarchical: false },
        interaction: { dragNodes: true, dragView: true, hover: true, tooltipDelay: 200, navigationButtons: true, keyboard: true },
        physics: {
            enabled: true, barnesHut: { gravitationalConstant: -12000, centralGravity: 0.2, springLength: 180, springConstant: 0.025, damping: 0.08, avoidOverlap: 0.1 },
            solver: 'barnesHut', stabilization: { enabled: true, iterations: 800, fit: true, updateInterval: 30 }
        },
        nodes: { borderWidth: 1.5, shadow: { enabled: true, size: 7, x:4, y:4, color: shadowColor } },
        edges: {
            smooth: { enabled: true, type: "continuous", roundness: 0.5 },
            arrows: { to: { enabled: true, scaleFactor: 0.9, type: 'arrow' } },
            width: 1.8
        }
    };

    try {
        rootNetwork = new vis.Network(container, data, options);
    } catch (e) {
        console.error("Error initializing Vis.js Network:", e);
        container.innerHTML = `<p style="color:red;text-align:center;padding:20px;">Error creating graph. Check console.</p>`;
        return;
    }
    

    // CLICK HANDLER FOR POPUP
    rootNetwork.on("click", function (params) {
        // console.log("Network click params:", params); // For debugging
        activeRootNodeIdForPopup = null; 
        if (rootNodePopupEl) rootNodePopupEl.style.display = 'none';

        if (params.nodes.length > 0) {
            const clickedNodeId = params.nodes[0];
            // console.log("Clicked node ID:", clickedNodeId); // For debugging
            activeRootNodeIdForPopup = clickedNodeId; 
            positionRootNodePopupElement(clickedNodeId); 
        } else {
            // Click was not on a node, ensure popup is hidden (already done above)
            // console.log("Clicked on canvas, not a node.");
        }
    });

    const updatePopupOnMoveOrZoom = () => {
        if (activeRootNodeIdForPopup !== null && rootNodePopupEl && rootNodePopupEl.style.display === 'block') {
            positionRootNodePopupElement(activeRootNodeIdForPopup);
        }
    };
    rootNetwork.on("dragging", updatePopupOnMoveOrZoom);
    rootNetwork.on("zoom", updatePopupOnMoveOrZoom);
    rootNetwork.on("dragEnd", function(params) {
         if (activeRootNodeIdForPopup !== null && params.nodes && params.nodes.includes(activeRootNodeIdForPopup)) {
             positionRootNodePopupElement(activeRootNodeIdForPopup);
         }
    });
}

        
        function positionRootNodePopupElement(nodeId) {
                if (!rootNetwork || !rootNodePopupEl) {
                    console.warn("positionRootNodePopupElement: rootNetwork or rootNodePopupEl not available.");
                    if (rootNodePopupEl) rootNodePopupEl.style.display = 'none';
                    return;
                }

                if (nodeId === null) { // Call this to hide the popup
                    rootNodePopupEl.style.display = 'none';
                    activeRootNodeIdForPopup = null; // Reset active node ID
                    return;
                }

                const visNodesDataSet = rootNetwork.body.data.nodes; // Access the DataSet
                const clickedNodeData = visNodesDataSet.get(nodeId);

                if (!clickedNodeData) {
                    console.warn("Node data not found for ID:", nodeId, "in vis.DataSet. Hiding popup.");
                    rootNodePopupEl.style.display = 'none';
                    activeRootNodeIdForPopup = null;
                    return;
                }

                // --- CONTENT POPULATION ---
                let popupHTML = "";
                const arabicFont = getCssVar('--font-arabic');
                const accentDarkColor = getCssVar('--color-accent-dark');
                const textPrimaryColor = getCssVar('--color-text-primary'); // For general text if needed
                const generalFontSize = '1.1rem';
                const arabicContextFontSize = '1.6rem';
                const generalLineHeight = '1.8';
                const arabicContextLineHeight = '2';


                if (clickedNodeData.isCentralRoot) {
                    const rootDescriptionText = document.getElementById('root-description').value; // Get live value
                    popupHTML = `
                        <h4 style="font-family: ${arabicFont}; font-size: 1.5rem; color: ${accentDarkColor}; margin-top:0; margin-bottom:10px;">Root: ${clickedNodeData.label}</h4>
                        <p style="margin:0; line-height: ${generalLineHeight}; font-size: ${generalFontSize}; color: ${textPrimaryColor};">
                            ${rootDescriptionText.trim() !== "" ? rootDescriptionText.replace(/\n/g, '<br>') : "No description available for this root."}
                        </p>`;
                } else { // This is for the occurrence nodes (Ayah context)
                    const wordDisplay = clickedNodeData.details_word || clickedNodeData.label.split(' (S')[0];
                    popupHTML = `
                        <h4 style="font-family: ${arabicFont}; font-size: 1.5rem; color: ${accentDarkColor}; margin-top:0; margin-bottom:10px;">
                            ${wordDisplay} (S${clickedNodeData.details_surah || '?'}:A${clickedNodeData.details_ayah || '?'})
                        </h4>
                        <p style="margin:0; line-height: ${arabicContextLineHeight}; font-size: ${arabicContextFontSize}; font-family: ${arabicFont}; direction: rtl; text-align: right; color: ${textPrimaryColor};">
                            ${clickedNodeData.details_context || "Full Ayah context not available."}
                        </p>`;
                }
                rootNodePopupEl.innerHTML = popupHTML;
                // --- END CONTENT POPULATION ---

                // --- POSITIONING ---
                try {
                    const nodePosition = rootNetwork.getPositions([nodeId])[nodeId];
                    if (!nodePosition) {
                        rootNodePopupEl.style.display = 'none'; return;
                    }
                    const domPosition = rootNetwork.canvasToDOM(nodePosition);
                    
                    rootNodePopupEl.style.display = 'block'; // Make it visible to measure

                    let popupLeft = domPosition.x + 25;
                    let popupTop = domPosition.y - (rootNodePopupEl.offsetHeight / 2);

                    const popupRect = rootNodePopupEl.getBoundingClientRect();
                    const vw = window.innerWidth;
                    const vh = window.innerHeight;

                    if (popupLeft + popupRect.width > vw - 15) {
                        popupLeft = domPosition.x - popupRect.width - 25;
                    }
                    if (popupLeft < 15) {
                        popupLeft = 15;
                    }
                    if (popupTop + popupRect.height > vh - 15) {
                        popupTop = vh - popupRect.height - 15;
                    }
                    if (popupTop < 15) {
                        popupTop = 15;
                    }

                    rootNodePopupEl.style.left = popupLeft + 'px';
                    rootNodePopupEl.style.top = popupTop + 'px';

                } catch (e) {
                    console.warn("Could not get node position for popup:", e);
                    if (rootNodePopupEl) rootNodePopupEl.style.display = 'none';
                }
         }


        // --- Recitation Log Functions ---
        async function loadRecitationLogs() {
             if (!db) return;
             const listEl = document.getElementById('recitations-list');
             listEl.innerHTML = '';
             showLoading("Loading recitation logs...");
             try {
                 const logs = await getAllData(STORE_RECITATIONS);
                 if (logs.length === 0) {
                     listEl.innerHTML = '<li>No entries logged yet.</li>'; hideLoading(); return;
                 }
                 logs.sort((a, b) => new Date(b.date) - new Date(a.date));
                 logs.forEach(log => {
                     const li = document.createElement('li');
                     const range = log.ayahStart && log.ayahEnd ? `Ayahs ${log.ayahStart}-${log.ayahEnd}` :
                                   log.ayahStart ? `Ayah ${log.ayahStart}` : 'Full Surah';
                     li.innerHTML = `
                         <strong>S ${log.surah} (${surahNames[log.surah-1]})</strong> - ${range} <br>
                         Qari: ${log.qari || 'N/A'} | Date: ${log.date || 'N/A'}
                         ${log.notes ? `<br>Notes: <em>${log.notes}</em>` : ''}
                         <div style="margin-top: 5px;">
                             <button data-log-id="${log.id}" class="delete-recitation-btn">Delete</button>
                         </div>
                     `;
                     listEl.appendChild(li);
                 });
                 listEl.querySelectorAll('.delete-recitation-btn').forEach(b => b.addEventListener('click', handleDeleteRecitationLog));
             } catch (error) {
                 listEl.innerHTML = `<li>Error: ${error.message}</li>`;
             } finally {
                 hideLoading();
             }
        }

        async function saveRecitationLog() {
            if (!db) return;
            const surah = parseInt(document.getElementById('rec-surah-select').value, 10);
            const ayahStart = document.getElementById('rec-ayah-start').value ? parseInt(document.getElementById('rec-ayah-start').value, 10) : null;
            const ayahEnd = document.getElementById('rec-ayah-end').value ? parseInt(document.getElementById('rec-ayah-end').value, 10) : null;
            const qari = document.getElementById('rec-qari').value.trim();
            const date = document.getElementById('rec-date').value;
            const notes = document.getElementById('rec-notes').value.trim();

            if (isNaN(surah)) { setStatusMessage('recitation-status', 'Select Surah.', true); return; }
            if (!date) { setStatusMessage('recitation-status', 'Select date.', true); return; }
            if (ayahStart && (isNaN(ayahStart) || ayahStart < 1 || ayahStart > surahAyahCounts[surah])) {
                setStatusMessage('recitation-status', `Invalid Ayah Start.`, true); return;
            }
            if (ayahEnd && (isNaN(ayahEnd) || ayahEnd < 1 || ayahEnd > surahAyahCounts[surah])) {
                setStatusMessage('recitation-status', `Invalid Ayah End.`, true); return;
            }
            if (ayahStart && ayahEnd && ayahStart > ayahEnd) {
                setStatusMessage('recitation-status', 'Start Ayah > End Ayah.', true); return;
            }

            showLoading("Saving recitation log...");
            try {
                await addData(STORE_RECITATIONS, { surah, ayahStart, ayahEnd, qari, date, notes });
                setStatusMessage('recitation-status', 'Log entry saved.', false);
                ['rec-ayah-start', 'rec-ayah-end', 'rec-qari', 'rec-date', 'rec-notes'].forEach(id => document.getElementById(id).value = '');
                loadRecitationLogs();
            } catch (error) {
                setStatusMessage('recitation-status', 'Failed to save log.', true);
            } finally {
                hideLoading();
            }
        }

         async function handleDeleteRecitationLog(event) {
             if (!db) return;
             const logId = parseInt(event.target.getAttribute('data-log-id'), 10);
             if (isNaN(logId) || !confirm("Delete this log entry?")) return;
             showLoading("Deleting log entry...");
             try {
                 await deleteData(STORE_RECITATIONS, logId);
                 setStatusMessage('recitation-status', 'Log entry deleted.', false);
                 loadRecitationLogs();
             } catch (error) {
                 setStatusMessage('recitation-status', 'Failed to delete log.', true);
             } finally {
                 hideLoading();
             }
         }

        // --- Memorization Hub Functions ---
        async function loadHifzForSurah(surah) {
             if (!db) return;
             const listEl = document.getElementById('hifz-ayahs-list');
             listEl.innerHTML = '';
             if (isNaN(surah) || surah < 1 || surah > 114) {
                 listEl.innerHTML = '<p class="text-center">Select a valid Surah.</p>'; return;
             }
             showLoading(`Loading Hifz for Surah ${surah}...`);
             try {
                 const totalAyahs = surahAyahCounts[surah];
                 const store = getObjectStore(STORE_HIFZ, 'readonly');
                 const request = store.getAll(IDBKeyRange.bound([surah, 1], [surah, totalAyahs]));
                 const hifzEntries = await new Promise(r => { request.onsuccess = () => r(request.result); });
                 const hifzMap = new Map(hifzEntries.map(e => [e.ayah, e]));

                 for (let i = 1; i <= totalAyahs; i++) {
                     const ayahData = hifzMap.get(i) || { surah, ayah: i, status: 'not-started', lastReviewDate: null, nextReviewDate: null, reviewCount: 0, notes: '' };
                     const li = document.createElement('div');
                     li.classList.add('ayah');
                     li.innerHTML = `
                         <div class="ayah-number">S ${surah}:${i}</div>
                         <div class="hifz-ayah-controls">
                             Status: <span class="hifz-ayah-status status-${ayahData.status}">${ayahData.status.replace('-', ' ')}</span>
                             ${ayahData.nextReviewDate ? ` | Next Review: ${ayahData.nextReviewDate}` : ''} <br>
                             <button data-surah="${surah}" data-ayah="${i}" data-status="in-progress" class="set-hifz-status-btn">In Progress</button>
                             <button data-surah="${surah}" data-ayah="${i}" data-status="memorized" class="set-hifz-status-btn">Memorized</button>
                             ${ayahData.status === 'memorized' ? `<button data-surah="${surah}" data-ayah="${i}" class="record-review-btn">Record Review</button>` : ''}
                             <button data-surah="${surah}" data-ayah="${i}" class="view-hifz-notes-btn">Notes</button>
                         </div>
                     `;
                     listEl.appendChild(li);
                 }
                 listEl.querySelectorAll('.set-hifz-status-btn').forEach(b => b.addEventListener('click', handleSetHifzStatus));
                 listEl.querySelectorAll('.record-review-btn').forEach(b => b.addEventListener('click', handleRecordReview));
                 listEl.querySelectorAll('.view-hifz-notes-btn').forEach(b => b.addEventListener('click', handleViewHifzNotes));
             } catch (error) {
                 listEl.innerHTML = `<li>Error: ${error.message}</li>`;
             } finally {
                 hideLoading();
             }
        }

        async function handleSetHifzStatus(event) {
             if (!db) return;
             const surah = parseInt(event.target.getAttribute('data-surah'), 10);
             const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
             const status = event.target.getAttribute('data-status');
             showLoading(`Setting status for ${surah}:${ayah}...`);
             try {
                 const existing = await getData(STORE_HIFZ, [surah, ayah]) || { surah, ayah, status: 'not-started', lastReviewDate: null, nextReviewDate: null, reviewCount: 0, notes: '' };
                 existing.status = status;
                 if (status !== 'memorized') {
                     existing.lastReviewDate = null; existing.nextReviewDate = null; existing.reviewCount = 0;
                 } else if (!existing.lastReviewDate) {
                     existing.lastReviewDate = new Date().toISOString().split('T')[0];
                     existing.reviewCount = 0;
                     existing.nextReviewDate = calculateNextReview(existing.lastReviewDate, existing.reviewCount);
                 }
                 await putData(STORE_HIFZ, existing);
                 setStatusMessage('hifz-status', `Status updated for ${surah}:${ayah}.`, false);
                 loadHifzForSurah(surah);
             } catch (error) {
                 setStatusMessage('hifz-status', 'Failed to update status.', true);
             } finally {
                 hideLoading();
             }
        }

        async function handleRecordReview(event) {
             if (!db) return;
             const surah = parseInt(event.target.getAttribute('data-surah'), 10);
             const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
             showLoading(`Recording review for ${surah}:${ayah}...`);
             try {
                 const existing = await getData(STORE_HIFZ, [surah, ayah]);
                 if (!existing || existing.status !== 'memorized') {
                     setStatusMessage('hifz-status', 'Ayah not memorized.', true); hideLoading(); return;
                 }
                 existing.lastReviewDate = new Date().toISOString().split('T')[0];
                 existing.reviewCount = (existing.reviewCount || 0) + 1;
                 existing.nextReviewDate = calculateNextReview(existing.lastReviewDate, existing.reviewCount);
                 await putData(STORE_HIFZ, existing);
                 setStatusMessage('hifz-status', `Review recorded. Next: ${existing.nextReviewDate}`, false);
                 loadHifzForSurah(surah);
             } catch (error) {
                 setStatusMessage('hifz-status', 'Failed to record review.', true);
             } finally {
                 hideLoading();
             }
        }

        function calculateNextReview(lastReviewDate, reviewCount) {
            const date = new Date(lastReviewDate);
            let daysToAdd = [1, 3, 7, 15, 30, 60, 90][Math.min(reviewCount, 6)] || 120; // Cap at 120 or extend
            date.setDate(date.getDate() + daysToAdd);
            return date.toISOString().split('T')[0];
        }

         async function handleViewHifzNotes(event) {
             if (!db) return;
             const surah = parseInt(event.target.getAttribute('data-surah'), 10);
             const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
             showLoading(`Loading notes for ${surah}:${ayah}...`);
             try {
                 const existing = await getData(STORE_HIFZ, [surah, ayah]) || { surah, ayah, status: 'not-started', notes: '' };
                 const notes = prompt(`Notes for Surah ${surah}:${ayah}:\n${existing.notes}\nEdit notes:`, existing.notes || '');
                 if (notes !== null && notes !== existing.notes) {
                     existing.notes = notes;
                     await putData(STORE_HIFZ, existing);
                     setStatusMessage('hifz-status', `Notes updated.`, false);
                     loadHifzForSurah(surah);
                 } else {
                      setStatusMessage('hifz-status', 'Notes unchanged.', false);
                 }
             } catch (error) {
                 setStatusMessage('hifz-status', 'Failed to load/save notes.', true);
             } finally {
                 hideLoading();
             }
         }


        // --- Advanced Search Functions ---
         async function performSearch() {
             if (!db) return;
             const searchTerm = document.getElementById('search-input').value.trim().toLowerCase();
             const searchScopes = Array.from(document.querySelectorAll('.search-scope:checked')).map(cb => cb.value);
             const searchResultsList = document.getElementById('search-results-list');
             searchResultsList.innerHTML = '';

             if (!searchTerm) {
                 setStatusMessage('search-status', 'Please enter a search term.', true);
                 return;
             }
             if (searchScopes.length === 0) {
                 setStatusMessage('search-status', 'Please select at least one search scope.', true);
                 return;
             }

             showLoading(`Searching for "${searchTerm}"...`);
             try {
                 const results = [];

                 // Search Quran text and translation
                 if (searchScopes.includes('quran-arabic') || searchScopes.includes('quran-translation')) {
                     const allAyahs = await getAllData(STORE_QURAN);
                     allAyahs.forEach(ayah => {
                         const normalizedSearchTerm = searchTerm.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").replace(/ؤ|و/g, "(و|ؤ)").replace(/ك|ک/g, "(ك|ک)").replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)").replace(/ى|ی|ي/g, "(ى|ی|ي)").replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)").replace(/ے/g, "(ے|ی)").replace(/م/g, "(مٰ|م)");

                         const matchArabic = searchScopes.includes('quran-arabic') &&
                                             ayah.arabic.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").replace(/ؤ|و/g, "(و|ؤ)").replace(/ك|ک/g, "(ك|ک)").replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)").replace(/ى|ی|ي/g, "(ى|ی|ي)").replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)").replace(/ے/g, "(ے|ی)").replace(/م/g, "(مٰ|م)").includes(normalizedSearchTerm);

                         let matchTranslation = false;
                         let translationSource = '';
                         let allTranslationsContext = [];

                         if (searchScopes.includes('quran-translation')) {
                             for (const langKey in TRANSLATION_CONFIG) {
                                 // Check if the ayah object has this translation field and if it matches
                                 if (ayah[langKey] && ayah[langKey].toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").includes(normalizedSearchTerm)) {
                                     matchTranslation = true;
                                     translationSource = TRANSLATION_CONFIG[langKey].label; // Get human-readable label
                                 }
                                 // Add all available translations to context string regardless of match
                                 if (ayah[langKey]) {
                                     allTranslationsContext.push(`${TRANSLATION_CONFIG[langKey].label}: ${ayah[langKey]}`);
                                 }
                             }
                         }

                         if (matchArabic || matchTranslation) {
                             results.push({
                                 type: 'Quran',
                                 ref: `Surah ${ayah.surah}:${ayah.ayah}`,
                                 surah: ayah.surah,
                                 ayah: ayah.ayah,
                                 context: `${ayah.arabic}${allTranslationsContext.length > 0 ? ' - ' + allTranslationsContext.join(' - ') : ''}`,
                                 source: matchArabic && matchTranslation ? `Arabic & Translation (${translationSource})` : matchArabic ? 'Arabic' : `Translation (${translationSource})`
                             });
                         }
                     });
                 }

                 // Search Personal Tafsir
                 if (searchScopes.includes('tafsir')) {
                     const allTafsir = await getAllData(STORE_TAFSIR);
                     allTafsir.forEach(tafsir => {
                         if (tafsir.notes && tafsir.notes.toLowerCase().includes(searchTerm)) {
                             results.push({
                                 type: 'Tafsir',
                                 ref: `Surah ${tafsir.surah}:${tafsir.ayah}`,
                                 surah: tafsir.surah,
                                 ayah: tafsir.ayah,
                                 context: tafsir.notes,
                                 source: 'Personal Tafsir'
                             });
                         }
                     });
                 }

                 // Search Theme Notes (assuming theme description/notes field exists)
                 if (searchScopes.includes('themes')) {
                     const allThemes = await getAllData(STORE_THEMES);
                     allThemes.forEach(theme => {
                         if (theme.description && theme.description.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").includes(searchTerm)) {
                              results.push({
                                 type: 'Theme',
                                 ref: `Theme: ${theme.name}`,
                                 context: theme.description,
                                 source: 'Theme Description'
                             });
                         }
                     });
                     // Also search notes on theme-ayah links
                     const allThemeAyahLinks = await getAllData(STORE_THEME_AYAHS);
                      const themesMap = new Map((await getAllData(STORE_THEMES)).map(t => [t.id, t.name]));
                     allThemeAyahLinks.forEach(link => {
                         if (link.notes && link.notes.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").includes(searchTerm)) {
                              results.push({
                                 type: 'Theme Link',
                                 ref: `Surah ${link.surah}:${link.ayah} (Theme: ${themesMap.get(link.themeId) || 'Unknown'})`,
                                 surah: link.surah,
                                 ayah: link.ayah,
                                 context: link.notes,
                                 source: 'Theme Link Notes'
                             });
                         }
                     });
                 }

                 // Search Root Notes (assuming root description/notes field exists)
                 if (searchScopes.includes('roots')) {
                     const allRoots = await getAllData(STORE_ROOTS);
                     allRoots.forEach(root => {
                         if (root.description && root.description.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").includes(searchTerm)) { // Assuming 'description' is the notes field
                             results.push({
                                 type: 'Root',
                                 ref: `Root: ${root.root}`,
                                 context: root.description,
                                 source: 'Root Notes'
                             });
                         }
                     });
                      // Could also list specific ayah occurrences if needed, but the main root analysis section does this.
                 }

                 // Search Recitation Notes
                 if (searchScopes.includes('recitation')) {
                     const allRecitations = await getAllData(STORE_RECITATIONS);
                     allRecitations.forEach(log => {
                         if (log.notes && log.notes.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").includes(searchTerm)) {
                              const range = log.ayahStart && log.ayahEnd ? `${log.ayahStart}-${log.ayahEnd}` :
                                   log.ayahStart ? `${log.ayahStart}` :
                                   log.ayahEnd ? `Up to ${log.ayahEnd}` : 'Full Surah';
                             results.push({
                                 type: 'Recitation Log',
                                 ref: `Surah ${log.surah} (${range})`,
                                 context: log.notes,
                                 source: 'Recitation Notes'
                             });
                         }
                     });
                 }

                 // Search Hifz Notes
                 if (searchScopes.includes('hifz')) {
                     const allHifz = await getAllData(STORE_HIFZ);
                     allHifz.forEach(hifz => {
                         if (hifz.notes && hifz.notes.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g,"").includes(searchTerm)) {
                             results.push({
                                 type: 'Hifz',
                                 ref: `Surah ${hifz.surah}:${hifz.ayah}`,
                                  surah: hifz.surah,
                                  ayah: hifz.ayah,
                                 context: hifz.notes,
                                 source: 'Hifz Notes'
                             });
                         }
                     });
                 }


                 if (results.length === 0) {
                     searchResultsList.innerHTML = '<li>No results found.</li>';
                     setStatusMessage('search-status', `No results found for "${searchTerm}".`, false);
                 } else {
                     setStatusMessage('search-status', `Found ${results.length} results for "${searchTerm}".`, false);
                      // Sort Quran/Hifz results by Surah/Ayah
                     results.sort((a, b) => {
                         if (a.surah && b.surah && a.surah !== b.surah) return a.surah - b.surah;
                         if (a.ayah && b.ayah) return a.ayah - b.ayah;
                         return 0; // Don't sort other types
                     });

                     results.forEach(result => {
                         const li = document.createElement('li');
                         li.innerHTML = `
                             <strong>${result.type}: ${result.ref}</strong> (${result.source})
                             <div class="result-context">${highlightMatch(result.context, searchTerm)}</div>
                             ${(result.type === 'Quran' || result.type === 'Tafsir' || result.type === 'Hifz') ?
                                `<button data-surah="${result.surah}" data-ayah="${result.ayah}" class="go-to-ayah-btn" style="margin-top: 5px; padding: 3px 8px; font-size: 0.8rem;">Go to Ayah</button>` : ''}
                         `;
                         searchResultsList.appendChild(li);
                     });

                     // Add listeners for "Go to Ayah" buttons
                     searchResultsList.querySelectorAll('.go-to-ayah-btn').forEach(button => {
                         button.addEventListener('click', handleGoToAyahFromSearch);
                     });
                 }

             } catch (error) {
                 console.error("Error during search:", error);
                 setStatusMessage('search-status', 'Failed to perform search.', true);
                 searchResultsList.innerHTML = `<li>Error during search: ${error.message}</li>`;
             } finally {
                 hideLoading();
             }
        }


        function highlightMatch(text, searchTerm) {
            if (!text || !searchTerm) return text;
            const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        async function handleGoToAyahFromSearch(event) {
             const surah = parseInt(event.target.getAttribute('data-surah'), 10);
             const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
             if (!isNaN(surah) && !isNaN(ayah)) {
                 await loadAyah(surah, ayah);
                 showSection('quran');
             }
        }


        // --- Data Export/Import ---
        async function exportData() {
             if (!db) return;
             showLoading("Exporting data...");
             try {
                 const data = {};
                 const userStores = [STORE_TAFSIR, STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS, STORE_HIFZ];
                 for (const storeName of userStores) {
                     data[storeName] = await getAllData(storeName);
                 }
                 const jsonString = JSON.stringify(data, null, 2);
                 const blob = new Blob([jsonString], { type: 'application/json' });
                 const url = URL.createObjectURL(blob);
                 const a = document.createElement('a');
                 a.href = url;
                 a.download = `nur-al-quran-studio-backup-${new Date().toISOString().split('T')[0]}.json`;
                 document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                 setStatusMessage('export-status', 'Data exported.', false);
             } catch (error) {
                 setStatusMessage('export-status', 'Export failed.', true);
             } finally {
                 hideLoading();
             }
        }
                // Helper function to get computed CSS variable value
       function getCssVar(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }
        async function importData(file) {
             if (!db || !file || !confirm("Importing will overwrite existing data. Continue?")) return;
             showLoading("Importing data...");
             try {
                 const reader = new FileReader();
                 reader.onload = async (event) => {
                     try {
                         const data = JSON.parse(event.target.result);
                         const userStores = [STORE_TAFSIR, STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS, STORE_HIFZ];
                         for (const storeName of userStores) {
                             if (!Array.isArray(data[storeName])) throw new Error(`Invalid data for ${storeName}`);
                         }
                         const transaction = db.transaction(userStores, 'readwrite');
                         transaction.oncomplete = async () => {
                             setStatusMessage('import-status', 'Data imported.', false);
                             await loadAyah(currentSurah, currentAyah); // Refresh UI
                             displayThemesList(); loadRecitationLogs();
                             if(document.getElementById('hifz-surah-select').value) loadHifzForSurah(parseInt(document.getElementById('hifz-surah-select').value,10));
                             hideLoading();
                         };
                         transaction.onerror = () => { setStatusMessage('import-status', 'Import transaction failed.', true); hideLoading(); };
                         for (const storeName of userStores) {
                             const store = transaction.objectStore(storeName);
                             store.clear();
                             if (data[storeName]) {
                                data[storeName].forEach(item => {
                                    // For auto-increment stores, remove old ID if present to let DB assign new.
                                    // This simplified import might break ID-based relationships if IDs aren't managed carefully.
                                    if ([STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS].includes(storeName)) {
                                        const newItem = {...item};
                                        delete newItem.id; // Let DB assign new ID
                                        store.add(newItem).catch(e => console.warn(`Could not add item to ${storeName} during import: `, item, e));
                                    } else {
                                        store.put(item).catch(e => console.warn(`Could not put item to ${storeName} during import: `, item, e));
                                    }
                                });
                             }
                         }
                     } catch (parseError) {
                         setStatusMessage('import-status', 'Invalid import file format.', true); hideLoading();
                     }
                 };
                 reader.onerror = () => { setStatusMessage('import-status', 'Failed to read file.', true); hideLoading(); };
                 reader.readAsText(file);
             } catch (error) {
                 setStatusMessage('import-status', 'Import initiation failed.', true); hideLoading();
             }
        }

         async function clearAllPersonalData() {
             if (!db || !confirm("DELETE ALL personal data? This cannot be undone.")) return;
             showLoading("Clearing all personal data...");
             try {
                 const userStores = [STORE_TAFSIR, STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS, STORE_HIFZ];
                 const transaction = db.transaction(userStores, 'readwrite');
                 transaction.oncomplete = () => {
                     setStatusMessage('clear-status', 'All personal data cleared.', false);
                     // Reset UI elements
                     document.getElementById('tafsir-notes').value = '';
                     document.getElementById('themes-list').innerHTML = '<li>No themes added yet.</li>';
                     document.getElementById('root-occurrences-list').innerHTML = '<li>Enter a root word and click "Analyze Root".</li>';
                     document.getElementById('recitations-list').innerHTML = '<li>No entries logged yet.</li>';
                     document.getElementById('hifz-ayahs-list').innerHTML = '<p class="text-center">Select a Surah to track Hifz progress.</p>';
                     populateThemeSelects();
                     hideLoading();
                 };
                 transaction.onerror = () => { setStatusMessage('clear-status', 'Failed to clear data.', true); hideLoading(); };
                 userStores.forEach(storeName => transaction.objectStore(storeName).clear());
             } catch (error) {
                 setStatusMessage('clear-status', 'Data clear failed.', true); hideLoading();
             }
         }

        // --- Settings Functions ---
        function applyTheme(themeName) {
            document.body.className = '';
            if (themeName !== 'serene') document.body.classList.add(`theme-${themeName}`);
            if (db) putData(STORE_SETTINGS, { name: 'theme', value: themeName }).catch(console.error);
        }
        async function loadThemePreference() {
             if (!db) return;
             try {
                 const settings = await getData(STORE_SETTINGS, 'theme');
                 const theme = settings ? settings.value : 'serene';
                 document.getElementById('theme-switcher').value = theme;
                 applyTheme(theme);
             } catch (error) { // Fallback to default
                 document.getElementById('theme-switcher').value = 'serene'; applyTheme('serene');
             }
        }


        // --- Event Listeners Setup ---
        function setupEventListeners() {
            document.getElementById('surah-select').addEventListener('change', (event) => {
                currentSurah = parseInt(event.target.value, 10);
                updateAyahSelect(currentSurah);
                loadAyah(currentSurah, currentAyah);
            });
            document.getElementById('ayah-select').addEventListener('change', (event) => {
                currentAyah = parseInt(event.target.value, 10);
                loadAyah(currentSurah, currentAyah);
            });
            document.getElementById('translation-select').addEventListener('change', () => loadAyah(currentSurah, currentAyah));

            document.querySelectorAll('.nav-link').forEach(link => {
                link.addEventListener('click', (event) => {
                    event.preventDefault();
                    showSection(event.target.getAttribute('data-section'));
                });
            });

            document.getElementById('save-tafsir-btn').addEventListener('click', saveTafsir);
            document.getElementById('add-theme-btn').addEventListener('click', addTheme);
            document.getElementById('link-ayah-to-theme-btn').addEventListener('click', linkAyahToTheme);
            document.getElementById('link-theme-select').addEventListener('change', displayLinkedAyahsForCurrentTheme);
            document.getElementById('analyze-root-btn').addEventListener('click', analyzeRoot);
            document.getElementById('save-root-notes-btn').addEventListener('click', saveRootNotes);
            document.getElementById('save-recitation-btn').addEventListener('click', saveRecitationLog);
            document.getElementById('rec-surah-select').addEventListener('change', (event) => {
                 const surah = parseInt(event.target.value, 10);
                 const totalAyahs = surahAyahCounts[surah];
                 document.getElementById('rec-ayah-start').max = totalAyahs;
                 document.getElementById('rec-ayah-end').max = totalAyahs;
            });
            document.getElementById('hifz-surah-select').addEventListener('change', (event) => {
                 loadHifzForSurah(parseInt(event.target.value, 10));
            });
            document.getElementById('perform-search-btn').addEventListener('click', performSearch);
            document.getElementById('export-data-btn').addEventListener('click', exportData);
            document.getElementById('import-file').addEventListener('change', (event) => {
                 document.getElementById('import-data-btn').disabled = !event.target.files[0];
            });
            document.getElementById('import-data-btn').addEventListener('click', () => {
                 const fileInput = document.getElementById('import-file');
                 if (fileInput.files.length > 0) importData(fileInput.files[0]);
                 else setStatusMessage('import-status', 'Select file to import.', true);
            });
            document.getElementById('clear-data-btn').addEventListener('click', clearAllPersonalData);
            document.getElementById('theme-switcher').addEventListener('change', (event) => applyTheme(event.target.value));

            document.querySelectorAll('.modal .close-button').forEach(button => {
                button.addEventListener('click', (event) => event.target.closest('.modal').style.display = 'none');
            });
            window.addEventListener('click', (event) => {
                 document.querySelectorAll('.modal').forEach(modal => { if (event.target === modal) modal.style.display = 'none'; });
            });
            window.addEventListener('keydown', (event) => { // Close modals with Escape key
                if (event.key === 'Escape') {
                    document.querySelectorAll('.modal').forEach(modal => modal.style.display = 'none');
                }
            });
            setupTafsirDocxButton();
                            // Inside setupEventListeners function:
        document.querySelectorAll('input[name="root-view-mode"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const newViewMode = this.value;
                const rootContents = document.querySelectorAll('.root-view-content');
                rootContents.forEach(el => {
                    el.classList.remove('active-view');
                    el.style.display = 'none'; // Explicitly hide all first
                });

                document.getElementById('root-graph-placeholder').style.display = 'none';
                const paginationControls = document.getElementById('root-graph-pagination-controls');
                const occurrencesListElement = document.getElementById('root-occurrences-list');
                const graphContainerWrapper = document.getElementById('root-network-graph-container'); // The wrapper
                const graphContainer = document.getElementById('root-network-graph'); // The vis.js target
                const analyzedRootTerm = document.getElementById('analyzed-root-term').textContent;

                if (newViewMode === 'list') {
                    occurrencesListElement.classList.add('active-view');
                    occurrencesListElement.style.display = 'block'; // Explicitly show
                    paginationControls.style.display = 'none';

                    if (analyzedRootTerm !== 'N/A' && allRootOccurrencesCache.length > 0) {
                        occurrencesListElement.innerHTML = '';
                        allRootOccurrencesCache.forEach(occ => {
                            const li = document.createElement('li');
                            li.innerHTML = `
                                <strong>Surah ${occ.surah}:${occ.ayah}</strong> - Word: <span lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.word}</span>
                                <div class="result-context" lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.context}</div>
                            `;
                            occurrencesListElement.appendChild(li);
                        });
                    } else if (analyzedRootTerm === 'N/A') {
                        occurrencesListElement.innerHTML = '<li>Enter a root word and click "Analyze Root".</li>';
                    } else {
                        occurrencesListElement.innerHTML = '<li>No occurrences found or error in analysis.</li>';
                    }

                } else if (newViewMode === 'tree') {
                    graphContainerWrapper.classList.add('active-view');
                    graphContainerWrapper.style.display = 'block'; // CRITICAL: Make wrapper visible BEFORE graph update
                    occurrencesListElement.innerHTML = '<li>Graph view active. Results may be paginated below if applicable.</li>';

                    if (analyzedRootTerm !== 'N/A' && allRootOccurrencesCache.length > 0) {
                        updateRootGraphView(); // Now this will find a visible container
                        paginationControls.style.display = (allRootOccurrencesCache.length > rootGraphItemsPerPage) ? 'flex' : 'none';
                    } else if (analyzedRootTerm !== 'N/A' && allRootOccurrencesCache.length === 0 && graphContainer.children.length === 0) {
                        analyzeRoot(); // analyzeRoot itself will handle calling updateRootGraphView
                    } else if (analyzedRootTerm === 'N/A') {
                        graphContainer.innerHTML = '';
                        document.getElementById('root-graph-placeholder').style.display = 'block';
                        document.getElementById('root-graph-placeholder').textContent = 'Enter a root and click "Analyze Root" to see the graph.';
                        paginationControls.style.display = 'none';
                    }
                }
            });
        });

        // New functions for pagination
        function goToPrevRootGraphPage() {
            if (currentRootGraphPage > 1) {
                currentRootGraphPage--;
                updateRootGraphView();
            }
        }

        function goToNextRootGraphPage() {
            const totalPages = Math.ceil(allRootOccurrencesCache.length / rootGraphItemsPerPage);
            if (currentRootGraphPage < totalPages) {
                currentRootGraphPage++;
                updateRootGraphView();
            }
        }

        // Add event listeners for pagination buttons
        document.getElementById('prev-root-graph-page-btn').addEventListener('click', goToPrevRootGraphPage);
        document.getElementById('next-root-graph-page-btn').addEventListener('click', goToNextRootGraphPage);

                // Inside setupEventListeners function:
        // (after your existing event listeners)

        let graphCloseButton = null; // Keep a reference to the close button

        document.querySelectorAll('input[name="root-view-mode"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const newViewMode = this.value;
                const rootSection = document.getElementById('roots');
                const graphContainerWrapper = document.getElementById('root-network-graph-container');
                const occurrencesListElement = document.getElementById('root-occurrences-list');
                const mainContent = document.querySelector('.main-content'); // For restoring scroll
                const header = document.querySelector('header'); // To hide/show
                const sidebar = document.querySelector('.sidebar'); // To hide/show


                // Hide existing graph close button if any
                if (graphCloseButton && graphCloseButton.parentNode) {
                    graphCloseButton.parentNode.removeChild(graphCloseButton);
                    graphCloseButton = null;
                }
                // Hide node popup if open
                if (rootNodePopupEl) rootNodePopupEl.style.display = 'none';
                activeRootNodeIdForPopup = null;

                if (newViewMode === 'tree') {
                    // Enter Fullscreen Graph Mode
                    document.body.classList.add('graph-fullscreen-active');
                    graphContainerWrapper.classList.add('fullscreen-graph');
                    if(header) header.style.display = 'none';
                    if(sidebar) sidebar.style.display = 'none';
                    mainContent.style.overflowY = 'hidden'; // Prevent main content from scrolling

                    // Hide list view, show graph view wrapper
                    occurrencesListElement.classList.remove('active-view');
                    occurrencesListElement.style.display = 'none';
                    graphContainerWrapper.classList.add('active-view');
                    graphContainerWrapper.style.display = 'flex'; // Changed to flex for alignment

                    // Add close button for fullscreen
                    graphCloseButton = document.createElement('button');
                    graphCloseButton.textContent = 'Close Graph (Esc)';
                    graphCloseButton.classList.add('graph-fullscreen-close-btn');
                    graphCloseButton.onclick = () => {
                        document.getElementById('root-view-list').click(); // Simulate click on list view radio
                    };
                    graphContainerWrapper.appendChild(graphCloseButton);

                    // Ensure graph renders/re-renders
                    // If allRootOccurrencesCache has data, update/render the graph
                    if (allRootOccurrencesCache.length > 0 || document.getElementById('analyzed-root-term').textContent !== 'N/A') {
                         updateRootGraphView(); // This should call renderRootTreeGraph
                    } else {
                        document.getElementById('root-network-graph').innerHTML = ''; // Clear
                        document.getElementById('root-graph-placeholder').textContent = 'Analyze a root to see the graph.';
                        document.getElementById('root-graph-placeholder').style.display = 'block';
                    }
                     // Ensure pagination controls are visible if needed
                    const paginationControls = document.getElementById('root-graph-pagination-controls');
                     if (paginationControls) {
                        paginationControls.style.display = (allRootOccurrencesCache.length > rootGraphItemsPerPage) ? 'flex' : 'none';
                     }


                } else { // newViewMode === 'list'
                    // Exit Fullscreen Graph Mode
                    document.body.classList.remove('graph-fullscreen-active');
                    graphContainerWrapper.classList.remove('fullscreen-graph');
                    if(header) header.style.display = ''; // Or 'flex' depending on its default
                    if(sidebar) sidebar.style.display = '';
                    mainContent.style.overflowY = 'auto';


                    // Show list view, hide graph view wrapper
                    graphContainerWrapper.classList.remove('active-view');
                    graphContainerWrapper.style.display = 'none';
                    occurrencesListElement.classList.add('active-view');
                    occurrencesListElement.style.display = 'block';
                    document.getElementById('root-graph-pagination-controls').style.display = 'none';


                    // Populate list view (your existing logic for this)
                    const analyzedRootTermText = document.getElementById('analyzed-root-term').textContent;
                    if (analyzedRootTermText !== 'N/A' && allRootOccurrencesCache.length > 0) {
                        occurrencesListElement.innerHTML = ''; // Clear previous
                        allRootOccurrencesCache.forEach(occ => {
                            const li = document.createElement('li');
                            li.innerHTML = `<strong>Surah ${occ.surah}:${occ.ayah}</strong> - Word: <span lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.word}</span><div class="result-context" lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.context}</div>`;
                            occurrencesListElement.appendChild(li);
                        });
                    } else if (analyzedRootTermText === 'N/A' || analyzedRootTermText.trim() === '') {
                        occurrencesListElement.innerHTML = '<li>Enter a root word and click "Analyze Root".</li>';
                    } else {
                        occurrencesListElement.innerHTML = '<li>No occurrences found or error in analysis.</li>';
                    }
                }
            });
        });

        // Add Escape key listener for fullscreen graph
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && document.body.classList.contains('graph-fullscreen-active')) {
                if (graphCloseButton) {
                    graphCloseButton.click(); // Trigger the close button's logic
                }
            }
        });

        // ... (rest of your setupEventListeners, including pagination for graph)

        }

        // --- App Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await openDB();
                await loadThemePreference();
                setupEventListeners(); // Setup listeners after DB is open
                await loadQuranData(); // This populates selects and loads initial ayah
                displayThemesList();
                // loadRecitationLogs(); // Called when section is shown
                // loadHifzForSurah(); // Called when section is shown and surah selected
            } catch (error) {
                console.error("App initialization failed:", error);
                hideLoading();
                alert("Failed to initialize: " + error.message + "\nPlease clear website data and refresh. Check console for details.");
            }
            rootNodePopupEl = document.getElementById('root-node-popup');
            if (!rootNodePopupEl) {
                console.error("CRITICAL: Popup element #root-node-popup not found in the DOM!");
            }
        });
    </script>
</body>
</html>
<script>
        // --- Tafsir Export to DOCX Functions ---

        async function loadDocxJs() {
            return new Promise((resolve, reject) => {
                if (window.docx) { // Check if already loaded
                    console.log("docx.js already loaded.");
                    resolve(window.docx);
                    return;
                }
                console.log("Loading docx.js library...");
                const script = document.createElement('script');
                // Using jsDelivr CDN - always check for the latest stable version
                script.src = 'https://cdn.jsdelivr.net/npm/docx@9.5.0/dist/index.iife.min.js';
                script.onload = () => {
                    console.log("docx.js loaded successfully.");
                    resolve(window.docx); // The library attaches itself to window.docx
                };
                script.onerror = (err) => {
                    console.error("Failed to load docx.js library:", err);
                    reject("Failed to load DOCX library. Please check your internet connection.");
                };
                document.head.appendChild(script);
            });
        }


        async function exportTafsirToDocx() {
            setStatusMessage('export-tafsir-docx-status', 'Initializing DOCX export...', false);
            showLoading("Preparing Tafsir for DOCX export...");

            let docx;
            try {
                docx = await loadDocxJs();
                if (!docx || !docx.Document || !docx.Packer || !docx.Paragraph || !docx.TextRun || !docx.HeadingLevel) {
                    throw new Error("DOCX library not loaded correctly or is an incompatible version.");
                }
            } catch (error) {
                console.error("Error loading DOCX library:", error);
                setStatusMessage('export-tafsir-docx-status', typeof error === 'string' ? error : 'Failed to load DOCX library.', true);
                hideLoading();
                return;
            }

            if (!db) {
                setStatusMessage('export-tafsir-docx-status', 'Database not ready.', true);
                hideLoading();
                return;
            }

            try {
                const allTafsirEntries = await getAllData(STORE_TAFSIR);
                if (!allTafsirEntries || allTafsirEntries.length === 0) {
                    setStatusMessage('export-tafsir-docx-status', 'No Tafsir notes found to export.', false);
                    hideLoading();
                    return;
                }

                allTafsirEntries.sort((a, b) => {
                    if (a.surah !== b.surah) return a.surah - b.surah;
                    return a.ayah - b.ayah;
                });

                const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, ShadingType, convertInchesToTwip } = docx;

                const children = [];

                // Document Title
                children.push(
                    new Paragraph({
                        text: "My Personal Quran Tafsir",
                        heading: HeadingLevel.TITLE,
                        alignment: AlignmentType.CENTER,
                    })
                );
                children.push(new Paragraph(" ")); // Spacer

                let currentProcessingSurah = -1;

                for (const tafsirEntry of allTafsirEntries) {
                    if (tafsirEntry.surah !== currentProcessingSurah) {
                        currentProcessingSurah = tafsirEntry.surah;
                        const surahNameStr = surahNames[currentProcessingSurah - 1] || `Surah ${currentProcessingSurah}`;

                        // Surah Title
                        children.push(
                            new Paragraph({
                                children: [
                                    new TextRun({
                                        text: `Surah ${currentProcessingSurah}: ${surahNameStr}`,
                                        bold: true,
                                        size: 32, // 16pt font size (2 * 16)
                                        color: "2E74B5", // A blue color
                                    }),
                                ],
                                heading: HeadingLevel.HEADING_1,
                                spacing: { before: convertInchesToTwip(0.2), after: convertInchesToTwip(0.1) },
                            })
                        );
                    }

                    // Fetch Arabic text for the Ayah
                    const quranAyahData = await getData(STORE_QURAN, [tafsirEntry.surah, tafsirEntry.ayah]);
                    const arabicText = quranAyahData ? quranAyahData.arabic : "Arabic text not found.";

                    // Ayah Reference
                    children.push(
                        new Paragraph({
                            children: [
                                new TextRun({
                                    text: `Ayah ${tafsirEntry.ayah}`,
                                    bold: true,
                                    size: 28, // 14pt
                                    color: "1F4E79", // Darker blue
                                }),
                            ],
                            spacing: { before: convertInchesToTwip(0.15), after: convertInchesToTwip(0.05) },
                        })
                    );

                    // Arabic Text Paragraph
                    // Note: RTL text handling in docx.js might require specific paragraph properties.
                    // Fonts also need to be available on the system opening the DOCX.
                    children.push(
                        new Paragraph({
                            children: [
                                new TextRun({
                                    text: arabicText,
                                    font: "Scheherazade New", // Specify an Arabic font
                                    size: 36, // 18pt
                                    rightToLeft: true, // Crucial for Arabic
                                }),
                            ],
                            alignment: AlignmentType.RIGHT,
                            bidirectional: true, // Important for mixed LTR/RTL content handling in Word
                            shading: { // Basic background color
                                type: ShadingType.SOLID,
                                color: "E8F5E9", // Light green (hex without #)
                                fill: "E8F5E9",
                            },
                            spacing: { after: convertInchesToTwip(0.1) },
                        })
                    );

                    // Tafsir Notes Paragraph
                    // Split notes by newline and create separate TextRuns or Paragraphs for proper line breaks
                    const notesLines = tafsirEntry.notes.split('\n');
                    notesLines.forEach((line, index) => {
                        children.push(
                            new Paragraph({
                                children: [
                                    new TextRun({
                                        text: line,
                                        size: 24, // 12pt
                                    }),
                                ],
                                indentation: { left: convertInchesToTwip(0.25) }, // Indent Tafsir notes
                                spacing: { after: (index === notesLines.length - 1) ? convertInchesToTwip(0.15) : convertInchesToTwip(0.02) },
                            })
                        );
                    });
                     children.push(new Paragraph(" ")); // Spacer after each tafsir entry
                }

                const doc = new Document({
                    sections: [{
                        properties: {
                            page: {
                                margin: {
                                    top: convertInchesToTwip(0.75),
                                    right: convertInchesToTwip(0.75),
                                    bottom: convertInchesToTwip(0.75),
                                    left: convertInchesToTwip(0.75),
                                },
                            },
                        },
                        children: children,
                    }],
                    // Define default fonts if possible, though this is more for the document's meta
                    // Actual font rendering depends on the user's system.
                    styles: {
                        default: {
                            document: {
                                run: {
                                    font: "Calibri", // Default LTR font
                                    size: 22, // 11pt default
                                },
                                paragraph: {
                                    spacing: { line: 276 } // approx 1.15 line spacing
                                }
                            },
                        },
                        paragraphStyles: [
                            {
                                id: "arabicStyle",
                                name: "Arabic Text",
                                basedOn: "Normal",
                                next: "Normal",
                                run: {
                                    font: "Scheherazade New",
                                    size: 36,
                                    rightToLeft: true,
                                },
                                paragraph: {
                                    alignment: AlignmentType.RIGHT,
                                    bidirectional: true,
                                }
                            }
                        ]
                    }
                });

                // Packer to generate the .docx file
                Packer.toBlob(doc).then(blob => {
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(blob);
                    link.download = `Personal-Tafsir-${new Date().toISOString().split('T')[0]}.docx`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);
                    setStatusMessage('export-tafsir-docx-status', 'Tafsir DOCX file generated.', false);
                }).catch(packError => {
                    console.error("Error packing DOCX:", packError);
                    setStatusMessage('export-tafsir-docx-status', 'Failed to generate DOCX file.', true);
                });

            } catch (error) {
                console.error("Error exporting Tafsir to DOCX:", error);
                setStatusMessage('export-tafsir-docx-status', 'Failed to export Tafsir to DOCX.', true);
            } finally {
                hideLoading();
            }
        }


        // Add this to your setupEventListeners function
        function setupTafsirDocxButton() {
            const exportDocxBtn = document.getElementById('export-tafsir-to-docx-btn');
            if (exportDocxBtn) {
                exportDocxBtn.addEventListener('click', exportTafsirToDocx);
            } else {
                console.warn("Export Tafsir to DOCX button not found.");
            }
        }






///////////// Games

// === GAME LOGIC AND UI - PASTE THIS AT THE END OF YOUR EXISTING <script> TAG ===
// === Make sure this is *inside* the main <script> tag, before its closing 

function setupGameModal() {
const gameModalHTML = `
    <div id="quranGameModal" class="modal game-modal" role="dialog" aria-modal="true" aria-labelledby="gameModalTitle" style="display: none;">
        <div class="modal-content game-modal-content">
            <span class="close-button game-close-button" aria-label="Close Game">×</span>
            <h2 id="gameModalTitle">Quranic Games</h2>
            <div class="game-selection-area">
                <p>Choose a game to play:</p>
                <button id="startGameWordWhiz" class="game-select-btn">Word Whiz (Vocabulary)</button>
                <button id="startGameAyahJumble" class="game-select-btn">Ayah Jumble (Order)</button>
            </div>
            <div id="gamePlayArea" class="game-play-area" style="display: none;">
                <!-- Game content will be loaded here -->
            </div>
                <div id="gameScoreArea" class="game-score-area" style="display: none;">
                    <p>Score: <span id="gameCurrentScore">0</span></p>
                    <p>High Score: <span id="gameHighScore">0</span> (for this session)</p>
                </div>
                <div class="game-controls">
                     <button id="quitGameButton" style="display:none; background-color: var(--color-error); margin-top:15px;">Quit Current Game</button>
                </div>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', gameModalHTML);

    // Add CSS for the game modal and elements
    const gameModalCSS = `
        .game-modal .modal-content {
            max-width: 90%;
            width: 700px; /* Adjust as needed */
            max-height: 90vh;
            overflow-y: auto;
            background-color: var(--color-bg-primary); /* Use theme colors */
            color: var(--color-text-primary);
        }
        .game-modal-content h2 {
            text-align: center;
            color: var(--color-text-secondary);
            margin-bottom: 0px;
        }
        .game-selection-area {
            text-align: center;
            margin-bottom: -3px;
        }
        .game-select-btn {
            margin: 10px;
            padding: 12px 20px;
            font-size: 1.1rem;
        }
        .game-play-area {
            padding: 8px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-secondary);
            min-height: fit-content;
            text-align: center;
        }
        .game-question-arabic {
            font-family: var(--font-arabic);
            font-size: 2rem;
            margin-bottom: 13px;
            direction: rtl;
        }
        .game-options-list {
            list-style: none;
            padding: 0;
            margin: 0 auto;
            max-width: 400px; /* Or adjust based on content */
        }
        .game-options-list li button {
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 12px;
            background-color: var(--color-accent);
            border: 1px solid var(--color-accent-dark);
            color: white;
            font-family: var(--font-general); /* Or specific language font */
        }
        .game-options-list li button:hover {
            background-color: var(--color-accent-dark);
        }
        .game-options-list li button.correct {
            background-color: #1050c5 !important;
        }
        .game-options-list li button.incorrect {
            background-color: var(--color-error) !important;
        }
        .game-feedback {
            margin-top: 15px;
            font-weight: bold;
        }
        .game-score-area {
            text-align: center;
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid var(--color-border);
        }
        .game-controls {
            text-align: center;
            margin-top: 20px;
        }

        /* Ayah Jumble Specific */
        .jumble-word-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            min-height: 50px; /* So it doesn't collapse */
            padding: 10px;
            border: 1px dashed var(--color-border);
            border-radius: var(--border-radius);
        }
        .jumble-word {
            font-family: var(--font-arabic);
            font-size: 1.8rem;
            padding: 8px 12px;
            background-color: var(--color-bg-primary);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            cursor: grab;
            user-select: none; /* Prevent text selection during drag */
            direction: rtl;
        }
        .jumble-word.dragging {
            opacity: 0.5;
            background-color: var(--color-highlight);
        }
        .jumble-target-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start; /* RTL friendly start */
            gap: 5px; /* Small gap for visual separation */
            padding: 10px;
            border: 2px solid var(--color-accent);
            border-radius: var(--border-radius);
            min-height: 70px;
            background-color: var(--color-bg-secondary);
            direction: rtl; /* Important for correct ordering display */
        }
        .jumble-target-area .jumble-word {
             cursor: default; /* No longer grabbable once placed */
        }
        #jumbleSubmitAnswer { margin-top: 15px; }
        .game-modal.fullscreen {
            padding: 0;
        }
        .game-modal.fullscreen .modal-content {
            width: 100%;
            max-width: 100%;
            height: 100vh;
            max-height: 100vh;
            border-radius: 0;
            display: flex;
            flex-direction: column;
        }
        .game-modal.fullscreen .game-play-area {
            flex-grow: 1;
            overflow-y: auto;
        }
    `;
    const styleSheet = document.createElement("style");
    styleSheet.type = "text/css";
    styleSheet.innerText = gameModalCSS;
    document.head.appendChild(styleSheet);

    // Event Listeners for Modal
    const gameModal = document.getElementById('quranGameModal');
    const closeButton = gameModal.querySelector('.game-close-button');
    const startGameWordWhizBtn = document.getElementById('startGameWordWhiz');
    const startGameAyahJumbleBtn = document.getElementById('startGameAyahJumble');
    const quitGameButton = document.getElementById('quitGameButton');


    closeButton.addEventListener('click', () => {
        gameModal.style.display = 'none';
        resetGameUI(); // Ensure game state is reset when closing
    });
    window.addEventListener('click', (event) => {
        if (event.target === gameModal) {
            gameModal.style.display = 'none';
            resetGameUI();
        }
    });
     window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && gameModal.style.display === 'flex') {
            gameModal.style.display = 'none';
            resetGameUI();
        }
    });

    startGameWordWhizBtn.addEventListener('click', () => startWordWhizGame());
    startGameAyahJumbleBtn.addEventListener('click', () => startAyahJumbleGame());
    quitGameButton.addEventListener('click', () => {
        activeGame = null;
        resetGameUI();
    });


    // Add a button to the main UI to open the game modal
    const sidebarNav = document.querySelector('.sidebar nav ul');
    if (sidebarNav) {
        const gameLi = document.createElement('li');
        const gameLink = document.createElement('a');
        gameLink.href = "#games";
        gameLink.textContent = "Quranic Games";
        gameLink.id = "openGamesModalBtn";
        gameLi.appendChild(gameLink);
        sidebarNav.appendChild(gameLi);

        gameLink.addEventListener('click', (e) => {
            e.preventDefault();
            // Ensure other sections are not "active" visually if needed
            document.querySelectorAll('.nav-link.active').forEach(l => l.classList.remove('active'));
            gameLink.classList.add('active'); // Visually activate game link
            gameModal.style.display = 'flex';
            gameModal.classList.add('fullscreen'); // Make it fullscreen
            resetGameUI(); // Show selection screen first
        });
    }
    addFlashcardSuiteButtonToModal();
    addAyahTypingGameButtonToModal();
    addEnhancedFullScreenReaderLaunchButton();
}

let activeGame = null; // To track which game is running
let gameScore = 0;
let gameHighScore = 0; // Session high score
let wordWhizQuestions = [];
let currentWordWhizQuestionIndex = 0;
let ayahJumbleQuestion = null;

function resetGameUI() {
    const gamePlayArea = document.getElementById('gamePlayArea');
    const gameSelectionArea = document.getElementById('game-selection-area');
    const gameScoreArea = document.getElementById('gameScoreArea');
    const quitGameButton = document.getElementById('quitGameButton');
    const gameModalTitle = document.getElementById('gameModalTitle');

    if (gamePlayArea) {
        gamePlayArea.style.display = 'none';
        gamePlayArea.innerHTML = '';
    } else {
        console.error("resetGameUI: gamePlayArea not found");
    }

    if (gameSelectionArea) {
        gameSelectionArea.style.display = 'block';
    } else {
        console.error("resetGameUI: gameSelectionArea not found");
    }

    if (gameScoreArea) {
        gameScoreArea.style.display = 'none';
    } else {
        console.error("resetGameUI: gameScoreArea not found");
    }

    if (quitGameButton) {
        quitGameButton.style.display = 'none';
    } else {
        console.error("resetGameUI: quitGameButton not found");
    }

    if (gameModalTitle) {
        gameModalTitle.textContent = "Quranic Games";
    } else {
        console.error("resetGameUI: gameModalTitle not found");
    }
}

function showGamePlayUI(gameTitle) {
    const gameSelectionArea = document.getElementById('game-selection-area');
    const gamePlayArea = document.getElementById('gamePlayArea');
    const gameScoreArea = document.getElementById('gameScoreArea');
    const quitGameButton = document.getElementById('quitGameButton');
    const gameModalTitle = document.getElementById('gameModalTitle');

    if (gameSelectionArea) {
        gameSelectionArea.style.display = 'none';
    } else {
        console.error("showGamePlayUI: gameSelectionArea not found");
    }

    if (gamePlayArea) {
        gamePlayArea.style.display = 'block';
    } else {
        console.error("showGamePlayUI: gamePlayArea not found");
    }

    if (gameScoreArea) {
        gameScoreArea.style.display = 'block';
        updateScoreDisplay(); // Call this only if gameScoreArea exists
    } else {
        console.error("showGamePlayUI: gameScoreArea not found");
    }

    if (quitGameButton) {
        quitGameButton.style.display = 'block';
    } else {
        console.error("showGamePlayUI: quitGameButton not found");
    }

    if (gameModalTitle) {
        gameModalTitle.textContent = gameTitle;
    } else {
        console.error("showGamePlayUI: gameModalTitle not found");
    }
}

// Also, ensure updateScoreDisplay has checks:
function updateScoreDisplay() {
    const gameCurrentScoreEl = document.getElementById('gameCurrentScore');
    const gameHighScoreEl = document.getElementById('gameHighScore');

    if (gameCurrentScoreEl) {
        gameCurrentScoreEl.textContent = gameScore;
    } else {
        console.error("updateScoreDisplay: gameCurrentScore element not found");
    }

    if (gameHighScoreEl) {
        gameHighScoreEl.textContent = gameHighScore;
    } else {
        console.error("updateScoreDisplay: gameHighScore element not found");
    }
}

function updateScoreDisplay() {
    document.getElementById('gameCurrentScore').textContent = gameScore;
    document.getElementById('gameHighScore').textContent = gameHighScore;
}

// --- WORD WHIZ GAME ---
async function startWordWhizGame() {
    activeGame = 'wordWhiz';
    gameScore = 0;
    updateScoreDisplay();
    showGamePlayUI("Word Whiz Challenge");
    document.getElementById('gamePlayArea').innerHTML = '<p>Loading questions...</p>';

    try {
        // Fetch a pool of words. For simplicity, let's fetch some random words.
        // In a real scenario, you might want to fetch words from recently viewed ayahs or specific surahs.
        const allWordMetadata = await getAllData(STORE_WORD_METADATA);
        const allWordTranslations = await getAllData(STORE_WORD_TRANSLATIONS);

        if (allWordMetadata.length < 10 || allWordTranslations.length < 10) {
            document.getElementById('gamePlayArea').innerHTML = '<p>Not enough word data to start the game. Please load Quran data first.</p>';
            return;
        }

        // Create a map for quick translation lookup by word_id
        const translationMap = new Map();
        allWordTranslations.forEach(wt => translationMap.set(wt.word_id, wt));

        wordWhizQuestions = [];
        const selectedWordIds = new Set(); // To avoid duplicate questions with same word_id

        for (let i = 0; i < 10; i++) { // Generate 10 questions
            let attempt = 0;
            let randomMetaEntry, quranAyah, wordText, translationEntry;

            // Find a word that has a translation and its corresponding Quran text
            while(attempt < 50) { // Try to find a valid word
                randomMetaEntry = allWordMetadata[Math.floor(Math.random() * allWordMetadata.length)];
                if (selectedWordIds.has(randomMetaEntry.word_id)) {
                    attempt++;
                    continue;
                }

                translationEntry = translationMap.get(randomMetaEntry.word_id);
                if (!translationEntry || (!translationEntry.en_meaning && !translationEntry.ur_meaning && !translationEntry.bn_meaning)) { // Check if any translation exists
                     attempt++;
                     continue;
                }

                quranAyah = await getData(STORE_QURAN, [randomMetaEntry.surah, randomMetaEntry.ayah]);
                if (!quranAyah) {
                     attempt++;
                     continue;
                }

                const wordsInAyah = quranAyah.arabic.split(/\s+/);
                if (randomMetaEntry.word_position < wordsInAyah.length) {
                    wordText = wordsInAyah[randomMetaEntry.word_position];
                    if(wordText && wordText.trim() !== "") break; // Found a valid word
                }
                attempt++;
            }

            if (!wordText) continue; // Skip if no valid word found after attempts

            selectedWordIds.add(randomMetaEntry.word_id);

            const selectedTranslationLang = document.getElementById('translation-select').value; // urdu, english, Bangali
            let correctAnswerText;
            let fontPreference;

            if (selectedTranslationLang === 'urdu' && translationEntry.ur_meaning) {
                correctAnswerText = translationEntry.ur_meaning;
                fontPreference = 'var(--font-urdu)';
            } else if (selectedTranslationLang === 'english' && translationEntry.en_meaning) {
                correctAnswerText = translationEntry.en_meaning;
                fontPreference = 'var(--font-english)';
            } else if (selectedTranslationLang === 'Bangali' && translationEntry.bn_meaning) { // Assuming you add bn_meaning to data5
                correctAnswerText = translationEntry.bn_meaning || (translationMap.get(randomMetaEntry.word_id).en_meaning || "No Bengali Translation"); // Fallback
                fontPreference = 'var(--font-Bangali)';
            } else { // Fallback to English or whatever is available
                correctAnswerText = translationEntry.en_meaning || translationEntry.ur_meaning || "Meaning N/A";
                fontPreference = 'var(--font-english)';
            }

            if (correctAnswerText === "Meaning N/A" || correctAnswerText.trim() === "") continue; // Skip if no good answer

            const options = [correctAnswerText];
            // Get 3 distractor options
            let distractorCount = 0;
            while (distractorCount < 3 && options.length < allWordTranslations.length) {
                const randomDistractorTrans = allWordTranslations[Math.floor(Math.random() * allWordTranslations.length)];
                let distractorText;
                 if (selectedTranslationLang === 'urdu' && randomDistractorTrans.ur_meaning) {
                    distractorText = randomDistractorTrans.ur_meaning;
                } else if (selectedTranslationLang === 'english' && randomDistractorTrans.en_meaning) {
                    distractorText = randomDistractorTrans.en_meaning;
                } else if (selectedTranslationLang === 'Bangali' && randomDistractorTrans.bn_meaning) {
                    distractorText = randomDistractorTrans.bn_meaning || randomDistractorTrans.en_meaning;
                } else {
                    distractorText = randomDistractorTrans.en_meaning || randomDistractorTrans.ur_meaning;
                }

                if (distractorText && distractorText.trim() !== "" && !options.includes(distractorText) && distractorText !== correctAnswerText) {
                    options.push(distractorText);
                    distractorCount++;
                }
            }
            shuffleArray(options); // Randomize options order

            wordWhizQuestions.push({
                word_id: randomMetaEntry.word_id,
                arabicWord: wordText,
                options: options,
                correctAnswer: correctAnswerText,
                fontPreference: fontPreference,
                translationLangDir: selectedTranslationLang === 'urdu' ? 'rtl' : 'ltr'
            });
        }

        if (wordWhizQuestions.length === 0) {
             document.getElementById('gamePlayArea').innerHTML = '<p>Could not generate questions. Try again or check data.</p>';
             return;
        }
        currentWordWhizQuestionIndex = 0;
        displayWordWhizQuestion();

    } catch (error) {
        console.error("Error starting WordWhiz game:", error);
        document.getElementById('gamePlayArea').innerHTML = `<p>Error loading game: ${error.message}</p>`;
    }
}

function displayWordWhizQuestion() {
    if (currentWordWhizQuestionIndex >= wordWhizQuestions.length) {
        endWordWhizGame();
        return;
    }
    const q = wordWhizQuestions[currentWordWhizQuestionIndex];
    let optionsHTML = '<ul class="game-options-list">';
    q.options.forEach(option => {
        optionsHTML += `<li><button data-answer="${option}" style="font-family: ${q.fontPreference}; direction: ${q.translationLangDir}; text-align: ${q.translationLangDir === 'rtl' ? 'right' : 'left'};">${option}</button></li>`;
    });
    optionsHTML += '</ul>';

    const gamePlayArea = document.getElementById('gamePlayArea');
    gamePlayArea.innerHTML = `
        <p>What is the meaning of this word(in Quran)?</p>
        <div class="game-question-arabic">${q.arabicWord}</div>
        ${optionsHTML}
        <div class="game-feedback" id="wordWhizFeedback"></div>
        <button id="nextWordWhizQuestion" style="display:none; margin-top: 10px;">Next Question</button>
    `;

    gamePlayArea.querySelectorAll('.game-options-list button').forEach(button => {
        button.addEventListener('click', handleWordWhizAnswer);
    });
    document.getElementById('nextWordWhizQuestion').addEventListener('click', () => {
        currentWordWhizQuestionIndex++;
        displayWordWhizQuestion();
    });
}

function handleWordWhizAnswer(event) {
    const selectedButton = event.target;
    const selectedAnswer = selectedButton.dataset.answer;
    const q = wordWhizQuestions[currentWordWhizQuestionIndex];
    const feedbackEl = document.getElementById('wordWhizFeedback');
    const nextButton = document.getElementById('nextWordWhizQuestion');

    document.querySelectorAll('.game-options-list button').forEach(btn => {
        btn.disabled = true; // Disable all options
        if (btn.dataset.answer === q.correctAnswer) {
            btn.classList.add('correct');
        }
    });

    if (selectedAnswer === q.correctAnswer) {
        feedbackEl.textContent = "Correct!";
        feedbackEl.style.color = 'var(--color-success)';
        gameScore += 10;
        if (gameScore > gameHighScore) gameHighScore = gameScore;
        updateScoreDisplay();
    } else {
        feedbackEl.textContent = `Incorrect. The correct answer is: ${q.correctAnswer}`;
        feedbackEl.style.color = 'var(--color-error)';
        selectedButton.classList.add('incorrect'); // Mark the specific wrong choice
    }
    nextButton.style.display = 'inline-block';
}

function endWordWhizGame() {
    document.getElementById('gamePlayArea').innerHTML = `
        <h3>Game Over!</h3>
        <p>Your final score: ${gameScore}</p>
        <button id="playWordWhizAgain">Play Again</button>
    `;
    document.getElementById('playWordWhizAgain').addEventListener('click', startWordWhizGame);
    activeGame = null;
}

// --- AYAH JUMBLE GAME ---
let jumbledWords = [];
let correctOrderWords = [];
let draggedItem = null;

async function startAyahJumbleGame() {
    activeGame = 'ayahJumble';
    gameScore = 0; // Reset score for this game type
    updateScoreDisplay();
    showGamePlayUI("Ayah Jumble Challenge");
    document.getElementById('gamePlayArea').innerHTML = '<p>Loading Ayah...</p>';

    try {
        let randomAyahData, words;
        let attempts = 0;
        const MAX_ATTEMPTS = 20;
        const MIN_WORDS = 4;
        const MAX_WORDS = 10; // Keep ayahs relatively short for jumbling

        while(attempts < MAX_ATTEMPTS) {
            const randomSurah = Math.floor(Math.random() * 114) + 1;
            const randomAyahNum = Math.floor(Math.random() * surahAyahCounts[randomSurah]) + 1;
            randomAyahData = await getData(STORE_QURAN, [randomSurah, randomAyahNum]);

            if (randomAyahData && randomAyahData.arabic) {
                words = randomAyahData.arabic.trim().split(/\s+/).filter(w => w.length > 0);
                if (words.length >= MIN_WORDS && words.length <= MAX_WORDS) {
                    break; // Found a suitable Ayah
                }
            }
            attempts++;
        }

        if (!words || words.length < MIN_WORDS) {
            document.getElementById('gamePlayArea').innerHTML = '<p>Could not find a suitable Ayah for the game. Please try again.</p>';
            return;
        }

        correctOrderWords = [...words]; // Store the correct order
        jumbledWords = shuffleArray([...words]); // Shuffle a copy for display

        ayahJumbleQuestion = {
            originalAyah: randomAyahData.arabic,
            words: words,
            surah: randomAyahData.surah,
            ayah: randomAyahData.ayah
        };

        displayAyahJumbleQuestion();

    } catch (error) {
        console.error("Error starting AyahJumble game:", error);
        document.getElementById('gamePlayArea').innerHTML = `<p>Error loading game: ${error.message}</p>`;
    }
}

function displayAyahJumbleQuestion() {
    const gamePlayArea = document.getElementById('gamePlayArea');
    let jumbledWordsHTML = '';
    // jumbledWords is already shuffled and contains the words for the source container
    jumbledWords.forEach((word, index) => {
        // We need a unique identifier for each original word if not already present.
        // The index in the *original* `correctOrderWords` array is a good candidate.
        // Let's assume jumbledWords items are just strings. We need to find their original index.
        // This part is tricky if jumbledWords doesn't preserve original identity/index.
        // For simplicity, let's assume `jumbledWords` was created from `correctOrderWords`
        // and we can map them back or ensure `data-index` refers to original shuffled position.
        // The current `jumbledWords.forEach((word, index)` uses the shuffled index.
        // Let's use data-word attribute to store the word itself for re-sorting later if needed.
        jumbledWordsHTML += `<div class="jumble-word" draggable="true" data-index="${index}" data-word="${word}">${word}</div>`;
    });

    gamePlayArea.innerHTML = `
        <p>Arrange the words to form the correct Ayah (Drag or Click):</p>
        <div id="jumbleSourceContainer" class="jumble-word-container">
            ${jumbledWordsHTML}
        </div>
        <p style="margin-top: 20px;">Your arrangement:</p>
        <div id="jumbleTargetContainer" class="jumble-target-area">
            <!-- Dropped/Clicked words will appear here -->
        </div>
        <button id="jumbleSubmitAnswer">Check Answer</button>
        <button id="jumbleResetArrangement" style="margin-left:10px;">Reset</button>
        <div class="game-feedback" id="ayahJumbleFeedback"></div>
        <button id="nextAyahJumbleQuestion" style="display:none; margin-top: 10px;">Next Ayah</button>
    `;

    addJumbleDragDropListeners(); // Sets up drag/drop
    
    // Add click listener using event delegation on a common parent
    const jumbleArea = gamePlayArea; // Or a more specific parent of both containers
    jumbleArea.removeEventListener('click', handleJumbleWordClick); // Remove old if any
    jumbleArea.addEventListener('click', handleJumbleWordClick);


    document.getElementById('jumbleSubmitAnswer').addEventListener('click', handleAyahJumbleSubmit);
    document.getElementById('jumbleResetArrangement').addEventListener('click', resetJumbleArrangement);
    document.getElementById('nextAyahJumbleQuestion').addEventListener('click', () => startAyahJumbleGame());
}

// Ensure draggedItem is declared in a scope accessible by these functions
// let draggedItem = null; // (already declared globally in your original script)

// Your addJumbleDragDropListeners function structure:
function addJumbleDragDropListeners() {
    const sourceContainer = document.getElementById('jumbleSourceContainer');
    const targetContainer = document.getElementById('jumbleTargetContainer');
    
    // It's better to use event delegation for draggables if words are frequently added/removed
    // from these containers. However, if addJumbleDragDropListeners is called reliably
    // *after* the HTML for words is (re)generated, direct listeners are okay.
    // For simplicity, let's assume direct listeners are being re-added correctly when needed.
    
    const attachListenersToWords = (containerSelector) => {
        document.querySelectorAll(`${containerSelector} .jumble-word`).forEach(draggable => {
            // To prevent multiple listeners if this function is called multiple times on same elements,
            // you'd ideally remove old ones or use a flag.
            // For this example, assuming fresh elements or controlled calls.
            draggable.removeEventListener('dragstart', dragStartHandler); // Example of removing first
            draggable.addEventListener('dragstart', dragStartHandler);
            
            draggable.removeEventListener('dragend', dragEndHandler);
            draggable.addEventListener('dragend', dragEndHandler);
        });
    };

    const dragStartHandler = (e) => {
        draggedItem = e.target;
        setTimeout(() => draggedItem.classList.add('dragging'), 0);
    };
    const dragEndHandler = () => {
        if (draggedItem) {
            draggedItem.classList.remove('dragging');
        }
        draggedItem = null;
    };

    attachListenersToWords('#jumbleSourceContainer');
    attachListenersToWords('#jumbleTargetContainer'); // If you want to drag within target too

    [sourceContainer, targetContainer].forEach(container => {
        // Remove old listeners before adding new ones to prevent duplicates
        container.removeEventListener('dragover', dragOverHandler);
        container.addEventListener('dragover', dragOverHandler);

        container.removeEventListener('drop', dropHandler);
        container.addEventListener('drop', dropHandler);
    });
}

const dragOverHandler = (e) => {
    e.preventDefault(); // Allow drop
};

const dropHandler = (e) => {
    e.preventDefault();
    const targetDropContainer = e.target.closest('.jumble-word-container, .jumble-target-area');
    if (draggedItem && targetDropContainer) { // Ensure draggedItem exists and drop is on a valid container
        const afterElement = getDragAfterElement(targetDropContainer, e.clientY, e.clientX);
        if (afterElement == null) {
            targetDropContainer.appendChild(draggedItem);
        } else {
            targetDropContainer.insertBefore(draggedItem, afterElement);
        }
        // draggedItem's 'dragging' class is removed in dragEndHandler
        // No need to nullify draggedItem here, dragEndHandler does it.

        // If word moved to target, it might become non-draggable from source perspective
        // If word moved to source, it should be draggable again.
        // This logic can get complex; click-to-move simplifies some of this.
        // For now, draggability is just on the element itself.
        const feedbackEl = document.getElementById('ayahJumbleFeedback');
        const submitButton = document.getElementById('jumbleSubmitAnswer');
        if (feedbackEl) feedbackEl.textContent = '';
        if (submitButton) submitButton.disabled = false;

    }
}



function handleJumbleWordClick(event) {
    const clickedWord = event.target.closest('.jumble-word');
    if (!clickedWord) return;

    const sourceContainer = document.getElementById('jumbleSourceContainer');
    const targetContainer = document.getElementById('jumbleTargetContainer');
    const feedbackEl = document.getElementById('ayahJumbleFeedback');
    const submitButton = document.getElementById('jumbleSubmitAnswer');


    if (clickedWord.parentNode === sourceContainer) {
        // Move from source to target
        targetContainer.appendChild(clickedWord);
    } else if (clickedWord.parentNode === targetContainer) {
        // Move from target back to source
        sourceContainer.appendChild(clickedWord); // Temporarily append
        
        // Re-sort words in source container based on their original data-index
        const wordsInSource = [...sourceContainer.children];
        wordsInSource.sort((a, b) => parseInt(a.dataset.index) - parseInt(b.dataset.index));
        wordsInSource.forEach(word => sourceContainer.appendChild(word)); // Re-append in sorted order
    }
    
    // Clear feedback and enable submit if it was disabled
    if (feedbackEl) feedbackEl.textContent = '';
    if (submitButton) submitButton.disabled = false;

    // Words in target should not be draggable if moved by click,
    // but if we allow dragging within target, this needs to be rethought.
    // For now, click just moves it. Drag listeners handle draggability.
}


// Replace your existing getDragAfterElement function with this one:
// Replace your existing getDragAfterElement function with this one:
function getDragAfterElement(container, y, x) {
    const draggableElements = [...container.querySelectorAll('.jumble-word:not(.dragging)')];
    const containerDir = getComputedStyle(container).direction;

    for (const child of draggableElements) {
        const box = child.getBoundingClientRect();
        const childMidY = box.top + box.height / 2;
        const childMidX = box.left + box.width / 2; // Horizontal midpoint of the child element

        // Check if the drop point y is roughly on the same line as the child
        if (Math.abs(y - childMidY) < box.height) { // Is drop y-coordinate within the vertical span of the child?
            if (containerDir === 'rtl') {
                // For RTL:
                // If cursor's x-coordinate is to the RIGHT of the child's midpoint (larger x value),
                // it means the dragged item should come BEFORE this child in the visual flow (further to the right).
                if (x > childMidX) { // << REVERSED THIS COMPARISON for RTL
                    // console.log(`RTL (Reversed Logic): Drop X (${x.toFixed(0)}) is Right of Child "${child.textContent}" MidX (${childMidX.toFixed(0)}). Insert before.`);
                    return child;
                }
            } else { // LTR
                // For LTR:
                // If cursor's x-coordinate is to the LEFT of the child's midpoint (smaller x value),
                // it means the dragged item should come BEFORE this child in the visual flow.
                if (x < childMidX) {
                    // console.log(`LTR: Drop X (${x.toFixed(0)}) is Left of Child "${child.textContent}" MidX (${childMidX.toFixed(0)}). Insert before.`);
                    return child;
                }
            }
        } else if (y < childMidY) {
            // If drop point is clearly on a line above the current child's line,
            // then this child is the correct one to insert before.
            // console.log(`Drop Y (${y.toFixed(0)}) is Above Child "${child.textContent}" MidY (${childMidY.toFixed(0)}). Insert before.`);
            return child;
        }
        // If drop point y is below the child's line, or on the same line but to the "logical end" side of it,
        // continue to check the next child.
    }

    // console.log("No specific element to insert before. Appending.");
    return null; // If no element is found to insert before, append to the end of the container.
}





function resetJumbleArrangement() {
    const targetContainer = document.getElementById('jumbleTargetContainer');
    const sourceContainer = document.getElementById('jumbleSourceContainer');
    
    // Move all words from target back to source
    [...targetContainer.children].forEach(child => sourceContainer.appendChild(child));

    // Re-sort ALL words now in source container based on their initial `data-index` from the shuffle
    const wordsInSource = [...sourceContainer.children];
    wordsInSource.sort((a, b) => parseInt(a.dataset.index) - parseInt(b.dataset.index));
    wordsInSource.forEach(word => sourceContainer.appendChild(word)); // Re-append in sorted order

    if (document.getElementById('ayahJumbleFeedback')) {
        document.getElementById('ayahJumbleFeedback').textContent = '';
    }
    const submitButton = document.getElementById('jumbleSubmitAnswer');
    if (submitButton) {
        submitButton.disabled = false;
    }
    const nextButton = document.getElementById('nextAyahJumbleQuestion');
    if (nextButton) {
        nextButton.style.display = 'none';
    }
}


function handleAyahJumbleSubmit() {
    const targetContainer = document.getElementById('jumbleTargetContainer');
    const userAnswerWords = [...targetContainer.children].map(el => el.textContent.trim());
    const feedbackEl = document.getElementById('ayahJumbleFeedback');
    const nextButton = document.getElementById('nextAyahJumbleQuestion');
    const submitButton = document.getElementById('jumbleSubmitAnswer');


    if (userAnswerWords.join(' ') === correctOrderWords.join(' ')) {
        feedbackEl.textContent = "Correct! Masha'Allah!";
        feedbackEl.style.color = 'var(--color-success)';
        gameScore += 20; // Jumble might be harder
        if (gameScore > gameHighScore) gameHighScore = gameScore;
        updateScoreDisplay();
        nextButton.style.display = 'inline-block';
        submitButton.disabled = true;
         // Highlight target words green
        [...targetContainer.children].forEach(child => child.style.backgroundColor = 'var(--color-success)');


    } else {
        feedbackEl.textContent = `Not quite. Try again or reset. The correct Ayah is: ${ayahJumbleQuestion.originalAyah}`;
        feedbackEl.style.color = 'var(--color-error)';
        // Optionally show correct order or give hints, for now just this.
        nextButton.style.display = 'none'; // Don't show next if wrong, encourage retry
         // Highlight target words red
        [...targetContainer.children].forEach(child => child.style.backgroundColor = 'var(--color-error)');
        setTimeout(() => { // Reset color after a bit
            [...targetContainer.children].forEach(child => child.style.backgroundColor = '');
        }, 2000);
    }
}


// Helper function
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}



// setTimeout(setupGameModal, 0); // Slight delay to ensure main UI is set up

// Modify your main DOMContentLoaded listener
document.addEventListener('DOMContentLoaded', async () => {
    try {
        await openDB();
        await loadThemePreference();
        setupEventListeners(); // Your existing listeners
        await loadQuranData();
        displayThemesList();
        setupTafsirDocxButton(); // Your existing function for docx
        setTimeout(setupGameModal, 200);
        //setupGameModal(); // ***** ADD THIS LINE HERE *****

    } catch (error) {
        console.error("App initialization failed:", error);
        // Your existing error handling for app init
        const loadingOverlay = document.getElementById('loading-overlay');
        if (loadingOverlay && loadingOverlay.style.display !== 'none') {
            document.getElementById('loading-message-primary').textContent = "Initialization Error";
            document.getElementById('loading-message-secondary').textContent = `Critical error: ${error.message}. Please refresh or clear site data.`;
        } else {
            alert("Failed to initialize: " + error.message + "\nPlease clear website data and refresh. Check console for details.");
        }
    }
});




// === FULLY DYNAMIC FLASHCARD & MEMORY MATCH GAME SUITE ===
// === PASTE THIS ENTIRE BLOCK AT THE END OF YOUR MAIN SCRIPT ===

// --- Shared Global Game Variables (ensure not re-declared if already global) ---
// let activeGame = null;
// let gameScore = 0;
// let gameHighScore = 0; // Assumed to be managed globally by your main game script

// --- Flashcard Game Specific Variables ---
let flashcardQuestions = [];
let currentFlashcardIndex = 0;
let flashcardShowAnswer = false;

// --- Memory Match Game Specific Variables ---
let memoryMatchCardsArray = []; // Renamed to avoid conflict if 'memoryMatchCards' is used elsewhere
let memoryFirstCardFlipped = null; // Renamed
let memorySecondCardFlipped = null; // Renamed
let memoryLockBoardActive = false; // Renamed
let memoryPairsFoundCount = 0; // Renamed
let memoryAttemptCount = 0; // Renamed
let memoryWordPairsForGame = []; // Renamed

// --- CSS Injection Functions ---
function injectFlashcardGameCSS_Suite() {
    const cssId = "flashcardGameStylesSuite"; // Unique ID
    if (document.getElementById(cssId)) return;
    const styles = `
        .flashcard-game-area { display: flex; flex-direction: column; align-items: center; width: 100%; padding: 10px; }
        .flashcard-container { perspective: 1000px; width: 90%; max-width: 320px; min-height: 180px; height: auto; aspect-ratio: 3 / 2; margin: 15px auto; cursor: pointer; }
        .flashcard { width: 100%; height: 100%; position: relative; transform-style: preserve-3d; transition: transform 0.6s; border: 1px solid var(--color-border); border-radius: var(--border-radius); }
        .flashcard.is-flipped { transform: rotateY(180deg); }
        .flashcard-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 15px; text-align: center; border-radius: var(--border-radius); background-color: var(--color-bg-secondary); color: var(--color-text-primary); overflow-wrap: break-word; word-break: break-word; }
        .flashcard-front { font-family: var(--font-arabic); font-size: clamp(1.8rem, 6vw, 2.8rem); direction: rtl; }
        .flashcard-back { transform: rotateY(180deg); font-size: clamp(1rem, 4vw, 1.4rem); }
        .flashcard-controls { margin-top: 15px; text-align: center; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; }
        .flashcard-controls button { min-width: 100px; }
    `;
    const styleSheet = document.createElement("style");
    styleSheet.id = cssId;
    styleSheet.type = "text/css";
    styleSheet.innerText = styles;
    document.head.appendChild(styleSheet);
}

function injectMemoryMatchGameCSS_Suite() {
    const cssId = "memoryMatchGameStylesSuite"; // Unique ID
    if (document.getElementById(cssId)) return;
    const styles = `
        .memory-match-info { text-align: center; margin-bottom: 10px; font-size: 1.1rem; }
        .memory-match-attempts { font-weight: bold; color: var(--color-text-secondary); }
        .memory-match-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 10px; padding: 10px; max-width: 500px; margin: 15px auto; }
        .memory-card { aspect-ratio: 1 / 1; background-color: var(--color-accent); border: 1px solid var(--color-accent-dark); border-radius: var(--border-radius); display: flex; justify-content: center; align-items: center; cursor: pointer; font-size: 1rem; color: white; user-select: none; transform-style: preserve-3d; transition: transform 0.3s, background-color 0.3s; }
        .memory-card .card-content { display: none; text-align: center; overflow-wrap: break-word; word-break: break-word; padding: 5px; }
        .memory-card.arabic-text .card-content { font-family: var(--font-arabic); direction: rtl; font-size: clamp(1.1rem, 3.5vw, 1.6rem); }
        .memory-card.meaning-text .card-content { font-size: clamp(0.7rem, 2.5vw, 1rem); }
        .memory-card.is-flipped .card-content { display: block; }
        .memory-card.is-flipped { background-color: var(--color-bg-secondary); color: var(--color-text-primary); }
        .memory-card.is-matched { background-color: var(--color-success) !important; color: white !important; cursor: default; opacity: 0.8; }
        .memory-card.is-matched .card-content { display: block; }
    `;
    const styleSheet = document.createElement("style");
    styleSheet.id = cssId;
    styleSheet.type = "text/css";
    styleSheet.innerText = styles;
    document.head.appendChild(styleSheet);
}

// --- Flashcard Game Logic ---
async function startFlashcardGame_Suite() {
    activeGame = 'flashcards_suite'; // Unique game ID
    // gameScore = 0; // Reset if managing score per game
    // updateScoreDisplay(); // Your global function
    showGamePlayUI("Flashcard Frenzy"); // Your global function
    injectFlashcardGameCSS_Suite();

    const gamePlayArea = document.getElementById('gamePlayArea');
    if (!gamePlayArea) { console.error("Flashcard: gamePlayArea not found!"); return; }
    gamePlayArea.innerHTML = '<p style="text-align:center; padding:20px;">Loading flashcards...</p>';

    try {
        // Data fetching (same as before, ensure robustness)
        const allWordMetadata = await getAllData(STORE_WORD_METADATA);
        const allWordTranslations = await getAllData(STORE_WORD_TRANSLATIONS);

        if (!allWordMetadata || allWordMetadata.length < 3 || !allWordTranslations || allWordTranslations.length < 3) {
            gamePlayArea.innerHTML = '<p style="text-align:center; padding:20px; color:var(--color-error);">Not enough word data for flashcards.</p>';
            return;
        }

        const translationMap = new Map(allWordTranslations.map(wt => [wt.word_id, wt]));
        flashcardQuestions = [];
        const selectedWordIds = new Set();
        const maxCards = 10;

        for (let i = 0; i < maxCards * 2 && flashcardQuestions.length < maxCards; i++) {
            let attempt = 0;
            let randomMetaEntry, quranAyah, wordText, translationEntry;
            while (attempt < 20) {
                randomMetaEntry = allWordMetadata[Math.floor(Math.random() * allWordMetadata.length)];
                if (selectedWordIds.has(randomMetaEntry.word_id)) { attempt++; continue; }
                translationEntry = translationMap.get(randomMetaEntry.word_id);
                if (!translationEntry || (!translationEntry.en_meaning && !translationEntry.ur_meaning && !translationEntry.bn_meaning)) { attempt++; continue; }
                quranAyah = await getData(STORE_QURAN, [randomMetaEntry.surah, randomMetaEntry.ayah]);
                if (!quranAyah || !quranAyah.arabic) { attempt++; continue; }
                const wordsInAyah = quranAyah.arabic.split(/\s+/);
                if (randomMetaEntry.word_position < wordsInAyah.length) {
                    wordText = wordsInAyah[randomMetaEntry.word_position];
                    if (wordText && wordText.trim() !== "") break;
                }
                attempt++;
            }
            if (!wordText) continue;
            selectedWordIds.add(randomMetaEntry.word_id);

            const selectedTranslationKey = document.getElementById('translation-select').value;
            let meaningText, meaningLangDir = 'ltr', meaningFont = 'var(--font-english)';
            if (selectedTranslationKey === 'urdu' && translationEntry.ur_meaning) {
                meaningText = translationEntry.ur_meaning; meaningLangDir = 'rtl'; meaningFont = 'var(--font-urdu)';
            } else if (selectedTranslationKey === 'english' && translationEntry.en_meaning) {
                meaningText = translationEntry.en_meaning;
            } else if (selectedTranslationKey === 'Bangali' && translationEntry.bn_meaning) {
                meaningText = translationEntry.bn_meaning; meaningFont = 'var(--font-Bangali)';
            } else {
                meaningText = translationEntry.en_meaning || translationEntry.ur_meaning || translationEntry.bn_meaning;
                if (translationEntry.en_meaning) {} 
                else if (translationEntry.ur_meaning) { meaningLangDir = 'rtl'; meaningFont = 'var(--font-urdu)';}
                else if (translationEntry.bn_meaning) { meaningFont = 'var(--font-Bangali)';}
            }
            if (!meaningText || meaningText.trim() === "" || meaningText.trim().toLowerCase() === "n/a") {
                selectedWordIds.delete(randomMetaEntry.word_id); continue;
            }
            flashcardQuestions.push({ arabicWord: wordText, meaning: meaningText, meaningLangDir, meaningFont });
        }
        
        if (flashcardQuestions.length === 0) {
             gamePlayArea.innerHTML = '<p style="text-align:center; padding:20px; color:var(--color-error);">Could not generate any flashcards.</p>';
             return;
        }
        currentFlashcardIndex = 0;
        displayFlashcard_Suite();
    } catch (error) {
        console.error("Error starting Flashcard game (Suite):", error);
        gamePlayArea.innerHTML = `<p style="text-align:center; padding:20px; color:var(--color-error);">Error loading game: ${error.message}.</p>`;
    }
}

function displayFlashcard_Suite() {
    if (currentFlashcardIndex >= flashcardQuestions.length) {
        endFlashcardGame_Suite();
        return;
    }
    flashcardShowAnswer = false;
    const cardData = flashcardQuestions[currentFlashcardIndex];
    const gamePlayArea = document.getElementById('gamePlayArea');
    gamePlayArea.innerHTML = '';

    const gameAreaWrapper = document.createElement('div'); // Wrapper for content
    gameAreaWrapper.className = 'flashcard-game-area';

    const container = document.createElement('div');
    container.className = 'flashcard-container';
    const card = document.createElement('div');
    card.className = 'flashcard';
    const frontFace = document.createElement('div');
    frontFace.className = 'flashcard-face flashcard-front';
    frontFace.textContent = cardData.arabicWord;
    const backFace = document.createElement('div');
    backFace.className = 'flashcard-face flashcard-back';
    backFace.textContent = cardData.meaning;
    backFace.style.fontFamily = cardData.meaningFont;
    backFace.style.direction = cardData.meaningLangDir;
    backFace.style.textAlign = cardData.meaningLangDir === 'rtl' ? 'right' : 'left';
    card.append(frontFace, backFace);
    container.appendChild(card);
    gameAreaWrapper.appendChild(container);

    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'flashcard-controls';
    const flipButton = document.createElement('button');
    flipButton.textContent = 'Flip Card';
    const gotItButton = document.createElement('button');
    gotItButton.textContent = 'Got it!';
    gotItButton.style.display = 'none';
    const notYetButton = document.createElement('button');
    notYetButton.textContent = 'Not Yet';
    notYetButton.style.display = 'none';
    controlsDiv.append(flipButton, gotItButton, notYetButton);
    gameAreaWrapper.appendChild(controlsDiv);
    gamePlayArea.appendChild(gameAreaWrapper);

    container.addEventListener('click', () => toggleFlashcardFlip_Suite(card, gotItButton, notYetButton, flipButton));
    flipButton.addEventListener('click', () => toggleFlashcardFlip_Suite(card, gotItButton, notYetButton, flipButton));
    gotItButton.addEventListener('click', () => handleFlashcardResponse_Suite(true));
    notYetButton.addEventListener('click', () => handleFlashcardResponse_Suite(false));
}

function toggleFlashcardFlip_Suite(cardEl, gotItBtn, notYetBtn, flipBtn) {
    cardEl.classList.toggle('is-flipped');
    flashcardShowAnswer = cardEl.classList.contains('is-flipped');
    gotItBtn.style.display = flashcardShowAnswer ? 'inline-block' : 'none';
    notYetBtn.style.display = flashcardShowAnswer ? 'inline-block' : 'none';
    flipBtn.textContent = flashcardShowAnswer ? 'Show Question' : 'Flip Card';
}

function handleFlashcardResponse_Suite(knewIt) {
    if (knewIt) {
        // gameScore += 5; // If scoring
    } else {
        const currentCardData = flashcardQuestions[currentFlashcardIndex]; // Get before incrementing
        flashcardQuestions.push(currentCardData); // Re-add to end
    }
    // updateScoreDisplay();
    currentFlashcardIndex++;
    displayFlashcard_Suite();
}

function endFlashcardGame_Suite() {
    const gamePlayArea = document.getElementById('gamePlayArea');
    if (!gamePlayArea) return;

    const originalFlashcardSet = flashcardQuestions.slice(0, currentFlashcardIndex);
    const uniqueWordsForMemory = [];
    const seenArabicWords = new Set();
    for (const card of originalFlashcardSet) {
        if (!seenArabicWords.has(card.arabicWord) && uniqueWordsForMemory.length < 6) { // Max 6 pairs for memory game
            uniqueWordsForMemory.push(card);
            seenArabicWords.add(card.arabicWord);
        }
        if (uniqueWordsForMemory.length >= 6) break;
    }
    
    const canPlayMemory = uniqueWordsForMemory.length >= 2;
    let memoryBtnHTML = canPlayMemory ? `<button id="startMemoryMatchGameBtn_Suite">Test Your Memory!</button>` : `<p style="font-size:0.9em; margin-top:10px;">(Not enough unique cards seen for a memory game.)</p>`;

    gamePlayArea.innerHTML = `
        <div style="text-align:center; padding: 20px;">
            <h3>Flashcard Session Over!</h3>
            <p style="font-size:0.9em;">(Cards marked "Not Yet" are re-added to the end for more practice in the next flashcard round.)</p>
            <div style="margin-top: 20px; display:flex; flex-direction:column; align-items:center; gap:10px;">
                <button id="playFlashcardsAgain_Suite">Practice Flashcards Again</button>
                ${memoryBtnHTML}
            </div>
        </div>
    `;

    const playAgainFCBtn = document.getElementById('playFlashcardsAgain_Suite');
    if (playAgainFCBtn) playAgainFCBtn.addEventListener('click', startFlashcardGame_Suite);

    if (canPlayMemory) {
        const startMemoryBtn = document.getElementById('startMemoryMatchGameBtn_Suite');
        if (startMemoryBtn) startMemoryBtn.addEventListener('click', () => startMemoryMatchGame_Suite(uniqueWordsForMemory));
    }
    activeGame = null;
}


// --- Memory Match Game Logic ---
async function startMemoryMatchGame_Suite(wordDataForGame) {
    activeGame = 'memoryMatch_suite';
    showGamePlayUI("Memory Match Challenge");
    injectMemoryMatchGameCSS_Suite();

    const gamePlayArea = document.getElementById('gamePlayArea');
    if (!gamePlayArea) { console.error("Memory Match: gamePlayArea not found!"); return; }
    gamePlayArea.innerHTML = '<p style="text-align:center; padding:20px;">Setting up the memory board...</p>';

    memoryWordPairsForGame = [...wordDataForGame];
    memoryMatchCardsArray = [];
    memoryPairsFoundCount = 0;
    memoryAttemptCount = 0;
    memoryLockBoardActive = false;
    memoryFirstCardFlipped = null;
    memorySecondCardFlipped = null;


    memoryWordPairsForGame.forEach((pair, index) => {
        memoryMatchCardsArray.push({ id: `arabic-${index}`, type: 'arabic', content: pair.arabicWord, pairId: index, isFlipped: false, isMatched: false });
        memoryMatchCardsArray.push({ id: `meaning-${index}`, type: 'meaning', content: pair.meaning, pairId: index, font: pair.meaningFont, dir: pair.meaningLangDir, isFlipped: false, isMatched: false });
    });

    shuffleArray(memoryMatchCardsArray); // Your global shuffle function
    renderMemoryBoard_Suite();
    updateMemoryGameInfo_Suite();
}

function renderMemoryBoard_Suite() {
    const gamePlayArea = document.getElementById('gamePlayArea');
    gamePlayArea.innerHTML = '';

    const infoDiv = document.createElement('div');
    infoDiv.className = 'memory-match-info';
    infoDiv.innerHTML = `Pairs Found: <span id="memoryPairsFoundEl_Suite">0</span>/${memoryWordPairsForGame.length} | Attempts: <span id="memoryAttemptsEl_Suite" class="memory-match-attempts">0</span>`;
    gamePlayArea.appendChild(infoDiv);

    const grid = document.createElement('div');
    grid.className = 'memory-match-grid';
    const numCards = memoryMatchCardsArray.length;
    let columns = (numCards <= 6) ? 3 : (numCards <= 8) ? 4 : (numCards <= 12) ? 4 : 4;
    grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;

    memoryMatchCardsArray.forEach(cardData => {
        const cardElement = document.createElement('div');
        cardElement.className = 'memory-card';
        cardElement.dataset.id = cardData.id;
        const contentSpan = document.createElement('span');
        contentSpan.className = 'card-content';
        contentSpan.textContent = cardData.content;
        if (cardData.type === 'arabic') cardElement.classList.add('arabic-text');
        else {
            cardElement.classList.add('meaning-text');
            contentSpan.style.fontFamily = cardData.font;
            contentSpan.style.direction = cardData.dir;
            contentSpan.style.textAlign = cardData.dir === 'rtl' ? 'right' : 'left';
        }
        cardElement.appendChild(contentSpan);
        if (cardData.isFlipped) cardElement.classList.add('is-flipped');
        if (cardData.isMatched) cardElement.classList.add('is-matched', 'is-flipped');
        cardElement.addEventListener('click', () => handleMemoryCardClick_Suite(cardElement, cardData));
        grid.appendChild(cardElement);
    });
    gamePlayArea.appendChild(grid);
}

function handleMemoryCardClick_Suite(cardEl, cardData) {
    if (memoryLockBoardActive || cardData.isFlipped || cardData.isMatched) return;
    cardData.isFlipped = true;
    cardEl.classList.add('is-flipped');

    if (!memoryFirstCardFlipped) {
        memoryFirstCardFlipped = cardData;
        return;
    }
    memorySecondCardFlipped = cardData;
    memoryLockBoardActive = true;
    memoryAttemptCount++;
    updateMemoryGameInfo_Suite();
    checkForMemoryMatch_Suite();
}

function checkForMemoryMatch_Suite() {
    const isMatch = memoryFirstCardFlipped.pairId === memorySecondCardFlipped.pairId;
    if (isMatch) {
        memoryFirstCardFlipped.isMatched = true;
        memorySecondCardFlipped.isMatched = true;
        memoryPairsFoundCount++;
        updateMemoryGameInfo_Suite();
        document.querySelector(`.memory-card[data-id="${memoryFirstCardFlipped.id}"]`)?.classList.add('is-matched');
        document.querySelector(`.memory-card[data-id="${memorySecondCardFlipped.id}"]`)?.classList.add('is-matched');
        resetMemoryTurn_Suite();
        if (memoryPairsFoundCount === memoryWordPairsForGame.length) {
            setTimeout(endMemoryMatchGame_Suite, 600);
        }
    } else {
        setTimeout(() => {
            if(memoryFirstCardFlipped) memoryFirstCardFlipped.isFlipped = false; // Check if nullified by rapid clicks
            if(memorySecondCardFlipped) memorySecondCardFlipped.isFlipped = false;
            document.querySelector(`.memory-card[data-id="${memoryFirstCardFlipped?.id}"]`)?.classList.remove('is-flipped');
            document.querySelector(`.memory-card[data-id="${memorySecondCardFlipped?.id}"]`)?.classList.remove('is-flipped');
            resetMemoryTurn_Suite();
        }, 1200);
    }
}

function resetMemoryTurn_Suite() {
    memoryFirstCardFlipped = null;
    memorySecondCardFlipped = null;
    memoryLockBoardActive = false;
}

function updateMemoryGameInfo_Suite() {
    const pairsEl = document.getElementById('memoryPairsFoundEl_Suite');
    const attemptsEl = document.getElementById('memoryAttemptsEl_Suite');
    if (pairsEl) pairsEl.textContent = memoryPairsFoundCount;
    if (attemptsEl) attemptsEl.textContent = memoryAttemptCount;
}

function endMemoryMatchGame_Suite() {
    const gamePlayArea = document.getElementById('gamePlayArea');
    if (!gamePlayArea) return;
    gamePlayArea.innerHTML = `
        <div style="text-align:center; padding: 20px;">
            <h3>Memory Game Cleared!</h3>
            <p>You found all ${memoryPairsFoundCount} pairs in ${memoryAttemptCount} attempts!</p>
            <div style="margin-top:15px; display:flex; justify-content:center; gap:10px;">
                <button id="playMemoryMatchAgainBtn_Suite">Play Memory Again</button>
                <button id="backToGameSelectionBtn_Suite">Game Selection</button>
            </div>
        </div>
    `;
    const playAgainMMBtn = document.getElementById('playMemoryMatchAgainBtn_Suite');
    if (playAgainMMBtn) playAgainMMBtn.addEventListener('click', () => startMemoryMatchGame_Suite(memoryWordPairsForGame)); // Restart with same words
    
    const backBtn = document.getElementById('backToGameSelectionBtn_Suite');
    if (backBtn) backBtn.addEventListener('click', () => { activeGame = null; resetGameUI(); });
    activeGame = null;
}

// --- Function to Add the Initial Flashcard Game Button to the Modal ---
function addFlashcardSuiteButtonToModal() {
    const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
    const buttonId = 'startGameFlashcardSuiteBtn';

    if (gameSelectionArea && !document.getElementById(buttonId)) {
        const suiteButton = document.createElement('button');
        suiteButton.id = buttonId;
        suiteButton.className = 'game-select-btn';
        suiteButton.textContent = 'Flashcard & Memory'; // Combined name
        suiteButton.addEventListener('click', startFlashcardGame_Suite);
        
        const existingButtons = gameSelectionArea.querySelectorAll('.game-select-btn');
        if (existingButtons.length > 0) {
            existingButtons[existingButtons.length - 1].insertAdjacentElement('afterend', suiteButton);
        } else {
            gameSelectionArea.appendChild(suiteButton);
        }
    }
}










// === ENHANCED FULL-SCREEN TAJ QURAN READER - DYNAMIC JS ===
// === PASTE AND REPLACE PREVIOUS READER CODE - KEEP OTHER GAME CODE SEPARATE ===

// --- Reader State & Configuration Variables ---
let isFullScreenReaderActive = false;
let fullScreenReaderCurrentPage = 1; // For 15-line Taj Company style pages
let fullScreenReaderCurrentSurah = 1;
let fullScreenReaderCurrentAyah = 1;
let fullScreenReaderViewMode = 'paged'; // 'paged' or 'continuous-scroll'
let fullScreenReaderAudioPlayer = null;
let fullScreenReaderAudioQueue = []; // For continuous play
let fullScreenReaderIsPlayingAudio = false;
let fullScreenReaderContinuousAudioMode = false; // New setting
let fullScreenReaderSettings = {
    arabicFont: 'Scheherazade New',
    fontSize: '2.5rem', // Base size, applied to a container
    linesPerPage: 15, // For paged view estimation
    showTransliteration: false,
    autoScrollAudio: true, // For highlighting and view adjustment
    highlightColor: 'rgba(255, 255, 150, 0.4)', // Lighter yellow
    continuousAudio: false // New: User setting for continuous play
};
const TAJ_COMPANY_PAGES = 604;
let tajMushafPageData = []; // Populated by loadTajMushafPageData()

// For continuous scroll
let continuousScrollNextSurahToLoad = 1;
let continuousScrollNextAyahToLoad = 1;
const CONTINUOUS_SCROLL_LOAD_COUNT = 60; // Ayahs to load at a time
let isLoadingMoreAyahs = false;
let continuousScrollSurahContainer = null; // The main div holding all surah content

// --- CSS Injection for Full-Screen Reader (Revised) ---
function injectEnhancedFullScreenReaderCSS() {
    const cssId = "enhancedFullScreenReaderStyles";
    if (document.getElementById(cssId)) return;

    const styles = `
        #fullScreenReaderOverlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: var(--color-bg-primary, #f0f0f0); /* Lighter bg for reader */
            z-index: 10000; display: flex; flex-direction: column; overflow: hidden;
            font-family: var(--font-arabic);
        }
        #fsReaderHeader, #fsReaderFooter {
            padding: 8px 12px; background-color: var(--color-bg-secondary, #e0e0e0);
            border-bottom: 1px solid var(--color-border, #ccc); flex-shrink: 0;
            display: flex; justify-content: space-between; align-items: center;
        }
        #fsReaderFooter { border-top: 1px solid var(--color-border, #ccc); border-bottom: none; }
        #fsReaderHeader .title-page-container { text-align: center; flex-grow: 1; }
        #fsReaderHeader .title { font-size: 1.1rem; font-weight: bold; color: var(--color-text-primary); }
        #fsReaderHeader .page-info { font-size: 0.9rem; color: var(--color-text-secondary); }
        
        #fsReaderContent {
            flex-grow: 1; overflow-y: auto; overflow-x: hidden; padding: 5px;
            display: flex; flex-direction: column; align-items: center; /* Centers paged view */
        }
        /* Paged View Page */
        .fsReaderPage {
            background-color: #fff; border: 1px solid #ddd; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 15px 20px; margin-bottom: 15px; width: 96%; /* max-width: 750px; */ direction: rtl;
        }
        /* Continuous Scroll Container & Surah Blocks */
        #continuousScrollSurahContainer { width: 96%; /* Centered */ margin: 0 auto; }
        .continuousSurahBlock {
            padding: 10px 15px; margin-bottom: 20px; direction: rtl;
            border-bottom: 2px solid var(--color-accent, #4caf50); /* Separator */
        }
        .continuousSurahBlock h2.surahNameHeader { /* For Surah Name in Continuous */
            text-align: center; font-size: 1.8em; /* Relative to parent font-size */
            color: var(--color-accent-dark, #388e3c); margin-bottom: 0.8em;
            padding: 5px; border-bottom: 1px solid var(--color-border);
        }
        .bismillahText {
            text-align: center; font-size: 1.5em; /* Relative */ margin: 1em 0;
            font-family: 'KFGQPC Uthman Taha Naskh', var(--font-arabic); /* Often specific font for Bismillah */
        }

        /* Ayah Styling (common for both views) */
        .fsReaderAyah {
            display: inline; margin-right: 0.1em; line-height: 2.3; /* Increased line-height */
            transition: background-color 0.2s; cursor: pointer; /* Click to play Ayah */
        }
        .fsReaderAyahNumber {
            font-size: 0.65em; color: var(--color-accent-dark, #388e3c);
            padding: 0px 0.25em; margin: 0 0.15em;
            border: 1px solid var(--color-accent, #4caf50); border-radius: 50%;
            display: inline-block; line-height: 1.2; vertical-align: middle;
        }
        .fsReaderTransliteration {
            display: block; font-size: 0.7em; color: #666;
            font-family: var(--font-english); direction: ltr; text-align: right;
            margin-top: -1em; margin-bottom: 0.6em; padding-right: 2em; /* Indent under Arabic */
        }
        .highlighted-ayah { border-radius: 3px; } /* Background set by JS */

        #fsReaderFooter button, #fsReaderHeader button { font-size: 1.4rem; padding: 6px 8px; }
        #fsReaderScrubSlider { flex-grow:1; margin:0 10px; accent-color: var(--color-accent); }

        /* Panels (Settings & Index) */
        .fsReaderSlidingPanel {
            position: absolute; top: 33px; /* Below header */
            width: 320px; max-width: 90%; background-color: var(--color-bg-primary);
            border: 1px solid var(--color-border); box-shadow: 0 3px 10px rgba(0,0,0,0.15);
            padding: 15px; z-index: 10001; display: none;
            color: var(--color-text-primary); overflow-y:auto;
        }
        #fsReaderSettingsPanel { right: 0; border-radius: 0 0 0 var(--border-radius); }
        #fsReaderIndexPanel { left: 0; border-radius: 0 0 var(--border-radius) 0; }
        
        .fsReaderSlidingPanel h4 { margin-top: 0; margin-bottom:12px; color: var(--color-text-secondary); border-bottom: 1px solid var(--color-border); padding-bottom: 8px;}
        .fsReaderSlidingPanel label { display: block; margin-top: 8px; margin-bottom: 2px; font-size:0.95em; font-weight:normal; color: var(--color-text-secondary); }
        .fsReaderSlidingPanel select, .fsReaderSlidingPanel input[type=range], .fsReaderSlidingPanel input[type=checkbox], .fsReaderSlidingPanel input[type=color] { 
            width: 100%; margin-bottom:12px; 
        }
        .fsReaderSlidingPanel input[type=range] { padding: 0; }
        .fsReaderSlidingPanel .panel-section { margin-bottom:15px; }
        .fsReaderSlidingPanel .panel-section h5 { margin-bottom:5px; font-size:1em; color: var(--color-text-primary); }

        #fsReaderIndexPanel .index-tabs { display:flex; margin-bottom:10px; border-bottom: 1px solid var(--color-border); }
        #fsReaderIndexPanel .index-tab { padding: 8px 12px; cursor:pointer; border-radius: 4px 4px 0 0; }
        #fsReaderIndexPanel .index-tab.active-tab { background-color: var(--color-bg-secondary); border: 1px solid var(--color-border); border-bottom:1px solid var(--color-bg-secondary); }
        
        .index-list { list-style: none; padding-left: 0; max-height: calc(100vh - 200px); overflow-y: auto;}
        .index-list li a { display: block; padding: 7px 5px; color: var(--color-text-primary); font-size:0.95em; border-bottom: 1px dotted var(--color-border); }
        .index-list li a:hover { background-color: var(--color-bg-secondary); text-decoration:none; }
        .index-list-item-num { color: var(--color-accent-dark); font-weight:bold; margin-right:8px; display:inline-block; width:25px; text-align:right;}
    `;
    const styleSheet = document.createElement("style");
    styleSheet.id = cssId;
    styleSheet.type = "text/css";
    styleSheet.innerText = styles;
    document.head.appendChild(styleSheet);
}

// --- Reader Launch & Core Structure ---
async function launchFullScreenQuranReaderEnhanced() {
    if (isFullScreenReaderActive) return;
    isFullScreenReaderActive = true;
    document.body.style.overflow = 'hidden';

    injectEnhancedFullScreenReaderCSS();
    await loadTajMushafPageDataIfNeeded(); // Ensure page data is loaded
    loadFullScreenReaderSettings(); // Load user preferences

    const overlay = document.createElement('div');
    overlay.id = 'fullScreenReaderOverlay';
    overlay.innerHTML = `
        <div id="fsReaderHeader">
            <button id="fsReaderIndexToggleBtn" title="Index">☰</button>
            <div class="title-page-container">
                <div id="fsReaderSurahTitle" class="title">Loading...</div>
                <div id="fsReaderPageInfo" class="page-info">Page ...</div>
            </div>
            <button id="fsReaderSettingsToggleBtn" title="Settings">⚙️</button>
        </div>
        <div id="fsReaderContent" style="font-size: ${fullScreenReaderSettings.fontSize};">
            <p>Loading Quran content...</p>
        </div>
        <div id="fsReaderFooter">
            <button id="fsReaderPrevBtn" title="Previous">◀</button>
            <input type="range" id="fsReaderScrubSlider" min="1" max="${TAJ_COMPANY_PAGES}" value="1" title="Navigate">
            <button id="fsReaderNextBtn" title="Next">▶</button>
            <button id="fsReaderPlayPauseBtn" title="Play/Pause">🔊</button>
            <button id="fsReaderCloseBtnEnhanced" title="Close Reader">✕</button>
        </div>

        <!-- Settings Panel -->
        <div id="fsReaderSettingsPanel" class="fsReaderSlidingPanel">
            <h4>Reader Settings</h4>
            <div class="panel-section">
                <h5>Appearance</h5>
                <label for="fsArabicFontSelect">Arabic Font:</label>
                <select id="fsArabicFontSelect">
                    <option value="Scheherazade New">Scheherazade New</option>
                    <option value="KFGQPC Uthman Taha Naskh">KFGQPC Uthman Naskh</option>
                    <option value="Amiri">Amiri</option>
                    <option value="Lateef">Lateef</option>
                    <option value="Noto Naskh Arabic">Noto Naskh Arabic</option>
                    <option value="var(--font-arabic)">App Default Arabic</option>
                </select>
                <label for="fsFontSizeSlider">Base Font Size (<span id="fsFontSizeValue">${fullScreenReaderSettings.fontSize}</span>):</label>
                <input type="range" id="fsFontSizeSlider" min="1.8" max="4.0" step="0.1" value="${parseFloat(fullScreenReaderSettings.fontSize)}">
                <div id="fsLinesPerPageSettingDiv">
                    <label for="fsLinesPerPageSlider">Lines Per Page (Paged View) (<span id="fsLinesPerPageValue">${fullScreenReaderSettings.linesPerPage}</span>):</label>
                    <input type="range" id="fsLinesPerPageSlider" min="10" max="20" step="1" value="${fullScreenReaderSettings.linesPerPage}">
                </div>
                <label><input type="checkbox" id="fsShowTransliterationCheck"> Show Transliteration</label>
            </div>
            <div class="panel-section">
                <h5>Audio</h5>
                <label><input type="checkbox" id="fsContinuousAudioCheck"> Continuous Audio Playback</label>
                <label><input type="checkbox" id="fsAutoScrollAudioCheck"> Auto-scroll with Audio</label>
                <label for="fsHighlightColorPicker">Highlight Color:</label>
                <input type="color" id="fsHighlightColorPicker" value="${fullScreenReaderSettings.highlightColor.startsWith('rgba') ? '#ffff96' : fullScreenReaderSettings.highlightColor}">
            </div>
            <div class="panel-section">
                <h5>Navigation</h5>
                <label for="fsViewModeSelect">View Mode:</label>
                <select id="fsViewModeSelect">
                    <option value="paged">Paged (Mushaf Style)</option>
                    <option value="continuous-scroll">Continuous Scroll</option>
                </select>
            </div>
        </div>

        <!-- Index Panel -->
        <div id="fsReaderIndexPanel" class="fsReaderSlidingPanel">
            <h4>Index</h4>
            <div class="index-tabs">
                <span class="index-tab active-tab" data-tab="surahs">Surahs</span>
                <span class="index-tab" data-tab="juz">Juz (Parahs)</span>
                <span class="index-tab" data-tab="themes">Themes</span>
            </div>
            <div id="fsIndexContentSurahs" class="index-content-panel">
                <ul class="index-list" id="fsIndexSurahList"></ul>
            </div>
            <div id="fsIndexContentJuz" class="index-content-panel" style="display:none;">
                <ul class="index-list" id="fsIndexJuzList"></ul>
            </div>
            <div id="fsIndexContentThemes" class="index-content-panel" style="display:none;">
                 <input type="text" id="fsThematicIndexSearchInput" placeholder="Search themes..." style="width:100%; margin-bottom:10px;">
                <ul class="index-list" id="fsIndexThemeList">
                    <li><a href="#" data-s="2" data-a="255">Ayat al-Kursi</a></li>
                    <!-- Add more themes -->
                </ul>
            </div>
        </div>
    `;
    document.body.appendChild(overlay);

    setupEnhancedFullScreenReaderEventListeners();
    populateIndexLists();
    loadLastReadPosition(); // Load last position, then render

    // Initial render based on loaded/default state
    if (fullScreenReaderViewMode === 'paged') {
        document.getElementById('fsLinesPerPageSettingDiv').style.display = 'block';
        await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
    } else {
        document.getElementById('fsLinesPerPageSettingDiv').style.display = 'none';
        continuousScrollNextSurahToLoad = fullScreenReaderCurrentSurah; // Start loading from current
        continuousScrollNextAyahToLoad = fullScreenReaderCurrentAyah;
        await initializeContinuousScroll();
    }
    updateReaderHeaderInfo();
    updateScrubSliderRangeAndValue();
}

function closeFullScreenQuranReaderEnhanced() {
    const overlay = document.getElementById('fullScreenReaderOverlay');
    if (overlay) {
        document.body.removeChild(overlay);
    }
    document.body.style.overflow = 'auto';
    isFullScreenReaderActive = false;
    stopAndClearAudio(); // Your existing function
    saveLastReadPosition(); // Your existing function
    saveFullScreenReaderSettings(); // Save any last minute changes
}

// --- Data Loading (Page Map, etc.) ---
async function loadTajMushafPageDataIfNeeded() {
    // Same as your loadTajMushafPageData(), ensure it's robust
    // and ideally loads from a reliable external JSON or pre-compiled JS array.
    // For this example, ensure it's called and `tajMushafPageData` is populated.
    // If it's already loaded, it should just return.
    if (tajMushafPageData.length > 0) return;
    console.warn("loadTajMushafPageDataIfNeeded: Triggering SIMULATED Taj Mushaf page data load. REPLACE with actual data source.");
    // --- SIMULATED PAGE DATA (REPLACE WITH ACTUAL DATA) ---
    tajMushafPageData = [];
    let currentS = 1, currentA = 1;
    let currentJuz = 1;
    // A very simplified Juz assignment for simulation
    const pagePerJuzApprox = TAJ_COMPANY_PAGES / 30;

    for (let page = 1; page <= TAJ_COMPANY_PAGES; page++) {
        const pageStartS = currentS;
        const pageStartA = currentA;
        let ayahsOnPageCount = 0; // Count ayahs added to this page
        let pageEndS = currentS;
        let pageEndA = currentA;

        // Crude Juz calculation for simulation
        if (page > (currentJuz * pagePerJuzApprox) && currentJuz < 30) {
            currentJuz++;
        }

        while (ayahsOnPageCount < fullScreenReaderSettings.linesPerPage && currentS <= 114) {
            ayahsOnPageCount++; // This is a line counter, not strictly ayah counter for Taj layout
            pageEndS = currentS;
            pageEndA = currentA;
            currentA++;
            if (currentA > surahAyahCounts[currentS]) { // surahAyahCounts must be globally available
                currentS++;
                currentA = 1;
                if (currentS > 114) break;
            }
        }
        tajMushafPageData.push({
            page: page,
            startSurah: pageStartS, startAyah: pageStartA,
            endSurah: pageEndS, endAyah: pageEndA,
            juz: currentJuz
        });
        if (currentS > 114) break;
    }
    // --- END SIMULATION ---
    console.log("Taj Mushaf Page Data Loaded (Simulated):", tajMushafPageData.length, "pages");
}


// === In ENHANCED FULL-SCREEN TAJ QURAN READER block ===
async function renderQuranPageEnhanced(pageNumber) {
    const contentDiv = document.getElementById('fsReaderContent');
    if (!contentDiv || !tajMushafPageData.length) {
        console.error("renderQuranPageEnhanced: Content div or page data missing.");
        if(contentDiv) contentDiv.innerHTML = "<p style='color:red;text-align:center;'>Error rendering page.</p>";
        return;
    }
    contentDiv.innerHTML = ''; 
    contentDiv.style.alignItems = 'center'; 
    contentDiv.style.fontSize = fullScreenReaderSettings.fontSize;

    const pageData = tajMushafPageData.find(p => p.page === pageNumber);
    if (!pageData) {
        contentDiv.innerHTML = `<div class="fsReaderPage" style="text-align:center; padding: 50px;">Page ${pageNumber} data not found.</div>`;
        return;
    }

    fullScreenReaderCurrentPage = pageNumber;
    fullScreenReaderCurrentSurah = pageData.startSurah; // Set global current S/A to page start
    fullScreenReaderCurrentAyah = pageData.startAyah;  // for header and play button context

    const pageDiv = document.createElement('div');
    pageDiv.className = 'fsReaderPage';

    let currentS_loop_var = pageData.startSurah; // Use loop-specific variables
    let currentA_loop_var = pageData.startAyah;
    let lineCountApproximation = 0;

    while (true) {
        if (currentS_loop_var > pageData.endSurah || (currentS_loop_var === pageData.endSurah && currentA_loop_var > pageData.endAyah)) {
            break; 
        }
        if (currentS_loop_var > 114) break;

        const ayahData = await getData(STORE_QURAN, [currentS_loop_var, currentA_loop_var]);
        if (ayahData && ayahData.arabic) {
            if (currentA_loop_var === 1 && currentS_loop_var !== 1 && currentS_loop_var !== 9) {
                const bismDiv = document.createElement('div');
                bismDiv.className = 'bismillahText';
                bismDiv.style.fontFamily = fullScreenReaderSettings.arabicFont;
                bismDiv.textContent = "بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ";
                pageDiv.appendChild(bismDiv);
                lineCountApproximation++;
            }

            const ayahSpan = document.createElement('span');
            ayahSpan.className = 'fsReaderAyah';
            ayahSpan.dataset.surah = currentS_loop_var;
            ayahSpan.dataset.ayah = currentA_loop_var;
            ayahSpan.style.fontFamily = fullScreenReaderSettings.arabicFont;
            ayahSpan.textContent = ayahData.arabic.trim();

            const s_for_click = currentS_loop_var; // Capture for closure
            const a_for_click = currentA_loop_var; // Capture for closure
            ayahSpan.addEventListener('click', () => {
                handleAyahSpanClick(s_for_click, a_for_click);
            });
            pageDiv.appendChild(ayahSpan);

            const ayahNumSpan = document.createElement('span');
            ayahNumSpan.className = 'fsReaderAyahNumber';
            ayahNumSpan.textContent = arabicNumber(currentA_loop_var);
            pageDiv.appendChild(ayahNumSpan);

            if (fullScreenReaderSettings.showTransliteration) {
                const translitText = await getAyahTransliteration(currentS_loop_var, currentA_loop_var);
                if (translitText) {
                    const translitSpan = document.createElement('span');
                    translitSpan.className = 'fsReaderTransliteration';
                    translitSpan.textContent = translitText;
                    pageDiv.appendChild(translitSpan);
                }
            }
            lineCountApproximation++;
        } else if (!ayahData) {
            // console.warn(`renderQuranPageEnhanced: No data for S${currentS_loop_var}:A${currentA_loop_var}`);
        }


        currentA_loop_var++;
        if (currentA_loop_var > surahAyahCounts[currentS_loop_var]) {
            currentS_loop_var++;
            currentA_loop_var = 1;
        }
        
        if (lineCountApproximation >= fullScreenReaderSettings.linesPerPage && pageNumber < TAJ_COMPANY_PAGES) {
             if (currentS_loop_var < pageData.endSurah || (currentS_loop_var === pageData.endSurah && currentA_loop_var <= pageData.endAyah)) {
                 break;
             }
        }
    }
    contentDiv.appendChild(pageDiv);
    contentDiv.scrollTop = 0;
    updateReaderHeaderInfo();
    updateScrubSliderRangeAndValue();
}

// --- Content Rendering (Continuous Scroll - Revised) ---

async function initializeContinuousScroll() {
    const contentDiv = document.getElementById('fsReaderContent');
    if (!contentDiv) {
        console.error("initializeContinuousScroll: fsReaderContent not found.");
        return;
    }
    contentDiv.innerHTML = ''; 
    contentDiv.style.alignItems = 'stretch';
    contentDiv.style.fontSize = fullScreenReaderSettings.fontSize;

    continuousScrollSurahContainer = document.createElement('div');
    continuousScrollSurahContainer.id = 'continuousScrollSurahContainer';
    contentDiv.appendChild(continuousScrollSurahContainer);

    continuousScrollNextSurahToLoad = parseInt(fullScreenReaderCurrentSurah);
    continuousScrollNextAyahToLoad = parseInt(fullScreenReaderCurrentAyah);

    if (isNaN(continuousScrollNextSurahToLoad) || continuousScrollNextSurahToLoad < 1 || continuousScrollNextSurahToLoad > 114) {
        continuousScrollNextSurahToLoad = 1;
    }
    const maxAyahsForInitS = (continuousScrollNextSurahToLoad >= 1 && continuousScrollNextSurahToLoad <= 114 && surahAyahCounts[continuousScrollNextSurahToLoad]) ? surahAyahCounts[continuousScrollNextSurahToLoad] : 0;
    if (isNaN(continuousScrollNextAyahToLoad) || continuousScrollNextAyahToLoad < 1 || (maxAyahsForInitS > 0 && continuousScrollNextAyahToLoad > maxAyahsForInitS) ) {
        continuousScrollNextAyahToLoad = 1;
    }
    
    isLoadingMoreAyahs = false;
    await loadMoreAyahsForContinuousScroll();

    // Scroll to the initially intended Ayah if it's not the very start of the Quran
    const initialTargetS = continuousScrollNextSurahToLoad; // Use the validated start values
    const initialTargetA = continuousScrollNextAyahToLoad;

    if (initialTargetS > 1 || initialTargetA > 1) {
         setTimeout(() => {
            const targetAyahEl = continuousScrollSurahContainer.querySelector(
                `.fsReaderAyah[data-surah="${initialTargetS}"][data-ayah="${initialTargetA}"]`
            );
            if (targetAyahEl) {
                targetAyahEl.scrollIntoView({ behavior: "auto", block: "start" });
                highlightAyahEnhanced(initialTargetS, initialTargetA);
            }
            updateReaderHeaderInfo();
            updateScrubSliderRangeAndValue();
        }, 200); // Timeout allows DOM to render
    } else {
        updateReaderHeaderInfo();
        updateScrubSliderRangeAndValue();
    }
}


// === In ENHANCED FULL-SCREEN TAJ QURAN READER block ===
async function loadMoreAyahsForContinuousScroll() {
    if (!continuousScrollSurahContainer || !document.body.contains(continuousScrollSurahContainer)) {
        isLoadingMoreAyahs = false; return;
    }
    if (isLoadingMoreAyahs || continuousScrollNextSurahToLoad > 114) {
        if (continuousScrollNextSurahToLoad > 114) isLoadingMoreAyahs = false;
        return;
    }
    isLoadingMoreAyahs = true;

    let ayahsLoadedInBatch = 0;
    let currentRenderingSurah = -1;
    let surahBlockDiv = null;

    while (ayahsLoadedInBatch < CONTINUOUS_SCROLL_LOAD_COUNT && continuousScrollNextSurahToLoad <= 114) {
        if (!continuousScrollSurahContainer || !document.body.contains(continuousScrollSurahContainer)) {
            isLoadingMoreAyahs = false; return;
        }

        const s_loop = parseInt(continuousScrollNextSurahToLoad);
        const a_loop = parseInt(continuousScrollNextAyahToLoad);

        if (isNaN(s_loop) || isNaN(a_loop) || s_loop < 1 || s_loop > 114 || a_loop < 1) {
            isLoadingMoreAyahs = false; break; 
        }

        if (s_loop !== currentRenderingSurah) {
            currentRenderingSurah = s_loop;
            surahBlockDiv = continuousScrollSurahContainer.querySelector(`.continuousSurahBlock[data-surah-num="${s_loop}"]`);
            if (!surahBlockDiv) {
                surahBlockDiv = document.createElement('div');
                surahBlockDiv.className = 'continuousSurahBlock';
                surahBlockDiv.dataset.surahNum = s_loop;
                
                const surahNameHeader = document.createElement('h2');
                surahNameHeader.className = 'surahNameHeader';
                surahNameHeader.style.fontFamily = fullScreenReaderSettings.arabicFont;
                surahNameHeader.textContent = `${s_loop}. Surah ${surahNames[s_loop-1] || `Surah ${s_loop}`}`;
                surahBlockDiv.appendChild(surahNameHeader);

                if (s_loop !== 1 && s_loop !== 9) {
                    const bismDiv = document.createElement('div');
                    bismDiv.className = 'bismillahText';
                    bismDiv.style.fontFamily = fullScreenReaderSettings.arabicFont;
                    bismDiv.textContent = "بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ";
                    surahBlockDiv.appendChild(bismDiv);
                }
                continuousScrollSurahContainer.appendChild(surahBlockDiv);
            }
        }
        
        if (!surahBlockDiv || !document.body.contains(surahBlockDiv)) {
             isLoadingMoreAyahs = false; return;
        }

        const ayahData = await getData(STORE_QURAN, [s_loop, a_loop]);
        
        if (!surahBlockDiv || !document.body.contains(surahBlockDiv) || !continuousScrollSurahContainer || !document.body.contains(continuousScrollSurahContainer)) {
            isLoadingMoreAyahs = false; return; 
        }

        const ayahSpan = document.createElement('span');
        ayahSpan.className = 'fsReaderAyah';
        ayahSpan.dataset.surah = s_loop;
        ayahSpan.dataset.ayah = a_loop;
        ayahSpan.style.fontFamily = fullScreenReaderSettings.arabicFont;

        if (ayahData && ayahData.arabic && ayahData.arabic.trim() !== "") {
            ayahSpan.textContent = ayahData.arabic.trim();
        } else {
            ayahSpan.textContent = "[No Text]"; 
            ayahSpan.style.color = "red"; 
            ayahSpan.style.fontStyle = "italic";
        }
        
        const s_for_click = s_loop; // Capture for closure
        const a_for_click = a_loop; // Capture for closure
        ayahSpan.addEventListener('click', () => {
            handleAyahSpanClick(s_for_click, a_for_click);
        });
        surahBlockDiv.appendChild(ayahSpan);

        const ayahNumSpan = document.createElement('span');
        ayahNumSpan.className = 'fsReaderAyahNumber';
        ayahNumSpan.textContent = arabicNumber(a_loop);
        surahBlockDiv.appendChild(ayahNumSpan);

        ayahsLoadedInBatch++;

        if (fullScreenReaderSettings.showTransliteration && ayahData) {
            const translitText = await getAyahTransliteration(s_loop,a_loop);
            if (translitText) {
                const translitSpan = document.createElement('span');
                translitSpan.className = 'fsReaderTransliteration';
                translitSpan.textContent = translitText;
                surahBlockDiv.appendChild(translitSpan);
            }
        }

        continuousScrollNextAyahToLoad++;
        const maxAyahsThisSurah = (s_loop >= 1 && s_loop <= 114 && surahAyahCounts[s_loop]) ? surahAyahCounts[s_loop] : 0;
        if (maxAyahsThisSurah > 0 && continuousScrollNextAyahToLoad > maxAyahsThisSurah) {
            if (s_loop < 114) {
                 continuousScrollNextSurahToLoad = s_loop + 1; // This should be next surah
                 continuousScrollNextAyahToLoad = 1;
            } else { 
                 continuousScrollNextSurahToLoad = 115; 
                 break; 
            }
        } else if (maxAyahsThisSurah === 0 && s_loop <= 114) {
            isLoadingMoreAyahs = false; break;
        }
    }
    isLoadingMoreAyahs = false;
}


// --- Index Panel Logic ---
function populateIndexLists() {
    const surahListEl = document.getElementById('fsIndexSurahList');
    const juzListEl = document.getElementById('fsIndexJuzList');
    // ... (theme list elements if you have them)
    if (!surahListEl || !juzListEl) return;

    surahListEl.innerHTML = '';
    juzListEl.innerHTML = '';
    // ... (themes list innerHTML = '' if exists)


    // Surahs (no change here, assumed correct)
    for (let i = 1; i <= 114; i++) {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = '#';
        a.dataset.surah = i;
        a.innerHTML = `<span class="index-list-item-num">${arabicNumber(i)}</span> ${surahNames[i-1] || `Surah ${i}`}`; // Fallback
        a.addEventListener('click', handleIndexSurahClick);
        li.appendChild(a);
        surahListEl.appendChild(li);
    }

    // Juz (Parahs) - Updated
    juzBoundariesData.forEach(juzInfo => {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = '#';
        a.dataset.juz = juzInfo.juz;
        a.dataset.startSurah = juzInfo.startSurah;
        a.dataset.startAyah = juzInfo.startAyah;
        // Display Juz number and its common starting phrase/name
        a.innerHTML = `<span class="index-list-item-num">${arabicNumber(juzInfo.juz)}</span> ${juzInfo.name}`;
        a.addEventListener('click', handleIndexJuzClick);
        li.appendChild(a);
        juzListEl.appendChild(li);
    });

    // Themes - Placeholder, will be populated by populateThemesIndexList
    populateThemesIndexList();
}
// === Within your ENHANCED FULL-SCREEN TAJ QURAN READER block ===

async function handleIndexSurahClick(event) {
    event.preventDefault();
    const surahNum = parseInt(event.currentTarget.dataset.surah) || 1;
    const indexPanel = document.getElementById('fsReaderIndexPanel');
    if(indexPanel) indexPanel.style.display = 'none';
    
    const contentDiv = document.getElementById('fsReaderContent');
    if (!contentDiv) {
        console.error("handleIndexSurahClick: fsReaderContent not found.");
        return;
    }
    stopAndClearAudio();

    fullScreenReaderCurrentSurah = surahNum;
    fullScreenReaderCurrentAyah = 1; 

    if (fullScreenReaderViewMode === 'paged') {
        const page = surahToPageEnhanced(surahNum, 1);
        fullScreenReaderCurrentPage = page;
        await renderQuranPageEnhanced(page);
    } else { 
        continuousScrollNextSurahToLoad = surahNum;
        continuousScrollNextAyahToLoad = 1;
        await initializeContinuousScroll(); 
    }
    // updateReaderHeaderInfo(); // Called by render/init functions
    // updateScrubSliderRangeAndValue(); // Called by render/init functions
}

async function handleIndexJuzClick(event) {
    event.preventDefault();
    const startS = parseInt(event.currentTarget.dataset.startSurah);
    const startA = parseInt(event.currentTarget.dataset.startAyah);
    const indexPanel = document.getElementById('fsReaderIndexPanel');
    if(indexPanel) indexPanel.style.display = 'none';

    const contentDiv = document.getElementById('fsReaderContent');
    if (!contentDiv) {
        console.error("handleIndexJuzClick: fsReaderContent not found.");
        return;
    }
    stopAndClearAudio(); // Stop any currently playing audio

    fullScreenReaderCurrentSurah = startS;
    fullScreenReaderCurrentAyah = startA;

    if (fullScreenReaderViewMode === 'paged') {
        const page = surahToPageEnhanced(startS, startA);
        fullScreenReaderCurrentPage = page;
        await renderQuranPageEnhanced(page);
        setTimeout(() => highlightAndScrollToAyahInPage(startS, startA), 250);
    } else {
        // For continuous scroll, clear existing content and re-initialize from the new start point
        if (continuousScrollSurahContainer) {
            continuousScrollSurahContainer.innerHTML = '';
        }
        continuousScrollNextSurahToLoad = startS;
        continuousScrollNextAyahToLoad = startA;
        await initializeContinuousScroll();
    }
    updateReaderHeaderInfo();
    updateScrubSliderRangeAndValue();
}

function highlightAndScrollToAyahInPage(surah, ayah) {
    const targetAyahEl = document.querySelector(`#fsReaderContent .fsReaderAyah[data-surah="${surah}"][data-ayah="${ayah}"]`);
    if (targetAyahEl) {
        // For paged view, scrolling within the page div might be needed if page is long
        // const pageDiv = targetAyahEl.closest('.fsReaderPage');
        // if(pageDiv) {
        //    const relativeOffset = targetAyahEl.offsetTop - pageDiv.offsetTop;
        //    pageDiv.scrollTop = relativeOffset - (pageDiv.clientHeight / 3); // Scroll to make it visible
        // }
        // Simpler: just ensure it's visible in the main content area
        targetAyahEl.scrollIntoView({ behavior: "smooth", block: "center" });
        highlightAyahEnhanced(surah, ayah);
    }
}


// --- UI Updates & Navigation (Revised) ---
function updateReaderHeaderInfo() {
    const surahTitleEl = document.getElementById('fsReaderSurahTitle');
    const pageInfoEl = document.getElementById('fsReaderPageInfo');
    if (!surahTitleEl || !pageInfoEl) return;

    let displayS = parseInt(fullScreenReaderCurrentSurah);
    let displayA = parseInt(fullScreenReaderCurrentAyah);
    let displayPage = parseInt(fullScreenReaderCurrentPage);

    // Fallback for NaN or out-of-bounds values for global state
    if (isNaN(displayS) || displayS < 1 || displayS > 114) displayS = 1;
    const maxAyahsForCurrentDisplayS = (displayS >=1 && displayS <=114 && surahAyahCounts[displayS]) ? surahAyahCounts[displayS] : 0;
    if (isNaN(displayA) || displayA < 1 || (maxAyahsForCurrentDisplayS > 0 && displayA > maxAyahsForCurrentDisplayS) ) displayA = 1;
    if (isNaN(displayPage) || displayPage < 1) displayPage = 1;


    if (fullScreenReaderViewMode === 'continuous-scroll' && continuousScrollSurahContainer) {
        const firstVisibleAyah = findFirstVisibleAyah();
        if (firstVisibleAyah) {
            let sFromDOM = parseInt(firstVisibleAyah.dataset.surah);
            let aFromDOM = parseInt(firstVisibleAyah.dataset.ayah);

            if (!isNaN(sFromDOM) && sFromDOM >= 1 && sFromDOM <= 114) displayS = sFromDOM;
            const maxAyahsForDomS = (sFromDOM >=1 && sFromDOM <=114 && surahAyahCounts[sFromDOM]) ? surahAyahCounts[sFromDOM] : 0;
            if (!isNaN(aFromDOM) && aFromDOM >= 1 && (maxAyahsForDomS > 0 && aFromDOM <= maxAyahsForDomS) ) displayA = aFromDOM;
        }
    } else if (fullScreenReaderViewMode === 'paged') {
        const pageData = tajMushafPageData.find(p => p.page === displayPage);
        if (pageData) {
            displayS = pageData.startSurah;
            displayA = pageData.startAyah;
        } else { // Page data not found, default gracefully
            displayS = 1; displayA = 1; displayPage = 1;
        }
    }

    let displayJuz = getJuzFromSurahAyah(displayS, displayA);
    if (isNaN(displayJuz) || displayJuz < 1 || displayJuz > 30) displayJuz = 1;

    const surahNameText = (displayS >= 1 && displayS <= 114 && surahNames[displayS - 1])
                          ? surahNames[displayS - 1]
                          : `Surah ${displayS}`; // Fallback if surahNames is not right

    surahTitleEl.textContent = `Surah ${displayS}: ${surahNameText}`;
    let pageText = `Juz ${displayJuz}`;
    if (fullScreenReaderViewMode === 'paged') {
        pageText = `Page ${displayPage}/${TAJ_COMPANY_PAGES} (Juz ${displayJuz})`;
    } else {
        pageText = `(S:${displayS} A:${displayA}) Juz ${displayJuz}`;
    }
    pageInfoEl.textContent = pageText;
}


function findFirstVisibleAyah() {
    const contentDiv = document.getElementById('fsReaderContent');
    if (!contentDiv) return null;
    const ayahs = contentDiv.querySelectorAll('.fsReaderAyah');
    for (let ayahEl of ayahs) {
        const rect = ayahEl.getBoundingClientRect();
        const contentRect = contentDiv.getBoundingClientRect();
        // Check if top of ayah is within viewport of contentDiv
        if (rect.top >= contentRect.top && rect.top <= contentRect.bottom - 50) { // 50px buffer
            return ayahEl;
        }
    }
    return ayahs.length > 0 ? ayahs[0] : null; // Fallback to first loaded
}


function updateScrubSliderRangeAndValue() {
    const slider = document.getElementById('fsReaderScrubSlider');
    if (!slider) return;
    if (fullScreenReaderViewMode === 'paged') {
        slider.min = 1;
        slider.max = TAJ_COMPANY_PAGES;
        slider.value = fullScreenReaderCurrentPage;
    } else { // continuous-scroll, slider represents Surah
        slider.min = 1;
        slider.max = 114;
        slider.value = fullScreenReaderCurrentSurah; // Or the dominant Surah on screen
    }
}

async function goToNextEnhanced() {
    stopAndClearAudio();
    if (fullScreenReaderViewMode === 'paged') {
        if (fullScreenReaderCurrentPage < TAJ_COMPANY_PAGES) {
            fullScreenReaderCurrentPage++;
            await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
        }
    } else { // continuous-scroll
        // This is more complex. "Next" could mean next block of Ayahs if at end of current view.
        // For simplicity, let's make it scroll to the *next Surah*.
        // Or, if we want fine-grained next, scroll by a certain amount or to next logical segment.
        const contentDiv = document.getElementById('fsReaderContent');
        contentDiv.scrollTop += contentDiv.clientHeight * 0.8; // Scroll down by 80% of viewport
        // Check if near bottom to load more
        if (contentDiv.scrollTop + contentDiv.clientHeight >= contentDiv.scrollHeight - 200) {
            await loadMoreAyahsForContinuousScroll();
        }
        // Update header based on what's now visible
        setTimeout(updateReaderHeaderInfo, 300); // After scroll settles
    }
}

async function goToPrevEnhanced() {
    stopAndClearAudio();
    if (fullScreenReaderViewMode === 'paged') {
        if (fullScreenReaderCurrentPage > 1) {
            fullScreenReaderCurrentPage--;
            await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
        }
    } else { // continuous-scroll
        const contentDiv = document.getElementById('fsReaderContent');
        contentDiv.scrollTop -= contentDiv.clientHeight * 0.8;
        setTimeout(updateReaderHeaderInfo, 300);
    }
}

// Helper: surah:ayah to page (more accurate for navigation)
function surahToPageEnhanced(surah, ayah = 1) {
    if (!tajMushafPageData || tajMushafPageData.length === 0) return 1;
    for (const pageInfo of tajMushafPageData) {
        // Check if surah:ayah falls within this page's range
        if (surah === pageInfo.startSurah && surah === pageInfo.endSurah) { // Single surah on page
            if (ayah >= pageInfo.startAyah && ayah <= pageInfo.endAyah) return pageInfo.page;
        } else if (surah === pageInfo.startSurah && ayah >= pageInfo.startAyah) { // Starts on this page
            return pageInfo.page;
        } else if (surah === pageInfo.endSurah && ayah <= pageInfo.endAyah) { // Ends on this page
            return pageInfo.page;
        } else if (surah > pageInfo.startSurah && surah < pageInfo.endSurah) { // Entirely within this page (multi-surah page)
            return pageInfo.page;
        }
    }
    // Fallback: find first page where surah appears
    const firstPageOfSurah = tajMushafPageData.find(p => p.startSurah === surah || p.endSurah === surah);
    return firstPageOfSurah ? firstPageOfSurah.page : 1;
}


// --- Settings Management (Revised) ---
function applyFullScreenReaderSettingsChanges() {
    const contentDiv = document.getElementById('fsReaderContent');
    if (contentDiv) {
        contentDiv.style.fontSize = fullScreenReaderSettings.fontSize;
        // Re-rendering is heavy, try to apply live where possible or just on view mode change / explicit reload
    }
    if (fullScreenReaderViewMode === 'paged') {
        renderQuranPageEnhanced(fullScreenReaderCurrentPage); // Re-render page for font/lines
    } else {
        // For continuous, existing content needs style updates or re-render sections
        // Simplest for now: force re-init of continuous view if font changes significantly
        // Or iterate through .fsReaderAyah and .bismillahText etc. to apply font
        continuousScrollSurahContainer.innerHTML = ''; // Clear
        continuousScrollNextSurahToLoad = fullScreenReaderCurrentSurah; // Or first visible
        continuousScrollNextAyahToLoad = fullScreenReaderCurrentAyah; // Or first visible
        initializeContinuousScroll();
    }
    saveFullScreenReaderSettings();
}

function saveFullScreenReaderSettings() { // Unchanged, ensure it saves all relevant settings
    localStorage.setItem('fsReaderSettingsEnhanced', JSON.stringify(fullScreenReaderSettings));
}
function loadFullScreenReaderSettings() { // Revised to load into new structure
    const saved = localStorage.getItem('fsReaderSettingsEnhanced');
    if (saved) {
        try {
            const parsed = JSON.parse(saved);
            // Carefully merge to avoid undefined overwriting defaults
            for (const key in parsed) {
                if (parsed[key] !== undefined && fullScreenReaderSettings.hasOwnProperty(key)) {
                    fullScreenReaderSettings[key] = parsed[key];
                }
            }
        } catch (e) { console.error("Error parsing saved reader settings", e); }
    }

    // Apply to UI elements in settings panel (ensure IDs match new panel)
    const fontSelect = document.getElementById('fsArabicFontSelect');
    const sizeSlider = document.getElementById('fsFontSizeSlider');
    const sizeValueEl = document.getElementById('fsFontSizeValue');
    const linesSlider = document.getElementById('fsLinesPerPageSlider');
    const linesValueEl = document.getElementById('fsLinesPerPageValue');
    const translitCheck = document.getElementById('fsShowTransliterationCheck');
    const contAudioCheck = document.getElementById('fsContinuousAudioCheck');
    const autoScrollCheck = document.getElementById('fsAutoScrollAudioCheck');
    const highlightPicker = document.getElementById('fsHighlightColorPicker');
    const viewModeSelect = document.getElementById('fsViewModeSelect');


    if(fontSelect) fontSelect.value = fullScreenReaderSettings.arabicFont;
    if(sizeSlider && sizeValueEl) {
        sizeSlider.value = parseFloat(fullScreenReaderSettings.fontSize);
        sizeValueEl.textContent = fullScreenReaderSettings.fontSize;
    }
    if(linesSlider && linesValueEl) {
        linesSlider.value = fullScreenReaderSettings.linesPerPage;
        linesValueEl.textContent = fullScreenReaderSettings.linesPerPage;
    }
    if(translitCheck) translitCheck.checked = fullScreenReaderSettings.showTransliteration;
    if(contAudioCheck) contAudioCheck.checked = fullScreenReaderSettings.continuousAudio;
    if(autoScrollCheck) autoScrollCheck.checked = fullScreenReaderSettings.autoScrollAudio;
    if(highlightPicker) {
         highlightPicker.value = fullScreenReaderSettings.highlightColor.startsWith('rgba') ? 
            rgbToHex(fullScreenReaderSettings.highlightColor) : // Convert RGBA to Hex for picker
            fullScreenReaderSettings.highlightColor;
    }
    if(viewModeSelect) viewModeSelect.value = fullScreenReaderViewMode; // From loaded last read pos
}
// Helper to convert rgba to hex for color picker
function rgbToHex(rgba) {
    if (rgba.startsWith('#')) return rgba; // Already hex
    const parts = rgba.substring(rgba.indexOf('(') + 1, rgba.lastIndexOf(')')).split(/,\s*/);
    if (parts.length < 3) return '#ffff96'; // Fallback
    const r = parseInt(parts[0]).toString(16).padStart(2, '0');
    const g = parseInt(parts[1]).toString(16).padStart(2, '0');
    const b = parseInt(parts[2]).toString(16).padStart(2, '0');
    return `#${r}${g}${b}`;
}


// === Within your ENHANCED FULL-SCREEN TAJ QURAN READER block ===

function loadLastReadPosition() {
    const saved = localStorage.getItem('fsReaderLastPosEnhanced');
    // Default values if nothing is saved or parsing fails
    let page = 1, surah = 1, ayah = 1, viewMode = 'paged';

    if (saved) {
        try {
            const pos = JSON.parse(saved);
            page = parseInt(pos.page);
            surah = parseInt(pos.surah); // `surah` could be NaN here if pos.surah is not a number string
            ayah = parseInt(pos.ayah);
            viewMode = pos.viewMode === 'continuous-scroll' ? 'continuous-scroll' : 'paged'; // Validate viewMode

            if (isNaN(page) || page < 1 || page > TAJ_COMPANY_PAGES) page = 1;
            
            // Crucial: Validate `surah` *before* using it as an index or for ayah validation
            if (isNaN(surah) || surah < 1 || surah > 114) {
                surah = 1; // Default surah
            }
            // Now `surah` is guaranteed to be a valid number (1-114)
            
            // Validate `ayah` against the (now validated) `surah`
            const maxAyahsForSurah = (surah >= 1 && surah <= 114 && surahAyahCounts[surah]) ? surahAyahCounts[surah] : 0;
            if (isNaN(ayah) || ayah < 1 || (maxAyahsForSurah > 0 && ayah > maxAyahsForSurah)) {
                 ayah = 1; // Default ayah
            }
            // Specific check for Al-Fatihah if surah was defaulted or loaded as 1
            if (surah === 1 && ayah > 7) ayah = 1; // Max 7 for Al-Fatihah, or reset to 1 if out of bounds


        } catch(e) {
            console.error("Error parsing last read position, resetting to defaults.", e);
            page = 1; surah = 1; ayah = 1; viewMode = 'paged';
        }
    } else {
         page = 1; surah = 1; ayah = 1; viewMode = 'paged';
    }

    fullScreenReaderCurrentPage = page;
    fullScreenReaderCurrentSurah = surah;
    fullScreenReaderCurrentAyah = ayah;
    fullScreenReaderViewMode = viewMode;

    const viewModeSelect = document.getElementById('fsViewModeSelect');
    if (viewModeSelect) {
        viewModeSelect.value = fullScreenReaderViewMode;
    }
}

function saveLastReadPosition() { // Revised
     localStorage.setItem('fsReaderLastPosEnhanced', JSON.stringify({
        page: fullScreenReaderCurrentPage,
        surah: fullScreenReaderCurrentSurah,
        ayah: fullScreenReaderCurrentAyah,
        viewMode: fullScreenReaderViewMode
    }));
}


// --- Audio & Highlighting (Revised) ---
// === In ENHANCED FULL-SCREEN TAJ QURAN READER block ===
// === Modify playAudioForAyahEnhanced ===
async function playAudioForAyahEnhanced(surah, ayah) {
    const sNum = parseInt(surah);
    const aNum = parseInt(ayah);

    // ... (your existing validation for sNum, aNum) ...
    if (isNaN(sNum) || isNaN(aNum) || sNum < 1 || sNum > 114 || aNum < 1 || 
        (surahAyahCounts[sNum] && aNum > surahAyahCounts[sNum])) {
        console.error(`playAudioForAyahEnhanced: Invalid input S:${surah} A:${ayah}. Aborting.`);
        if (fullScreenReaderIsPlayingAudio) stopAndClearAudio();
        return;
    }

    stopAndClearAudio(); 

    const surahPadded = String(sNum).padStart(3, '0');
    const ayahPadded = String(aNum).padStart(3, '0');
    const audioSrc = `https://everyayah.com/data/Alafasy_128kbps/${surahPadded}${ayahPadded}.mp3`;
    // console.log(`playAudioForAyahEnhanced: Preparing to play S${sNum} A${aNum} from ${audioSrc}`);

    fullScreenReaderAudioPlayer = new Audio(audioSrc);
    // Store the S/A this audio object is for:
    fullScreenReaderAudioPlayer.currentSrcAyahS = sNum;
    fullScreenReaderAudioPlayer.currentSrcAyahA = aNum;

    try {
        await fullScreenReaderAudioPlayer.play();
        // ... (rest of the try block: setting flags, button text, highlight) ...
        fullScreenReaderIsPlayingAudio = true;
        const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
        if (playPauseBtn) playPauseBtn.textContent = '❚❚';
        highlightAyahEnhanced(sNum, aNum);


        fullScreenReaderAudioPlayer.onended = async () => {
            // ... (existing onended logic) ...
             fullScreenReaderIsPlayingAudio = false;
            const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
            if (playPauseBtn) playPauseBtn.textContent = '🔊';
            
            if (fullScreenReaderSettings.continuousAudio) {
                let nextS = sNum; // Use sNum from the current closure
                let nextA = aNum + 1; // Use aNum from the current closure
                if (surahAyahCounts[nextS] && nextA > surahAyahCounts[nextS]) {
                    if (nextS < 114) {
                        nextS++;
                        nextA = 1;
                    } else {
                        removeHighlightEnhanced(); 
                        return; 
                    }
                } else if (!surahAyahCounts[nextS]) { 
                     removeHighlightEnhanced(); return;
                }

                fullScreenReaderCurrentSurah = nextS; // Update global state for the *next* one
                fullScreenReaderCurrentAyah = nextA;
                updateReaderHeaderInfo();
                playAudioForAyahEnhanced(nextS, nextA); 
            } else {
                 removeHighlightEnhanced();
            }
        };
        fullScreenReaderAudioPlayer.onerror = (e) => {
            // ... (existing onerror logic) ...
        };

    } catch (err) {
        // ... (existing catch block) ...
    }
}

function toggleAudioPlaybackEnhanced() {
    const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');

    if (!fullScreenReaderAudioPlayer || fullScreenReaderAudioPlayer.src === '' || fullScreenReaderAudioPlayer.src === window.location.href || fullScreenReaderAudioPlayer.ended) {
        // Case 1: No audio loaded, or previous audio finished. Start new playback.
        let targetS = parseInt(fullScreenReaderCurrentSurah);
        let targetA = parseInt(fullScreenReaderCurrentAyah);

        // Validate current global state
        if (isNaN(targetS) || targetS < 1 || targetS > 114) targetS = 1;
        const maxAyahsForGlobalS = (targetS >= 1 && targetS <= 114 && surahAyahCounts[targetS]) ? surahAyahCounts[targetS] : 0;
        if (isNaN(targetA) || targetA < 1 || (maxAyahsForGlobalS > 0 && targetA > maxAyahsForGlobalS)) targetA = 1;
        
        if (fullScreenReaderViewMode === 'continuous-scroll') {
            const firstVisible = findFirstVisibleAyah(); // This finds the Ayah at the top of the viewport
            if (firstVisible && firstVisible.dataset.surah && firstVisible.dataset.ayah) {
                let sFromDOM = parseInt(firstVisible.dataset.surah);
                let aFromDOM = parseInt(firstVisible.dataset.ayah);

                // Validate DOM values before using them
                if (!isNaN(sFromDOM) && sFromDOM >= 1 && sFromDOM <= 114) {
                    const maxAyahsForDomS = (sFromDOM >=1 && sFromDOM <=114 && surahAyahCounts[sFromDOM]) ? surahAyahCounts[sFromDOM] : 0;
                    if (!isNaN(aFromDOM) && aFromDOM >= 1 && (maxAyahsForDomS > 0 && aFromDOM <= maxAyahsForDomS)) {
                        targetS = sFromDOM;
                        targetA = aFromDOM;
                        // console.log(`TogglePlay: Continuous - Will play first visible S${targetS} A${targetA}`);
                    } else {
                        // console.warn(`TogglePlay: Continuous - Invalid Ayah from DOM (${aFromDOM}), using global S${targetS} A${targetA}`);
                    }
                } else {
                    // console.warn(`TogglePlay: Continuous - Invalid Surah from DOM (${sFromDOM}), using global S${targetS} A${targetA}`);
                }
            } else {
                // console.warn(`TogglePlay: Continuous - No visible Ayah found, using global S${targetS} A${targetA}`);
            }
        } else { // Paged view
            // For paged view, fullScreenReaderCurrentSurah/Ayah should ideally already be set
            // to the start of the current page, or the last clicked Ayah on that page.
            // console.log(`TogglePlay: Paged - Will play S${targetS} A${targetA}`);
        }
        
        // Update global state to reflect what we are about to play
        fullScreenReaderCurrentSurah = targetS;
        fullScreenReaderCurrentAyah = targetA;
        updateReaderHeaderInfo(); // Reflect this in the header
        playAudioForAyahEnhanced(targetS, targetA);

    } else if (fullScreenReaderIsPlayingAudio) {
        // Case 2: Audio is currently playing, so pause it.
        fullScreenReaderAudioPlayer.pause();
        fullScreenReaderIsPlayingAudio = false;
        if (playPauseBtn) playPauseBtn.textContent = '🔊';
        // console.log("TogglePlay: Paused audio");
    } else {
        // Case 3: Audio player exists and is loaded but paused, so resume.
        fullScreenReaderAudioPlayer.play().then(() => {
            fullScreenReaderIsPlayingAudio = true;
            if (playPauseBtn) playPauseBtn.textContent = '❚❚';
            // console.log("TogglePlay: Resumed audio");
            // Ensure the correct Ayah is highlighted if resuming
            highlightAyahEnhanced(parseInt(fullScreenReaderAudioPlayer.currentSrcAyahS) || fullScreenReaderCurrentSurah, 
                                  parseInt(fullScreenReaderAudioPlayer.currentSrcAyahA) || fullScreenReaderCurrentAyah);
        }).catch(err => {
            console.error("Error resuming audio:", err);
            if (playPauseBtn) playPauseBtn.textContent = '🔊';
        });
    }
}

// stopAndClearAudio remains mostly the same, just ensure it calls removeHighlightEnhanced
function stopAndClearAudio() {
    if (fullScreenReaderAudioPlayer) {
        fullScreenReaderAudioPlayer.pause();
        fullScreenReaderAudioPlayer.onended = null; // Remove onended listener
        fullScreenReaderAudioPlayer.onerror = null; // Remove onerror listener
        fullScreenReaderAudioPlayer.src = ''; 
        fullScreenReaderAudioPlayer.load(); // Important to release resources
        fullScreenReaderAudioPlayer = null;
    }
    fullScreenReaderIsPlayingAudio = false;
    removeHighlightEnhanced();
    const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
    if(playPauseBtn) playPauseBtn.textContent = '🔊';
}


function highlightAyahEnhanced(surah, ayah) {
    removeHighlightEnhanced();
    const contentDiv = document.getElementById('fsReaderContent');
    const ayahEl = contentDiv.querySelector(`.fsReaderAyah[data-surah="${surah}"][data-ayah="${ayah}"]`);
    if (ayahEl) {
        ayahEl.style.backgroundColor = fullScreenReaderSettings.highlightColor;
        ayahEl.classList.add('highlighted-ayah');
        if (fullScreenReaderSettings.autoScrollAudio) {
            // Check if element is already reasonably in view before forceful scroll
            const rect = ayahEl.getBoundingClientRect();
            const contentRect = contentDiv.getBoundingClientRect();
            const isVisible = rect.top >= contentRect.top && rect.bottom <= contentRect.bottom;
            if(!isVisible){
                 ayahEl.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
            }
        }
    }
}
function removeHighlightEnhanced() {
    const highlighted = document.querySelector('#fsReaderContent .highlighted-ayah');
    if (highlighted) {
        highlighted.style.backgroundColor = '';
        highlighted.classList.remove('highlighted-ayah');
    }
}
// Helper: arabicNumber (if not global)
function arabicNumber(num) {
    const arabicNumerals = ['٠', '١', '٢', '٣', '٤', '٥', '٦', '٧', '٨', '٩'];
    return String(num).split('').map(digit => arabicNumerals[parseInt(digit)]).join('');
}
// Helper: getAyahTransliteration (if not global)
async function getAyahTransliteration(surah, ayah) { return null; }


// --- Event Listeners for Enhanced Reader ---
// === Within your ENHANCED FULL-SCREEN TAJ QURAN READER block ===
// This function needs to be defined or modified

// Add a new state variable
let isReaderChromeVisible = true; // To track visibility of header/footer/panels

function setupEnhancedFullScreenReaderEventListeners() {
    const closeBtn = document.getElementById('fsReaderCloseBtnEnhanced');
    const nextBtn = document.getElementById('fsReaderNextBtn');
    const prevBtn = document.getElementById('fsReaderPrevBtn');
    const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
    const settingsToggleBtn = document.getElementById('fsReaderSettingsToggleBtn');
    const indexToggleBtn = document.getElementById('fsReaderIndexToggleBtn');
    const settingsPanel = document.getElementById('fsReaderSettingsPanel');
    const indexPanel = document.getElementById('fsReaderIndexPanel');
    const contentDiv = document.getElementById('fsReaderContent'); // Main content area
    const headerDiv = document.getElementById('fsReaderHeader');
    const footerDiv = document.getElementById('fsReaderFooter');
    const scrubSlider = document.getElementById('fsReaderScrubSlider'); // For enabling/disabling

    // Null checks for all elements before adding listeners
    if (closeBtn) closeBtn.addEventListener('click', closeFullScreenQuranReaderEnhanced);
    if (nextBtn) nextBtn.addEventListener('click', goToNextEnhanced);
    if (prevBtn) prevBtn.addEventListener('click', goToPrevEnhanced);
    if (playPauseBtn) playPauseBtn.addEventListener('click', toggleAudioPlaybackEnhanced);

    if (settingsToggleBtn && settingsPanel && indexPanel) {
        settingsToggleBtn.addEventListener('click', () => {
            const isSettingsVisible = settingsPanel.style.display === 'block';
            settingsPanel.style.display = isSettingsVisible ? 'none' : 'block';
            indexPanel.style.display = 'none'; // Always close index panel when settings is toggled

            // New: Toggle all UI chrome (header/footer) if settings panel is also being hidden
            // Or, you could have a separate dedicated "Full Immersive" button
            if (isSettingsVisible) { // i.e., settings panel was open and is now closing
                // Optionally, restore chrome if it was hidden
                // For now, let's assume settings icon ALSO controls chrome visibility
                // toggleReaderChromeVisibility(false); // Hide chrome when settings panel is closed by its own button
            } else {
                // If opening settings, ensure chrome is visible
                // toggleReaderChromeVisibility(true);
            }
        });
    }

    if (indexToggleBtn && indexPanel && settingsPanel) {
        indexToggleBtn.addEventListener('click', () => {
            const isIndexVisible = indexPanel.style.display === 'block';
            indexPanel.style.display = isIndexVisible ? 'none' : 'block';
            settingsPanel.style.display = 'none'; // Always close settings panel

            // If opening index, ensure chrome is visible
            // if (!isIndexVisible) toggleReaderChromeVisibility(true);
        });
    }
    
    // Toggle full UI chrome (header/footer/panels) when clicking on the content area
    // This gives a quick way to go into "distraction-free" mode.
    if (contentDiv && headerDiv && footerDiv && settingsPanel && indexPanel) {
        contentDiv.addEventListener('click', (e) => {
            // Only toggle chrome if the click is on the content background,
            // not on an Ayah text span or if a panel is already open.
            if (e.target === contentDiv && settingsPanel.style.display === 'none' && indexPanel.style.display === 'none') {
                toggleReaderChromeVisibility();
            } else if (settingsPanel.style.display === 'block' && !settingsPanel.contains(e.target) && e.target !== settingsToggleBtn){
                 settingsPanel.style.display = 'none';
            } else if (indexPanel.style.display === 'block' && !indexPanel.contains(e.target) && e.target !== indexToggleBtn){
                 indexPanel.style.display = 'none';
            }
        });
    }

    // Settings Panel Internal Listeners (IDs must match HTML)
    const arabicFontSelect = document.getElementById('fsArabicFontSelect');
    const fontSizeSlider = document.getElementById('fsFontSizeSlider');
    const fontSizeValueEl = document.getElementById('fsFontSizeValue');
    const linesPerPageSlider = document.getElementById('fsLinesPerPageSlider');
    const linesPerPageValueEl = document.getElementById('fsLinesPerPageValue');
    const showTransliterationCheck = document.getElementById('fsShowTransliterationCheck');
    const continuousAudioCheck = document.getElementById('fsContinuousAudioCheck');
    const autoScrollAudioCheck = document.getElementById('fsAutoScrollAudioCheck');
    const highlightColorPicker = document.getElementById('fsHighlightColorPicker');
    const viewModeSelect = document.getElementById('fsViewModeSelect');

    if (arabicFontSelect) arabicFontSelect.addEventListener('change', (e) => {
        fullScreenReaderSettings.arabicFont = e.target.value;
        applyFullScreenReaderSettingsChanges();
    });
    if (fontSizeSlider && fontSizeValueEl) {
        fontSizeSlider.addEventListener('input', (e) => {
            fullScreenReaderSettings.fontSize = `${e.target.value}rem`;
            fontSizeValueEl.textContent = fullScreenReaderSettings.fontSize;
            // Apply live to content div for immediate feedback
            const contentDiv = document.getElementById('fsReaderContent');
            if (contentDiv) contentDiv.style.fontSize = fullScreenReaderSettings.fontSize;
        });
        fontSizeSlider.addEventListener('change', applyFullScreenReaderSettingsChanges); // Save and re-render if needed
    }
    if (linesPerPageSlider && linesPerPageValueEl) {
        linesPerPageSlider.addEventListener('input', (e) => {
            fullScreenReaderSettings.linesPerPage = parseInt(e.target.value, 10);
            linesPerPageValueEl.textContent = fullScreenReaderSettings.linesPerPage;
        });
        linesPerPageSlider.addEventListener('change', applyFullScreenReaderSettingsChanges);
    }
    if (showTransliterationCheck) showTransliterationCheck.addEventListener('change', (e) => {
        fullScreenReaderSettings.showTransliteration = e.target.checked;
        applyFullScreenReaderSettingsChanges();
    });
    if (continuousAudioCheck) continuousAudioCheck.addEventListener('change', (e) => {
        fullScreenReaderSettings.continuousAudio = e.target.checked;
        saveFullScreenReaderSettings(); // Save immediately
    });
    if (autoScrollAudioCheck) autoScrollAudioCheck.addEventListener('change', (e) => {
        fullScreenReaderSettings.autoScrollAudio = e.target.checked;
        saveFullScreenReaderSettings(); // Save immediately
    });
    if (highlightColorPicker) highlightColorPicker.addEventListener('change', (e) => {
        fullScreenReaderSettings.highlightColor = e.target.value;
        saveFullScreenReaderSettings(); // Save immediately
    });
    if (viewModeSelect) {
        viewModeSelect.addEventListener('change', async (e) => {
            fullScreenReaderViewMode = e.target.value;
            saveFullScreenReaderSettings(); // Save new view mode
            document.getElementById('fsLinesPerPageSettingDiv').style.display = (fullScreenReaderViewMode === 'paged') ? 'block' : 'none';
            stopAndClearAudio(); // Stop audio when changing view mode

            if (fullScreenReaderViewMode === 'paged') {
                fullScreenReaderCurrentPage = surahToPageEnhanced(fullScreenReaderCurrentSurah, fullScreenReaderCurrentAyah);
                await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
            } else {
                // Re-initialize continuous scroll from current position
                continuousScrollNextSurahToLoad = fullScreenReaderCurrentSurah;
                continuousScrollNextAyahToLoad = fullScreenReaderCurrentAyah;
                await initializeContinuousScroll();
            }
            updateReaderHeaderInfo();
            updateScrubSliderRangeAndValue();
        });
    }

    // Index Panel Internal Listeners
    document.querySelectorAll('#fsReaderIndexPanel .index-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
            document.querySelectorAll('#fsReaderIndexPanel .index-tab').forEach(t => t.classList.remove('active-tab'));
            e.target.classList.add('active-tab');
            document.querySelectorAll('#fsReaderIndexPanel .index-content-panel').forEach(p => p.style.display = 'none');
            document.getElementById(`fsIndexContent${e.target.dataset.tab.charAt(0).toUpperCase() + e.target.dataset.tab.slice(1)}`).style.display = 'block';
        });
    });

    // Scrub Slider Listener
    if (scrubSlider) {
        scrubSlider.addEventListener('input', () => {
            // Update header info live as slider is dragged
            if (fullScreenReaderViewMode === 'paged') {
                const page = parseInt(scrubSlider.value, 10);
                const pageData = tajMushhafPageData.find(p => p.page === page);
                if (pageData) {
                    document.getElementById('fsReaderSurahTitle').textContent = `Surah ${pageData.startSurah}: ${surahNames[pageData.startSurah - 1]}`;
                    document.getElementById('fsReaderPageInfo').textContent = `Page ${page}/${TAJ_COMPANY_PAGES} (Juz ${pageData.juz || getJuzFromSurahAyah(pageData.startSurah, pageData.startAyah)})`;
                }
            } else { // Continuous scroll, slider represents Surah
                const surah = parseInt(scrubSlider.value, 10);
                document.getElementById('fsReaderSurahTitle').textContent = `Surah ${surah}: ${surahNames[surah - 1]}`;
                document.getElementById('fsReaderPageInfo').textContent = `Juz ${getJuzFromSurahAyah(surah, 1)}`;
            }
        });
        scrubSlider.addEventListener('change', async () => {
            stopAndClearAudio();
            if (fullScreenReaderViewMode === 'paged') {
                fullScreenReaderCurrentPage = parseInt(scrubSlider.value, 10);
                await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
            } else { // Continuous scroll, jump to Surah
                fullScreenReaderCurrentSurah = parseInt(scrubSlider.value, 10);
                fullScreenReaderCurrentAyah = 1; // Always start from Ayah 1 of the selected Surah
                continuousScrollNextSurahToLoad = fullScreenReaderCurrentSurah;
                continuousScrollNextAyahToLoad = 1;
                await initializeContinuousScroll();
            }
            updateReaderHeaderInfo(); // Ensure final update
        });
    }

    // Continuous scroll loading trigger
    if (contentDiv) {
        contentDiv.addEventListener('scroll', async () => {
            if (fullScreenReaderViewMode === 'continuous-scroll' && !isLoadingMoreAyahs) {
                const scrollThreshold = contentDiv.scrollHeight - contentDiv.clientHeight - 300; // 300px from bottom
                if (contentDiv.scrollTop >= scrollThreshold) {
                    await loadMoreAyahsForContinuousScroll();
                }
                // Update header info as user scrolls
                updateReaderHeaderInfo();
            }
        });
    }

    setupKeyboardAndTapNavigation(); 
    
}

// New function to toggle header/footer visibility
function toggleReaderChromeVisibility(forceShow) {
    const headerDiv = document.getElementById('fsReaderHeader');
    const footerDiv = document.getElementById('fsReaderFooter');
    // Panels are handled by their own buttons, but can also be hidden here
    const settingsPanel = document.getElementById('fsReaderSettingsPanel');
    const indexPanel = document.getElementById('fsReaderIndexPanel');


    if (forceShow !== undefined) {
        isReaderChromeVisible = !forceShow; // Set to opposite so toggle flips it to desired state
    }

    isReaderChromeVisible = !isReaderChromeVisible; // Toggle state

    if (headerDiv) headerDiv.style.display = isReaderChromeVisible ? 'flex' : 'none';
    if (footerDiv) footerDiv.style.display = isReaderChromeVisible ? 'flex' : 'none';
    
    // When chrome is hidden, also ensure panels are hidden
    if (!isReaderChromeVisible) {
        if (settingsPanel) settingsPanel.style.display = 'none';
        if (indexPanel) indexPanel.style.display = 'none';
    }
}

// --- Function to ADD the LAUNCHER BUTTON (Revised) ---
function addEnhancedFullScreenReaderLaunchButton() {
    const quranViewerSection = document.getElementById('quran');
    if (!quranViewerSection) { console.error("Quran viewer section not found for launch button."); return; }
    const buttonId = 'launchFullScreenReaderBtnEnhanced';
    if (document.getElementById(buttonId)) return; // Already added

    const launchButton = document.createElement('button');
    launchButton.id = buttonId;
    launchButton.innerHTML = '📖 <span class="sr-only">Open Full Screen Reader</span>'; // Icon + SR text
    launchButton.title = 'Open Immersive Quran Reader';
    // Apply some default styling, can be overridden by app's global button styles
    launchButton.style.padding = '5px 10px';
    launchButton.style.fontSize = '1.2rem';
    launchButton.style.marginLeft = '10px'; // Space from other controls
    launchButton.style.verticalAlign = 'middle';


    launchButton.addEventListener('click', () => {
        // Update reader's start position from main viewer's current state
        // Assuming `currentSurah` and `currentAyah` are global vars for your main viewer
        fullScreenReaderCurrentSurah = window.currentSurah || 1;
        fullScreenReaderCurrentAyah = window.currentAyah || 1;
        if (fullScreenReaderViewMode === 'paged') { // Use the reader's current view mode preference
            fullScreenReaderCurrentPage = surahToPageEnhanced(fullScreenReaderCurrentSurah, fullScreenReaderCurrentAyah);
        }
        launchFullScreenQuranReaderEnhanced();
        setTimeout(() => {
            document.getElementById('fsReaderSettingsToggleBtn').click(); // Open settings panel on launch
            setTimeout(() => {
                document.getElementById('fsReaderSettingsToggleBtn').click(); // off settings panel on launch
            }, 200);
            document.querySelector("#fsReaderSettingsPanel").style.right = "66px"
            document.querySelector("#fsReaderSettingsPanel").style.top = "4px"
            document.querySelector("#fsReaderSettingsPanel").style.maxHeight = "100%"
        }, 200);
        
    });

    const quranControls = quranViewerSection.querySelector('.quran-controls:first-of-type .flex-group'); // Target the flex-group in first controls div
    if (quranControls) {
        quranControls.appendChild(launchButton); // Add to existing controls
    } else { // Fallback
        const header = quranViewerSection.querySelector('h2');
        if (header) header.insertAdjacentElement('afterend', launchButton);
        else quranViewerSection.insertBefore(launchButton, quranViewerSection.firstChild);
    }
}

function handleAyahSpanClick(clickedSurah, clickedAyah) {
    // console.log(`Ayah Span Clicked: S${clickedSurah} A${clickedAyah}`);

    fullScreenReaderCurrentSurah = parseInt(clickedSurah);
    fullScreenReaderCurrentAyah = parseInt(clickedAyah);

    updateReaderHeaderInfo(); 
    // playAudioForAyahEnhanced itself calls stopAndClearAudio, so it's not needed here.
    playAudioForAyahEnhanced(fullScreenReaderCurrentSurah, fullScreenReaderCurrentAyah);
}

function setupKeyboardAndTapNavigation() {
    const readerOverlay = document.getElementById('fullScreenReaderOverlay');
    const contentArea = document.getElementById('fsReaderContent'); // For tap events

    if (!readerOverlay) {
        console.warn("Keyboard/Tap Nav: fullScreenReaderOverlay not found.");
        return;
    }

    // --- Keyboard Navigation (Arrow Keys) ---
    const handleKeyDown = (event) => {
        // Ensure the reader is active and no input field is focused (to avoid interfering with typing in search, etc.)
        if (!isFullScreenReaderActive || 
            (document.activeElement && ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName))) {
            return;
        }

        // Check if a modal inside the reader is open (like settings or index panel)
        const settingsPanel = document.getElementById('fsReaderSettingsPanel');
        const indexPanel = document.getElementById('fsReaderIndexPanel');
        if ((settingsPanel && settingsPanel.style.display === 'block') || 
            (indexPanel && indexPanel.style.display === 'block')) {
            // If a panel is open, let Escape close it, but don't trigger page navigation
            if (event.key === 'Escape') {
                 if (settingsPanel && settingsPanel.style.display === 'block') settingsPanel.style.display = 'none';
                 if (indexPanel && indexPanel.style.display === 'block') indexPanel.style.display = 'none';
                 event.preventDefault(); // Prevent other escape actions if any
            }
            return;
        }


        switch (event.key) {
            case 'ArrowLeft':
                // console.log("ArrowLeft pressed");
                if (typeof goToPrevEnhanced === "function") {
                    goToPrevEnhanced();
                    event.preventDefault(); // Prevent default browser scroll
                }
                break;
            case 'ArrowRight':
                // console.log("ArrowRight pressed");
                if (typeof goToNextEnhanced === "function") {
                    goToNextEnhanced();
                    event.preventDefault(); // Prevent default browser scroll
                }
                break;
            case 'Escape': // Also allow Esc to close reader if no panels are open
                // console.log("Escape pressed in reader");
                 if (typeof closeFullScreenQuranReaderEnhanced === "function") {
                    closeFullScreenQuranReaderEnhanced();
                    event.preventDefault();
                 }
                break;
        }
    };

    // Add listener to the document or readerOverlay
    // Using document is simpler if readerOverlay might be recreated or if you want global keys when active.
    // Ensure to remove it when the reader is closed to prevent conflicts.
    document.addEventListener('keydown', handleKeyDown);


    // --- Tap Navigation (Top/Bottom of Content Area) ---
    if (contentArea) {
        let touchStartY = 0;
        let touchEndY = 0;
        const tapThreshold = 50; // Min pixels to be considered a swipe/meaningful tap movement
        const screenPortionThreshold = 0.33; // Tap in top 33% or bottom 33%

        const handleTouchStart = (event) => {
            if (event.touches.length === 1) { // Single touch
                touchStartY = event.touches[0].clientY;
            }
        };

        const handleTouchEnd = (event) => {
            if (event.changedTouches.length === 1) { // Single touch ended
                touchEndY = event.changedTouches[0].clientY;
                
                const verticalDiff = touchEndY - touchStartY;
                const screenHeight = window.innerHeight; // or contentArea.clientHeight

                // Distinguish between a swipe and a tap
                // If it's mostly a vertical swipe, don't treat as top/bottom tap for page turn
                if (Math.abs(verticalDiff) > tapThreshold * 1.5) { // If it was a noticeable swipe
                     // console.log("Vertical swipe detected, not a top/bottom tap for page turn.");
                     return;
                }

                // Check tap position relative to contentArea or screen
                // Using clientY from the *start* of the touch is more reliable for "tap" location
                const tapYPosition = touchStartY; // Where the tap initiated

                if (tapYPosition < screenHeight * screenPortionThreshold) {
                    // Tap in the top portion (e.g., top 33%)
                    // console.log("Tap in TOP portion of the screen");
                    if (typeof goToPrevEnhanced === "function") {
                        goToPrevEnhanced();
                    }
                } else if (tapYPosition > screenHeight * (1 - screenPortionThreshold)) {
                    // Tap in the bottom portion (e.g., bottom 33%)
                    // console.log("Tap in BOTTOM portion of the screen");
                    if (typeof goToNextEnhanced === "function") {
                        goToNextEnhanced();
                    }
                } else {
                    // console.log("Tap in middle portion, or not a distinct top/bottom tap.");
                }
            }
        };
        
        // Using 'click' for desktop mouse simulation and simple taps if touch events don't capture all cases.
        // More robust tap handling might use touchend without much movement.
        const handleContentClickForTap = (event) => {
             // Make sure the click is directly on the content area or its immediate children,
             // not on an interactive element like an Ayah span itself (which has its own click for audio)
             // or a button within the content if any.
            if (event.target.closest('.fsReaderAyah, button, select, input, a')) {
                return; // Don't interpret clicks on interactive elements as page turns
            }
            
            // Check if a panel is open
            const settingsPanel = document.getElementById('fsReaderSettingsPanel');
            const indexPanel = document.getElementById('fsReaderIndexPanel');
            if ((settingsPanel && settingsPanel.style.display === 'block') || 
                (indexPanel && indexPanel.style.display === 'block')) {
                return; // Don't trigger tap navigation if a panel is open
            }


            const contentRect = contentArea.getBoundingClientRect();
            const clickYRelativeToContent = event.clientY - contentRect.top;
            const contentHeight = contentArea.clientHeight;

             if (clickYRelativeToContent < contentHeight * screenPortionThreshold) {
                // console.log("Click in TOP portion of contentArea");
                if (typeof goToPrevEnhanced === "function") {
                    goToPrevEnhanced();
                }
            } else if (clickYRelativeToContent > contentHeight * (1 - screenPortionThreshold)) {
                // console.log("Click in BOTTOM portion of contentArea");
                if (typeof goToNextEnhanced === "function") {
                    goToNextEnhanced();
                }
            }
        };

        contentArea.addEventListener('touchstart', handleTouchStart, { passive: true });
        contentArea.addEventListener('touchend', handleTouchEnd, { passive: true });
        contentArea.addEventListener('click', handleContentClickForTap);

        // Store handlers to remove them later
        readerOverlay.readerKeyDownHandler = handleKeyDown;
        contentArea.readerTouchStartHandler = handleTouchStart;
        contentArea.readerTouchEndHandler = handleTouchEnd;
        contentArea.readerContentClickHandler = handleContentClickForTap;
    }
}




// === AYAH TYPING SPEED TEST GAME ===
// === PASTE THIS ENTIRE BLOCK AT THE END OF YOUR MAIN SCRIPT, AFTER OTHER GAME CODE ===

// --- Ayah Typing Game Specific Variables ---
let ayahTypingTargetText = "";
let ayahTypingTargetCleanText = ""; // Target text without diacritics
let ayahTypingTargetSpans = [];
let ayahTypingCurrentIndex = 0; // Index in the TARGET Ayah
let ayahTypingErrors = 0;
let ayahTypingCorrectStrokes = 0;
let ayahTypingTotalStrokesAttemptedByPlayer = 0; // How many chars player tried to type for current Ayah
let ayahTypingStartTime = 0;
let ayahTypingTimerInterval = null;
let ayahTypingGameActive = false;
let ayahTypingDiacriticMode = 'ignore'; // 'ignore' or 'strict'
let ayahTypingSessionHighScoreWPM = 0;
let ayahTypingSessionHighScoreAcc = 0;
let ayahTypingCurrentAyahData = null; // To store {surah, ayah} for audio

// --- Utility Function to Remove Diacritics (from your thoughts, ensure it's robust) ---
function normalizeArabicCharForTyping(char) {
    if (!char) return "";
    let nfdNormalizedChar = char.normalize('NFD');
    let marksRemovedChar = nfdNormalizedChar.replace(/\p{M}/gu, '');
    let tatweelRemovedChar = marksRemovedChar.replace(/\u0640/g, '');

    let letterNormalizedChar = tatweelRemovedChar;
    letterNormalizedChar = letterNormalizedChar.replace(/[آأإٱ]/g, 'ا');
    letterNormalizedChar = letterNormalizedChar.replace(/[ؤو]/g, 'و');
    letterNormalizedChar = letterNormalizedChar.replace(/[ىیي]/g, 'ي');
    
    // === MODIFIED HEH NORMALIZATION ===
    letterNormalizedChar = letterNormalizedChar.replace(/[ہھةۃه]/g, 'ه'); // Teh Marbuta, HEH DOACHASHMEE, HEH GOAL to standard HEH
    
    letterNormalizedChar = letterNormalizedChar.replace(/[كک]/g, 'ك');
    letterNormalizedChar = letterNormalizedChar.replace(/[لٰل]/g, 'ل'); // Lam with Hamza to standard Lam
    letterNormalizedChar = letterNormalizedChar.replace(/[ڤ]/g, 'ف'); // V to F
    letterNormalizedChar = letterNormalizedChar.replace(/[مٰم]/g, 'م'); // V to F
    return letterNormalizedChar;
}

// --- CSS Injection for Ayah Typing Game ---
function injectAyahTypingGameCSS_Engine() {
    const cssId = "ayahTypingGameStylesEngine";
    if (document.getElementById(cssId)) return;
    const styles = `
        .ayah-typing-game-area { display: flex; flex-direction: column; align-items: center; width: 100%; padding: 10px; height: 100%; }
        .typing-options-bar { display: flex; justify-content: space-around; align-items: center; width: 100%; max-width: 600px; margin-bottom: 15px; padding: 8px; background-color: var(--color-bg-secondary); border-radius: var(--border-radius); }
        .typing-options-bar label { font-size: 0.9em; display:flex; align-items:center; gap: 5px;}
        .typing-options-bar select, .typing-options-bar button { font-size: 0.9em; padding: 5px 8px; }
        
        #ayahDisplayContainer_Engine {
            font-family: var(--font-arabic);
            font-size: 2.2rem; /* Will be adjusted by main reader settings */
            line-height: 2.5;
            direction: rtl;
            text-align: right;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            width: 100%;
            max-width: 90%; /* Or set a fixed max-width like 700px */
            min-height: 100px; /* Adjust based on typical ayah length */
            overflow-wrap: break-word;
        }
        #ayahDisplayContainer_Engine span {
            transition: background-color 0.1s, color 0.1s;
            padding: 0; /* === MODIFIED: Removed padding === */
            /* border-radius: 2px; */ /* Optional: keep or remove */
            /* Ensure default browser letter-spacing isn't causing issues */
            letter-spacing: normal; 
        }
        #ayahDisplayContainer_Engine .char-correct { background-color: #d4edda; color: #155724; } /* Light green */
        #ayahDisplayContainer_Engine .char-incorrect { background-color: #f8d7da; color: #721c24; } /* Light red */
        #ayahDisplayContainer_Engine .char-current { background-color: var(--color-highlight); box-shadow: 0 0 0 2px var(--color-accent); }
        #ayahDisplayContainer_Engine .char-pending { color: var(--color-text-secondary); opacity: 0.7; }

        #typingInputArea_Engine {
            font-family: var(--font-arabic);
            font-size: 2rem; /* Match display somewhat */
            direction: rtl;
            text-align: right;
            width: 100%;
            max-width: 90%; /* Match display */
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid var(--color-accent);
            border-radius: var(--border-radius);
            min-height: 60px;
            resize: none; /* Or vertical */
        }
        #typingInputArea_Engine:focus { outline: 2px solid var(--color-accent-dark); }

        .typing-stats-container { display: flex; justify-content: space-around; width: 100%; max-width: 600px; margin-bottom: 15px; font-size: 1.1rem; }
        .typing-stats-container div { background-color: var(--color-bg-secondary); padding: 8px 12px; border-radius: var(--border-radius); text-align: center; }
        .typing-stats-container strong { color: var(--color-accent-dark); display:block; font-size: 1.3em; }
        
        .typing-controls-area { margin-top: 15px; }
        .typing-controls-area button { margin: 0 5px; }
        .typing-results-area { text-align: center; padding: 20px; }
    `;
    const styleSheet = document.createElement("style");
    styleSheet.id = cssId;
    styleSheet.type = "text/css";
    styleSheet.innerText = styles;
    document.head.appendChild(styleSheet);
}


// --- Ayah Typing Game Main Logic ---
// Modify your existing startAyahTyping_Engine function

async function startAyahTyping_Engine() {
    activeGame = 'ayahTyping_engine';
    // showGamePlayUI("Ayah Typing Challenge"); // We will manage UI differently for this game

    injectAyahTypingGameCSS_Engine(); // Ensure CSS is injected

    const mainGameModal = document.getElementById('quranGameModal');
    const gamePlayArea = document.getElementById('gamePlayArea'); // Get the gamePlayArea

    if (!gamePlayArea) {
        console.error("Ayah Typing: gamePlayArea element not found in the modal!");
        return;
    }
    if (!mainGameModal) {
        console.error("Ayah Typing: Main game modal not found!");
        return;
    }

    // Hide the main game modal temporarily as we are taking over with browser fullscreen
    mainGameModal.style.display = 'none';

    // Prepare gamePlayArea content (same as before)
    gamePlayArea.innerHTML = `
        <div class="ayah-typing-game-area">
            <div class="typing-options-bar">
                <label for="diacriticModeSelect_Engine">Diacritics:
                    <select id="diacriticModeSelect_Engine">
                        <option value="ignore">Ignore (Type Base Letters)</option>
                        <option value="strict">Strict (Match Exactly)</option>
                    </select>
                </label>
                <button id="playAyahAudioBtn_Engine" title="Play Ayah Recitation" style="display:none;">🔊</button>
            </div>
            <div id="ayahDisplayContainer_Engine">Press "Start" to load an Ayah.</div>
            <textarea id="typingInputArea_Engine" rows="2" placeholder="ابدأ الكتابة هنا..." disabled></textarea>
            <div class="typing-stats-container">
                <div>Timer: <strong id="typingTimer_Engine">0s</strong></div>
                <div>WPM: <strong id="typingWPM_Engine">0</strong></div>
                <div>Accuracy: <strong id="typingAccuracy_Engine">0%</strong></div>
            </div>
            <div class="typing-controls-area">
                <button id="startTypingGameBtn_Engine">Start</button>
                <button id="resetTypingGameBtn_Engine" style="display:none;">Next Ayah</button>
            </div>
            <div id="typingResultsArea_Engine" class="typing-results-area" style="display:none;"></div>
        </div>
    `;
    
    // Apply current reader font size (optional)
    const ayahDisplay = document.getElementById('ayahDisplayContainer_Engine');
    if (isFullScreenReaderActive && fullScreenReaderSettings && fullScreenReaderSettings.fontSize) {
        ayahDisplay.style.fontSize = fullScreenReaderSettings.fontSize;
    }

    // Add event listeners for game controls (same as before)
    document.getElementById('startTypingGameBtn_Engine').addEventListener('click', loadNextAyahForTyping_Engine);
    document.getElementById('resetTypingGameBtn_Engine').addEventListener('click', loadNextAyahForTyping_Engine);
    document.getElementById('diacriticModeSelect_Engine').addEventListener('change', (e) => {
        ayahTypingDiacriticMode = e.target.value;
    });
    document.getElementById('playAyahAudioBtn_Engine').addEventListener('click', () => {
        if (ayahTypingCurrentAyahData && typeof playAudioForAyahEnhanced === 'function') {
            playAudioForAyahEnhanced(ayahTypingCurrentAyahData.surah, ayahTypingCurrentAyahData.ayah);
        } else {
             console.warn("Cannot play audio: Ayah data missing or audio player function not available.");
        }
    });
    document.getElementById('typingInputArea_Engine').addEventListener('input', handleTypingInput_Engine);

    // Load persisted high scores (same as before)
    ayahTypingSessionHighScoreWPM = parseInt(localStorage.getItem('ayahTypingHighScoreWPM') || '0');
    ayahTypingSessionHighScoreAcc = parseInt(localStorage.getItem('ayahTypingHighScoreAcc') || '0');

    // NOW, request fullscreen for the gamePlayArea
    requestAyahTypingFullscreen(gamePlayArea);

    // Load the first Ayah after setting up fullscreen potentially
    // Or you can call loadNextAyahForTyping_Engine inside requestAyahTypingFullscreen
    // once the container is ready. For now, calling it here.
    // Consider a slight delay if DOM manipulation within gamePlayArea happens too quickly.
    // await loadNextAyahForTyping_Engine(); // Initial Ayah load - commented out, start button will do this
}


async function loadNextAyahForTyping_Engine() {
    ////console.log("[loadNextAyahForTyping_Engine] Function started.");
    resetTypingGameState_Engine();
    const ayahDisplay = document.getElementById('ayahDisplayContainer_Engine');
    const typingInput = document.getElementById('typingInputArea_Engine');
    ayahDisplay.innerHTML = '<p>Loading new Ayah...</p>';
    typingInput.disabled = true;
    typingInput.value = '';
    document.getElementById('startTypingGameBtn_Engine').style.display = 'none';
    document.getElementById('resetTypingGameBtn_Engine').style.display = 'inline-block';
    document.getElementById('resetTypingGameBtn_Engine').textContent = 'Loading...';
    document.getElementById('resetTypingGameBtn_Engine').disabled = true;
    document.getElementById('playAyahAudioBtn_Engine').style.display = 'none';
    document.getElementById('typingResultsArea_Engine').style.display = 'none';

    try {
        let randomAyahObj;
        let attempts = 0;
        const MIN_CHARS = 15; // Adjusted min characters slightly
        const MAX_CHARS = 180; // Adjusted max characters slightly

        do {
            const randomSurah = Math.floor(Math.random() * 114) + 1;
            const randomAyahNum = Math.floor(Math.random() * (surahAyahCounts[randomSurah] || 1)) + 1;
            console.log(`[loadNextAyahForTyping_Engine] Attempt ${attempts + 1}: Trying S${randomSurah}:A${randomAyahNum}`);
            randomAyahObj = await getData(STORE_QURAN, [randomSurah, randomAyahNum]);
            if (randomAyahObj && randomAyahObj.arabic) {
                console.log(`[loadNextAyahForTyping_Engine] Fetched Ayah (raw): '${randomAyahObj.arabic}' (Length: ${randomAyahObj.arabic.length})`);
            } else {
                console.log(`[loadNextAyahForTyping_Engine] Ayah S${randomSurah}:A${randomAyahNum} not found or no Arabic text.`);
            }
            attempts++;
        } while ((!randomAyahObj || !randomAyahObj.arabic || randomAyahObj.arabic.trim().length < MIN_CHARS || randomAyahObj.arabic.trim().length > MAX_CHARS) && attempts < 50);

        if (!randomAyahObj || !randomAyahObj.arabic) {
            const errorMsg = "[loadNextAyahForTyping_Engine] Could not load a suitable Ayah after 50 attempts.";
            console.error(errorMsg);
            ayahDisplay.innerHTML = `<p style="color:red;">${errorMsg}</p>`;
            document.getElementById('startTypingGameBtn_Engine').style.display = 'inline-block';
            document.getElementById('resetTypingGameBtn_Engine').style.display = 'none';
            return;
        }
        
        ayahTypingCurrentAyahData = { surah: randomAyahObj.surah, ayah: randomAyahObj.ayah };
        ayahTypingTargetText = randomAyahObj.arabic.trim(); // Crucial: Use the trimmed version

        // *** DEBUGGING LOG FOR Fix 1A ***
        console.log(`[loadNextAyahForTyping_Engine] FINAL ayahTypingTargetText for rendering: '${ayahTypingTargetText}' (Length: ${ayahTypingTargetText.length})`);
        // To inspect for hidden/extra spaces, copy the output of the log above (including the single quotes)
        // and paste it into a text editor or an online tool that can show invisible characters.

        ayahTypingTargetCleanText = normalizeArabicCharForTyping(ayahTypingTargetText); // Normalize the final target text
        console.log(`[loadNextAyahForTyping_Engine] Normalized (Clean) Target Text: '${ayahTypingTargetCleanText}'`);

        renderAyahForTyping_Engine(ayahTypingTargetText); // Render the original (trimmed) text
        
        typingInput.disabled = false;
        typingInput.placeholder = "ابدأ الكتابة هنا عند الجاهزية";
        setTimeout(() => typingInput.focus(), 100);

        document.getElementById('resetTypingGameBtn_Engine').textContent = 'Next Ayah';
        document.getElementById('resetTypingGameBtn_Engine').disabled = false;
        document.getElementById('playAyahAudioBtn_Engine').style.display = 'inline-block';
        //loadNextAyahForTyping_Engine] New Ayah loaded successfully.");

    } catch (error) {
        console.error("[loadNextAyahForTyping_Engine] Error loading Ayah for typing:", error);
        ayahDisplay.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
        document.getElementById('startTypingGameBtn_Engine').style.display = 'inline-block';
        document.getElementById('resetTypingGameBtn_Engine').style.display = 'none';
    }
}


function renderAyahForTyping_Engine(ayahText) {
    const ayahDisplay = document.getElementById('ayahDisplayContainer_Engine');
    ayahDisplay.innerHTML = '';
    ayahTypingTargetSpans = [];

    for (let i = 0; i < ayahText.length; i++) {
        const charSpan = document.createElement('span');
        charSpan.textContent = ayahText[i];
        charSpan.className = 'char-pending';
        ayahDisplay.appendChild(charSpan);
        ayahTypingTargetSpans.push(charSpan);
    }
    if (ayahTypingTargetSpans.length > 0) {
        ayahTypingTargetSpans[0].classList.add('char-current'); // Highlight first char
    }
}

function resetTypingGameState_Engine() {
    if (ayahTypingTimerInterval) clearInterval(ayahTypingTimerInterval);
    ayahTypingGameActive = false;
    ayahTypingCurrentIndex = 0;
    ayahTypingErrors = 0;
    ayahTypingCorrectStrokes = 0;
    ayahTypingTotalStrokesAttemptedByPlayer = 0;
    ayahTypingStartTime = 0;
    ayahTypingTimerInterval = null;
    ayahTypingCurrentAyahData = null;

    document.getElementById('typingTimer_Engine').textContent = "0s";
    document.getElementById('typingWPM_Engine').textContent = "0";
    document.getElementById('typingAccuracy_Engine').textContent = "0%";
    const resultsArea = document.getElementById('typingResultsArea_Engine');
    if(resultsArea) resultsArea.style.display = 'none';

    const typingInput = document.getElementById('typingInputArea_Engine');
    if (typingInput) {
        typingInput.value = '';
        typingInput.disabled = true; // Disable until new Ayah is loaded
    }
}

function handleTypingInput_Engine() {
    ////console.log("[handleTypingInput_Engine] Current Diacritic Mode: " + ayahTypingDiacriticMode);

    const typingInput = document.getElementById('typingInputArea_Engine');
    if (!typingInput) { /* ... error handling ... */ return; }
    const userInput = typingInput.value; // What the user has ACTUALLY typed so far

    if (!ayahTypingGameActive && ayahTypingTargetSpans.length > 0 && userInput.length > 0) {
        ayahTypingGameActive = true;
        ayahTypingStartTime = Date.now();
        if (ayahTypingTimerInterval) clearInterval(ayahTypingTimerInterval);
        ayahTypingTimerInterval = setInterval(updateTypingTimer_Engine, 1000);
       ////console.log("[handleTypingInput_Engine] Game timer started.");
    }
    // ... (initial empty input handling) ...
    if (ayahTypingTargetSpans.length === 0) return;

    let currentEffectiveInputIndex = 0; // Tracks position in userInput
    let MismatchEncountered = false;

    for (let targetIdx = 0; targetIdx < ayahTypingTargetSpans.length; targetIdx++) {
        const span = ayahTypingTargetSpans[targetIdx];
        const targetCharOriginal = ayahTypingTargetText[targetIdx];
        span.className = ''; // Reset classes

        if (MismatchEncountered) { // If a mismatch already happened, all subsequent are pending
            span.classList.add('char-pending');
            continue;
        }

        const normalizedTargetChar = normalizeArabicCharForTyping(targetCharOriginal);

        if (ayahTypingDiacriticMode === 'ignore' && normalizedTargetChar === '') {
            // Target is a diacritic (or something that normalizes to empty).
            // In 'ignore' mode, we consider this "correctly skipped" by the user.
            // The user doesn't type anything for this.
            span.classList.add('char-correct'); // Visually mark it as "handled"
            // DO NOT increment currentEffectiveInputIndex here.
            if (targetIdx === userInput.length && currentEffectiveInputIndex === userInput.length) {
                // This logic is tricky. If current target is diacritic and user input matches up to previous base char
                // the "current" highlight should be on the NEXT base char.
            }
            continue; // Move to the next target character
        }

        // If we reach here, targetChar is a base letter (or space, or something not normalizing to empty)
        const userTypedCharOriginal = userInput[currentEffectiveInputIndex];

        if (currentEffectiveInputIndex < userInput.length) { // User has typed a character for this position
            const normalizedUserChar = normalizeArabicCharForTyping(userTypedCharOriginal);

            if (targetIdx === currentEffectiveInputIndex && !MismatchEncountered ) { // Log for current comparison point
                 console.log(`[Compare Char TargetIdx #${targetIdx} / InputIdx #${currentEffectiveInputIndex}] TargetOrig: '${targetCharOriginal}', UserTypedOrig: '${userTypedCharOriginal}'`);
                 if(ayahTypingDiacriticMode === 'ignore') {
                     console.log(`    NormTarget: '${normalizedTargetChar}', NormUser: '${normalizedUserChar}'`);
                 }
            }

            if (normalizedUserChar === normalizedTargetChar) {
                span.classList.add('char-correct');
            } else {
                 // Lenient space check
                if (ayahTypingDiacriticMode === 'ignore' && normalizedTargetChar.trim() === '' && normalizedUserChar.trim() === '') {
                     span.classList.add('char-correct');
                } else {
                    span.classList.add('char-incorrect');
                    MismatchEncountered = true; // Stop further correct marking
                    if (targetIdx === currentEffectiveInputIndex) {
                         console.log(`    MISMATCH. UserNorm: '${normalizedUserChar}' vs TargetNorm: '${normalizedTargetChar}'`);
                    }
                }
            }
            currentEffectiveInputIndex++;
        } else { // User hasn't typed up to this base character yet
            if (!MismatchEncountered) { // Only mark as current if no prior mismatch
                span.classList.add('char-current');
                MismatchEncountered = true; // From here on, subsequent chars are pending until this 'current' is typed
            } else {
                span.classList.add('char-pending');
            }
        }
    }
    
    // If user input is longer than effective target (after skipping diacritics), that's also an error.
    // This part needs careful thought based on how `currentEffectiveInputIndex` ends up.

    ayahTypingCurrentIndex = currentEffectiveInputIndex; // This is now the count of BASE characters matched/attempted

    if (ayahTypingGameActive) {
        updateLiveTypingStats_Engine(userInput); // userInput still reflects raw typed data
    }

    // Game completion check:
    // Needs to compare `currentEffectiveInputIndex` against the count of non-diacritic characters in target.
    let baseTargetLength = 0;
    for(let char of ayahTypingTargetText) {
        if(normalizeArabicCharForTyping(char) !== '') baseTargetLength++;
    }

    if (currentEffectiveInputIndex >= baseTargetLength && !MismatchEncountered && ayahTypingGameActive) {
         ////console.log("[handleTypingInput_Engine] Effective target base length reached. Ending round.");
        endTypingRound_Engine(userInput); // Pass the raw user input for stat calculation
    }
}



function updateLiveTypingStats_Engine(currentUserInput) {
    if (!ayahTypingGameActive) {
        document.getElementById('typingWPM_Engine').textContent = "0";
        document.getElementById('typingAccuracy_Engine').textContent = "0%";
        return;
    }

    let liveCorrectChars = 0; // Use local variable for this function's calculations
    let liveErrors = 0;       // Use local variable for this function's calculations
    const typedLength = currentUserInput.length;

    const comparisonLength = Math.min(typedLength, ayahTypingTargetText.length);

    for (let i = 0; i < comparisonLength; i++) {
        const targetOriginal = ayahTypingTargetText[i];
        const userTypedOriginal = currentUserInput[i];

        if (ayahTypingDiacriticMode === 'ignore') {
            if (normalizeArabicCharForTyping(userTypedOriginal) === normalizeArabicCharForTyping(targetOriginal)) {
                liveCorrectChars++;
            } else {
                if (targetOriginal.trim() === '' && userTypedOriginal && userTypedOriginal.trim() === '') { // Lenient space
                    liveCorrectChars++;
                } else {
                    liveErrors++;
                }
            }
        } else { // 'strict' mode
            if (userTypedOriginal === targetOriginal) {
                liveCorrectChars++;
            } else {
                liveErrors++;
            }
        }
    }

    // Account for extra characters typed beyond the target as errors
    if (typedLength > ayahTypingTargetText.length) {
        liveErrors += (typedLength - ayahTypingTargetText.length);
    }
    
    // *** CRITICAL: Update global variables that endTypingRound_Engine will use ***
    ayahTypingCorrectStrokes = liveCorrectChars; 
    ayahTypingErrors = liveErrors; 
    // ayahTypingTotalStrokesAttemptedByPlayer should be typedLength for accuracy calculation
    ayahTypingTotalStrokesAttemptedByPlayer = typedLength;


    const currentTime = Date.now();
    const timeElapsedSeconds = (currentTime - ayahTypingStartTime) / 1000;

    let wpm = 0;
    if (timeElapsedSeconds > 0.5) { 
        const wordsTypedCorrectly = liveCorrectChars / 5; 
        const minutesElapsed = timeElapsedSeconds / 60;
        wpm = minutesElapsed > 0 ? Math.round(wordsTypedCorrectly / minutesElapsed) : 0;
    }

    let accuracy = 0;
    if (typedLength > 0) { 
        accuracy = Math.round((liveCorrectChars / typedLength) * 100);
    }
    if (accuracy < 0) accuracy = 0; 

    document.getElementById('typingWPM_Engine').textContent = wpm;
    document.getElementById('typingAccuracy_Engine').textContent = `${accuracy}%`;
}
// Replace your existing endTypingRound_Engine function with this one

function endTypingRound_Engine(finalUserInput) { // finalUserInput is passed
    if (!ayahTypingGameActive) {
        console.warn("[endTypingRound_Engine] Called when game not active. Ignoring.");
        return;
    }

    //console.log("[endTypingRound_Engine] Ending round. Final user input (up to target length):", "'" + finalUserInput + "'");

    ayahTypingGameActive = false; // Set game to inactive
    if (ayahTypingTimerInterval) {
        clearInterval(ayahTypingTimerInterval);
        ayahTypingTimerInterval = null;
    }

    const typingInputEl = document.getElementById('typingInputArea_Engine');
    if (typingInputEl) typingInputEl.disabled = true;
    
    const timeElapsedSeconds = (Date.now() - ayahTypingStartTime) / 1000;
    console.log(`[endTypingRound_Engine] Time elapsed: ${timeElapsedSeconds.toFixed(2)}s`);

    // Recalculate correct strokes and errors based on the *finalUserInput* and *ayahTypingTargetText*
    // to ensure accuracy, rather than solely relying on the last update from updateLiveTypingStats_Engine.
    // This is more robust.
    let finalCorrectStrokes = 0;
    let finalErrors = 0;
    const finalComparisonLength = Math.min(finalUserInput.length, ayahTypingTargetText.length);

    for (let i = 0; i < finalComparisonLength; i++) {
        const targetOriginal = ayahTypingTargetText[i];
        const userTypedOriginal = finalUserInput[i];

        if (ayahTypingDiacriticMode === 'ignore') {
            if (normalizeArabicCharForTyping(userTypedOriginal) === normalizeArabicCharForTyping(targetOriginal)) {
                finalCorrectStrokes++;
            } else {
                if (targetOriginal.trim() === '' && userTypedOriginal && userTypedOriginal.trim() === '') { // Lenient space
                    finalCorrectStrokes++;
                } else {
                    finalErrors++;
                }
            }
        } else { // 'strict' mode
            if (userTypedOriginal === targetOriginal) {
                finalCorrectStrokes++;
            } else {
                finalErrors++;
            }
        }
    }

    // If user input was shorter than target, remaining target chars are effectively errors in terms of completion.
    // However, for WPM/Accuracy, we usually consider what they *did* type.
    // Let's stick to errors based on comparison up to finalUserInput.length.
    // If finalUserInput.length < ayahTypingTargetText.length, it means they didn't finish typing.
    // Accuracy should reflect what they DID type.
    // WPM can be calculated based on how much of the target they correctly typed.

    console.log(`[endTypingRound_Engine] Final Calculated Correct Strokes: ${finalCorrectStrokes}`);
    console.log(`[endTypingRound_Engine] Final Calculated Errors (within typed length): ${finalErrors}`);

    // Accuracy: (Correctly typed characters / Total characters ACTUALLY typed by user) * 100
    // finalUserInput.length is the total characters the user attempted for this round.
    let finalAccuracy = 0;
    if (finalUserInput.length > 0) { // Avoid division by zero
        finalAccuracy = Math.round((finalCorrectStrokes / finalUserInput.length) * 100);
    }
    finalAccuracy = Math.max(0, Math.min(100, finalAccuracy)); // Clamp between 0 and 100

    console.log(`[endTypingRound_Engine] Final Accuracy: ${finalAccuracy}% (Correct: ${finalCorrectStrokes}, Typed: ${finalUserInput.length})`);

    // WPM: ( (Correctly typed characters / 5) / time_in_minutes )
    // Use finalCorrectStrokes here.
    let finalWPM = 0;
    if (timeElapsedSeconds > 0.5) { // Only calculate if some meaningful time has passed
        const correctlyTypedWords = finalCorrectStrokes / 5; // Standard 5 characters per "word" for WPM
        const minutesElapsed = timeElapsedSeconds / 60;
        finalWPM = minutesElapsed > 0 ? Math.round(correctlyTypedWords / minutesElapsed) : 0;
    }
    finalWPM = Math.max(0, finalWPM); // Ensure WPM is not negative

    console.log(`[endTypingRound_Engine] Final WPM: ${finalWPM}`);
    
    // Update display
    document.getElementById('typingWPM_Engine').textContent = finalWPM;
    document.getElementById('typingAccuracy_Engine').textContent = `${finalAccuracy}%`;
    document.getElementById('typingTimer_Engine').textContent = `${timeElapsedSeconds.toFixed(1)}s`; // Show final time

    // Update session high scores
    if (finalWPM > ayahTypingSessionHighScoreWPM) {
        ayahTypingSessionHighScoreWPM = finalWPM;
        localStorage.setItem('ayahTypingHighScoreWPM', ayahTypingSessionHighScoreWPM);
    }
    // For high score accuracy, only update if WPM is also decent, or just track highest accuracy.
    // Let's just track highest accuracy achieved in a completed round.
    if (finalAccuracy > ayahTypingSessionHighScoreAcc) {
        ayahTypingSessionHighScoreAcc = finalAccuracy;
        localStorage.setItem('ayahTypingHighScoreAcc', ayahTypingSessionHighScoreAcc);
    }
    
    const resultsArea = document.getElementById('typingResultsArea_Engine');
    resultsArea.innerHTML = `
        <h4>Ayah Complete!</h4>
        <p>Your WPM: ${finalWPM}</p>
        <p>Accuracy: ${finalAccuracy}%</p>
        <p>Correct Characters: ${finalCorrectStrokes} / ${finalUserInput.length} (typed)</p>
        <p>Errors (in what you typed): ${finalErrors}</p>
        <p>Time: ${timeElapsedSeconds.toFixed(1)}s</p>
        <p><em>Session High: ${ayahTypingSessionHighScoreWPM} WPM, ${ayahTypingSessionHighScoreAcc}% Acc</em></p>
    `;
    resultsArea.style.display = 'block';

    const resetButton = document.getElementById('resetTypingGameBtn_Engine');
    if (resetButton) resetButton.focus();
}


function updateTypingTimer_Engine() {
    if (!ayahTypingGameActive) return;
    const currentTime = Date.now();
    const timeElapsed = Math.round((currentTime - ayahTypingStartTime) / 1000);
    document.getElementById('typingTimer_Engine').textContent = `${timeElapsed}s`;
}
// --- Add Button to Main Game Modal ---
function addAyahTypingGameButtonToModal() {
    const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
    const buttonId = 'startGameAyahTypingEngineBtn';

    if (gameSelectionArea && !document.getElementById(buttonId)) {
        const typingGameButton = document.createElement('button');
        typingGameButton.id = buttonId;
        typingGameButton.className = 'game-select-btn';
        typingGameButton.textContent = 'Ayah Typing Challenge';
        typingGameButton.addEventListener('click', () => {
            const gamePlayArea = document.getElementById('gamePlayArea');
            const gameSelectionArea = document.getElementById('game-selection-area');

            if (gameSelectionArea) gameSelectionArea.style.display = 'none';
            if (gamePlayArea) gamePlayArea.style.display = 'flex';

            setTimeout(() => {
                startAyahTyping_Engine();
            }, 50); // Small delay, e.g., 50-100ms
        });
        
        // Append after existing buttons or as first if none
        const existingButtons = gameSelectionArea.querySelectorAll('.game-select-btn');
        if (existingButtons.length > 0) {
            existingButtons[existingButtons.length - 1].insertAdjacentElement('afterend', typingGameButton);
        } else {
            // If no buttons, find the <p> and insert after it
            const pElement = gameSelectionArea.querySelector('p');
            if (pElement) {
                pElement.insertAdjacentElement('afterend', typingGameButton);
            } else {
                gameSelectionArea.appendChild(typingGameButton);
            }
        }
    }
}

// === AYAH TYPING GAME - STANDALONE BROWSER FULLSCREEN LOGIC ===
// Place these functions in your script. They are specific to this game.

let ayahTypingGameOriginalParent = null; // To store where gamePlayArea was before fullscreen
let ayahTypingGameCloseButtonFS = null; // The dedicated close button for fullscreen

function requestAyahTypingFullscreen(gamePlayAreaElement) {
    if (!gamePlayAreaElement) {
        console.error("requestAyahTypingFullscreen: gamePlayAreaElement is null.");
        return;
    }

    // Create a dedicated container for fullscreen mode
    const fullscreenContainer = document.createElement('div');
    fullscreenContainer.id = 'ayahTypingFullscreenContainer';
    fullscreenContainer.style.position = 'fixed';
    fullscreenContainer.style.top = '0';
    fullscreenContainer.style.left = '0';
    fullscreenContainer.style.width = '100vw';
    fullscreenContainer.style.height = '100vh';
    fullscreenContainer.style.backgroundColor = 'var(--color-bg-primary, #e8f5e9)'; // Use your theme's primary bg
    fullscreenContainer.style.zIndex = '20000'; // Very high z-index
    fullscreenContainer.style.display = 'flex';
    fullscreenContainer.style.flexDirection = 'column';
    fullscreenContainer.style.justifyContent = 'center';
    fullscreenContainer.style.alignItems = 'center';
    fullscreenContainer.style.padding = '20px'; // Some padding around the game area
    fullscreenContainer.style.boxSizing = 'border-box';


    // Store original parent and move gamePlayArea
    ayahTypingGameOriginalParent = gamePlayAreaElement.parentNode;
    fullscreenContainer.appendChild(gamePlayAreaElement); // Move gamePlayArea into our new container

    // Style gamePlayArea for fullscreen (it's already styled by injectAyahTypingGameCSS_Engine)
    // We just need to ensure it behaves well within its new fullscreen parent
    gamePlayAreaElement.style.width = '100%'; // Or a specific max-width like '90vw', '1200px'
    gamePlayAreaElement.style.height = '100%'; // Or '90vh'
    gamePlayAreaElement.style.maxWidth = '1200px'; // Example constraint
    gamePlayAreaElement.style.maxHeight = '95vh';
    gamePlayAreaElement.style.overflow = 'auto'; // If content overflows
    gamePlayAreaElement.style.backgroundColor = 'var(--color-bg-secondary, #c8e6c9)'; // Content background
    gamePlayAreaElement.style.borderRadius = 'var(--border-radius, 8px)';
    gamePlayAreaElement.style.boxShadow = '0 0 20px rgba(0,0,0,0.2)';


    // Add a dedicated close button for this fullscreen mode
    ayahTypingGameCloseButtonFS = document.createElement('button');
    ayahTypingGameCloseButtonFS.id = 'ayahTypingCloseFullscreenBtn';
    ayahTypingGameCloseButtonFS.textContent = '✕';
    ayahTypingGameCloseButtonFS.style.position = 'absolute';
    ayahTypingGameCloseButtonFS.style.top = '20px';
    ayahTypingGameCloseButtonFS.style.right = '20px';
    ayahTypingGameCloseButtonFS.style.fontSize = '1.8rem';
    ayahTypingGameCloseButtonFS.style.padding = '5px 12px';
    ayahTypingGameCloseButtonFS.style.backgroundColor = 'var(--color-error, #ef5350)';
    ayahTypingGameCloseButtonFS.style.color = 'white';
    ayahTypingGameCloseButtonFS.style.border = 'none';
    ayahTypingGameCloseButtonFS.style.borderRadius = '50%';
    ayahTypingGameCloseButtonFS.style.cursor = 'pointer';
    ayahTypingGameCloseButtonFS.style.zIndex = '20001'; // Above gamePlayArea
    ayahTypingGameCloseButtonFS.title = "Exit Fullscreen Typing (Esc)";
    ayahTypingGameCloseButtonFS.onclick = exitAyahTypingFullscreen;
    fullscreenContainer.appendChild(ayahTypingGameCloseButtonFS);

    document.body.appendChild(fullscreenContainer);
    document.body.style.overflow = 'hidden'; // Prevent body scroll

    // Request browser fullscreen for the new container
    if (fullscreenContainer.requestFullscreen) {
        fullscreenContainer.requestFullscreen().catch(err => {
            console.warn(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            // If browser FS fails, our custom "fixed" overlay is still active
        });
    } else if (fullscreenContainer.webkitRequestFullscreen) { /* Safari */
        fullscreenContainer.webkitRequestFullscreen();
    } else if (fullscreenContainer.msRequestFullscreen) { /* IE11 */
        fullscreenContainer.msRequestFullscreen();
    }

    // Listen for browser fullscreen exit (e.g., user presses Esc)
    document.addEventListener('fullscreenchange', handleBrowserFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleBrowserFullscreenChange); // Safari
    document.addEventListener('mozfullscreenchange', handleBrowserFullscreenChange);    // Firefox
    document.addEventListener('MSFullscreenChange', handleBrowserFullscreenChange);   // IE
}

function exitAyahTypingFullscreen() {
    const gamePlayAreaElement = document.getElementById('gamePlayArea');
    const fullscreenContainer = document.getElementById('ayahTypingFullscreenContainer');

    // Exit browser fullscreen first if active
    if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) { /* Firefox */
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
        }
    }
    // If browser fullscreen wasn't active or after it exits, clean up our custom overlay
    cleanupAyahTypingCustomFullscreenOverlay(gamePlayAreaElement, fullscreenContainer);
}

function cleanupAyahTypingCustomFullscreenOverlay(gamePlayAreaElement, fullscreenContainer) {
    if (fullscreenContainer && fullscreenContainer.parentNode) {
        // Move gamePlayArea back to its original parent within the modal
        if (gamePlayAreaElement && ayahTypingGameOriginalParent) {
            // Reset styles that were specific for fullscreen
            gamePlayAreaElement.style.width = '';
            gamePlayAreaElement.style.height = '';
            gamePlayAreaElement.style.maxWidth = '';
            gamePlayAreaElement.style.maxHeight = '';
            gamePlayAreaElement.style.overflow = '';
            gamePlayAreaElement.style.backgroundColor = ''; // Let original CSS take over
            gamePlayAreaElement.style.borderRadius = '';
            gamePlayAreaElement.style.boxShadow = '';

            ayahTypingGameOriginalParent.appendChild(gamePlayAreaElement);
        }
        fullscreenContainer.parentNode.removeChild(fullscreenContainer);
    }

    if (ayahTypingGameCloseButtonFS && ayahTypingGameCloseButtonFS.parentNode) {
        ayahTypingGameCloseButtonFS.parentNode.removeChild(ayahTypingGameCloseButtonFS);
        ayahTypingGameCloseButtonFS = null;
    }

    document.body.style.overflow = ''; // Restore body scroll

    // Clean up event listeners for browser fullscreen
    document.removeEventListener('fullscreenchange', handleBrowserFullscreenChange);
    document.removeEventListener('webkitfullscreenchange', handleBrowserFullscreenChange);
    document.removeEventListener('mozfullscreenchange', handleBrowserFullscreenChange);
    document.removeEventListener('MSFullscreenChange', handleBrowserFullscreenChange);

    // Important: After exiting our custom fullscreen, we need to tell the main game modal
    // to reset its UI to the game selection screen.
    activeGame = null; // Mark no game as active
    resetGameUI(); // Your existing function to show game selection

    // Also ensure the main game modal is still visible if it was hidden
    const mainGameModal = document.getElementById('quranGameModal');
    if (mainGameModal && mainGameModal.style.display === 'none') {
        mainGameModal.style.display = 'flex'; // Or whatever its default display is
    }
}


function handleBrowserFullscreenChange() {
    // If the browser exits fullscreen (e.g., user pressed Esc)
    // AND our custom container is still there, we need to clean it up.
    const fullscreenContainer = document.getElementById('ayahTypingFullscreenContainer');
    if (!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
        if (fullscreenContainer) { // If our container exists, it means we initiated this
            console.log("Browser fullscreen exited, cleaning up custom overlay.");
            // Call cleanup directly, no need to call document.exitFullscreen() again
            cleanupAyahTypingCustomFullscreenOverlay(
                document.getElementById('gamePlayArea'),
                fullscreenContainer
            );
        }
    }
}









// In the STANDALONE IMMERSIVE MODE block:

function enterSimpleImmersiveView() {
    const gameModalTitleEl = document.getElementById('gameModalTitle');
    // const gameSelectionArea = document.getElementById('game-selection-area'); // Temporarily ignore

    if (gameModalTitleEl) {
        originalTitleDisplay_SimpleImmersive = gameModalTitleEl.style.display;
        gameModalTitleEl.style.display = 'none';
        //console.log("[SimpleImmersive] Title hidden.");
    } else {
        console.warn("[SimpleImmersive] gameModalTitleEl not found for hiding.");
    }
    // if (gameSelectionArea) { ... } // Temporarily ignore
    isSimpleImmersiveActive = true;
}

function exitSimpleImmersiveView() {
    if (!isSimpleImmersiveActive) return;
    const gameModalTitleEl = document.getElementById('gameModalTitle');
    // const gameSelectionArea = document.getElementById('game-selection-area'); // Temporarily ignore

    if (gameModalTitleEl) {
        gameModalTitleEl.style.display = originalTitleDisplay_SimpleImmersive;
        //console.log("[SimpleImmersive] Title restored.");
    }
    // if (gameSelectionArea) { ... } // Temporarily ignore
    isSimpleImmersiveActive = false;
}




// === STANDALONE BROWSER FULLSCREEN REQUESTER (with Timeout for Button) ===
// Paste this entire block at the very end of your existing <script> tag.

(function() { // IIFE to keep it self-contained

    function requestBrowserFullscreenForReaderOverlay() {
        const readerOverlayElement = document.getElementById('fullScreenReaderOverlay');
        // ... (rest of requestBrowserFullscreenForReaderOverlay function remains the same as previous)
        if (!readerOverlayElement) {
            console.error("Standalone FS: Reader overlay (#fullScreenReaderOverlay) not found. Cannot request fullscreen.");
            return;
        }
        if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
            console.log("Standalone FS: Already in browser fullscreen mode.");
            return;
        }
        //console.log("[StandaloneFS] Attempting to request browser fullscreen for #fullScreenReaderOverlay.");
        try {
            if (readerOverlayElement.requestFullscreen) {
                readerOverlayElement.requestFullscreen();
            } else if (readerOverlayElement.webkitRequestFullscreen) { // Safari
                readerOverlayElement.webkitRequestFullscreen();
            } else if (readerOverlayElement.mozRequestFullScreen) { // Older Firefox
                readerOverlayElement.mozRequestFullScreen();
            } else if (readerOverlayElement.msRequestFullscreen) { // IE11
                readerOverlayElement.msRequestFullscreen();
            } else {
                console.warn("Standalone FS: Browser Fullscreen API not fully supported.");
            }
        } catch (err) {
            console.error(`[StandaloneFS] Error during fullscreen request: ${err.message} (${err.name})`);
        }
    }

    function setupLaunchButtonForStandaloneFullscreenWithTimeout() {
        const launchButton = document.getElementById('launchFullScreenReaderBtnEnhanced');
        if (launchButton) {
            launchButton.addEventListener('click', () => {
                //console.log("[StandaloneFS with Timeout] #launchFullScreenReaderBtnEnhanced clicked.");
                if (typeof window.launchFullScreenQuranReaderEnhanced === 'function') {
                    window.launchFullScreenQuranReaderEnhanced(); 
                } else {
                    console.error("[StandaloneFS with Timeout] window.launchFullScreenQuranReaderEnhanced() is not defined.");
                }
                setTimeout(() => {
                    requestBrowserFullscreenForReaderOverlay();
                }, 100); // Delay after launching reader UI
            });
            //console.log("[StandaloneFS with Timeout] Event listener attached to #launchFullScreenReaderBtnEnhanced.");
        } else {
            console.warn("[StandaloneFS with Timeout] #launchFullScreenReaderBtnEnhanced button not found after timeout. Fullscreen will not be triggered.");
        }
    }

    // --- MODIFIED SETUP ---
    // Wait for the full window to load, then wait an additional 300ms
    window.addEventListener('load', () => {
        //console.log("[StandaloneFS] Window 'load' event fired.");
        setTimeout(() => {
            //console.log("[StandaloneFS] Attempting to set up launch button after 300ms delay post-load.");
            setupLaunchButtonForStandaloneFullscreenWithTimeout();
        }, 300); // 0.3 seconds delay
    });
    // --- END MODIFIED SETUP ---


    function handleFullscreenChange() {
        if (!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
            //console.log("[StandaloneFS] Browser exited fullscreen mode.");
        }
    }
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleFullscreenChange);

})();





// === BROWSER FULLSCREEN FOR THE ENTIRE GAME MODAL (with Robust Button Wait) ===
// Paste this entire block at the very end of your existing <script> tag.

(function() { // IIFE to keep it self-contained

    const GAME_MODAL_ID = 'quranGameModal';
    const GAME_MODAL_LAUNCH_BUTTON_ID = 'openGamesModalBtn';
    const INITIALIZATION_DELAY_MS = 300; // 0.3 seconds delay after window load

    function attemptModalFullscreen() {
        const gameModalElement = document.getElementById(GAME_MODAL_ID);

        if (!gameModalElement) {
            console.error(`ModalFS: Element with ID "${GAME_MODAL_ID}" not found. Cannot go fullscreen.`);
            return;
        }

        if (gameModalElement.style.display === 'none' || getComputedStyle(gameModalElement).display === 'none') {
            console.warn(`ModalFS: Target modal "${GAME_MODAL_ID}" is not visible. Fullscreen might fail. Ensure original click handler makes it visible.`);
        }
        
        console.log(`ModalFS: Attempting fullscreen for #${GAME_MODAL_ID}`);
        if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
            console.log("ModalFS: Already in browser fullscreen mode.");
            return; // Avoid re-requesting if already fullscreen with some element
        }

        if (gameModalElement.requestFullscreen) {
            gameModalElement.requestFullscreen().catch(err => console.warn("ModalFS: Fullscreen request failed:", err.message));
        } else if (gameModalElement.webkitRequestFullscreen) { // Safari
            gameModalElement.webkitRequestFullscreen().catch(err => console.warn("ModalFS: Fullscreen request failed (webkit):", err.message));
        } else if (gameModalElement.mozRequestFullScreen) { // Older Firefox
            gameModalElement.mozRequestFullScreen();
        } else if (gameModalElement.msRequestFullscreen) { // IE11
            gameModalElement.msRequestFullscreen();
        } else {
            console.warn("ModalFS: Browser Fullscreen API not supported on this element.");
        }
    }

    function setupModalFullscreenLaunchListenerWithWait() {
        const launchButton = document.getElementById(GAME_MODAL_LAUNCH_BUTTON_ID);

        if (launchButton) {
            launchButton.addEventListener('click', (event) => {
                // Your original event listener for this button should have already:
                // 1. Made the #quranGameModal visible (e.g., style.display = 'flex')
                // 2. Called resetGameUI() to show the game selection screen.
                console.log(`ModalFS: Button #${GAME_MODAL_LAUNCH_BUTTON_ID} clicked. Original handler should have shown modal.`);

                // Attempt fullscreen AFTER the original click handler has likely made the modal visible.
                setTimeout(() => {
                    attemptModalFullscreen();
                }, 50); // Short delay for DOM updates from original handler
            });
            console.log(`ModalFS: Fullscreen trigger listener attached to #${GAME_MODAL_LAUNCH_BUTTON_ID}.`);
        } else {
            console.warn(`ModalFS: Game modal launch button with ID "${GAME_MODAL_LAUNCH_BUTTON_ID}" not found after wait. Fullscreen cannot be triggered by it.`);
        }
    }

    // --- MODIFIED SETUP ---
    // Wait for the full window to load, then wait an additional delay
    window.addEventListener('load', () => {
        //console.log("[ModalFS] Window 'load' event fired for game modal fullscreen setup.");
        setTimeout(() => {
            console.log(`[ModalFS] Attempting to set up launch button listener after ${INITIALIZATION_DELAY_MS}ms delay post-load.`);
            setupModalFullscreenLaunchListenerWithWait();
        }, INITIALIZATION_DELAY_MS);
    });
    // --- END MODIFIED SETUP ---

    function logModalFullscreenExit(event) {
        if (!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
            console.log("ModalFS: Exited browser fullscreen mode for modal.");
        }
    }
    document.addEventListener('fullscreenchange', logModalFullscreenExit);
    document.addEventListener('webkitfullscreenchange', logModalFullscreenExit);
    document.addEventListener('mozfullscreenchange', logModalFullscreenExit);
    document.addEventListener('MSFullscreenChange', logModalFullscreenExit);

    console.log("ModalFS: Fullscreen logic for the entire game modal (with wait) initialized.");

})();
</script>