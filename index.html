<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nur-Ul-Quran Offline - By Yasin Ullah</title>
    <meta name="author" content="Yasin Ullah, Pakistani">
    <meta name="description"
        content="An offline-first, client-side Quranic study environment with personal Tafsir, thematic linking, root analysis, Hifz tracking, and advanced search.">
    <script type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/vis-network@latest/dist/vis-network.min.js"></script>
    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    <style>
        :root {
            --color-bg-primary: #e8f5e9;
            --color-bg-secondary: #c8e6c9;
            --color-text-primary: #1b5e20;
            --color-text-secondary: #388e3c;
            --color-accent: #4caf50;
            --color-accent-dark: #388e3c;
            --color-border: #a5d6a7;
            --color-shadow: rgba(0, 0, 0, 0.1);
            --color-highlight: #fff9c4;
            --color-error: #ef5350;
            --color-success: #66bb6a;
            --font-arabic: 'Scheherazade New', 'Lateef', 'Amiri', 'Traditional Arabic', calibri;
            --font-urdu: 'Jameel Noori Nastaleeq', 'Noto Nastaliq Urdu', 'Pak Nastaleeq', calibri;
            --font-pashto: 'Mirza', 'Noto Nastaliq Urdu', 'Pak Nastaleeq', calibri;
            /* Added for Pashto */
            --font-Bangali: 'Noto Sans Bangali', 'Arial', calibri;
            --font-english: 'Roboto', 'Segoe UI', calibri;
            --font-general: 'Roboto', 'Segoe UI', calibri;
            --border-radius: 8px;
            --padding-main: 20px;
            --transition-speed: 0.3s;
        }

        body.theme-manuscript {
            --color-bg-primary: #f5f5dc;
            --color-bg-secondary: #fff8dc;
            --color-text-primary: #5d4037;
            --color-text-secondary: #795548;
            --color-accent: #ffb300;
            --color-accent-dark: #fb8c00;
            --color-border: #d7ccc8;
            --color-shadow: rgba(0, 0, 0, 0.15);
            --color-highlight: #ffe082;
            --color-error: #c62828;
            --color-success: #388e3c;
            --font-arabic: 'Scheherazade New', calibri;
            --font-urdu: 'Jameel Noori Nastaleeq', calibri;
            --font-Bangali: 'Noto Sans Bangali', calibri;
            --font-english: 'Merriweather', calibri;
            --font-general: 'Merriweather', calibri;
        }

        body.theme-holo {
            --color-bg-primary: #0d1a2b;
            --color-bg-secondary: #1a2b3c;
            --color-text-primary: #e0f7fa;
            --color-text-secondary: #b2ebf2;
            --color-accent: #00bcd4;
            --color-accent-dark: #00838f;
            --color-border: #26a69a;
            --color-shadow: rgba(0, 188, 212, 0.2);
            --color-highlight: #80deea;
            --color-error: #ff5252;
            --color-success: #00e676;
            --font-arabic: 'Orbitron', calibri;
            --font-urdu: 'Orbitron', calibri;
            --font-Bangali: 'Orbitron', calibri;
            --font-english: 'Orbitron', calibri;
            --font-general: 'Orbitron', calibri;
            --border-radius: 4px;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-general);
            line-height: 1.6;
            color: var(--color-text-primary);
            background-color: var(--color-bg-primary);
            transition: background-color var(--transition-speed), color var(--transition-speed);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-y: scroll;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            color: var(--color-text-secondary);
            margin-bottom: 15px;
        }

        button,
        input[type="submit"],
        input[type="button"] {
            font-family: var(--font-general);
            background-color: var(--color-accent);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color var(--transition-speed), opacity var(--transition-speed);
            font-size: 1rem;
        }

        button:hover,
        input[type="submit"]:hover,
        input[type="button"]:hover {
            background-color: var(--color-accent-dark);
            opacity: 0.9;
        }

        button:focus,
        input[type="submit"]:focus,
        input[type="button"]:focus {
            outline: 2px solid var(--color-accent-dark);
            outline-offset: 2px;
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            font-family: var(--font-general);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
            width: 100%;
            max-width: 400px;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        textarea:focus,
        select:focus {
            outline: 2px solid var(--color-accent);
            border-color: var(--color-accent);
        }

        textarea {
            min-height: 150px;
            resize: vertical;
            max-width: 100%;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--color-text-secondary);
        }

        a {
            color: var(--color-accent-dark);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .container {
            display: flex;
            flex-grow: 1;
            padding: 6px 0px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .sidebar {
            width: 250px;
            margin-right: var(--padding-main);
            flex-shrink: 0;
            background-color: var(--color-bg-secondary);
            padding: 7px;
            border-radius: var(--border-radius);
            box-shadow: 0 8px 14px rgb(0 0 0);
            margin-top: -61px;
        }

        .main-content {
            flex-grow: 1;
            background-color: var(--color-bg-secondary);
            padding: var(--padding-main);
            border-radius: var(--border-radius);
            box-shadow: 0 2px 5px var(--color-shadow);
            overflow-y: auto;
        }

        header {
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
            padding: 5px var(--padding-main);
            box-shadow: 0 2px 5px var(--color-shadow);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }

        header h1 {
            margin: 0;
            font-size: 1.8rem;
            color: var(--color-text-primary);
            margin-right: 16px;
        }

        nav ul {
            list-style: none;
            padding: 0;
        }

        nav ul li {
            margin-bottom: 10px;
        }

        nav a {
            display: block;
            padding: 7px;
            background-color: var(--color-bg-primary);
            border-radius: var(--border-radius);
            color: var(--color-text-primary);
            transition: background-color var(--transition-speed), color var(--transition-speed);
            text-align: center;
            box-shadow: 0px 5px 7px;
        }

        nav a:hover,
        nav a.active {
            background-color: var(--color-accent);
            color: white;
            text-decoration: none;
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        .quran-viewer h2 {
            text-align: center;
            margin-bottom: 20px;
        }

        .ayah {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            transition: background-color var(--transition-speed);
        }

        .ayah:hover {
            background-color: var(--color-highlight);
        }

        .ayah-number {
            font-weight: bold;
            color: var(--color-accent-dark);
            margin-bottom: 10px;
            display: block;
            text-align: center;
        }

        .ayah-arabic {
            font-family: var(--font-arabic);
            font-size: 1.8rem;
            text-align: right;
            direction: rtl;
            margin-bottom: 10px;
            line-height: 2.5;
        }

        .ayah-arabic span {
            cursor: pointer;
            padding: 2px 4px;
            border-bottom: 1px dashed transparent;
            transition: background-color 0.2s, border-bottom-color 0.2s;
        }

        .ayah-arabic span:hover {
            background-color: rgba(var(--color-accent-dark-rgb, 56, 142, 60), 0.2);
            border-bottom-color: var(--color-accent-dark);
        }

        :root {
            --color-accent-dark-rgb: 56, 142, 60;
        }

        body.theme-manuscript {
            --color-accent-dark-rgb: 251, 140, 0;
        }

        body.theme-holo {
            --color-accent-dark-rgb: 0, 131, 143;
        }

        .ayah-translation {
            font-size: 1.3rem;
            color: #3b0aff;
        }

        .tafsir-editor {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--color-border);
        }

        .tafsir-editor textarea {
            width: 100%;
            max-width: 100%;
            margin-bottom: 10px;
            font-size: medium;
        }

        .theme-manager,
        .theme-linker {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
        }

        .theme-list ul {
            list-style: none;
            padding-left: 20px;
        }

        .theme-list li {
            margin-bottom: 5px;
        }

        .theme-list li span {
            cursor: pointer;
            color: var(--color-text-secondary);
            transition: color var(--transition-speed);
        }

        .theme-list li span:hover {
            color: var(--color-accent-dark);
            text-decoration: underline;
        }

        .theme-list .theme-actions button {
            padding: 3px 8px;
            font-size: 0.8rem;
            margin-left: 5px;
        }

        .root-analyzer-form {
            margin-bottom: 20px;
        }

        .root-results ul {
            list-style: none;
            padding: 0;
        }

        .root-results li {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            font-size: 1.5rem;
        }

        .recitation-log-form {
            margin-bottom: 20px;
        }

        .recitation-list ul {
            list-style: none;
            padding: 0;
        }

        .recitation-list li {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
        }

        .hifz-ayah-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: var(--border-radius);
            font-size: 0.9rem;
            margin-left: 10px;
        }

        .status-not-started {
            background-color: #e0e0e0;
            color: #424242;
        }

        .status-in-progress {
            background-color: #fff59d;
            color: #fbc02d;
        }

        .status-memorized {
            background-color: #a5d6a7;
            color: #388e3c;
        }

        .search-options label {
            display: inline-block;
            margin-right: 15px;
            font-weight: normal;
        }

        .search-results ul {
            list-style: none;
            padding: 0;
            margin-top: 20px;
        }

        .search-results li {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
        }

        .search-results .result-context {
            font-size: large;
            color: var(--color-text-secondary);
            margin-top: 5px;
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--color-bg-secondary);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 15px var(--color-shadow);
            max-width: 600px;
            width: 90%;
            position: relative;
        }

        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            color: var(--color-text-secondary);
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }

        #loading-overlay {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 1.5rem;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            display: none;
        }

        .text-center {
            text-align: center;
        }

        .mt-20 {
            margin-top: 20px;
        }

        .mb-10 {
            margin-bottom: 10px;
        }

        .mb-20 {
            margin-bottom: -3px;
        }

        .flex-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        [tabindex="0"]:focus,
        button:focus,
        input:focus,
        select:focus,
        textarea:focus,
        a:focus {
            outline: 3px solid var(--color-accent-dark);
            outline-offset: 2px;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        [dir="rtl"] .ayah-arabic,
        [dir="rtl"] .ayah-translation {
            /* text-align: right; */
        }

        [dir="rtl"] .sidebar {
            margin-right: 0;
            margin-left: var(--padding-main);
        }

        [dir="rtl"] .theme-list ul {
            padding-left: 0;
            padding-right: 20px;
        }

        [dir="rtl"] .theme-list .theme-actions button {
            margin-left: 0;
            margin-right: 5px;
        }

        [dir="rtl"] .hifz-ayah-status {
            margin-left: 0;
            margin-right: 10px;
        }

        [dir="rtl"] .search-options label {
            margin-right: 0;
            margin-left: 15px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                padding: 10px;
            }

            .sidebar {
                width: 100%;
                margin-right: 0;
                margin-bottom: 20px;
            }

            [dir="rtl"] .sidebar {
                margin-left: 0;
                margin-bottom: 20px;
            }

            .main-content {
                padding: 15px;
            }

            header {
                flex-direction: column;
                align-items: flex-start;
                padding: 10px;
            }

            header h1 {
                margin-bottom: 10px;
            }

            nav ul {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
            }

            nav ul li {
                margin-bottom: 0;
            }

            nav a {
                padding: 8px 12px;
                font-size: 0.9rem;
            }

            input[type="text"],
            input[type="number"],
            textarea,
            select {
                max-width: 100%;
            }

            .flex-group {
                flex-direction: column;
                gap: 10px;
            }

            .flex-group button,
            .flex-group input {
                width: 100%;
            }
        }

        body.theme-holo .ayah:hover {
            background: linear-gradient(90deg, rgba(0, 188, 212, 0.1) 0%, rgba(0, 188, 212, 0.05) 100%);
        }

        body.theme-holo .ayah-arabic span:hover {
            background-color: rgba(0, 188, 212, 0.3);
            border-bottom-color: var(--color-highlight);
        }

        body.theme-holo nav a.active {
            background-color: var(--color-accent);
            box-shadow: 0 0 8px var(--color-accent);
        }

        #loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            text-align: center;
            padding: 20px;
        }

        .loading-content {
            background-color: var(--color-bg-secondary, #1a2b3c);
            padding: 30px 40px;
            border-radius: var(--border-radius, 8px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
        }

        body.theme-serene .loading-content {
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
        }

        body.theme-manuscript .loading-content {
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
        }

        body.theme-holo .loading-content {
            background-color: #1a2b3c;
            color: #e0f7fa;
        }

        #loading-message-primary {
            font-size: 1.4rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #loading-message-secondary {
            font-size: 1rem;
            margin-bottom: 20px;
            min-height: 1.6em;
        }

        #loading-progress-bar-container {
            width: 100%;
            background-color: var(--color-border, #a5d6a7);
            border-radius: var(--border-radius, 8px);
            overflow: hidden;
            height: 20px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        body.theme-holo #loading-progress-bar-container {
            background-color: #26a69a;
        }

        #loading-progress-bar {
            height: 100%;
            background-color: var(--color-accent, #4caf50);
            width: 0%;
            transition: width 0.3s ease-out;
            border-radius: var(--border-radius, 8px) 0 0 var(--border-radius, 8px);
        }

        body.theme-holo #loading-progress-bar {
            background-color: var(--color-accent);
        }

        #loading-percentage {
            font-size: 1.1rem;
            font-weight: bold;
        }

        #loading-first-time-notice {
            font-size: 0.85em;
            margin-top: 15px;
            opacity: 0.8;
        }

        .view-switcher label {
            display: inline-block;
            margin-bottom: 0;
        }

        .view-switcher div>label {
            margin-left: 3px;
        }

        .root-view-content {
            display: none;
        }

        .root-view-content.active-view {
            display: block;
        }

        #root-network-graph-container {
            margin-top: 20px;
        }

        .view-switcher label {
            display: inline-block;
            margin-bottom: 0;
        }

        .view-switcher div>label {
            margin-left: 3px;
        }

        .root-view-content {
            display: none;
        }

        .root-view-content.active-view {
            display: block;
        }

        #root-network-graph-container {
            margin-top: 20px;
        }

        .custom-popup#root-node-popup {
            position: absolute;
            background-color: var(--color-bg-secondary);
            border: 1px solid var(--color-border);
            padding: 15px;
            box-shadow: 0 8px 36px black;
            display: none;
            border-radius: var(--border-radius);
            word-wrap: break-word;
            font-size: 1.1rem !important;
        }

        .custom-popup#root-node-popup h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--color-accent-dark);
            font-family: var(--font-arabic);
            font-size: 1.5rem;
        }

        .custom-popup#root-node-popup p {
            margin: 0;
            line-height: 2;
            font-size: 1.3rem;
        }

        #root-graph-placeholder {
            text-align: center;
            margin: 20px 0;
        }

        body.graph-fullscreen-active {
            overflow: hidden;
        }

        #root-network-graph-container.fullscreen-graph {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1500;
            background-color: var(--color-bg-primary);
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: stretch;
        }

        #root-network-graph-container.fullscreen-graph #root-network-graph {
            flex-grow: 1;
            border: none;
            width: 100%;
            height: 100%;
        }

        .graph-fullscreen-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 1501;
            padding: 8px 15px;
            font-size: 1.2rem;
            background-color: var(--color-error);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
        }

        #root-network-graph-container.fullscreen-graph #root-graph-pagination-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(var(--color-bg-secondary-rgb, 200, 230, 201), 0.9);
            padding: 5px 10px;
            border-radius: var(--border-radius);
            z-index: 1501;
        }

        :root {
            --color-bg-secondary-rgb: 200, 230, 201;
        }

        body.theme-manuscript {
            --color-bg-secondary-rgb: 255, 248, 220;
        }

        body.theme-holo {
            --color-bg-secondary-rgb: 26, 43, 60;
        }

        div#root-node-popup {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            font-family: var(--font-arabic) !important;
            direction: rtl !important;
            text-align: right !important;
            z-index: 214748364799999999999999999999999999999999999999999999999999999999999999 !important;
        }

        button#launchFullScreenReaderBtnEnhanced {
            position: absolute;
            right: 23px;
            top: 6px;
        }

        button#quitGameButton {
            position: fixed;
            bottom: 1px;
            left: 3px;
        }

        #fsReaderSettingsPanel>div:nth-child(2)>label:nth-child(7) {
            display: none;
        }

        span.item-surah-ayah.theme-modal-ayah-link {
            cursor: pointer;
        }

        /* ========================================================= */
        /* --- FINAL HAMBURGER MENU & SIDEBAR STYLES --- */
        /* ========================================================= */
        /* --- Default Hamburger Icon State (Hidden on Desktop) --- */
        #hamburger-btn {
            display: none;
            position: relative;
            width: 30px;
            height: 22px;
            background: none;
            border: none;
            cursor: pointer;
            z-index: 1010;
            margin-right: 15px;
        }

        #hamburger-btn span {
            display: block;
            position: absolute;
            height: 3px;
            width: 100%;
            background: var(--color-text-primary);
            border-radius: 2px;
            left: 0;
        }

        #hamburger-btn span:nth-child(1) {
            top: 0px;
        }

        #hamburger-btn span:nth-child(2) {
            top: 9px;
        }

        #hamburger-btn span:nth-child(3) {
            top: 18px;
        }

        /* --- Hidden Overlay --- */
        #sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        /* --- Mobile-Only Overrides --- */
        @media (max-width: 768px) {
            #hamburger-btn {
                display: block !important;
            }

            /* By default on mobile, HIDE the sidebar completely */
            .sidebar {
                display: none !important;
            }

            /* When body.sidebar-open is active, FORCE the sidebar to appear */
            body.sidebar-open .sidebar {
                display: block !important;
                position: fixed;
                left: 0;
                top: 0;
                width: 280px;
                height: 100%;
                z-index: 1000;
                margin: 0;
                overflow-y: auto;
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
                background-color: var(--color-bg-secondary);
            }

            /* Show the overlay when the sidebar is open */
            body.sidebar-open #sidebar-overlay {
                display: block !important;
            }
        }

        button#fsReaderBookmarkBtn {
            margin-right: 3px;
        }

        .tajweed.ham_wasl,
        .tajweed.slnt,
        .tajweed.laam_shamsiyah {
            color: #AAAAAA;
        }

        .tajweed.madda_normal {
            color: #537FFF;
        }

        .tajweed.madda_permissible {
            color: #4050FF;
        }

        .tajweed.madda_necessary {
            color: #0000FF;
        }

        .tajweed.qalqalah {
            color: #DD0000;
        }

        .tajweed.madda_obligatory {
            color: #FF0000;
        }

        .tajweed.ikhafa_shafawi {
            color: #D500B4;
        }

        .tajweed.ikhafa {
            color: #9400A8;
        }

        .tajweed.idgham_shafawi {
            color: #58B800;
        }

        .tajweed.idgham_wo_ghunnah {
            color: #169200;
        }

        .tajweed.idgham_ghunnah {
            color: #169200;
        }

        .tajweed.iqlab {
            color: #26BFFD;
        }

        .tajweed.ghunnah {
            color: #FF7D7D;
        }

        span.end {
            display: none;
        }

        @font-face {
            font-family: "KFGQPC Uthman Taha Naskh";
            src: url("https://db.onlinewebfonts.com/t/f0034555c887b9dbfb67c6fd228d8f33.eot");
            src: url("https://db.onlinewebfonts.com/t/f0034555c887b9dbfb67c6fd228d8f33.eot?#iefix")format("embedded-opentype"),
                url("https://db.onlinewebfonts.com/t/f0034555c887b9dbfb67c6fd228d8f33.woff2")format("woff2"),
                url("https://db.onlinewebfonts.com/t/f0034555c887b9dbfb67c6fd228d8f33.woff")format("woff"),
                url("https://db.onlinewebfonts.com/t/f0034555c887b9dbfb67c6fd228d8f33.ttf")format("truetype"),
                url("https://db.onlinewebfonts.com/t/f0034555c887b9dbfb67c6fd228d8f33.svg#KFGQPC Uthman Taha Naskh")format("svg");
        }

        /* Add these new rules for the Word-by-Word table */
        .word-by-word-options {
            margin-top: 20px;
        }

        #wordByWordLanguageOptions {
            padding-left: 25px;
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Styles for the table in the generated image */
        .word-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 1.2em;
            /* Base size for the table */
        }

        .word-table th,
        .word-table td {
            border: 1px solid var(--color-border);
            padding: 8px 12px;
            text-align: center;
            vertical-align: middle;
        }

        .word-table th {
            background-color: var(--color-bg-secondary);
            color: var(--color-text-secondary);
            font-weight: bold;
        }

        .word-table .arabic-word-cell {
            font-family: var(--font-arabic);
            font-size: 1.5em;
            /* Make Arabic words larger */
            direction: rtl;
        }

        button.generate-image-btn {
            padding: 5px;
            margin-top: 18px;
        }
    </style>
    <!-- Optional: Include fonts if not available locally -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- <link href="https://fonts.googleapis.com/css2?family=Mada:wght@200..900&display=swap" rel="stylesheet"> -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Mirza:wght@700&display=swap');
    </style>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Scheherazade+New:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Jameel+Noori+Nastaleeq&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Nastaliq+Urdu&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+Bangali&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lateef&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Naskh+Arabic:wght@400;700&display=swap">
</head>

<body dir="ltr"> <!-- Default direction, will be set dynamically if needed -->

    <!-- Modal for Ayah Image Generation (UPDATED) -->
    <div id="ayahImageModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="ayahImageModalTitle">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.style.display='none'">×</span>
            <h3 id="ayahImageModalTitle">Generate Ayah Image</h3>

            <!-- Section for Full Ayah Translations -->
            <p><strong>Step 1:</strong> Select which full-ayah translations to include:</p>
            <div id="imageTranslationOptions">
                <!-- Checkboxes will be populated here by JavaScript -->
            </div>

            <!-- NEW Section for Word-by-Word Table -->
            <div class="word-by-word-options">
                <p><strong>Step 2:</strong> Add a word-by-word translation table (optional):</p>
                <label>
                    <input type="checkbox" id="includeWordByWordTable"> Include Word-by-Word Table
                </label>
                <div id="wordByWordLanguageOptions" style="display: none;">
                    <p style="margin-bottom: 5px; font-size: 0.9em;">Select languages for the table:</p>
                    <!-- Language choices for the table will be populated here -->
                </div>
            </div>

            <button id="createImageBtn" style="margin-top: 25px;">Create & Download Image</button>
        </div>
    </div>
    <div id="sidebar-overlay"></div>
    <div id="loading-overlay">
        <div class="loading-content">
            <div id="loading-message-primary">Loading Quran data...</div>
            <div id="loading-message-secondary">Initializing...</div>
            <div id="loading-progress-bar-container">
                <div id="loading-progress-bar" style="width: 0%;"></div>
            </div>
            <div id="loading-percentage">0%</div>
            <div id="loading-first-time-notice" style="font-size: 0.9em; margin-top: 10px;">
                (Loads slow first time or after update. After that, it opens quickly.)
                <br />
                <span dir="rtl">
                    (پہلی بار یا اپ ڈیٹ کے بعد ایپ تھوڑا وقت لے گا، اگلی بار فوراً کھلے گا۔)
                </span>
            </div>
        </div>
    </div>
    <header>
        <button id="hamburger-btn" aria-label="Open menu"><span></span><span></span><span></span></button>
        <h1>Nur Al-Quran Studio Offline</h1>
        <div class="header-controls">
            <label for="theme-switcher" class="sr-only">Choose Theme</label>
            <select id="theme-switcher" aria-label="Choose Theme">
                <option value="serene">Serene Digital Mosque</option>
                <option value="manuscript">Ancient Illuminated Manuscript</option>
                <option value="holo">Futuristic Holo-Quran</option>
            </select>
        </div>
    </header>
    <div class="container">
        <aside class="sidebar">
            <nav>
                <ul>
                    <li><a href="#quran" class="nav-link active" data-section="quran">Quran Viewer</a></li>
                    <li><a href="#tafsir" class="nav-link" data-section="tafsir">Personal Tafsir</a></li>
                    <li><a href="#themes" class="nav-link" data-section="themes">Thematic Linker</a></li>
                    <li><a href="#roots" class="nav-link" data-section="roots">Root Word Analyzer</a></li>
                    <li><a href="#recitation" class="nav-link" data-section="recitation">Recitation Log</a></li>
                    <li><a href="#hifz" class="nav-link" data-section="hifz">Memorization Hub</a></li>
                    <li><a href="#search" class="nav-link" data-section="search">Advanced Search</a></li>
                    <li><a href="#data" class="nav-link" data-section="data">Data Management</a></li>
                </ul>
            </nav>
        </aside>
        <main class="main-content">
            <section id="quran" class="section active" role="region" aria-labelledby="quran-heading">
                <h2 id="quran-heading">Quran Viewer</h2>
                <div class="quran-controls flex-group mb-20">
                    <label for="surah-select" class="sr-only">Select Surah</label>
                    <select id="surah-select" aria-label="Select Surah"></select>
                    <label for="ayah-select" class="sr-only">Select Ayah</label>
                    <select id="ayah-select" aria-label="Select Ayah"></select>
                </div>
                <div class="quran-controls flex-group mb-20">
                    <label>View Mode:</label>
                    <label><input type="radio" name="quran-view-mode" value="single" checked> Single Ayah</label>
                    <label><input type="radio" name="quran-view-mode" value="continuous"> Continuous</label>
                </div>
                <div class="quran-controls flex-group mb-20">
                    <label for="translation-select" class="sr-only">Select Translation</label>
                    <select id="translation-select" aria-label="Select Translation">
                        <option value="urdu">Urdu (Included)</option>
                        <option value="english">English (Included)</option>
                        <option value="Bangali">Bangali (Included)</option>
                        <option value="pashto">Pashto (Included)</option>
                    </select>
                </div>
                <div id="quran-display" class="quran-viewer" lang="ar" dir="rtl">
                    <!-- Quran Ayahs will be loaded here -->
                    <p class="text-center">Select a Surah and Ayah to start.</p>
                </div>
                <div id="quran-continuous-display" class="quran-viewer" style="display:none;" lang="ar" dir="rtl"></div>
                <div id="word-translation-area" class="mt-20">
                    <!-- Word translation or full ayah translation on word click -->
                    <p class="text-center">Click on an Arabic word to see its translation.</p>
                </div>
            </section>
            <section id="tafsir" class="section" role="region" aria-labelledby="tafsir-heading">
                <h2 id="tafsir-heading">Personal Tafsir Builder</h2>
                <p>Write your notes and reflections for the current Ayah.</p>
                <div id="current-ayah-tafsir" class="ayah mb-20">
                    <!-- Current Ayah will be displayed here -->
                    <p class="text-center">Navigate to an Ayah in the Quran Viewer to add Tafsir.</p>
                </div>
                <div class="tafsir-editor">
                    <label for="tafsir-notes">Your Tafsir Notes:</label>
                    <textarea id="tafsir-notes"
                        placeholder="Enter your personal notes, interpretations, and reflections here..."></textarea>
                    <button id="save-tafsir-btn">Save Tafsir</button>
                    <p id="tafsir-status" aria-live="polite"></p>
                </div>
            </section>
            <section id="themes" class="section" role="region" aria-labelledby="themes-heading">
                <h2 id="themes-heading">Thematic Linker Pro</h2>
                <p>Create and manage themes, and link Ayahs to them.</p>
                <div class="theme-manager mb-20">
                    <h3>Manage Themes</h3>
                    <div class="flex-group mb-10">
                        <label for="new-theme-name" class="sr-only">New Theme Name</label>
                        <input type="text" id="new-theme-name" placeholder="New Theme Name">
                        <label for="parent-theme-select" class="sr-only">Parent Theme (Optional)</label>
                        <select id="parent-theme-select" aria-label="Parent Theme (Optional)">
                            <option value="">-- No Parent --</option>
                            <!-- Options populated by JS -->
                        </select>
                        <button id="add-theme-btn">Add Theme</button>
                    </div>
                    <div class="theme-list">
                        <h4>Existing Themes</h4>
                        <ul id="themes-list">
                            <!-- Themes populated by JS -->
                            <li>No themes added yet.</li>
                        </ul>
                    </div>
                    <p id="theme-manager-status" aria-live="polite"></p>
                </div>
                <div class="theme-linker">
                    <h3>Link Current Ayah (<span id="current-ayah-theme-ref">N/A</span>)</h3>
                    <div id="current-ayah-theme-text" class="ayah mb-20">
                        <!-- Current Ayah text will be displayed here -->
                        <p class="text-center">Navigate to an Ayah in the Quran Viewer to link themes.</p>
                    </div>
                    <label for="link-theme-select">Select Theme to Link:</label>
                    <select id="link-theme-select" aria-label="Select Theme to Link">
                        <option value="">-- Select Theme --</option>
                        <!-- Options populated by JS -->
                    </select>
                    <label for="theme-link-notes">Notes for this link (Optional):</label>
                    <textarea id="theme-link-notes"
                        placeholder="Notes on why this Ayah relates to this theme..."></textarea>
                    <button id="link-ayah-to-theme-btn">Link Ayah</button>
                    <p id="theme-linker-status" aria-live="polite"></p>
                    <h4 class="mt-20">Ayahs Linked to Selected Theme: <span id="linked-theme-name">N/A</span></h4>
                    <ul id="linked-ayahs-list">
                        <!-- Linked ayahs populated by JS -->
                        <li>Select a theme above to see linked ayahs.</li>
                    </ul>
                </div>
            </section>
            <section id="roots" class="section" role="region" aria-labelledby="roots-heading">
                <h2 id="roots-heading">Root Word Analyzer & Concordance</h2>
                <p>Input an Arabic root word to find occurrences in the Quran.</p>
                <div class="root-analyzer-form mb-20">
                    <div class="flex-group mb-10">
                        <label for="root-input" class="sr-only">Arabic Root Word</label>
                        <input type="text" id="root-input"
                            placeholder="Enter Arabic Root (e.g., ق-و-ل) or (ع ل م) or (ر۔ب)" lang="ar" dir="rtl">
                        <button id="analyze-root-btn">Analyze Root</button>
                    </div>
                    <label for="root-description">Description/Notes for this Root (Optional):</label>
                    <textarea id="root-description" placeholder="Your notes on this root's meaning..."></textarea>
                    <button id="save-root-notes-btn">Save Root Notes</button>
                    <p id="root-status" aria-live="polite"></p>
                </div>
                <!-- View Switcher -->
                <div class="view-switcher mb-10 flex-group" style="justify-content: flex-start;">
                    <label style="margin-bottom:0;">View Mode: </label>
                    <div>
                        <input type="radio" id="root-view-list" name="root-view-mode" value="list" checked>
                        <label for="root-view-list" style="margin-right: 10px; font-weight:normal;">List</label>
                    </div>
                    <div>
                        <input type="radio" id="root-view-tree" name="root-view-mode" value="tree">
                        <label for="root-view-tree" style="font-weight:normal;">Tree Graph</label>
                    </div>
                </div>
                <div class="root-results">
                    <h3>Occurrences Found for: <span id="analyzed-root-term">N/A</span></h3>
                    <!-- List View Container -->
                    <ul id="root-occurrences-list" class="root-view-content active-view">
                        <li>Enter a root word and click "Analyze Root".</li>
                    </ul>
                    <!-- Tree View Container -->
                    <div id="root-network-graph-container" class="root-view-content" style="display: none;">
                        <p id="root-graph-placeholder" class="text-center" style="display:none; margin: 20px 0;">Graph
                            will appear here after analysis.</p>
                        <div id="root-network-graph"
                            style="width: 100%; height: 500px; border: 1px solid var(--color-border);"></div>
                        <!-- Pagination Controls for Graph -->
                        <div id="root-graph-pagination-controls" class="flex-group mt-10"
                            style="justify-content: center; display: none;">
                            <button id="prev-root-graph-page-btn" disabled>« Previous</button>
                            <span id="root-graph-page-info" style="margin: 0 15px; font-weight: normal;">Page 1 of
                                1</span>
                            <button id="next-root-graph-page-btn" disabled>Next »</button>
                        </div>
                    </div>
                </div>
                <!-- Custom Popup for Vis.js Graph Nodes -->
                <div id="root-node-popup" class="custom-popup"
                    style="font-family: var(--font-arabic); direction: rtl; text-align: right;">
                    <!-- Popup content will be injected here by JavaScript -->
                </div>
            </section>
            <section id="recitation" class="section" role="region" aria-labelledby="recitation-heading">
                <h2 id="recitation-heading">Comparative Recitation Log</h2>
                <p>Log your listening sessions to different Qaris.</p>
                <div class="recitation-log-form mb-20">
                    <h3>Add Log Entry</h3>
                    <div class="flex-group mb-10">
                        <label for="rec-surah-select" class="sr-only">Surah</label>
                        <select id="rec-surah-select" aria-label="Surah"></select>
                        <label for="rec-ayah-start" class="sr-only">Ayah Start</label>
                        <input type="number" id="rec-ayah-start" required placeholder="Ayah Start" min="1">
                        <label for="rec-ayah-end" class="sr-only">Ayah End</label>
                        <input type="number" id="rec-ayah-end" required placeholder="Ayah End" min="1">
                    </div>
                    <div class="flex-group mb-10">
                        <label for="rec-qari" class="sr-only">Qari/Source</label>
                        <input type="text" id="rec-qari"
                            placeholder="Qari or Source (e.g., Mishary Alafasy, Local Masjid Imam)">
                        <label for="rec-date" class="sr-only">Date</label>
                        <input type="date" id="rec-date" aria-label="Date">
                    </div>
                    <label for="rec-notes">Notes (Tajweed, Style, Impact):</label>
                    <textarea id="rec-notes" placeholder="Notes on Tajweed, style, emotional impact..."></textarea>
                    <button id="save-recitation-btn">Save Log Entry</button>
                    <p id="recitation-status" aria-live="polite"></p>
                </div>
                <div class="recitation-list">
                    <h3>Log Entries</h3>
                    <ul id="recitations-list">
                        <!-- Log entries populated by JS -->
                        <li>No entries logged yet.</li>
                    </ul>
                </div>
            </section>
            <section id="hifz" class="section" role="region" aria-labelledby="hifz-heading">
                <h2 id="hifz-heading">Memorization Hub</h2>
                <p>Track your Hifz progress and review schedule.</p>
                <div class="hifz-controls flex-group mb-20">
                    <label for="hifz-surah-select" class="sr-only">Select Surah for Hifz</label>
                    <select id="hifz-surah-select" aria-label="Select Surah for Hifz"></select>
                </div>
                <div id="hifz-ayahs-list">
                    <!-- List of ayahs for the selected surah with status/controls -->
                    <p class="text-center">Select a Surah to track Hifz progress.</p>
                </div>
                <p id="hifz-status" aria-live="polite"></p>
            </section>
            <section id="search" class="section" role="region" aria-labelledby="search-heading">
                <h2 id="search-heading">Advanced Search</h2>
                <p>Search across Quran text, translations, and your personal data.</p>
                <div class="search-form mb-20">
                    <label for="search-input" class="sr-only">Search Term</label>
                    <input type="text" id="search-input" placeholder="Enter search term">
                    <div class="search-options mb-10" role="group" aria-label="Search Scope">
                        <label><input type="checkbox" class="search-scope" value="quran-arabic" checked> Quran
                            Arabic</label>
                        <label><input type="checkbox" class="search-scope" value="quran-translation" checked> Quran
                            Translation</label>
                        <label><input type="checkbox" class="search-scope" value="tafsir"> Personal Tafsir</label>
                        <label><input type="checkbox" class="search-scope" value="themes"> Theme Notes</label>
                        <label><input type="checkbox" class="search-scope" value="roots"> Root Notes</label>
                        <label><input type="checkbox" class="search-scope" value="recitation"> Recitation Notes</label>
                        <label><input type="checkbox" class="search-scope" value="hifz"> Hifz Notes</label>
                    </div>
                    <button id="perform-search-btn">Search</button>
                    <p id="search-status" aria-live="polite"></p>
                </div>
                <div class="search-results">
                    <h3>Search Results</h3>
                    <ul id="search-results-list">
                        <!-- Search results populated by JS -->
                        <li>Enter a search term and click "Search".</li>
                    </ul>
                </div>
            </section>
            <section id="data" class="section" role="region" aria-labelledby="data-heading">
                <h2 id="data-heading">Data Management</h2>
                <p>Manage your personal data (Tafsir, Themes, Roots, Logs, Hifz).</p>
                <div class="settings-section mb-20">
                    <h3>Backup Data</h3>
                    <p>Export your personal data as a JSON file.</p>
                    <button id="export-data-btn">Export Data</button>
                    <p id="export-status" aria-live="polite"></p>
                </div>
                <div class="settings-section mb-20">
                    <h3>Restore Data</h3>
                    <p>Import your personal data from a JSON file. This will overwrite existing data.</p>
                    <label for="import-file" class="sr-only">Choose JSON file to import</label>
                    <input type="file" id="import-file" accept="application/json">
                    <button id="import-data-btn" disabled>Import Data</button>
                    <p id="import-status" aria-live="polite"></p>
                </div>
                <div class="settings-section">
                    <h3>Clear All Personal Data</h3>
                    <p class="mb-10" style="color: var(--color-error);">Warning: This will permanently delete ALL your
                        personal Tafsir, Themes, Roots, Logs, and Hifz data.</p>
                    <button id="clear-data-btn" style="background-color: var(--color-error);">Clear All Data</button>
                    <p id="clear-status" aria-live="polite"></p>
                </div>
                <div class="settings-section mb-20">
                    <h3>Export Personal Tafsir to Word (.docx)</h3>
                    <p>Generates a .docx file of all your Tafsir notes (basic styling).</p>
                    <button id="export-tafsir-to-docx-btn">Export Tafsir to .docx</button>
                    <p id="export-tafsir-docx-status" aria-live="polite"></p>
                </div>
            </section>
        </main>
    </div>
    <!-- Modal for Theme Ayahs -->
    <div id="themeAyahsModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="themeAyahsModalTitle">
        <div class="modal-content">
            <span class="close-button" aria-label="Close Theme Ayahs Modal">&times;</span>
            <h3 id="themeAyahsModalTitle">Ayahs Linked to Theme: <span id="modal-theme-name"></span></h3>
            <ul id="modal-linked-ayahs-list">
                <!-- Linked ayahs populated here -->
            </ul>
        </div>
    </div>
    <!-- Modal for Root Occurrences -->
    <div id="rootOccurrencesModal" class="modal" role="dialog" aria-modal="true"
        aria-labelledby="rootOccurrencesModalTitle">
        <div class="modal-content">
            <span class="close-button" aria-label="Close Root Occurrences Modal">&times;</span>
            <h3 id="rootOccurrencesModalTitle">Occurrences for Root: <span id="modal-root-term"></span></h3>
            <ul id="modal-root-occurrences-list">
                <!-- Root occurrences populated here -->
            </ul>
        </div>
    </div>
    <script>
        const DB_NAME = 'NurAlQuranStudioDBz';
        const DB_VERSION = 8; // << UPDATED for new word_metadata store and word_translations key
        let db;
        let rootNetwork = null; // To hold the vis.js network instance
        let rootNodePopupEl = null; // To hold the popup DOM element
        let activeRootNodeIdForPopup = null; // Track which node's popup is open
        let allRootOccurrencesCache = []; // To store all occurrences for the current analyzed root
        let currentRootGraphPage = 1;
        const rootGraphItemsPerPage = 20; // Number of occurrence nodes per page
        const STORE_QURAN = 'quran';
        const STORE_TAFSIR = 'tafsir';
        const STORE_THEMES = 'themes';
        const STORE_THEME_AYAHS = 'theme_ayahs';
        const STORE_ROOTS = 'roots';
        const STORE_ROOT_AYAHS = 'root_ayahs';
        const STORE_RECITATIONS = 'recitations';
        const STORE_HIFZ = 'hifz';
        const STORE_SETTINGS = 'settings';
        const STORE_WORD_TRANSLATIONS = 'word_translations'; // Keyed by word_id
        const STORE_WORD_METADATA = 'word_metadata';         // Keyed by word_id, indexed by location
        let totalProgressUnits = 0;
        let completedProgressUnits = 0;
        const WORD_TRANSLATION_FILE = 'data5 new.AM'; // Contains word_id, ur_meaning, en_meaning
        const WORD_METADATA_FILE = 'word2.AM';       // Contains word_id, surah, ayah, word_postion
        let currentSurah = 1;
        let currentAyah = 1;
        let totalAyahsInSurah = 7; // Default for Surah 1
        let quranDataLoaded = false;
        const juzStartSurahs = [0, 1, 2, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 20, 21, 22, 23, 25, 26, 27, 29, 33, 36, 39, 41, 46, 51, 58, 67, 78]; // Example: Surah where Juz N+1 starts
        const juzStartAyahs = [0, 1, 142, 253, 93, 24, 148, 82, 111, 41, 88, 93, 6, 53, 1, 1, 75, 1, 1, 56, 47, 31, 28, 36, 46, 60, 31, 1, 31, 28, 22, 47, 1, 31, 1, 1, 1]; // Example: Ayah where Juz N+1 starts (for the surah above)
        const juzBoundariesData = [
            { juz: 1, name: "Alif laam meem (آلم)", startSurah: 1, startAyah: 1 },
            { juz: 2, name: "Sayaqulu (سَيَقُولُ)", startSurah: 2, startAyah: 142 },
            { juz: 3, name: "Tilka r Rusulu (تِلْكَ الرُّسُلُ)", startSurah: 2, startAyah: 253 },
            { juz: 4, name: "Lan Tana Loo (لَنْ تَنَالُوا)", startSurah: 3, startAyah: 93 }, // 92 in some, 93 in others. Using 93 as per some common divisions.
            { juz: 5, name: "Wal Mohsanat (وَالْمُحْصَنَاتُ)", startSurah: 4, startAyah: 24 },
            { juz: 6, name: "La Yahubbullah (لَا يُحِبُّ اللَّهُ)", startSurah: 4, startAyah: 148 },
            { juz: 7, name: "Wa Iza Samiu (وَإِذَا سَمِعُوا)", startSurah: 5, startAyah: 82 }, // some say 83
            { juz: 8, name: "Wa Lau Annana (وَلَوْ أَنَّنَا)", startSurah: 6, startAyah: 111 },
            { juz: 9, name: "Qalal Malao (قَالَ الْمَلَأُ)", startSurah: 7, startAyah: 88 },
            { juz: 10, name: "Wa A'lamu (وَاعْلَمُوا)", startSurah: 8, startAyah: 41 },
            { juz: 11, name: "Yatazeroon (يَعْتَذِرُونَ)", startSurah: 9, startAyah: 93 }, // some say 94
            { juz: 12, name: "Wa Mamin Da'abat (وَمَا مِنْ دَابَّةٍ)", startSurah: 11, startAyah: 6 },
            { juz: 13, name: "Wa Ma Ubiroo (وَمَا أُبَرِّئُ)", startSurah: 12, startAyah: 53 },
            { juz: 14, name: "Rubama (رُبَمَا)", startSurah: 15, startAyah: 1 }, // Al-Hijr
            { juz: 15, name: "Subhanallazi (سُبْحَانَ الَّذِي)", startSurah: 17, startAyah: 1 }, // Al-Isra
            { juz: 16, name: "Qal Alam (قَالَ أَلَمْ)", startSurah: 18, startAyah: 75 }, // Al-Kahf
            { juz: 17, name: "Aqtarabo (اقْتَرَبَ لِلنَّاسِ)", startSurah: 21, startAyah: 1 }, // Al-Anbiya
            { juz: 18, name: "Qadd Aflaha (قَدْ أَفْلَحَ)", startSurah: 23, startAyah: 1 }, // Al-Mu'minun
            { juz: 19, name: "Wa Qalallazina (وَقَالَ الَّذِينَ)", startSurah: 25, startAyah: 21 }, // Al-Furqan
            { juz: 20, name: "A'man Khalaq (أَمَّنْ خَلَقَ)", startSurah: 27, startAyah: 56 }, // An-Naml (some 60)
            { juz: 21, name: "Utlu Ma Oohi (اتْلُ مَا أُوحِيَ)", startSurah: 29, startAyah: 46 }, // Al-'Ankabut
            { juz: 22, name: "Wa Manyaqnut (وَمَنْ يَقْنُتْ)", startSurah: 33, startAyah: 31 }, // Al-Ahzab
            { juz: 23, name: "Wa Mali (وَمَا لِيَ)", startSurah: 36, startAyah: 28 }, // Ya-Sin (some 22)
            { juz: 24, name: "Faman Azlam (فَمَنْ أَظْلَمُ)", startSurah: 39, startAyah: 32 }, // Az-Zumar
            { juz: 25, name: "Elahe Yuruddo (إِلَيْهِ يُرَدُّ)", startSurah: 41, startAyah: 47 }, // Fussilat
            { juz: 26, name: "Ha'a Meem (حم)", startSurah: 46, startAyah: 1 }, // Al-Ahqaf
            { juz: 27, name: "Qala Fama Khatbukum (قَالَ فَمَا خَطْبُكُمْ)", startSurah: 51, startAyah: 31 }, // Adh-Dhariyat
            { juz: 28, name: "Qadd Sami Allah (قَدْ سَمِعَ اللَّهُ)", startSurah: 58, startAyah: 1 }, // Al-Mujadila
            { juz: 29, name: "Tabarakallazi (تَبَارَكَ الَّذِي)", startSurah: 67, startAyah: 1 }, // Al-Mulk
            { juz: 30, name: "Amma Yatasa'aloon (عَمَّ يَتَسَاءَلُونَ)", startSurah: 78, startAyah: 1 } // An-Naba
        ];
        const staticQuranicThemes = [
            { id: 'static_01', name: "Ayat al-Kursi (Verse of the Throne)", exampleSurah: 2, exampleAyah: 255, description: "Greatest verse, protection, affirmation of Allah's sovereignty." },
            { id: 'static_02', name: "Surah Al-Fatihah (The Opening)", exampleSurah: 1, exampleAyah: 1, description: "Essence of the Quran, recited in every prayer." },
            { id: 'static_03', name: "Surah Yasin (Heart of the Quran)", exampleSurah: 36, exampleAyah: 1, description: "Recited for blessings, ease, and for the deceased." },
            { id: 'static_04', name: "Surah Al-Mulk (The Dominion - Protector from Grave)", exampleSurah: 67, exampleAyah: 1, description: "Recited for protection from torment of the grave." },
            { id: 'static_05', name: "Surah Al-Waqi'ah (The Inevitable - Sustenance)", exampleSurah: 56, exampleAyah: 1, description: "Recited for protection against poverty and for sustenance." },
            { id: 'static_06', name: "Surah Ar-Rahman (The Most Merciful - Bride of Quran)", exampleSurah: 55, exampleAyah: 1, description: "Highlights Allah's bounties and mercy." },
            { id: 'static_07', name: "Surah Al-Kahf (The Cave - Protection from Dajjal)", exampleSurah: 18, exampleAyah: 1, description: "Recited on Fridays, protection from Dajjal, stories of guidance." },
            { id: 'static_08', name: "Last two Ayahs of Surah Al-Baqarah", exampleSurah: 2, exampleAyah: 285, description: "Sufficient for protection and blessings if recited at night." },
            { id: 'static_09', name: "Surah Al-Ikhlas (Sincerity - Equals 1/3rd Quran)", exampleSurah: 112, exampleAyah: 1, description: "Pure monotheism, immense reward." },
            { id: 'static_10', name: "Surah Al-Falaq (The Daybreak - Protection)", exampleSurah: 113, exampleAyah: 1, description: "Seeking refuge from evil." },
            { id: 'static_11', name: "Surah An-Nas (Mankind - Protection)", exampleSurah: 114, exampleAyah: 1, description: "Seeking refuge from whispers of Shaytan." },
            { id: 'static_12', name: "Ayah for seeking Forgiveness (Syed-ul-Istighfar concept)", exampleSurah: 3, exampleAyah: 135, description: "Verses encouraging repentance and seeking forgiveness." }, // Rabbana zalamna anfusana
            { id: 'static_13', name: "Dua of Yunus (AS) / Ayat-e-Karima", exampleSurah: 21, exampleAyah: 87, description: "For relief from distress: La ilaha illa anta subhanaka inni kuntu minaz-zalimin." },
            { id: 'static_14', name: "Verse of Light (Ayat an-Nur)", exampleSurah: 24, exampleAyah: 35, description: "Metaphorical description of Allah's light and guidance." },
            { id: 'static_15', name: "Four Quls (Al-Kafirun, Al-Ikhlas, Al-Falaq, An-Nas)", exampleSurah: 109, exampleAyah: 1, description: "Collective term for these four protective Surahs." }, // Starts with Al-Kafirun
            { id: 'static_16', name: "Guidance in Decision Making (Istikhara concept)", exampleSurah: 2, exampleAyah: 216, description: "Trusting Allah's knowledge in what is good/bad for us." },
            { id: 'static_17', name: "Marriage and Family", exampleSurah: 30, exampleAyah: 21, description: "Signs of Allah in creating spouses for tranquility and affection." },
            { id: 'static_18', name: "Dealing with Grief and Loss", exampleSurah: 2, exampleAyah: 156, description: "Inna lillahi wa inna ilayhi raji'un - Turning to Allah in times of calamity." },
            { id: 'static_19', name: "Financial Dealings & Charity", exampleSurah: 2, exampleAyah: 261, description: "Parable of those who spend in Allah's way." },
            { id: 'static_20', name: "Good Conduct and Speech", exampleSurah: 17, exampleAyah: 53, description: "Speak that which is best." },
            { id: 'static_21', name: "Patience in Adversity", exampleSurah: 39, exampleAyah: 10, description: "The patient will be given their reward without account." },
            { id: 'static_22', name: "Seeking Knowledge", exampleSurah: 20, exampleAyah: 114, description: "Rabbi zidni ilma - My Lord, increase me in knowledge." },
            { id: 'static_23', name: "Respect for Parents", exampleSurah: 17, exampleAyah: 23, description: "Decree to not worship except Him, and to parents, good treatment." },
            { id: 'static_24', name: "Maintaining Ties of Kinship", exampleSurah: 4, exampleAyah: 1, description: "Fear Allah through whom you demand your mutual rights, and reverence the wombs." },
            { id: 'static_25', name: "Trust in Allah (Tawakkul)", exampleSurah: 65, exampleAyah: 3, description: "And whoever relies upon Allah - then He is sufficient for him." },
            { id: 'static_26', name: "Prohibition of Backbiting & Slander", exampleSurah: 49, exampleAyah: 12, description: "Avoid suspicion, do not spy or backbite each other." },
            { id: 'static_27', name: "Importance of Justice", exampleSurah: 5, exampleAyah: 8, description: "Be just; that is nearer to righteousness." },
            { id: 'static_28', name: "Humility", exampleSurah: 25, exampleAyah: 63, description: "Servants of the Most Merciful are those who walk upon the earth easily..." },
            { id: 'static_29', name: "Gratitude for Blessings", exampleSurah: 16, exampleAyah: 114, description: "So eat of what Allah has provided you lawful and good and be grateful for the favor of Allah." },
            { id: 'static_30', name: "Remembrance of Allah (Dhikr)", exampleSurah: 13, exampleAyah: 28, description: "Unquestionably, by the remembrance of Allah hearts are assured." },
            { id: 'static_31', name: "Overcoming Anxiety & Stress", exampleSurah: 94, exampleAyah: 5, description: "For indeed, with hardship [will be] ease." }, // Surah Ash-Sharh
            { id: 'static_32', name: "The Power of Dua (Supplication)", exampleSurah: 40, exampleAyah: 60, description: "And your Lord says, 'Call upon Me; I will respond to you.'" },
            { id: 'static_33', name: "Warning Against Arrogance", exampleSurah: 31, exampleAyah: 18, description: "And do not turn your cheek [in contempt] toward people..." },
            { id: 'static_34', name: "Importance of Consultation (Shura)", exampleSurah: 42, exampleAyah: 38, description: "...and whose affair is [determined by] consultation among themselves..." },
            { id: 'static_35', name: "Forgiving Others", exampleSurah: 64, exampleAyah: 14, description: "...but if you pardon and overlook and forgive - then indeed, Allah is Forgiving and Merciful." },
            { id: 'static_36', name: "Unity of the Ummah", exampleSurah: 3, exampleAyah: 103, description: "And hold firmly to the rope of Allah all together and do not become divided." },
            { id: 'static_37', name: "The Brevity of Worldly Life", exampleSurah: 57, exampleAyah: 20, description: "Know that the life of this world is but amusement and diversion..." },
            { id: 'static_38', name: "Reward for Good Deeds", exampleSurah: 99, exampleAyah: 7, description: "So whoever does an atom's weight of good will see it." },
            { id: 'static_39', name: "Call to Reflection (Tadabbur)", exampleSurah: 47, exampleAyah: 24, description: "Then do they not reflect upon the Qur'an, or are there locks upon [their] hearts?" },
            { id: 'static_40', name: "Friday Prayer (Jumu'ah)", exampleSurah: 62, exampleAyah: 9, description: "O you who have believed, when the adhan is called for the prayer on the day of Jumu'ah..." }
        ];
        function getJuzFromSurahAyah(surah, ayah) {
            if (isNaN(surah) || isNaN(ayah) || surah < 1 || ayah < 1) return 1; // Default for invalid input
            for (let i = juzBoundariesData.length - 1; i >= 0; i--) {
                const boundary = juzBoundariesData[i];
                if (surah > boundary.startSurah || (surah === boundary.startSurah && ayah >= boundary.startAyah)) {
                    return boundary.juz;
                }
            }
            return 1; // Should not happen if data is correct and input is valid Quran range
        }
        const surahNames = [
            "Al-Fatihah", "Al-Baqarah", "Al 'Imran", "An-Nisa'", "Al-Ma'idah", "Al-An'am", "Al-A'raf", "Al-Anfal", "At-Tawbah", "Yunus",
            "Hud", "Yusuf", "Ar-Ra'd", "Ibrahim", "Al-Hijr", "An-Nahl", "Al-Isra'", "Al-Kahf", "Maryam", "Taha",
            "Al-Anbya'", "Al-Hajj", "Al-Mu'minun", "An-Nur", "Al-Furqan", "Ash-Shu'ara'", "An-Naml", "Al-Qasas", "Al-'Ankabut", "Ar-Rum",
            "Luqman", "As-Sajdah", "Al-Ahzab", "Saba'", "Fatir", "Ya-Sin", "As-Saffat", "Sad", "Az-Zumar", "Ghafir",
            "Fussilat", "Ash-Shura", "Az-Zukhruf", "Ad-Dukhan", "Al-Jathiyah", "Al-Ahqaf", "Muhammad", "Al-Fath", "Al-Hujurat", "Qaf",
            "Adh-Dhariyat", "At-Tur", "An-Najm", "Al-Qamar", "Ar-Rahman", "Al-Waqi'ah", "Al-Hadid", "Al-Mujadilah", "Al-Hashr", "Al-Mumtahanah",
            "As-Saff", "Al-Jumu'ah", "Al-Munafiqun", "At-Taghabun", "At-Talaq", "At-Tahrim", "Al-Mulk", "Al-Qalam", "Al-Haqqah", "Al-Ma'arij",
            "Nuh", "Al-Jinn", "Al-Muzzammil", "Al-Muddaththir", "Al-Qiyamah", "Al-Insan", "Al-Mursalat", "An-Naba'", "An-Nazi'at", "'Abasa",
            "At-Takwir", "Al-Infitar", "Al-Mutaffifin", "Al-Inshiqaq", "Al-Buruj", "At-Tariq", "Al-A'la", "Al-Ghashiyah", "Al-Fajr", "Al-Balad",
            "Ash-Shams", "Al-Layl", "Ad-Duha", "Ash-Sharh", "At-Tin", "Al-'Alaq", "Al-Qadr", "Al-Bayyinah", "Az-Zalzalah", "Al-'Adiyat",
            "Al-Qari'ah", "At-Takathur", "Al-'Asr", "Al-Humazah", "Al-Fil", "Quraysh", "Al-Ma'un", "Al-Kawthar", "Al-Kafirun", "An-Nasr",
            "Al-Masad", "Al-Ikhlas", "Al-Falaq", "An-Nas"
        ];
        const surahAyahCounts = [
            0, 7, 286, 200, 176, 120, 165, 206, 75, 129, 109, 123, 111, 43, 52, 99, 128, 111, 110, 98, 135, 112, 78, 118, 64, 77, 227, 93, 88, 69,
            60, 34, 30, 73, 54, 45, 83, 182, 88, 75, 85, 54, 53, 89, 59, 37, 35, 38, 29, 18, 45, 60, 49, 62, 55, 78, 96, 29, 22, 24,
            13, 14, 11, 11, 18, 12, 12, 30, 52, 52, 44, 28, 28, 20, 56, 40, 31, 50, 40, 46, 42, 29, 19, 36, 25, 22, 17, 19, 26, 30,
            20, 15, 21, 11, 8, 5, 19, 5, 8, 8, 11, 11, 8, 3, 9, 5, 4, 7, 3, 6, 3, 5, 4, 5, 6
        ];
        const TRANSLATION_CONFIG = {
            urdu: { file: 'data new.AM', lang: 'ur', dir: 'rtl', label: 'Urdu' },
            english: { file: 'dataENG.AM', lang: 'en', dir: 'ltr', label: 'English' },
            Bangali: { file: 'dataBNG.AM', lang: 'bn', dir: 'ltr', label: 'Bangali' },
            pashto: { file: 'dataPS.AM', lang: 'ps', dir: 'rtl', label: 'Pashto' }
        };
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    const oldVersion = event.oldVersion;
                    console.log(`IndexedDB upgrade needed from version ${oldVersion} to ${DB_VERSION}.`);
                    if (!db.objectStoreNames.contains(STORE_QURAN)) {
                        db.createObjectStore(STORE_QURAN, { keyPath: ['surah', 'ayah'] });
                    } else if (oldVersion < 2) { // Example for multi-translation support (adjust version if needed)
                        console.log(`Upgrading ${STORE_QURAN} store schema. Clearing existing data for re-population.`);
                        db.deleteObjectStore(STORE_QURAN);
                        db.createObjectStore(STORE_QURAN, { keyPath: ['surah', 'ayah'] });
                    }
                    if (!db.objectStoreNames.contains(STORE_TAFSIR)) {
                        db.createObjectStore(STORE_TAFSIR, { keyPath: ['surah', 'ayah'] });
                    }
                    if (!db.objectStoreNames.contains(STORE_THEMES)) {
                        db.createObjectStore(STORE_THEMES, { keyPath: 'id', autoIncrement: true });
                    }
                    if (!db.objectStoreNames.contains(STORE_THEME_AYAHS)) {
                        const themeAyahsStore = db.createObjectStore(STORE_THEME_AYAHS, { keyPath: 'id', autoIncrement: true });
                        themeAyahsStore.createIndex('themeId', 'themeId', { unique: false });
                        themeAyahsStore.createIndex('surahAyah', ['surah', 'ayah'], { unique: false });
                    }
                    if (!db.objectStoreNames.contains(STORE_ROOTS)) {
                        db.createObjectStore(STORE_ROOTS, { keyPath: 'id', autoIncrement: true });
                    }
                    if (!db.objectStoreNames.contains(STORE_ROOT_AYAHS)) {
                        const rootAyahsStore = db.createObjectStore(STORE_ROOT_AYAHS, { keyPath: 'id', autoIncrement: true });
                        rootAyahsStore.createIndex('rootId', 'rootId', { unique: false });
                        rootAyahsStore.createIndex('surahAyah', ['surah', 'ayah'], { unique: false });
                        rootAyahsStore.createIndex('word', 'word', { unique: false });
                    }
                    if (!db.objectStoreNames.contains(STORE_RECITATIONS)) {
                        const recitationStore = db.createObjectStore(STORE_RECITATIONS, { keyPath: 'id', autoIncrement: true });
                        recitationStore.createIndex('surah', 'surah', { unique: false });
                        recitationStore.createIndex('date', 'date', { unique: false });
                    }
                    if (!db.objectStoreNames.contains(STORE_HIFZ)) {
                        const hifzStore = db.createObjectStore(STORE_HIFZ, { keyPath: ['surah', 'ayah'] });
                        hifzStore.createIndex('status', 'status', { unique: false });
                        hifzStore.createIndex('nextReviewDate', 'nextReviewDate', { unique: false });
                    }
                    if (!db.objectStoreNames.contains(STORE_SETTINGS)) {
                        db.createObjectStore(STORE_SETTINGS, { keyPath: 'name' });
                    }
                    if (db.objectStoreNames.contains(STORE_WORD_TRANSLATIONS)) {
                        if (oldVersion < 7) { // Version 7 introduced word_id keying
                            console.log(`Re-creating '${STORE_WORD_TRANSLATIONS}' for DB_VERSION ${DB_VERSION} to be keyed by 'word_id'.`);
                            db.deleteObjectStore(STORE_WORD_TRANSLATIONS);
                            db.createObjectStore(STORE_WORD_TRANSLATIONS, { keyPath: 'word_id' });
                        }
                    } else {
                        console.log(`Creating new '${STORE_WORD_TRANSLATIONS}' store, keyed by 'word_id'.`);
                        db.createObjectStore(STORE_WORD_TRANSLATIONS, { keyPath: 'word_id' });
                    }
                    if (!db.objectStoreNames.contains(STORE_WORD_METADATA)) {
                        console.log(`Creating new '${STORE_WORD_METADATA}' store for DB_VERSION ${DB_VERSION}.`);
                        const wordMetadataStore = db.createObjectStore(STORE_WORD_METADATA, { keyPath: 'word_id' });
                        wordMetadataStore.createIndex('location_idx', ['surah', 'ayah', 'word_position'], { unique: true });
                    } else if (oldVersion < 7) { // Version 7 introduced this store
                        console.log(`Re-creating '${STORE_WORD_METADATA}' for DB_VERSION ${DB_VERSION}.`);
                        db.deleteObjectStore(STORE_WORD_METADATA);
                        const wordMetadataStore = db.createObjectStore(STORE_WORD_METADATA, { keyPath: 'word_id' });
                        wordMetadataStore.createIndex('location_idx', ['surah', 'ayah', 'word_position'], { unique: true });
                    }
                    if (!db.objectStoreNames.contains('goals')) {
                        console.log("Creating new 'goals' object store.");
                        const goalsStore = db.createObjectStore('goals', { keyPath: 'id', autoIncrement: true });
                        goalsStore.createIndex('type', 'type', { unique: false });
                        goalsStore.createIndex('isComplete', 'isComplete', { unique: false });
                    }
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("IndexedDB opened successfully.");
                    resolve(db);
                };
                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.errorCode, event.target.error);
                    reject("Failed to open IndexedDB: " + event.target.error.message);
                };
            });
        }
        async function populateThemeSelects() {
            if (!db) return;
            const themeSelectElements = [
                document.getElementById('parent-theme-select'),
                document.getElementById('link-theme-select')
            ];
            try {
                const themes = await getAllData(STORE_THEMES);
                themeSelectElements.forEach(select => {
                    if (!select) return;
                    const preservedValue = select.value;
                    select.innerHTML = ''; // Clear existing options
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.textContent = select.id === 'parent-theme-select' ? "-- No Parent --" : "-- Select Theme --";
                    select.appendChild(defaultOption);
                    themes.forEach(theme => {
                        const option = document.createElement('option');
                        option.value = theme.id;
                        option.textContent = theme.name;
                        select.appendChild(option);
                    });
                    if (select.querySelector(`option[value="${preservedValue}"]`)) {
                        select.value = preservedValue;
                    } else {
                        select.value = ""; // Default to the "-- Select --" or "-- No Parent --" option
                    }
                });
            } catch (error) {
                console.error("Error populating theme selects:", error);
                if (typeof setStatusMessage === "function" && document.getElementById('theme-manager-status')) {
                    setStatusMessage('theme-manager-status', 'Failed to load themes for dropdowns.', true);
                }
            }
        }
        function getObjectStore(storeName, mode) {
            if (!db) {
                console.error("getObjectStore called but DB is not initialized.");
                throw new Error("Database not initialized.");
            }
            const transaction = db.transaction(storeName, mode);
            return transaction.objectStore(storeName);
        }
        async function populateThemesIndexList() {
            const themeListEl = document.getElementById('fsIndexThemeList');
            const searchInput = document.getElementById('fsThematicIndexSearchInput');
            if (!themeListEl) {
                const contentDiv = document.getElementById('fsReaderContent');
                if (contentDiv) contentDiv.innerHTML = "<p style='color:red; text-align:center;'>Error: Theme list UI element missing.</p>";
                return;
            }
            if (!searchInput) {
            }
            themeListEl.innerHTML = '<li>Loading themes...</li>'; // Initial message
            let dbThemes = [];
            try {
                if (db && typeof getAllData === "function") { // Ensure DB is open and function exists
                    dbThemes = await getAllData(STORE_THEMES);
                } else {
                }
            } catch (dbError) {
            }
            if (typeof staticQuranicThemes === 'undefined' || !Array.isArray(staticQuranicThemes)) {
                themeListEl.innerHTML = '<li>Error: Static theme data is missing.</li>';
                return;
            }
            const combinedThemes = [
                ...staticQuranicThemes.map(st => ({
                    id: st.id,
                    name: st.name,
                    isStatic: true,
                    exampleSurah: st.exampleSurah,
                    exampleAyah: st.exampleAyah,
                    description: st.description || "" // Add description for search
                })),
                ...(dbThemes || []).map(dbt => ({ // Handle if dbThemes is null/undefined
                    id: dbt.id,
                    name: dbt.name,
                    isStatic: false,
                    description: dbt.description || "" // Assuming DB themes might have a description
                }))
            ];
            let themesToDisplay = [...combinedThemes];
            const renderList = (themes) => {
                themeListEl.innerHTML = ''; // Clear previous items (like "Loading themes...")
                if (themes.length === 0) {
                    themeListEl.innerHTML = '<li>No themes found.</li>'; // This is the message you are seeing
                    return;
                }
                themes.sort((a, b) => a.name.localeCompare(b.name));
                themes.forEach(theme => {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = '#';
                    a.dataset.themeId = theme.id;
                    a.dataset.isStatic = theme.isStatic;
                    if (theme.isStatic) {
                        a.dataset.exampleSurah = theme.exampleSurah;
                        a.dataset.exampleAyah = theme.exampleAyah;
                    }
                    a.textContent = theme.name;
                    a.addEventListener('click', handleIndexThemeClick);
                    li.appendChild(a);
                    themeListEl.appendChild(li);
                });
            };
            renderList(themesToDisplay); // Render the combined list
            if (searchInput) { // Only add listener if searchInput exists
                searchInput.removeEventListener('input', themeSearchHandler); // Remove previous listener
                searchInput.addEventListener('input', themeSearchHandler);
            }
        }
        function themeSearchHandler(e) {
            const themeListEl = document.getElementById('fsIndexThemeList'); // Re-fetch in handler scope
            if (!themeListEl) return;
            const searchTerm = e.target.value.toLowerCase().trim();
            let currentDbThemes = [];
            if (db && typeof getAllData === "function") {
                getAllData(STORE_THEMES).then(fetchedDbThemes => { // Asynchronous, this logic flow for live search needs care
                    currentDbThemes = fetchedDbThemes || [];
                    filterAndRender(currentDbThemes);
                }).catch(() => filterAndRender([])); // Handle error by filtering static only
            } else {
                filterAndRender([]);
            }
            function filterAndRender(dbThemesForFilter) {
                const allCombinedForSearch = [
                    ...staticQuranicThemes.map(st => ({ id: st.id, name: st.name, isStatic: true, exampleSurah: st.exampleSurah, exampleAyah: st.exampleAyah, description: st.description || "" })),
                    ...(dbThemesForFilter).map(dbt => ({ id: dbt.id, name: dbt.name, isStatic: false, description: dbt.description || "" }))
                ];
                let filteredThemes;
                if (!searchTerm) {
                    filteredThemes = [...allCombinedForSearch];
                } else {
                    filteredThemes = allCombinedForSearch.filter(theme =>
                        theme.name.toLowerCase().includes(searchTerm) ||
                        (theme.description && theme.description.toLowerCase().includes(searchTerm)) // Also search description
                    );
                }
                themeListEl.innerHTML = '';
                if (filteredThemes.length === 0) {
                    themeListEl.innerHTML = '<li>No themes match your search.</li>';
                    return;
                }
                filteredThemes.sort((a, b) => a.name.localeCompare(b.name));
                filteredThemes.forEach(theme => {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = '#';
                    a.dataset.themeId = theme.id;
                    a.dataset.isStatic = theme.isStatic;
                    if (theme.isStatic) {
                        a.dataset.exampleSurah = theme.exampleSurah;
                        a.dataset.exampleAyah = theme.exampleAyah;
                    }
                    a.textContent = theme.name;
                    a.addEventListener('click', handleIndexThemeClick);
                    li.appendChild(a);
                    themeListEl.appendChild(li);
                });
            }
        }
        function addData(storeName, data) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.add(data);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error adding data to ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function putData(storeName, data) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.put(data);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error putting data to ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function getData(storeName, key) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readonly');
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error getting data from ${storeName} with key ${key}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function getAllData(storeName) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readonly');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => {
                    console.error(`Error getting all data from ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function deleteData(storeName, key) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.delete(key);
                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error(`Error deleting data from ${storeName} with key ${key}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function clearStore(storeName) {
            return new Promise((resolve, reject) => {
                const store = getObjectStore(storeName, 'readwrite');
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error(`Error clearing store ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        async function handleOnDemandLoad(config) {
            if (confirm(`Translation '${config.label}' is not loaded. Download and install now?`)) {
                showLoading(`Downloading ${config.label}...`);
                try {
                    await processDataFile(config);
                    const localManifest = await getLocalManifest();
                    localManifest[config.key] = { version: config.version };
                    await putData(STORE_SETTINGS, { name: SETTINGS_KEY_VERSIONS, value: localManifest });
                    await populateTranslationSelect(await fetchRemoteManifest(), localManifest);
                    document.getElementById('translation-select').value = config.key;
                    await loadAyah(currentSurah, currentAyah);
                } catch (error) {
                    alert(`Failed to load ${config.label}: ${error.message}`);
                } finally {
                    hideLoading();
                }
            }
        }
        const MANIFEST_URL = 'info.csv';
        const SETTINGS_KEY_VERSIONS = 'data_versions';
        window.appManifest = []; // Global manifest to replace TRANSLATION_CONFIG
        function getTranslationConfig(key) {
            const config = window.appManifest.find(item => item.key === key && item.file_type === 'quran_translation');
            if (!config) return { key: 'english', lang: 'en', dir: 'ltr', label: 'English', font: 'var(--font-english)' };
            return {
                key: config.key, // The key used for storing data (e.g., 'Bangali')
                lang: config.lang_code,
                dir: config.direction,
                label: config.label,
                font: `var(--font-${config.key})`
            };
        }
        function isNewDay() {
            const lastCheck = localStorage.getItem('lastUpdateCheck');
            if (!lastCheck) return true;
            return new Date(lastCheck).toDateString() !== new Date().toDateString();
        }
        async function getLocalManifest() {
            const versions = await getData(STORE_SETTINGS, SETTINGS_KEY_VERSIONS).catch(() => null);
            return versions ? versions.value : {};
        }
        async function populateTranslationSelect(localManifest) {
            const select = document.getElementById('translation-select');
            const quranTranslations = window.appManifest.filter(f => f.file_type === 'quran_translation');
            const previouslySelected = select.value || 'urdu';
            select.innerHTML = '';
            quranTranslations.forEach(config => {
                const option = document.createElement('option');
                option.value = config.key;
                const isLoaded = !!localManifest[config.key];
                option.textContent = isLoaded ? config.label : `${config.label} (Click to Load)`;
                option.dataset.isLoaded = isLoaded;
                option.dataset.config = JSON.stringify(config);
                select.appendChild(option);
            });
            if (select.querySelector(`option[value="${previouslySelected}"]`)) {
                select.value = previouslySelected;
            } else {
                select.value = 'urdu';
            }
        }
        async function processDataFile(config, progressCallback) {
            const response = await fetch(config.url, { cache: "no-store" });
            if (!response.ok) throw new Error(`HTTP error ${response.status} for ${config.url}`);
            const text = await response.text();
            const lines = text.split('\n').filter(line => line.trim());
            const totalLines = lines.length;
            let processedLines = 0;
            const storeNameMap = {
                'quran_translation': STORE_QURAN,
                'word_translation': STORE_WORD_TRANSLATIONS,
                'word_metadata': STORE_WORD_METADATA
            };
            const storeName = storeNameMap[config.file_type];
            if (!storeName) throw new Error(`Unknown file type: ${config.file_type}`);
            const transaction = db.transaction(storeName, 'readwrite');
            const store = transaction.objectStore(storeName);
            if (config.file_type !== 'quran_translation') {
                await new Promise(res => store.clear().onsuccess = res); // Clear for word data
            }
            let headers = [];
            if (config.file_type !== 'quran_translation') {
                headers = lines.shift().split(',').map(h => h.trim());
            }
            for (const line of lines) {
                if (config.file_type === 'quran_translation') {
                    const parts = line.split(' ترجمہ: ');
                    if (parts.length < 2) continue;
                    const metaMatch = parts[1].match(/<br\/>\s*(?:s|س)\s*\.?\s*(\d{1,3})\s*(?:a|آ)\s*\.?\s*(\d{1,3})\s*$/i);
                    if (!metaMatch) continue;
                    const surah = parseInt(metaMatch[1], 10), ayah = parseInt(metaMatch[2], 10);
                    const entry = await new Promise(r => store.get([surah, ayah]).onsuccess = e => r(e.target.result)) || { surah, ayah, arabic: parts[0].trim() };
                    entry[config.key] = parts[1].substring(0, metaMatch.index).trim();
                    store.put(entry);
                } else { // Word data
                    const values = line.split(',');
                    let entry = headers.reduce((obj, h, i) => ({ ...obj, [h]: values[i] ? values[i].trim() : '' }), {});
                    Object.keys(entry).forEach(k => {
                        if (!isNaN(entry[k]) && entry[k] !== '') entry[k] = parseInt(entry[k], 10);
                    });
                    store.put(entry);
                }
                processedLines++;
                if (processedLines % 100 === 0) { // Update progress every 100 lines
                    progressCallback(processedLines / totalLines);
                }
            }
            await new Promise(resolve => transaction.oncomplete = resolve);
        }
        let isUpdateCheckInProgress = false;
        async function loadQuranData() {
            if (isUpdateCheckInProgress) {
                console.log("Update check already running, skipping duplicate call.");
                return;
            }
            isUpdateCheckInProgress = true;
            showLoading("Initializing...", "Checking for app updates...", 0);
            totalProgressUnits = 100;
            completedProgressUnits = 5;
            updateLoadingProgress(0, "Fetching manifest...");
            try {
                window.appManifest = await fetch(MANIFEST_URL, { cache: "no-store" })
                    .then(res => res.ok ? res.text() : Promise.reject('Could not fetch manifest.'))
                    .then(text => {
                        const lines = text.trim().split('\n');
                        const headers = lines.shift().trim().split(',');
                        return lines.map(line => {
                            const values = line.trim().split(',');
                            return headers.reduce((obj, h, i) => ({ ...obj, [h.trim()]: values[i] ? values[i].trim() : '' }), {});
                        });
                    });
                completedProgressUnits = 10;
                updateLoadingProgress(0, "Checking local data versions...");
                const localManifest = await getLocalManifest();
                await populateTranslationSelect(localManifest);
                let updates = [];
                if (isNewDay()) {
                    updates = window.appManifest.filter(remote => {
                        const local = localManifest[remote.key];
                        return !local || parseFloat(remote.version) > parseFloat(local.version);
                    });
                }
                if (updates.length > 0 && confirm(`Updates available for: ${updates.map(u => u.label).join(', ')}. Download now?`)) {
                    const progressStep = (100 - completedProgressUnits) / updates.length;
                    const successfullyUpdatedFiles = []; // Track successful updates
                    for (let i = 0; i < updates.length; i++) {
                        const fileConfig = updates[i];
                        updateLoadingProgress(0, `Updating ${fileConfig.label}... (${i + 1}/${updates.length})`);
                        try {
                            await processDataFile(fileConfig, () => { });
                            localManifest[fileConfig.key] = { version: fileConfig.version };
                            await putData(STORE_SETTINGS, { name: SETTINGS_KEY_VERSIONS, value: localManifest });
                            successfullyUpdatedFiles.push(fileConfig.label);
                        } catch (error) {
                            alert(`Failed to update ${fileConfig.label}: ${error.message}`);
                        }
                        completedProgressUnits += progressStep;
                        updateLoadingProgress(0, `Finished ${fileConfig.label}.`);
                    }
                    await populateTranslationSelect(localManifest);
                    if (successfullyUpdatedFiles.length > 0) {
                        alert(`App data updated successfully for: ${successfullyUpdatedFiles.join(', ')}.`);
                    }
                } else {
                    console.log("Data is up-to-date or check not needed today.");
                }
                localStorage.setItem('lastUpdateCheck', new Date().toISOString());
                await populateSurahAyahSelects();
                await loadAyah(currentSurah, currentAyah);
            } catch (e) {
                alert("Failed to load app manifest. Please check your internet connection and refresh.");
            } finally {
                hideLoading();
                isUpdateCheckInProgress = false;
            }
        }
        function showPashtoNoticeOnce() {
            if (!localStorage.getItem('pashtoNoticeShown')) {
                const urduMessage = "پشتو ترجمہ خودکار ترجمہ ہے اور قرآنی معیارات کے مطابق مکمل تصدیق شدہ نہیں ہے۔";
                const pashtoMessage = "پښتو ژباړه اتوماتیکه ژباړه ده او د قرآني معیارونو سره مکمل سم نه ده تایید شوې.";
                alert(`${urduMessage}\n\n${pashtoMessage}`);
                localStorage.setItem('pashtoNoticeShown', 'true');
            }
        }
        function populateSurahAyahSelects() {
            const surahSelect = document.getElementById('surah-select');
            const ayahSelect = document.getElementById('ayah-select');
            const recSurahSelect = document.getElementById('rec-surah-select');
            const hifzSurahSelect = document.getElementById('hifz-surah-select');
            if (surahSelect.options.length === 0) {
                for (let i = 1; i <= 114; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `${i}. ${surahNames[i - 1]}`;
                    surahSelect.appendChild(option.cloneNode(true));
                    recSurahSelect.appendChild(option.cloneNode(true));
                    hifzSurahSelect.appendChild(option.cloneNode(true));
                }
            }
            surahSelect.value = currentSurah;
            recSurahSelect.value = currentSurah;
            hifzSurahSelect.value = currentSurah;
            updateAyahSelect(currentSurah);
            ayahSelect.value = currentAyah;
        }
        function updateAyahSelect(surahNum) {
            const ayahSelect = document.getElementById('ayah-select');
            ayahSelect.innerHTML = '';
            totalAyahsInSurah = surahAyahCounts[surahNum];
            for (let i = 1; i <= totalAyahsInSurah; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                ayahSelect.appendChild(option);
            }
            if (currentAyah > totalAyahsInSurah) {
                currentAyah = 1;
            }
            ayahSelect.value = currentAyah;
        }
        async function loadAyah(surah, ayah) {
            const selectedTranslationKey = document.getElementById('translation-select').value;
            if (selectedTranslationKey === 'pashto') {
                showPashtoNoticeIfNeeded();
            }
            if (!db) {
                console.error("Database not open for loadAyah.");
                document.getElementById('quran-display').innerHTML = `<p class="text-center" style="color: var(--color-error);">Database not ready. Please try again later.</p>`;
                return;
            }
            showLoading(`Loading Ayah ${surah}:${ayah}...`);
            try {
                const quran = await getData(STORE_QURAN, [surah, ayah]);
                if (quran) {
                    currentSurah = surah;
                    currentAyah = ayah;
                    updateAyahSelect(surah); // Ensure selects are updated
                    document.getElementById('surah-select').value = surah;
                    document.getElementById('ayah-select').value = ayah;
                    if (currentQuranView === 'single') {
                        await renderSingleAyahView(surah, ayah);
                    } else {
                        await renderContinuousView(surah, ayah);
                    }
                    await updateTafsirAndThemeViews();
                } else {
                    document.getElementById('quran-display').innerHTML = `<p class="text-center" style="color: var(--color-error);">Ayah ${surah}:${ayah} not found in data.</p>`;
                }
            } catch (error) {
                console.error("Error loading ayah:", error);
                document.getElementById('quran-display').innerHTML = `<p class="text-center" style="color: var(--color-error);">Error loading Ayah: ${error.message}</p>`;
            } finally {
                hideLoading();
            }
        }
        function addWordClickListeners() {
            document.querySelectorAll('.ayah-arabic span').forEach(wordSpan => {
                wordSpan.removeEventListener('click', handleWordClick);
                wordSpan.addEventListener('click', handleWordClick);
                wordSpan.removeEventListener('focus', handleWordFocus);
                wordSpan.addEventListener('focus', handleWordFocus);
                wordSpan.removeEventListener('blur', handleWordBlur);
                wordSpan.addEventListener('blur', handleWordBlur);
            });
        }
        async function getWordTranslationById(wordId) {
            if (isNaN(wordId)) return { ur: "N/A", en: "N/A", ps: "N/A" };
            try {
                const trans = await getData(STORE_WORD_TRANSLATIONS, wordId);
                return {
                    ur: trans?.ur_meaning || "N/A",
                    en: trans?.en_meaning || "N/A",
                    ps: trans?.pashto_text || "N/A"
                };
            } catch (e) {
                console.error("Error fetching translation for word_id:", wordId, e);
                return { ur: "Error", en: "Error", ps: "Error" };
            }
        }
        async function handleWordClick(event) {
            if (document.getElementById('translation-select').value === 'pashto') {
                showPashtoNoticeOnce();
            }
            const wordSpan = event.target;
            const wordId = parseInt(wordSpan.dataset.wordId, 10);
            document.querySelectorAll('.ayah-arabic span, #quran-continuous-display .arabic-word').forEach(span => span.style.backgroundColor = 'transparent');
            wordSpan.style.backgroundColor = 'var(--color-highlight)';
            if (isNaN(wordId)) {
                document.getElementById('word-translation-area').innerHTML = `<p>Translation not available for this word.</p>`;
                return;
            }
            try {
                const trans = await getData(STORE_WORD_TRANSLATIONS, wordId);
                const translations = {
                    ur: trans?.ur_meaning || "N/A",
                    en: trans?.en_meaning || "N/A",
                    ps: trans?.pashto_text || "N/A"
                };
                const translationArea = document.getElementById('word-translation-area');
                const fullAyahTranslation = wordSpan.closest('.ayah').querySelector('.ayah-translation').textContent;
                const fullTranslationInfo = getTranslationConfig(document.getElementById('translation-select').value);
                translationArea.innerHTML = `
            <p><strong>Selected Word:</strong> <span lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${wordSpan.dataset.wordText}</span></p>
            <p><strong>Urdu Meaning:</strong> <span lang="ur" dir="rtl" style="font-family: var(--font-urdu);">${translations.ur}</span></p>
            <p><strong>Pashto Meaning:</strong> <span lang="ps" dir="rtl" style="font-family: var(--font-pashto);">${translations.ps}</span></p>
            <p><strong>English Meaning:</strong> <span lang="en" dir="ltr" style="font-family: var(--font-english);">${translations.en}</span></p>
            <p><strong>Full Ayah Translation:</strong> <span lang="${fullTranslationInfo.lang}" dir="${fullTranslationInfo.dir}" style="font-family: ${fullTranslationInfo.font};">${fullAyahTranslation}</span></p>
        `;
            } catch (error) {
                console.error("Error handling word click:", error);
                document.getElementById('word-translation-area').innerHTML = `<p style="color: var(--color-error);">Error fetching word details.</p>`;
            }
        }
        function handleWordFocus(event) {
            handleWordClick(event);
        }
        function handleWordBlur(event) {
            event.target.style.backgroundColor = 'transparent';
        }
        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
                section.setAttribute('aria-hidden', 'true');
            });
            const activeSection = document.getElementById(sectionId);
            if (activeSection) {
                activeSection.classList.add('active');
                activeSection.setAttribute('aria-hidden', 'false');
                activeSection.focus();
            }
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                link.setAttribute('aria-current', 'false');
            });
            const activeLink = document.querySelector(`.nav-link[data-section="${sectionId}"]`);
            if (activeLink) {
                activeLink.classList.add('active');
                activeLink.setAttribute('aria-current', 'page');
            }
            if (sectionId === 'tafsir' || sectionId === 'themes') {
                updateTafsirAndThemeViews();
            } else if (sectionId === 'themes') {
                populateThemeSelects();
                displayLinkedAyahsForCurrentTheme();
            } else if (sectionId === 'recitation') {
                loadRecitationLogs();
            } else if (sectionId === 'hifz') {
                const hifzSurahSelect = document.getElementById('hifz-surah-select');
                if (hifzSurahSelect.value) {
                    loadHifzForSurah(parseInt(hifzSurahSelect.value, 10));
                }
            }
        }
        function showLoading(primaryMessage, secondaryMessage = "Initializing...", initialPercentage = 0) {
            const loadingOverlay = document.getElementById('loading-overlay');
            const primaryMsgEl = document.getElementById('loading-message-primary');
            const secondaryMsgEl = document.getElementById('loading-message-secondary');
            const progressBarEl = document.getElementById('loading-progress-bar');
            const percentageEl = document.getElementById('loading-percentage');
            const firstTimeNoticeEl = document.getElementById('loading-first-time-notice');
            if (primaryMsgEl) primaryMsgEl.textContent = primaryMessage;
            if (secondaryMsgEl) secondaryMsgEl.textContent = secondaryMessage;
            if (progressBarEl) progressBarEl.style.width = `${initialPercentage}%`;
            if (percentageEl) percentageEl.textContent = `${initialPercentage}%`;
            const currentTheme = document.body.className.includes('theme-manuscript') ? 'manuscript' :
                document.body.className.includes('theme-holo') ? 'holo' : 'serene';
            const loadingContent = loadingOverlay.querySelector('.loading-content');
            if (loadingContent) {
                if (currentTheme === 'holo') {
                    loadingContent.style.backgroundColor = 'var(--color-bg-secondary)'; // From holo theme
                    loadingContent.style.color = 'var(--color-text-primary)'; // From holo theme
                    if (document.getElementById('loading-progress-bar-container')) document.getElementById('loading-progress-bar-container').style.backgroundColor = '#26a69a';
                    if (progressBarEl) progressBarEl.style.backgroundColor = 'var(--color-accent)'; // From holo theme
                } else if (currentTheme === 'manuscript') {
                    loadingContent.style.backgroundColor = 'var(--color-bg-secondary)'; // From manuscript theme
                    loadingContent.style.color = 'var(--color-text-primary)'; // From manuscript theme
                    if (document.getElementById('loading-progress-bar-container')) document.getElementById('loading-progress-bar-container').style.backgroundColor = 'var(--color-border)';
                    if (progressBarEl) progressBarEl.style.backgroundColor = 'var(--color-accent)';
                } else { // Serene (default)
                    loadingContent.style.backgroundColor = 'var(--color-bg-secondary)';
                    loadingContent.style.color = 'var(--color-text-primary)';
                    if (document.getElementById('loading-progress-bar-container')) document.getElementById('loading-progress-bar-container').style.backgroundColor = 'var(--color-border)';
                    if (progressBarEl) progressBarEl.style.backgroundColor = 'var(--color-accent)';
                }
            }
            loadingOverlay.style.display = 'flex';
            document.body.setAttribute('aria-busy', 'true');
        }
        function updateLoadingProgress(unitsIncrement, secondaryMessage) {
            if (totalProgressUnits === 0) return; // Avoid division by zero if not set
            completedProgressUnits += unitsIncrement;
            const percentage = Math.min(100, Math.round((completedProgressUnits / totalProgressUnits) * 100));
            const secondaryMsgEl = document.getElementById('loading-message-secondary');
            const progressBarEl = document.getElementById('loading-progress-bar');
            const percentageEl = document.getElementById('loading-percentage');
            if (secondaryMsgEl) secondaryMsgEl.textContent = secondaryMessage;
            if (progressBarEl) progressBarEl.style.width = `${percentage}%`;
            if (percentageEl) percentageEl.textContent = `${percentage}%`;
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
            document.body.setAttribute('aria-busy', 'false');
            completedProgressUnits = 0;
            totalProgressUnits = 0; // Reset this as well
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
            document.body.setAttribute('aria-busy', 'false');
        }
        function setStatusMessage(elementId, message, isError = false) {
            const statusElement = document.getElementById(elementId);
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.style.color = isError ? 'var(--color-error)' : 'var(--color-success)';
                statusElement.style.fontWeight = 'bold';
                setTimeout(() => {
                    statusElement.textContent = '';
                    statusElement.style.color = '';
                    statusElement.style.fontWeight = '';
                }, 7000);
            }
        }
        async function saveTafsir() {
            if (!db) return;
            const notes = document.getElementById('tafsir-notes').value.trim();
            if (!notes) {
                setStatusMessage('tafsir-status', 'Tafsir notes cannot be empty.', true);
                return;
            }
            if (currentSurah === 0 || currentAyah === 0) {
                setStatusMessage('tafsir-status', 'Navigate to an Ayah first.', true);
                return;
            }
            showLoading(`Saving Tafsir for ${currentSurah}:${currentAyah}...`);
            try {
                await putData(STORE_TAFSIR, { surah: currentSurah, ayah: currentAyah, notes: notes });
                setStatusMessage('tafsir-status', `Tafsir saved for ${currentSurah}:${currentAyah}.`, false);
            } catch (error) {
                setStatusMessage('tafsir-status', 'Failed to save Tafsir.', true);
            } finally {
                hideLoading();
            }
        }
        async function handleIndexThemeClick(event) {
            event.preventDefault();
            const clickedAnchorElement = event.currentTarget; // Use a more descriptive name
            if (!clickedAnchorElement || !clickedAnchorElement.dataset) {
                console.error("handleIndexThemeClick: clickedAnchorElement or its dataset is invalid.", clickedAnchorElement);
                return;
            }
            const themeId = clickedAnchorElement.dataset.themeId;
            const isStatic = clickedAnchorElement.dataset.isStatic === 'true';
            const exampleSurahStr = clickedAnchorElement.dataset.exampleSurah;
            const exampleAyahStr = clickedAnchorElement.dataset.exampleAyah;
            if (!themeId) {
                console.error("Theme ID missing from clicked element's dataset.");
                return;
            }
            const indexPanel = document.getElementById('fsReaderIndexPanel');
            if (indexPanel) indexPanel.style.display = 'none';
            stopAndClearAudio();
            let targetSurah, targetAyah;
            if (isStatic) {
                targetSurah = exampleSurahStr ? parseInt(exampleSurahStr) : NaN;
                targetAyah = exampleAyahStr ? parseInt(exampleAyahStr) : NaN;
                const staticTheme = staticQuranicThemes.find(st => st.id === themeId);
                if (staticTheme) {
                    const surahTitleEl = document.getElementById('fsReaderSurahTitle');
                    const pageInfoEl = document.getElementById('fsReaderPageInfo');
                    if (surahTitleEl) surahTitleEl.textContent = `Theme: ${staticTheme.name}`;
                    if (pageInfoEl) {
                        if (isNaN(targetSurah) || isNaN(targetAyah)) {
                            pageInfoEl.textContent = "(Example Ayah not set or invalid)";
                        } else {
                            pageInfoEl.textContent = `(Example: S${targetSurah}:A${targetAyah})`;
                        }
                    }
                }
            } else {
                try {
                    const dbThemeId = parseInt(themeId);
                    if (isNaN(dbThemeId)) {
                        console.error("Invalid DB Theme ID:", themeId);
                        return;
                    }
                    const allThemeAyahLinks = await getAllData(STORE_THEME_AYAHS);
                    const linksForThisTheme = allThemeAyahLinks
                        .filter(link => link.themeId === dbThemeId)
                        .sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                    if (linksForThisTheme.length > 0) {
                        const firstLink = linksForThisTheme[0];
                        targetSurah = firstLink.surah;
                        targetAyah = firstLink.ayah;
                    } else {
                        alert("No Ayahs are currently linked to this user-defined theme.");
                        const themeData = await getData(STORE_THEMES, dbThemeId);
                        const surahTitleEl = document.getElementById('fsReaderSurahTitle');
                        const pageInfoEl = document.getElementById('fsReaderPageInfo');
                        if (themeData && surahTitleEl) surahTitleEl.textContent = `Theme: ${themeData.name}`;
                        if (pageInfoEl) pageInfoEl.textContent = "(No linked Ayahs)";
                        return;
                    }
                } catch (error) {
                    console.error("Error fetching links for DB theme:", error);
                    alert("Could not retrieve linked Ayahs for this theme.");
                    return;
                }
            }
            if (!isNaN(targetSurah) && !isNaN(targetAyah) && targetSurah >= 1 && targetSurah <= 114 && targetAyah >= 1) {
                const maxAyahs = (surahAyahCounts[targetSurah]) ? surahAyahCounts[targetSurah] : 0;
                if (maxAyahs > 0 && targetAyah <= maxAyahs) {
                    fullScreenReaderCurrentSurah = targetSurah;
                    fullScreenReaderCurrentAyah = targetAyah;
                    if (fullScreenReaderViewMode === 'paged') {
                        fullScreenReaderCurrentPage = surahToPageEnhanced(targetSurah, targetAyah);
                        await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
                        setTimeout(() => highlightAndScrollToAyahInPage(targetSurah, targetAyah), 300); // slight increase
                    } else {
                        continuousScrollNextSurahToLoad = targetSurah;
                        continuousScrollNextAyahToLoad = targetAyah;
                        await initializeContinuousScroll();
                    }
                } else {
                    console.warn(`Invalid Ayah number ${targetAyah} for Surah ${targetSurah}. Max is ${maxAyahs}. Cannot navigate.`);
                    if (isStatic) alert(`The example Ayah (S${targetSurah}:A${targetAyah}) for this static theme is invalid.`);
                }
            } else if (isStatic) {
            } else {
                console.warn(`Navigation aborted for theme "${themeId}" due to invalid targetSurah/Ayah.`);
            }
        }
        let isLoadingThemesListGlobalFlag = false;
        async function displayThemesList() {
            if (!db) {
                return;
            }
            if (isLoadingThemesListGlobalFlag) {
                return;
            }
            isLoadingThemesListGlobalFlag = true;
            const themesListElement = document.getElementById('themes-list');
            if (!themesListElement) {
                console.error('[displayThemesList] Element with ID "themes-list" not found.');
                isLoadingThemesListGlobalFlag = false;
                return;
            }
            themesListElement.innerHTML = ''; // Clear the list at the very beginning
            try {
                const themes = await getAllData(STORE_THEMES);
                if (!themesListElement.parentNode) {
                    isLoadingThemesListGlobalFlag = false;
                    return;
                }
                if (themes.length === 0) {
                    themesListElement.innerHTML = '<li>No themes added yet.</li>';
                } else {
                    themes.forEach(theme => {
                        const li = document.createElement('li');
                        li.innerHTML = `
                            <span data-theme-id="${theme.id}" class="view-theme-ayahs" tabindex="0" role="button" aria-label="View ayahs for theme ${theme.name}">${theme.name}</span>
                            <div class="theme-actions" style="display: inline-block;">
                                <button data-theme-id="${theme.id}" class="delete-theme-btn" aria-label="Delete theme ${theme.name}">Delete</button>
                            </div>
                        `;
                        themesListElement.appendChild(li);
                    });
                    themesListElement.querySelectorAll('.view-theme-ayahs').forEach(span => {
                        const newSpan = span.cloneNode(true);
                        span.parentNode.replaceChild(newSpan, span);
                        newSpan.addEventListener('click', handleViewThemeAyahs);
                        newSpan.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') handleViewThemeAyahs(e); });
                    });
                    themesListElement.querySelectorAll('.delete-theme-btn').forEach(button => {
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', handleDeleteTheme);
                    });
                }
            } catch (error) {
                console.error("[displayThemesList] Error:", error);
                if (themesListElement) {
                    themesListElement.innerHTML = `<li>Error loading themes: ${error.message}</li>`;
                }
            } finally {
                isLoadingThemesListGlobalFlag = false; // Reset the flag
            }
        }
        async function addTheme() {
            if (!db) return;
            const nameInput = document.getElementById('new-theme-name');
            const parentSelect = document.getElementById('parent-theme-select');
            const name = nameInput.value.trim();
            const parentId = parentSelect.value ? parseInt(parentSelect.value, 10) : null;
            if (!name) {
                setStatusMessage('theme-manager-status', 'Theme name cannot be empty.', true);
                return;
            }
            showLoading("Adding theme...");
            try {
                await addData(STORE_THEMES, { name: name, parentId: parentId, description: '' }); // Add description field
                setStatusMessage('theme-manager-status', `Theme "${name}" added.`, false);
                nameInput.value = '';
                parentSelect.value = '';
                await populateThemeSelects();
                await displayThemesList();
            } catch (error) {
                setStatusMessage('theme-manager-status', 'Failed to add theme.', true);
            } finally {
                hideLoading();
            }
        }
        async function handleDeleteTheme(event) {
            if (!db) return;
            const themeId = parseInt(event.target.getAttribute('data-theme-id'), 10);
            if (isNaN(themeId) || !confirm("Delete this theme and all its linked ayahs?")) return;
            showLoading("Deleting theme...");
            try {
                await deleteData(STORE_THEMES, themeId);
                const store = getObjectStore(STORE_THEME_AYAHS, 'readwrite');
                const index = store.index('themeId');
                const request = index.openCursor(IDBKeyRange.only(themeId));
                request.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        cursor.delete();
                        cursor.continue();
                    } else {
                        setStatusMessage('theme-manager-status', 'Theme and linked ayahs deleted.', false);
                        populateThemeSelects();
                        displayThemesList();
                        hideLoading();
                    }
                };
                request.onerror = () => {
                    setStatusMessage('theme-manager-status', 'Theme deleted, but failed to delete all linked ayahs.', true);
                    hideLoading();
                };
            } catch (error) {
                setStatusMessage('theme-manager-status', 'Failed to delete theme.', true);
                hideLoading();
            }
        }
        async function linkAyahToTheme() {
            if (!db) return;
            const themeSelect = document.getElementById('link-theme-select');
            const notesInput = document.getElementById('theme-link-notes');
            const themeId = themeSelect.value ? parseInt(themeSelect.value, 10) : null;
            const notes = notesInput.value.trim();
            if (!themeId) {
                setStatusMessage('theme-linker-status', 'Please select a theme.', true);
                return;
            }
            if (currentSurah === 0 || currentAyah === 0) {
                setStatusMessage('theme-linker-status', 'Navigate to an Ayah first.', true);
                return;
            }
            showLoading(`Linking Ayah ${currentSurah}:${currentAyah}...`);
            try {
                const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                const index = store.index('surahAyah');
                const request = index.getAll(IDBKeyRange.only([currentSurah, currentAyah]));
                const existingLinks = await new Promise(r => { request.onsuccess = () => r(request.result); });
                if (existingLinks.some(link => link.themeId === themeId)) {
                    setStatusMessage('theme-linker-status', 'Ayah already linked to this theme.', true);
                } else {
                    await addData(STORE_THEME_AYAHS, { themeId: themeId, surah: currentSurah, ayah: currentAyah, notes: notes });
                    setStatusMessage('theme-linker-status', `Ayah ${currentSurah}:${currentAyah} linked.`, false);
                    notesInput.value = '';
                    await displayLinkedAyahsForCurrentTheme();
                }
            } catch (error) {
                setStatusMessage('theme-linker-status', 'Failed to link Ayah.', true);
            } finally {
                hideLoading();
            }
        }
        async function handleGoToAyahFromThemeModal(event) {
            const surah = parseInt(event.currentTarget.getAttribute('data-surah'), 10);
            const ayah = parseInt(event.currentTarget.getAttribute('data-ayah'), 10);
            if (!isNaN(surah) && !isNaN(ayah)) {
                const modal = document.getElementById('themeAyahsModal');
                if (modal) {
                    modal.style.display = 'none';
                }
                if (typeof loadAyah === 'function' && typeof window.showSection === 'function') {
                    await loadAyah(surah, ayah);
                    window.showSection('quran'); // Use the globally patched showSection
                } else {
                    console.error("loadAyah or showSection function not found.");
                    alert("Error navigating to Ayah. Required functions are missing.");
                }
            } else {
                console.warn("Invalid Surah/Ayah data on clicked element:", event.currentTarget.dataset);
            }
        }
        async function handleViewThemeAyahs(event) {
            if (!db) return;
            const themeId = parseInt(event.target.closest('[data-theme-id]').getAttribute('data-theme-id'), 10); // More robust target selection
            if (isNaN(themeId)) {
                console.warn("handleViewThemeAyahs: Could not determine themeId from event target.", event.target);
                return;
            }
            showLoading("Loading linked ayahs...");
            try {
                const theme = await getData(STORE_THEMES, themeId);
                if (!theme) {
                    setStatusMessage('theme-manager-status', 'Theme not found.', true);
                    hideLoading();
                    return;
                }
                document.getElementById('modal-theme-name').textContent = theme.name;
                const listEl = document.getElementById('modal-linked-ayahs-list');
                listEl.innerHTML = ''; // Clear previous
                const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                const index = store.index('themeId');
                const request = index.openCursor(IDBKeyRange.only(themeId));
                const linkedAyahs = [];
                request.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        linkedAyahs.push(cursor.value);
                        cursor.continue();
                    } else {
                        if (linkedAyahs.length === 0) {
                            listEl.innerHTML = '<li>No ayahs linked yet.</li>';
                        } else {
                            linkedAyahs.sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                            linkedAyahs.forEach(link => {
                                const li = document.createElement('li');
                                li.innerHTML = `
                                    <strong>
                                        <span class="item-surah-ayah theme-modal-ayah-link" 
                                            data-surah="${link.surah}" 
                                            data-ayah="${link.ayah}" 
                                            tabindex="0" 
                                            role="button"
                                            title="Go to Surah ${link.surah}, Ayah ${link.ayah} in Quran Viewer">
                                            Surah ${link.surah}:${link.ayah}
                                        </span>
                                    </strong>
                                    ${link.notes ? ` - <em>${link.notes.substring(0, 100)}${link.notes.length > 100 ? '...' : ''}</em>` : ''}
                                    <button data-link-id="${link.id}" class="delete-theme-link-btn" style="margin-left: 10px;" aria-label="Unlink Ayah ${link.surah}:${link.ayah} from this theme">Unlink</button>
                                `;
                                listEl.appendChild(li);
                            });
                            listEl.querySelectorAll('.delete-theme-link-btn').forEach(button => {
                                const newButton = button.cloneNode(true); // Clone to ensure fresh listeners
                                button.parentNode.replaceChild(newButton, button);
                                newButton.addEventListener('click', handleDeleteThemeLink);
                            });
                            listEl.querySelectorAll('.theme-modal-ayah-link').forEach(span => {
                                const newSpan = span.cloneNode(true); // Clone for clean listeners
                                span.parentNode.replaceChild(newSpan, span);
                                newSpan.addEventListener('click', handleGoToAyahFromThemeModal);
                                newSpan.addEventListener('keydown', (ev) => {
                                    if (ev.key === 'Enter' || ev.key === ' ') {
                                        handleGoToAyahFromThemeModal(ev);
                                    }
                                });
                            });
                        }
                        hideLoading();
                        document.getElementById('themeAyahsModal').style.display = 'flex';
                        document.getElementById('themeAyahsModal').querySelector('.modal-content').setAttribute('data-current-theme-id', themeId);
                        document.getElementById('themeAyahsModalTitle').focus();
                    }
                };
                request.onerror = () => {
                    listEl.innerHTML = `<li>Error loading linked Ayahs.</li>`;
                    hideLoading();
                };
            } catch (error) {
                setStatusMessage('theme-manager-status', 'Failed to load theme details.', true);
                hideLoading();
            }
        }
        async function handleDeleteThemeLink(event) {
            if (!db) return;
            const linkId = parseInt(event.target.getAttribute('data-link-id'), 10);
            if (isNaN(linkId) || !confirm("Unlink this Ayah?")) return;
            showLoading("Unlinking Ayah...");
            try {
                await deleteData(STORE_THEME_AYAHS, linkId);
                setStatusMessage('theme-linker-status', 'Ayah unlinked.', false);
                const modalContent = event.target.closest('.modal-content');
                const currentModalThemeId = parseInt(modalContent.getAttribute('data-current-theme-id'), 10);
                if (!isNaN(currentModalThemeId)) {
                    await displayLinkedAyahsForThemeInModal(currentModalThemeId);
                } else {
                    document.getElementById('themeAyahsModal').style.display = 'none';
                    displayThemesList();
                }
            } catch (error) {
                setStatusMessage('theme-linker-status', 'Failed to unlink Ayah.', true);
            } finally {
                hideLoading();
            }
        }
        async function displayLinkedAyahsForThemeInModal(themeId) {
            if (!db) return;
            const listEl = document.getElementById('modal-linked-ayahs-list');
            listEl.innerHTML = '';
            try {
                const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                const index = store.index('themeId');
                const request = index.openCursor(IDBKeyRange.only(themeId));
                const linkedAyahs = [];
                request.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        linkedAyahs.push(cursor.value);
                        cursor.continue();
                    } else {
                        if (linkedAyahs.length === 0) { listEl.innerHTML = '<li>No ayahs linked.</li>'; }
                        else {
                            linkedAyahs.sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                            linkedAyahs.forEach(link => {
                                const li = document.createElement('li');
                                li.innerHTML = `
                                     <strong>Surah ${link.surah}:${link.ayah}</strong>
                                     ${link.notes ? ` - <em>${link.notes}</em>` : ''}
                                     <button data-link-id="${link.id}" class="delete-theme-link-btn">Unlink</button>
                                 `;
                                listEl.appendChild(li);
                            });
                            listEl.querySelectorAll('.delete-theme-link-btn').forEach(b => b.addEventListener('click', handleDeleteThemeLink));
                        }
                    }
                };
                request.onerror = () => { listEl.innerHTML = `<li>Error refreshing list.</li>`; };
            } catch (error) { listEl.innerHTML = `<li>Error: ${error.message}</li>`; }
        }
        async function displayLinkedAyahsForCurrentTheme() {
            if (!db) return;
            const themeSelect = document.getElementById('link-theme-select');
            const themeId = themeSelect.value ? parseInt(themeSelect.value, 10) : null;
            const listEl = document.getElementById('linked-ayahs-list');
            const nameEl = document.getElementById('linked-theme-name');
            listEl.innerHTML = '';
            if (!themeId) {
                nameEl.textContent = 'N/A';
                listEl.innerHTML = '<li>Select a theme to see linked ayahs.</li>';
                return;
            }
            showLoading("Loading linked ayahs...");
            try {
                const theme = await getData(STORE_THEMES, themeId);
                nameEl.textContent = theme ? theme.name : 'Unknown';
                const store = getObjectStore(STORE_THEME_AYAHS, 'readonly');
                const index = store.index('themeId');
                const request = index.openCursor(IDBKeyRange.only(themeId));
                const linkedAyahs = [];
                request.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        linkedAyahs.push(cursor.value);
                        cursor.continue();
                    } else {
                        if (linkedAyahs.length === 0) { listEl.innerHTML = '<li>No ayahs linked.</li>'; }
                        else {
                            linkedAyahs.sort((a, b) => (a.surah !== b.surah) ? a.surah - b.surah : a.ayah - b.ayah);
                            linkedAyahs.forEach(link => {
                                const li = document.createElement('li');
                                li.innerHTML = `<strong>S ${link.surah}:${link.ayah}</strong> ${link.notes ? `- <em>${link.notes}</em>` : ''}`;
                                listEl.appendChild(li);
                            });
                        }
                        hideLoading();
                    }
                };
                request.onerror = () => { listEl.innerHTML = `<li>Error loading.</li>`; hideLoading(); };
            } catch (error) {
                nameEl.textContent = 'Error'; listEl.innerHTML = `<li>Error: ${error.message}</li>`; hideLoading();
            }
        }
        async function analyzeRoot() {
            if (!db) return;
            const rootInput = document.getElementById('root-input');
            const rootTerm = rootInput.value.trim();
            const analyzedRootTermElement = document.getElementById('analyzed-root-term');
            const currentViewMode = document.querySelector('input[name="root-view-mode"]:checked').value; // Get current view mode at the start
            const occurrencesListElement = document.getElementById('root-occurrences-list');
            const graphContainer = document.getElementById('root-network-graph');
            const graphPlaceholder = document.getElementById('root-graph-placeholder');
            const paginationControls = document.getElementById('root-graph-pagination-controls');
            analyzedRootTermElement.textContent = rootTerm || 'N/A';
            allRootOccurrencesCache = [];
            currentRootGraphPage = 1;
            occurrencesListElement.innerHTML = '';
            graphContainer.innerHTML = '';
            if (rootNetwork) {
                rootNetwork.destroy();
                rootNetwork = null;
            }
            graphPlaceholder.style.display = 'none';
            paginationControls.style.display = 'none';
            if (!rootTerm) {
                setStatusMessage('root-status', 'Please enter an Arabic root word.', true);
                if (currentViewMode === 'list') occurrencesListElement.innerHTML = '<li>Please enter an Arabic root word.</li>';
                else { graphPlaceholder.textContent = 'Please enter an Arabic root word.'; graphPlaceholder.style.display = 'block'; }
                return;
            }
            if (rootTerm.length < 2) {
                setStatusMessage('root-status', 'Root term should be at least 2 characters.', true);
                if (currentViewMode === 'list') occurrencesListElement.innerHTML = '<li>Root term too short.</li>';
                else { graphPlaceholder.textContent = 'Root term too short.'; graphPlaceholder.style.display = 'block'; }
                return;
            }
            showLoading(`Analyzing root "${rootTerm}"...`);
            try {
                const allAyahs = await getAllData(STORE_QURAN);
                const foundOccurrences = []; // Temp array for this analysis run
                allAyahs.forEach(ayahData => {
                    const words = ayahData.arabic.split(/\s+/);
                    words.forEach(word => {
                        let wordanClean = word.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "");
                        let wordanNormalized = wordanClean
                            .replace(/ؤ|و/g, "(و|ؤ)")
                            .replace(/ك|ک/g, "(ك|ک)")
                            .replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)")
                            .replace(/ى|ی|ي/g, "(ى|ی|ي)")
                            .replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)")
                            .replace(/ے/g, "(ے|ی)")
                            .replace(/م/g, "(مٰ|م)");
                        let rootTermPatternPart = rootTerm.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "")
                            .replace(/ؤ|و/g, "(و|ؤ)")
                            .replace(/ك|ک/g, "(ك|ک)")
                            .replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)")
                            .replace(/ى|ی|ي/g, "(ى|ی|ي)")
                            .replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)")
                            .replace(/ے/g, "(ے|ی)")
                            .replace(/م/g, "(مٰ|م)");
                        let flexibleRootPatternStr = rootTermPatternPart
                            .replace(/ /g, ".{0,1}")
                            .replace(/-/g, ".{0,1}")
                            .replace(/۔/g, ".{0,1}");
                        let flexibleRegex = new RegExp(flexibleRootPatternStr);
                        let strictRootPatternStr = rootTermPatternPart.replace(/[ \-۔]/g, "");
                        if (flexibleRegex.test(wordanClean) || wordanClean.includes(strictRootPatternStr)) {
                            foundOccurrences.push({
                                surah: ayahData.surah,
                                ayah: ayahData.ayah,
                                word: word,
                                context: ayahData.arabic
                            });
                        }
                    });
                });
                allRootOccurrencesCache = [...foundOccurrences]; // Update the global cache
                if (allRootOccurrencesCache.length === 0) {
                    setStatusMessage('root-status', `No occurrences found for "${rootTerm}".`, false);
                    if (currentViewMode === 'list') {
                        occurrencesListElement.innerHTML = '<li>No occurrences found.</li>';
                    } else {
                        graphPlaceholder.textContent = 'No occurrences found to display in graph.';
                        graphPlaceholder.style.display = 'block';
                    }
                } else {
                    setStatusMessage('root-status', `Found ${allRootOccurrencesCache.length} occurrences for "${rootTerm}".`, false);
                    if (currentViewMode === 'list') {
                        occurrencesListElement.innerHTML = ''; // Clear any "graph active" message
                        allRootOccurrencesCache.forEach(occ => {
                            const li = document.createElement('li');
                            li.innerHTML = `
                                 <strong>Surah ${occ.surah}:${occ.ayah}</strong> - Word: <span lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.word}</span>
                                 <div class="result-context" lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.context}</div>
                             `;
                            occurrencesListElement.appendChild(li);
                        });
                    } else if (currentViewMode === 'tree') {
                        occurrencesListElement.innerHTML = '<li>Graph view active. Results may be paginated below.</li>';
                        graphPlaceholder.style.display = 'none';
                        updateRootGraphView(); // This will render the first page of the graph
                        paginationControls.style.display = (allRootOccurrencesCache.length > rootGraphItemsPerPage) ? 'flex' : 'none';
                    }
                }
            } catch (error) {
                console.error("Error analyzing root:", error);
                setStatusMessage('root-status', 'Failed to analyze root.', true);
                if (currentViewMode === 'list') occurrencesListElement.innerHTML = `<li>Error analyzing root: ${error.message}</li>`;
                else { graphPlaceholder.textContent = `Error analyzing root: ${error.message}`; graphPlaceholder.style.display = 'block'; }
            } finally {
                hideLoading();
            }
        }
        async function saveRootNotes() { // This function remains largely the same
            if (!db) return;
            const rootInput = document.getElementById('root-input');
            const descriptionInput = document.getElementById('root-description');
            const rootTerm = rootInput.value.trim();
            const description = descriptionInput.value.trim();
            if (!rootTerm) {
                setStatusMessage('root-status', 'Enter root word to save notes.', true);
                return;
            }
            showLoading("Saving root notes...");
            try {
                const allRoots = await getAllData(STORE_ROOTS);
                let existingRoot = allRoots.find(r => r.root === rootTerm);
                if (existingRoot) {
                    existingRoot.description = description;
                    await putData(STORE_ROOTS, existingRoot);
                    setStatusMessage('root-status', `Notes updated for "${rootTerm}".`, false);
                } else {
                    await addData(STORE_ROOTS, { root: rootTerm, description: description });
                    setStatusMessage('root-status', `Root "${rootTerm}" and notes saved.`, false);
                }
            } catch (error) {
                setStatusMessage('root-status', 'Failed to save root notes.', true);
            } finally {
                hideLoading();
            }
        }
        function updateRootGraphView() {
            const graphContainerWrapper = document.getElementById('root-network-graph-container');
            const graphContainer = document.getElementById('root-network-graph');
            const graphPlaceholder = document.getElementById('root-graph-placeholder');
            const paginationControls = document.getElementById('root-graph-pagination-controls');
            const analyzedRootTermElement = document.getElementById('analyzed-root-term');
            const rootTermForRender = analyzedRootTermElement ? analyzedRootTermElement.textContent : 'N/A'; // Defensive read
            if (graphContainerWrapper && !graphContainerWrapper.classList.contains('active-view')) {
                console.warn("updateRootGraphView called while graph view wrapper was not active. Forcing visible.");
                document.querySelectorAll('.root-view-content').forEach(el => {
                    el.classList.remove('active-view');
                    el.style.display = 'none';
                });
                graphContainerWrapper.classList.add('active-view');
                graphContainerWrapper.style.display = 'block';
            }
            if (rootTermForRender === 'N/A' || rootTermForRender.trim() === '') {
                if (graphContainer) graphContainer.innerHTML = '';
                if (rootNetwork) { rootNetwork.destroy(); rootNetwork = null; }
                if (graphPlaceholder) {
                    graphPlaceholder.textContent = 'Please analyze a root term first.';
                    graphPlaceholder.style.display = 'block';
                }
                if (paginationControls) paginationControls.style.display = 'none';
                console.log("updateRootGraphView: No root term analyzed.");
                return;
            }
            if (allRootOccurrencesCache.length === 0) {
                if (graphContainer) graphContainer.innerHTML = '';
                if (rootNetwork) { rootNetwork.destroy(); rootNetwork = null; }
                if (graphPlaceholder) {
                    graphPlaceholder.textContent = `No occurrences found for "${rootTermForRender}" to display in graph.`;
                    graphPlaceholder.style.display = 'block';
                }
                if (paginationControls) paginationControls.style.display = 'none';
                console.log("updateRootGraphView: allRootOccurrencesCache is empty.");
                return;
            }
            if (graphPlaceholder) graphPlaceholder.style.display = 'none';
            const startIndex = (currentRootGraphPage - 1) * rootGraphItemsPerPage;
            const endIndex = startIndex + rootGraphItemsPerPage;
            const occurrencesForPage = allRootOccurrencesCache.slice(startIndex, endIndex);
            console.log(`updateRootGraphView: Rendering page ${currentRootGraphPage} for root "${rootTermForRender}" with ${occurrencesForPage.length} items (from index ${startIndex} to ${endIndex - 1}).`);
            renderRootTreeGraph(rootTermForRender, occurrencesForPage);
            const totalPages = Math.ceil(allRootOccurrencesCache.length / rootGraphItemsPerPage);
            const pageInfoEl = document.getElementById('root-graph-page-info');
            const prevButton = document.getElementById('prev-root-graph-page-btn');
            const nextButton = document.getElementById('next-root-graph-page-btn');
            if (pageInfoEl) pageInfoEl.textContent = `Page ${currentRootGraphPage} of ${totalPages}`;
            if (prevButton) prevButton.disabled = (currentRootGraphPage === 1);
            if (nextButton) nextButton.disabled = (currentRootGraphPage >= totalPages);
            if (paginationControls) {
                if (totalPages > 1) {
                    paginationControls.style.display = 'flex';
                } else {
                    paginationControls.style.display = 'none';
                }
            }
            console.log(`Pagination updated: Page ${currentRootGraphPage}/${totalPages}. Prev disabled: ${prevButton ? prevButton.disabled : 'N/A'}, Next disabled: ${nextButton ? nextButton.disabled : 'N/A'}`);
        }
        function renderRootTreeGraph(rootTerm, occurrences) {
            if (typeof vis === 'undefined') {
                console.error("vis.js library is not loaded!");
                const errContainer = document.getElementById('root-network-graph');
                if (errContainer) errContainer.innerHTML = '<p style="color:red; text-align:center; padding:20px;">Error: Visualization library not loaded.</p>';
                return;
            }
            const container = document.getElementById('root-network-graph');
            if (!container) {
                console.error("Graph container #root-network-graph not found!");
                return;
            }
            container.innerHTML = '';
            if (rootNetwork) {
                rootNetwork.destroy();
                rootNetwork = null;
            }
            const popupEl = document.getElementById('root-node-popup');
            if (popupEl) popupEl.style.display = 'none';
            activeRootNodeIdForPopup = null;
            if (occurrences.length === 0 && rootTerm !== 'N/A' && rootTerm.trim() !== '') {
                container.innerHTML = `<p class="text-center" style="padding:20px;">No occurrences for "${rootTerm}" on this page.</p>`;
                return;
            } else if (rootTerm === 'N/A' || rootTerm.trim() === '') {
                container.innerHTML = `<p class="text-center" style="padding:20px;">Please analyze a root term.</p>`;
                return;
            }
            const arabicFontFamily = getCssVar('--font-arabic');
            const textPrimaryColor = getCssVar('--color-text-primary');
            const textSecondaryColor = getCssVar('--color-text-secondary');
            const bgSecondaryColor = getCssVar('--color-bg-secondary');
            const highlightBgColor = getCssVar('--color-highlight');
            const accentColorVar = getCssVar('--color-accent');
            const accentDarkColor = getCssVar('--color-accent-dark');
            const shadowColor = getCssVar('--color-shadow');
            const visNodes = new vis.DataSet();
            const visEdges = new vis.DataSet();
            const centralRootNodeId = 'ROOT_TERM_ID';
            visNodes.add({
                id: centralRootNodeId,
                label: rootTerm,
                font: { size: 22, face: arabicFontFamily, color: '#ffffff', strokeWidth: 0 },
                color: { background: accentDarkColor, border: accentColorVar, highlight: { background: accentColorVar, border: accentDarkColor } },
                shape: 'ellipse', size: 35, margin: { top: 15, right: 15, bottom: 15, left: 15 },
                fixed: false,
                isCentralRoot: true
            });
            occurrences.forEach((occ, index) => {
                const pageSpecificIndex = ((currentRootGraphPage - 1) * rootGraphItemsPerPage) + index;
                const nodeId = `occ_${occ.surah}_${occ.ayah}_${pageSpecificIndex}_${occ.word.replace(/[^a-zA-Z0-9א-آء-ي]/g, '')}`;
                visNodes.add({
                    id: nodeId,
                    label: `${occ.word} (S${occ.surah}:A${occ.ayah})`,
                    details_context: occ.context,
                    details_surah: occ.surah,
                    details_ayah: occ.ayah,
                    details_word: occ.word,
                    font: { face: arabicFontFamily, size: 16, color: textPrimaryColor, multi: true },
                    color: { background: bgSecondaryColor, border: accentColorVar, highlight: { background: highlightBgColor, border: accentDarkColor } },
                    margin: { top: 8, right: 8, bottom: 8, left: 8 }, widthConstraint: { maximum: 300 }, heightConstraint: { minimum: 40 },
                    shape: 'box',
                    isCentralRoot: false
                });
                visEdges.add({
                    from: centralRootNodeId, to: nodeId, arrows: 'to',
                    length: 180 + (occurrences.length > 10 ? occurrences.length * 2.5 : 0),
                    color: { color: textSecondaryColor, highlight: accentDarkColor, hover: accentColorVar }
                });
            });
            const data = { nodes: visNodes, edges: visEdges };
            const options = {
                layout: { hierarchical: false },
                interaction: { dragNodes: true, dragView: true, hover: true, tooltipDelay: 200, navigationButtons: true, keyboard: true },
                physics: {
                    enabled: true, barnesHut: { gravitationalConstant: -12000, centralGravity: 0.2, springLength: 180, springConstant: 0.025, damping: 0.08, avoidOverlap: 0.1 },
                    solver: 'barnesHut', stabilization: { enabled: true, iterations: 800, fit: true, updateInterval: 30 }
                },
                nodes: { borderWidth: 1.5, shadow: { enabled: true, size: 7, x: 4, y: 4, color: shadowColor } },
                edges: {
                    smooth: { enabled: true, type: "continuous", roundness: 0.5 },
                    arrows: { to: { enabled: true, scaleFactor: 0.9, type: 'arrow' } },
                    width: 1.8
                }
            };
            try {
                rootNetwork = new vis.Network(container, data, options);
            } catch (e) {
                console.error("Error initializing Vis.js Network:", e);
                container.innerHTML = `<p style="color:red;text-align:center;padding:20px;">Error creating graph. Check console.</p>`;
                return;
            }
            rootNetwork.on("click", function (params) {
                activeRootNodeIdForPopup = null;
                const clickPopupEl = document.getElementById('root-node-popup');
                if (clickPopupEl) clickPopupEl.style.display = 'none';
                if (params.nodes.length > 0) {
                    const clickedNodeId = params.nodes[0];
                    activeRootNodeIdForPopup = clickedNodeId;
                    positionRootNodePopupElement(clickedNodeId);
                } else {
                }
            });
            const updatePopupOnMoveOrZoom = () => {
                const movePopupEl = document.getElementById('root-node-popup');
                if (activeRootNodeIdForPopup !== null && movePopupEl && movePopupEl.style.display === 'block') {
                    positionRootNodePopupElement(activeRootNodeIdForPopup);
                }
            };
            rootNetwork.on("dragging", updatePopupOnMoveOrZoom);
            rootNetwork.on("zoom", updatePopupOnMoveOrZoom);
            rootNetwork.on("dragEnd", function (params) {
                if (activeRootNodeIdForPopup !== null && params.nodes && params.nodes.includes(activeRootNodeIdForPopup)) {
                    positionRootNodePopupElement(activeRootNodeIdForPopup);
                }
            });
        }
        function positionRootNodePopupElement(nodeId) {
            const popupEl = document.getElementById('root-node-popup'); // Get the element directly
            if (!rootNetwork || !popupEl) {
                console.warn("positionRootNodePopupElement: rootNetwork or popupEl not available.");
                if (popupEl) popupEl.style.display = 'none';
                return;
            }
            if (nodeId === null) { // Call this to hide the popup
                popupEl.style.display = 'none';
                activeRootNodeIdForPopup = null; // Reset active node ID
                return;
            }
            const visNodesDataSet = rootNetwork.body.data.nodes; // Access the DataSet
            const clickedNodeData = visNodesDataSet.get(nodeId);
            if (!clickedNodeData) {
                console.warn("Node data not found for ID:", nodeId, "in vis.DataSet. Hiding popup.");
                popupEl.style.display = 'none';
                activeRootNodeIdForPopup = null;
                return;
            }
            let popupHTML = "";
            const arabicFont = getCssVar('--font-arabic');
            const accentDarkColor = getCssVar('--color-accent-dark');
            const textPrimaryColor = getCssVar('--color-text-primary');
            const generalFontSize = '1.1rem';
            const arabicContextFontSize = '1.6rem';
            const generalLineHeight = '1.8';
            const arabicContextLineHeight = '2';
            if (clickedNodeData.isCentralRoot) {
                const rootDescriptionText = document.getElementById('root-description').value;
                popupHTML = `
                <h4 style="font-family: ${arabicFont}; font-size: 1.5rem; color: ${accentDarkColor}; margin-top:0; margin-bottom:10px;">Root: ${clickedNodeData.label}</h4>
                <p style="margin:0; line-height: ${generalLineHeight}; font-size: ${generalFontSize}; color: ${textPrimaryColor};">
                    ${rootDescriptionText.trim() !== "" ? rootDescriptionText.replace(/\n/g, '<br>') : "No description available for this root."}
                </p>`;
            } else {
                const wordDisplay = clickedNodeData.details_word || clickedNodeData.label.split(' (S')[0];
                popupHTML = `
                <h4 style="font-family: ${arabicFont}; font-size: 1.5rem; color: ${accentDarkColor}; margin-top:0; margin-bottom:10px;">
                    ${wordDisplay} (S${clickedNodeData.details_surah || '?'}:A${clickedNodeData.details_ayah || '?'})
                </h4>
                <p style="margin:0; line-height: ${arabicContextLineHeight}; font-size: ${arabicContextFontSize}; font-family: ${arabicFont}; direction: rtl; text-align: right; color: ${textPrimaryColor};">
                    ${clickedNodeData.details_context || "Full Ayah context not available."}
                </p>`;
            }
            popupEl.innerHTML = popupHTML;
            try {
                const nodePosition = rootNetwork.getPositions([nodeId])[nodeId];
                if (!nodePosition) {
                    popupEl.style.display = 'none'; return;
                }
                const domPosition = rootNetwork.canvasToDOM(nodePosition);
                popupEl.style.display = 'block';
                let popupLeft = domPosition.x + 25;
                let popupTop = domPosition.y - (popupEl.offsetHeight / 2);
                const popupRect = popupEl.getBoundingClientRect();
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                if (popupLeft + popupRect.width > vw - 15) {
                    popupLeft = domPosition.x - popupRect.width - 25;
                }
                if (popupLeft < 15) {
                    popupLeft = 15;
                }
                if (popupTop + popupRect.height > vh - 15) {
                    popupTop = vh - popupRect.height - 15;
                }
                if (popupTop < 15) {
                    popupTop = 15;
                }
                popupEl.style.left = popupLeft + 'px';
                popupEl.style.top = popupTop + 'px';
            } catch (e) {
                console.warn("Could not get node position for popup:", e);
                if (popupEl) popupEl.style.display = 'none';
            }
        }
        let isLoadingRecitationLogsGlobalFlag = false;
        async function loadRecitationLogs() {
            if (!db) {
                return;
            }
            if (isLoadingRecitationLogsGlobalFlag) {
                return;
            }
            isLoadingRecitationLogsGlobalFlag = true;
            const listEl = document.getElementById('recitations-list');
            if (!listEl) {
                console.error('[loadRecitationLogs] Element with ID "recitations-list" not found.');
                isLoadingRecitationLogsGlobalFlag = false;
                return;
            }
            listEl.innerHTML = ''; // Clear the list at the very beginning
            showLoading("Loading recitation logs...");
            try {
                const logs = await getAllData(STORE_RECITATIONS);
                if (!listEl.parentNode) {
                    isLoadingRecitationLogsGlobalFlag = false;
                    hideLoading();
                    return;
                }
                if (logs.length === 0) {
                    listEl.innerHTML = '<li>No entries logged yet.</li>';
                } else {
                    logs.sort((a, b) => new Date(b.date) - new Date(a.date));
                    logs.forEach(log => {
                        const li = document.createElement('li');
                        const range = log.ayahStart && log.ayahEnd ? `Ayahs ${log.ayahStart}-${log.ayahEnd}` :
                            log.ayahStart ? `Ayah ${log.ayahStart}` : 'Full Surah';
                        li.innerHTML = `
                                <strong>S ${log.surah} (${surahNames[log.surah - 1]})</strong> - ${range} <br>
                                Qari: ${log.qari || 'N/A'} | Date: ${log.date || 'N/A'}
                                ${log.notes ? `<br>Notes: <em>${log.notes}</em>` : ''}
                                <div style="margin-top: 5px;">
                                    <button data-log-id="${log.id}" class="delete-recitation-btn">Delete</button>
                                </div>
                            `;
                        listEl.appendChild(li);
                    });
                    listEl.querySelectorAll('.delete-recitation-btn').forEach(button => {
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', handleDeleteRecitationLog);
                    });
                }
            } catch (error) {
                console.error("[loadRecitationLogs] Error:", error);
                if (listEl) { // Check if listEl still exists before modifying
                    listEl.innerHTML = `<li>Error loading recitation logs: ${error.message}</li>`;
                }
            } finally {
                hideLoading();
                isLoadingRecitationLogsGlobalFlag = false; // Reset the flag
            }
        }
        async function saveRecitationLog() {
            if (!db) return;
            const surah = parseInt(document.getElementById('rec-surah-select').value, 10);
            const ayahStart = document.getElementById('rec-ayah-start').value ? parseInt(document.getElementById('rec-ayah-start').value, 10) : null;
            const ayahEnd = document.getElementById('rec-ayah-end').value ? parseInt(document.getElementById('rec-ayah-end').value, 10) : null;
            const qari = document.getElementById('rec-qari').value.trim();
            const date = document.getElementById('rec-date').value;
            const notes = document.getElementById('rec-notes').value.trim();
            if (isNaN(surah)) { setStatusMessage('recitation-status', 'Select Surah.', true); return; }
            if (!date) { setStatusMessage('recitation-status', 'Select date.', true); return; }
            if (ayahStart && (isNaN(ayahStart) || ayahStart < 1 || ayahStart > surahAyahCounts[surah])) {
                setStatusMessage('recitation-status', `Invalid Ayah Start.`, true); return;
            }
            if (ayahEnd && (isNaN(ayahEnd) || ayahEnd < 1 || ayahEnd > surahAyahCounts[surah])) {
                setStatusMessage('recitation-status', `Invalid Ayah End.`, true); return;
            }
            if (ayahStart && ayahEnd && ayahStart > ayahEnd) {
                setStatusMessage('recitation-status', 'Start Ayah > End Ayah.', true); return;
            }
            showLoading("Saving recitation log...");
            try {
                await addData(STORE_RECITATIONS, { surah, ayahStart, ayahEnd, qari, date, notes });
                setStatusMessage('recitation-status', 'Log entry saved.', false);
                ['rec-ayah-start', 'rec-ayah-end', 'rec-qari', 'rec-date', 'rec-notes'].forEach(id => document.getElementById(id).value = '');
                loadRecitationLogs();
            } catch (error) {
                setStatusMessage('recitation-status', 'Failed to save log.', true);
            } finally {
                hideLoading();
            }
        }
        async function handleDeleteRecitationLog(event) {
            if (!db) return;
            const logId = parseInt(event.target.getAttribute('data-log-id'), 10);
            if (isNaN(logId) || !confirm("Delete this log entry?")) return;
            showLoading("Deleting log entry...");
            try {
                await deleteData(STORE_RECITATIONS, logId);
                setStatusMessage('recitation-status', 'Log entry deleted.', false);
                loadRecitationLogs();
            } catch (error) {
                setStatusMessage('recitation-status', 'Failed to delete log.', true);
            } finally {
                hideLoading();
            }
        }
        let isLoadingHifzForSurahGlobalFlag = false;
        async function loadHifzForSurah(surah) {
            if (!db) {
                return;
            }
            if (isLoadingHifzForSurahGlobalFlag) {
                return;
            }
            isLoadingHifzForSurahGlobalFlag = true;
            const listEl = document.getElementById('hifz-ayahs-list');
            if (!listEl) {
                console.error('[loadHifzForSurah] Element with ID "hifz-ayahs-list" not found.');
                isLoadingHifzForSurahGlobalFlag = false;
                return;
            }
            listEl.innerHTML = ''; // Clear the list at the very beginning
            if (isNaN(surah) || surah < 1 || surah > 114) {
                listEl.innerHTML = '<p class="text-center">Select a valid Surah.</p>';
                isLoadingHifzForSurahGlobalFlag = false;
                return;
            }
            showLoading(`Loading Hifz for Surah ${surah} (${surahNames[surah - 1] || ''})...`);
            try {
                const totalAyahs = surahAyahCounts[surah]; // Ensure surahAyahCounts is globally available
                const store = getObjectStore(STORE_HIFZ, 'readonly');
                const keyRange = IDBKeyRange.bound([surah, 1], [surah, totalAyahs + 1]); // +1 to be inclusive of last ayah
                const request = store.getAll(keyRange);
                const hifzEntries = await new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => {
                        console.error(`Error fetching hifz entries for Surah ${surah}:`, event.target.error);
                        reject(event.target.error);
                    };
                });
                if (!listEl.parentNode) {
                    console.warn(`[loadHifzForSurah] listEl no longer in DOM after fetching data for Surah ${surah}.`);
                    isLoadingHifzForSurahGlobalFlag = false;
                    hideLoading();
                    return;
                }
                const hifzMap = new Map(hifzEntries.map(e => [e.ayah, e]));
                if (totalAyahs === 0) {
                    listEl.innerHTML = `<p class="text-center">No Ayahs listed for Surah ${surah}.</p>`;
                } else {
                    for (let i = 1; i <= totalAyahs; i++) {
                        const ayahData = hifzMap.get(i) || { surah, ayah: i, status: 'not-started', lastReviewDate: null, nextReviewDate: null, reviewCount: 0, notes: '' };
                        const li = document.createElement('div'); // Using div as per original for class 'ayah'
                        li.classList.add('ayah'); // This class usually has padding/border
                        li.setAttribute('data-ayah-ref', `${surah}:${i}`); // For easier debugging
                        let statusText = ayahData.status.replace('-', ' ');
                        let reviewInfo = '';
                        if (ayahData.status === 'memorized' && ayahData.nextReviewDate) {
                            reviewInfo = ` | Next Review: ${ayahData.nextReviewDate}`;
                        }
                        li.innerHTML = `
                            <div class="ayah-number">S ${surah}:${i}</div>
                            <div class="hifz-ayah-details" style="margin-bottom: 8px;">
                                Status: <span class="hifz-ayah-status status-${ayahData.status}">${statusText}</span>${reviewInfo}
                            </div>
                            <div class="hifz-ayah-controls flex-group" style="justify-content: flex-start; gap: 5px;">
                                <button data-surah="${surah}" data-ayah="${i}" data-status="not-started" class="set-hifz-status-btn" aria-label="Set Surah ${surah} Ayah ${i} to Not Started" ${ayahData.status === 'not-started' ? 'disabled' : ''}>Not Started</button>
                                <button data-surah="${surah}" data-ayah="${i}" data-status="in-progress" class="set-hifz-status-btn" aria-label="Set Surah ${surah} Ayah ${i} to In Progress" ${ayahData.status === 'in-progress' ? 'disabled' : ''}>In Progress</button>
                                <button data-surah="${surah}" data-ayah="${i}" data-status="memorized" class="set-hifz-status-btn" aria-label="Set Surah ${surah} Ayah ${i} to Memorized" ${ayahData.status === 'memorized' ? 'disabled' : ''}>Memorized</button>
                                ${ayahData.status === 'memorized' ? `<button data-surah="${surah}" data-ayah="${i}" class="record-review-btn" aria-label="Record review for Surah ${surah} Ayah ${i}">Record Review</button>` : ''}
                                <button data-surah="${surah}" data-ayah="${i}" class="view-hifz-notes-btn" aria-label="View or edit notes for Surah ${surah} Ayah ${i}">Notes</button>
                            </div>
                        `;
                        listEl.appendChild(li);
                    }
                    listEl.querySelectorAll('.set-hifz-status-btn').forEach(button => {
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', handleSetHifzStatus);
                    });
                    listEl.querySelectorAll('.record-review-btn').forEach(button => {
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', handleRecordReview);
                    });
                    listEl.querySelectorAll('.view-hifz-notes-btn').forEach(button => {
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', handleViewHifzNotes);
                    });
                }
            } catch (error) {
                console.error(`[loadHifzForSurah] Error for Surah ${surah}:`, error);
                if (listEl) { // Check if listEl still exists
                    listEl.innerHTML = `<li>Error loading Hifz data for Surah ${surah}: ${error.message}</li>`;
                }
            } finally {
                hideLoading();
                isLoadingHifzForSurahGlobalFlag = false; // Reset the flag
            }
        }
        async function handleSetHifzStatus(event) {
            if (!db) return;
            const surah = parseInt(event.target.getAttribute('data-surah'), 10);
            const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
            const status = event.target.getAttribute('data-status');
            showLoading(`Setting status for ${surah}:${ayah}...`);
            try {
                const existing = await getData(STORE_HIFZ, [surah, ayah]) || { surah, ayah, status: 'not-started', lastReviewDate: null, nextReviewDate: null, reviewCount: 0, notes: '' };
                existing.status = status;
                if (status !== 'memorized') {
                    existing.lastReviewDate = null; existing.nextReviewDate = null; existing.reviewCount = 0;
                } else if (!existing.lastReviewDate) {
                    existing.lastReviewDate = new Date().toISOString().split('T')[0];
                    existing.reviewCount = 0;
                    existing.nextReviewDate = calculateNextReview(existing.lastReviewDate, existing.reviewCount);
                }
                await putData(STORE_HIFZ, existing);
                setStatusMessage('hifz-status', `Status updated for ${surah}:${ayah}.`, false);
                loadHifzForSurah(surah);
            } catch (error) {
                setStatusMessage('hifz-status', 'Failed to update status.', true);
            } finally {
                hideLoading();
            }
        }
        async function handleRecordReview(event) {
            if (!db) return;
            const surah = parseInt(event.target.getAttribute('data-surah'), 10);
            const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
            showLoading(`Recording review for ${surah}:${ayah}...`);
            try {
                const existing = await getData(STORE_HIFZ, [surah, ayah]);
                if (!existing || existing.status !== 'memorized') {
                    setStatusMessage('hifz-status', 'Ayah not memorized.', true); hideLoading(); return;
                }
                existing.lastReviewDate = new Date().toISOString().split('T')[0];
                existing.reviewCount = (existing.reviewCount || 0) + 1;
                existing.nextReviewDate = calculateNextReview(existing.lastReviewDate, existing.reviewCount);
                await putData(STORE_HIFZ, existing);
                setStatusMessage('hifz-status', `Review recorded. Next: ${existing.nextReviewDate}`, false);
                loadHifzForSurah(surah);
            } catch (error) {
                setStatusMessage('hifz-status', 'Failed to record review.', true);
            } finally {
                hideLoading();
            }
        }
        function calculateNextReview(lastReviewDate, reviewCount) {
            const date = new Date(lastReviewDate);
            let daysToAdd = [1, 3, 7, 15, 30, 60, 90][Math.min(reviewCount, 6)] || 120; // Cap at 120 or extend
            date.setDate(date.getDate() + daysToAdd);
            return date.toISOString().split('T')[0];
        }
        async function handleViewHifzNotes(event) {
            if (!db) return;
            const surah = parseInt(event.target.getAttribute('data-surah'), 10);
            const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
            showLoading(`Loading notes for ${surah}:${ayah}...`);
            try {
                const existing = await getData(STORE_HIFZ, [surah, ayah]) || { surah, ayah, status: 'not-started', notes: '' };
                const notes = prompt(`Notes for Surah ${surah}:${ayah}:\n${existing.notes}\nEdit notes:`, existing.notes || '');
                if (notes !== null && notes !== existing.notes) {
                    existing.notes = notes;
                    await putData(STORE_HIFZ, existing);
                    setStatusMessage('hifz-status', `Notes updated.`, false);
                    loadHifzForSurah(surah);
                } else {
                    setStatusMessage('hifz-status', 'Notes unchanged.', false);
                }
            } catch (error) {
                setStatusMessage('hifz-status', 'Failed to load/save notes.', true);
            } finally {
                hideLoading();
            }
        }
        async function performSearch() {
            if (!db) return;
            const searchTerm = document.getElementById('search-input').value.trim().toLowerCase();
            const searchScopes = Array.from(document.querySelectorAll('.search-scope:checked')).map(cb => cb.value);
            const searchResultsList = document.getElementById('search-results-list');
            searchResultsList.innerHTML = '';
            if (!searchTerm) {
                setStatusMessage('search-status', 'Please enter a search term.', true);
                return;
            }
            if (searchScopes.length === 0) {
                setStatusMessage('search-status', 'Please select at least one search scope.', true);
                return;
            }
            showLoading(`Searching for "${searchTerm}"...`);
            try {
                const results = [];
                if (searchScopes.includes('quran-arabic') || searchScopes.includes('quran-translation')) {
                    const allAyahs = await getAllData(STORE_QURAN);
                    allAyahs.forEach(ayah => {
                        const normalizedSearchTerm = searchTerm.replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").replace(/ؤ|و/g, "(و|ؤ)").replace(/ك|ک/g, "(ك|ک)").replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)").replace(/ى|ی|ي/g, "(ى|ی|ي)").replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)").replace(/ے/g, "(ے|ی)").replace(/م/g, "(مٰ|م)");
                        const matchArabic = searchScopes.includes('quran-arabic') &&
                            ayah.arabic.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").replace(/ؤ|و/g, "(و|ؤ)").replace(/ك|ک/g, "(ك|ک)").replace(/آ|ا|أ|إ/g, "(آ|ا|أ|إ)").replace(/ى|ی|ي/g, "(ى|ی|ي)").replace(/ہ|ھ|ة|ۃ|ه/g, "(ہ|ھ|ة|ۃ|ه)").replace(/ے/g, "(ے|ی)").replace(/م/g, "(مٰ|م)").includes(normalizedSearchTerm);
                        let matchTranslation = false;
                        let translationSource = '';
                        let allTranslationsContext = [];
                        if (searchScopes.includes('quran-translation')) {
                            const translationConfigs = window.appManifest.filter(f => f.file_type === 'quran_translation');
                            translationConfigs.forEach(config => {
                                const langKey = config.key;
                                const label = config.label;
                                if (ayah[langKey] && ayah[langKey].toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").includes(normalizedSearchTerm)) {
                                    matchTranslation = true;
                                    translationSource = label; // Use the label from the manifest
                                }
                                if (ayah[langKey]) {
                                    allTranslationsContext.push(`${label}: ${ayah[langKey]}`);
                                }
                            });
                        }
                        if (matchArabic || matchTranslation) {
                            results.push({
                                type: 'Quran',
                                ref: `Surah ${ayah.surah}:${ayah.ayah}`,
                                surah: ayah.surah,
                                ayah: ayah.ayah,
                                context: `${ayah.arabic}${allTranslationsContext.length > 0 ? ' - ' + allTranslationsContext.join(' - ') : ''}`,
                                source: matchArabic && matchTranslation ? `Arabic & Translation (${translationSource})` : matchArabic ? 'Arabic' : `Translation (${translationSource})`
                            });
                        }
                    });
                }
                if (searchScopes.includes('tafsir')) {
                    const allTafsir = await getAllData(STORE_TAFSIR);
                    allTafsir.forEach(tafsir => {
                        if (tafsir.notes && tafsir.notes.toLowerCase().includes(searchTerm)) {
                            results.push({
                                type: 'Tafsir',
                                ref: `Surah ${tafsir.surah}:${tafsir.ayah}`,
                                surah: tafsir.surah,
                                ayah: tafsir.ayah,
                                context: tafsir.notes,
                                source: 'Personal Tafsir'
                            });
                        }
                    });
                }
                if (searchScopes.includes('themes')) {
                    const allThemes = await getAllData(STORE_THEMES);
                    allThemes.forEach(theme => {
                        if (theme.description && theme.description.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").includes(searchTerm)) {
                            results.push({
                                type: 'Theme',
                                ref: `Theme: ${theme.name}`,
                                context: theme.description,
                                source: 'Theme Description'
                            });
                        }
                    });
                    const allThemeAyahLinks = await getAllData(STORE_THEME_AYAHS);
                    const themesMap = new Map((await getAllData(STORE_THEMES)).map(t => [t.id, t.name]));
                    allThemeAyahLinks.forEach(link => {
                        if (link.notes && link.notes.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").includes(searchTerm)) {
                            results.push({
                                type: 'Theme Link',
                                ref: `Surah ${link.surah}:${link.ayah} (Theme: ${themesMap.get(link.themeId) || 'Unknown'})`,
                                surah: link.surah,
                                ayah: link.ayah,
                                context: link.notes,
                                source: 'Theme Link Notes'
                            });
                        }
                    });
                }
                if (searchScopes.includes('roots')) {
                    const allRoots = await getAllData(STORE_ROOTS);
                    allRoots.forEach(root => {
                        if (root.description && root.description.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").includes(searchTerm)) { // Assuming 'description' is the notes field
                            results.push({
                                type: 'Root',
                                ref: `Root: ${root.root}`,
                                context: root.description,
                                source: 'Root Notes'
                            });
                        }
                    });
                }
                if (searchScopes.includes('recitation')) {
                    const allRecitations = await getAllData(STORE_RECITATIONS);
                    allRecitations.forEach(log => {
                        if (log.notes && log.notes.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").includes(searchTerm)) {
                            const range = log.ayahStart && log.ayahEnd ? `${log.ayahStart}-${log.ayahEnd}` :
                                log.ayahStart ? `${log.ayahStart}` :
                                    log.ayahEnd ? `Up to ${log.ayahEnd}` : 'Full Surah';
                            results.push({
                                type: 'Recitation Log',
                                ref: `Surah ${log.surah} (${range})`,
                                context: log.notes,
                                source: 'Recitation Notes'
                            });
                        }
                    });
                }
                if (searchScopes.includes('hifz')) {
                    const allHifz = await getAllData(STORE_HIFZ);
                    allHifz.forEach(hifz => {
                        if (hifz.notes && hifz.notes.toLowerCase().replace(/[ًٌٍََُِِّْٰٓۡٔؒ]/g, "").includes(searchTerm)) {
                            results.push({
                                type: 'Hifz',
                                ref: `Surah ${hifz.surah}:${hifz.ayah}`,
                                surah: hifz.surah,
                                ayah: hifz.ayah,
                                context: hifz.notes,
                                source: 'Hifz Notes'
                            });
                        }
                    });
                }
                if (results.length === 0) {
                    searchResultsList.innerHTML = '<li>No results found.</li>';
                    setStatusMessage('search-status', `No results found for "${searchTerm}".`, false);
                } else {
                    setStatusMessage('search-status', `Found ${results.length} results for "${searchTerm}".`, false);
                    results.sort((a, b) => {
                        if (a.surah && b.surah && a.surah !== b.surah) return a.surah - b.surah;
                        if (a.ayah && b.ayah) return a.ayah - b.ayah;
                        return 0; // Don't sort other types
                    });
                    results.forEach(result => {
                        const li = document.createElement('li');
                        li.innerHTML = `
                     <strong>${result.type}: ${result.ref}</strong> (${result.source})
                     <div class="result-context">${highlightMatch(result.context, searchTerm)}</div>
                     ${(result.type === 'Quran' || result.type === 'Tafsir' || result.type === 'Hifz') ?
                                `<button data-surah="${result.surah}" data-ayah="${result.ayah}" class="go-to-ayah-btn" style="margin-top: 5px; padding: 3px 8px; font-size: 0.8rem;">Go to Ayah</button>` : ''}
                 `;
                        searchResultsList.appendChild(li);
                    });
                    searchResultsList.querySelectorAll('.go-to-ayah-btn').forEach(button => {
                        button.addEventListener('click', handleGoToAyahFromSearch);
                    });
                }
            } catch (error) {
                console.error("Error during search:", error);
                setStatusMessage('search-status', 'Failed to perform search.', true);
                searchResultsList.innerHTML = `<li>Error during search: ${error.message}</li>`;
            } finally {
                hideLoading();
            }
        }
        function highlightMatch(text, searchTerm) {
            if (!text || !searchTerm) return text;
            const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }
        async function handleGoToAyahFromSearch(event) {
            const surah = parseInt(event.target.getAttribute('data-surah'), 10);
            const ayah = parseInt(event.target.getAttribute('data-ayah'), 10);
            if (!isNaN(surah) && !isNaN(ayah)) {
                await loadAyah(surah, ayah);
                showSection('quran');
            }
        }
        async function exportData() {
            if (!db) return;
            showLoading("Exporting data...");
            try {
                const data = {};
                const userStores = [STORE_TAFSIR, STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS, STORE_HIFZ];
                for (const storeName of userStores) {
                    data[storeName] = await getAllData(storeName);
                }
                const jsonString = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `nur-al-quran-studio-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                setStatusMessage('export-status', 'Data exported.', false);
            } catch (error) {
                setStatusMessage('export-status', 'Export failed.', true);
            } finally {
                hideLoading();
            }
        }
        function getCssVar(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }
        async function importData(file) {
            if (!db || !file || !confirm("Importing will overwrite existing data. Continue?")) return;
            showLoading("Importing data...");
            try {
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        const userStores = [STORE_TAFSIR, STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS, STORE_HIFZ];
                        for (const storeName of userStores) {
                            if (!Array.isArray(data[storeName])) throw new Error(`Invalid data for ${storeName}`);
                        }
                        const transaction = db.transaction(userStores, 'readwrite');
                        transaction.oncomplete = async () => {
                            setStatusMessage('import-status', 'Data imported.', false);
                            await loadAyah(currentSurah, currentAyah); // Refresh UI
                            displayThemesList(); loadRecitationLogs();
                            if (document.getElementById('hifz-surah-select').value) loadHifzForSurah(parseInt(document.getElementById('hifz-surah-select').value, 10));
                            hideLoading();
                        };
                        transaction.onerror = () => { setStatusMessage('import-status', 'Import transaction failed.', true); hideLoading(); };
                        for (const storeName of userStores) {
                            const store = transaction.objectStore(storeName);
                            store.clear();
                            if (data[storeName]) {
                                data[storeName].forEach(item => {
                                    if ([STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS].includes(storeName)) {
                                        const newItem = { ...item };
                                        delete newItem.id; // Let DB assign new ID
                                        store.add(newItem).catch(e => console.warn(`Could not add item to ${storeName} during import: `, item, e));
                                    } else {
                                        store.put(item).catch(e => console.warn(`Could not put item to ${storeName} during import: `, item, e));
                                    }
                                });
                            }
                        }
                    } catch (parseError) {
                        setStatusMessage('import-status', 'Invalid import file format.', true); hideLoading();
                    }
                };
                reader.onerror = () => { setStatusMessage('import-status', 'Failed to read file.', true); hideLoading(); };
                reader.readAsText(file);
            } catch (error) {
                setStatusMessage('import-status', 'Import initiation failed.', true); hideLoading();
            }
        }
        async function clearAllPersonalData() {
            if (!db || !confirm("DELETE ALL personal data? This cannot be undone.")) return;
            showLoading("Clearing all personal data...");
            try {
                const userStores = [STORE_TAFSIR, STORE_THEMES, STORE_THEME_AYAHS, STORE_ROOTS, STORE_ROOT_AYAHS, STORE_RECITATIONS, STORE_HIFZ];
                const transaction = db.transaction(userStores, 'readwrite');
                transaction.oncomplete = () => {
                    setStatusMessage('clear-status', 'All personal data cleared.', false);
                    document.getElementById('tafsir-notes').value = '';
                    document.getElementById('themes-list').innerHTML = '<li>No themes added yet.</li>';
                    document.getElementById('root-occurrences-list').innerHTML = '<li>Enter a root word and click "Analyze Root".</li>';
                    document.getElementById('recitations-list').innerHTML = '<li>No entries logged yet.</li>';
                    document.getElementById('hifz-ayahs-list').innerHTML = '<p class="text-center">Select a Surah to track Hifz progress.</p>';
                    populateThemeSelects();
                    hideLoading();
                };
                transaction.onerror = () => { setStatusMessage('clear-status', 'Failed to clear data.', true); hideLoading(); };
                userStores.forEach(storeName => transaction.objectStore(storeName).clear());
            } catch (error) {
                setStatusMessage('clear-status', 'Data clear failed.', true); hideLoading();
            }
        }
        function applyTheme(themeName) {
            document.body.className = '';
            if (themeName !== 'serene') document.body.classList.add(`theme-${themeName}`);
            if (db) putData(STORE_SETTINGS, { name: 'theme', value: themeName }).catch(console.error);
        }
        async function loadThemePreference() {
            if (!db) return;
            try {
                const settings = await getData(STORE_SETTINGS, 'theme');
                const theme = settings ? settings.value : 'serene';
                document.getElementById('theme-switcher').value = theme;
                applyTheme(theme);
            } catch (error) { // Fallback to default
                document.getElementById('theme-switcher').value = 'serene'; applyTheme('serene');
            }
        }
        let eventListenersInitialized = false;
        function setupEventListeners() {
            if (eventListenersInitialized) {
                return;
            }
            const hamburgerBtn = document.getElementById('hamburger-btn');
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            const body = document.body;
            if (hamburgerBtn && sidebar && overlay && body) {
                const toggleSidebar = () => {
                    const isOpening = !body.classList.contains('sidebar-open');
                    body.classList.toggle('sidebar-open');
                    hamburgerBtn.setAttribute('aria-expanded', isOpening);
                };
                hamburgerBtn.addEventListener('click', toggleSidebar);
                overlay.addEventListener('click', toggleSidebar);
                sidebar.addEventListener('click', (e) => {
                    if (e.target.matches('a.nav-link') && body.classList.contains('sidebar-open')) {
                        toggleSidebar();
                    }
                });
            }
            document.getElementById('surah-select').addEventListener('change', (event) => {
                currentSurah = parseInt(event.target.value, 10);
                updateAyahSelect(currentSurah);
                loadAyah(currentSurah, currentAyah);
            });
            document.getElementById('ayah-select').addEventListener('change', (event) => {
                currentAyah = parseInt(event.target.value, 10);
                loadAyah(currentSurah, currentAyah);
            });
            document.getElementById('translation-select').addEventListener('change', async (event) => {
                const selectedKey = event.target.value;
                if (selectedKey === 'pashto') {
                    showPashtoNoticeOnce();
                }
                const selectedOption = event.target.selectedOptions[0];
                const isLoaded = selectedOption.dataset.isLoaded === 'true';
                if (!isLoaded) {
                    const config = JSON.parse(selectedOption.dataset.config);
                    await handleOnDemandLoad(config);
                } else {
                    await loadAyah(currentSurah, currentAyah);
                }
            });
            document.getElementById('save-tafsir-btn').addEventListener('click', saveTafsir);
            document.getElementById('add-theme-btn').addEventListener('click', addTheme);
            document.getElementById('link-ayah-to-theme-btn').addEventListener('click', linkAyahToTheme);
            document.getElementById('link-theme-select').addEventListener('change', displayLinkedAyahsForCurrentTheme);
            document.getElementById('analyze-root-btn').addEventListener('click', analyzeRoot);
            document.getElementById('save-root-notes-btn').addEventListener('click', saveRootNotes);
            document.getElementById('save-recitation-btn').addEventListener('click', saveRecitationLog);
            document.getElementById('rec-surah-select').addEventListener('change', (event) => {
                const surah = parseInt(event.target.value, 10);
                const totalAyahs = surahAyahCounts[surah];
                document.getElementById('rec-ayah-start').max = totalAyahs;
                document.getElementById('rec-ayah-end').max = totalAyahs;
            });
            document.getElementById('hifz-surah-select').addEventListener('change', (event) => {
                loadHifzForSurah(parseInt(event.target.value, 10));
            });
            document.getElementById('perform-search-btn').addEventListener('click', performSearch);
            document.getElementById('export-data-btn').addEventListener('click', exportData);
            document.getElementById('import-file').addEventListener('change', (event) => {
                document.getElementById('import-data-btn').disabled = !event.target.files[0];
            });
            document.getElementById('import-data-btn').addEventListener('click', () => {
                const fileInput = document.getElementById('import-file');
                if (fileInput.files.length > 0) importData(fileInput.files[0]);
                else setStatusMessage('import-status', 'Select file to import.', true);
            });
            document.getElementById('clear-data-btn').addEventListener('click', clearAllPersonalData);
            document.getElementById('theme-switcher').addEventListener('change', (event) => applyTheme(event.target.value));
            document.querySelectorAll('.modal .close-button').forEach(button => {
                button.addEventListener('click', (event) => event.target.closest('.modal').style.display = 'none');
            });
            window.addEventListener('click', (event) => {
                document.querySelectorAll('.modal').forEach(modal => { if (event.target === modal) modal.style.display = 'none'; });
            });
            window.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    document.querySelectorAll('.modal').forEach(modal => modal.style.display = 'none');
                }
            });
            setupTafsirDocxButton();
            document.querySelectorAll('input[name="root-view-mode"]').forEach(radio => {
                radio.addEventListener('change', function () {
                    const newViewMode = this.value;
                    const rootContents = document.querySelectorAll('.root-view-content');
                    rootContents.forEach(el => {
                        el.classList.remove('active-view');
                        el.style.display = 'none';
                    });
                    document.getElementById('root-graph-placeholder').style.display = 'none';
                    const paginationControls = document.getElementById('root-graph-pagination-controls');
                    const occurrencesListElement = document.getElementById('root-occurrences-list');
                    const graphContainerWrapper = document.getElementById('root-network-graph-container');
                    const graphContainer = document.getElementById('root-network-graph');
                    const analyzedRootTerm = document.getElementById('analyzed-root-term').textContent;
                    if (newViewMode === 'list') {
                        occurrencesListElement.classList.add('active-view');
                        occurrencesListElement.style.display = 'block';
                        paginationControls.style.display = 'none';
                        if (analyzedRootTerm !== 'N/A' && allRootOccurrencesCache.length > 0) {
                            occurrencesListElement.innerHTML = '';
                            allRootOccurrencesCache.forEach(occ => {
                                const li = document.createElement('li');
                                li.innerHTML = `
                        <strong>Surah ${occ.surah}:${occ.ayah}</strong> - Word: <span lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.word}</span>
                        <div class="result-context" lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.context}</div>
                    `;
                                occurrencesListElement.appendChild(li);
                            });
                        } else if (analyzedRootTerm === 'N/A') {
                            occurrencesListElement.innerHTML = '<li>Enter a root word and click "Analyze Root".</li>';
                        } else {
                            occurrencesListElement.innerHTML = '<li>No occurrences found or error in analysis.</li>';
                        }
                    } else if (newViewMode === 'tree') {
                        graphContainerWrapper.classList.add('active-view');
                        graphContainerWrapper.style.display = 'block';
                        occurrencesListElement.innerHTML = '<li>Graph view active. Results may be paginated below if applicable.</li>';
                        if (analyzedRootTerm !== 'N/A' && allRootOccurrencesCache.length > 0) {
                            updateRootGraphView();
                            paginationControls.style.display = (allRootOccurrencesCache.length > rootGraphItemsPerPage) ? 'flex' : 'none';
                        } else if (analyzedRootTerm !== 'N/A' && allRootOccurrencesCache.length === 0 && graphContainer.children.length === 0) {
                            analyzeRoot();
                        } else if (analyzedRootTerm === 'N/A') {
                            graphContainer.innerHTML = '';
                            document.getElementById('root-graph-placeholder').style.display = 'block';
                            document.getElementById('root-graph-placeholder').textContent = 'Enter a root and click "Analyze Root" to see the graph.';
                            paginationControls.style.display = 'none';
                        }
                    }
                });
            });
            function goToPrevRootGraphPage() {
                if (currentRootGraphPage > 1) {
                    currentRootGraphPage--;
                    updateRootGraphView();
                }
            }
            function goToNextRootGraphPage() {
                const totalPages = Math.ceil(allRootOccurrencesCache.length / rootGraphItemsPerPage);
                if (currentRootGraphPage < totalPages) {
                    currentRootGraphPage++;
                    updateRootGraphView();
                }
            }
            document.getElementById('prev-root-graph-page-btn').addEventListener('click', goToPrevRootGraphPage);
            document.getElementById('next-root-graph-page-btn').addEventListener('click', goToNextRootGraphPage);
            let graphCloseButton = null;
            document.querySelectorAll('input[name="root-view-mode"]').forEach(radio => {
                radio.addEventListener('change', function () {
                    const newViewMode = this.value;
                    const rootSection = document.getElementById('roots');
                    const graphContainerWrapper = document.getElementById('root-network-graph-container');
                    const occurrencesListElement = document.getElementById('root-occurrences-list');
                    const mainContent = document.querySelector('.main-content');
                    const header = document.querySelector('header');
                    const sidebar = document.querySelector('.sidebar');
                    if (graphCloseButton && graphCloseButton.parentNode) {
                        graphCloseButton.parentNode.removeChild(graphCloseButton);
                        graphCloseButton = null;
                    }
                    if (rootNodePopupEl) rootNodePopupEl.style.display = 'none';
                    activeRootNodeIdForPopup = null;
                    if (newViewMode === 'tree') {
                        document.body.classList.add('graph-fullscreen-active');
                        graphContainerWrapper.classList.add('fullscreen-graph');
                        if (header) header.style.display = 'none';
                        if (sidebar) sidebar.style.display = 'none';
                        mainContent.style.overflowY = 'hidden';
                        occurrencesListElement.classList.remove('active-view');
                        occurrencesListElement.style.display = 'none';
                        graphContainerWrapper.classList.add('active-view');
                        graphContainerWrapper.style.display = 'flex';
                        graphCloseButton = document.createElement('button');
                        graphCloseButton.textContent = 'Close Graph (Esc)';
                        graphCloseButton.classList.add('graph-fullscreen-close-btn');
                        graphCloseButton.onclick = () => {
                            document.getElementById('root-view-list').click();
                        };
                        graphContainerWrapper.appendChild(graphCloseButton);
                        if (allRootOccurrencesCache.length > 0 || document.getElementById('analyzed-root-term').textContent !== 'N/A') {
                            updateRootGraphView();
                        } else {
                            document.getElementById('root-network-graph').innerHTML = '';
                            document.getElementById('root-graph-placeholder').textContent = 'Analyze a root to see the graph.';
                            document.getElementById('root-graph-placeholder').style.display = 'block';
                        }
                        const paginationControls = document.getElementById('root-graph-pagination-controls');
                        if (paginationControls) {
                            paginationControls.style.display = (allRootOccurrencesCache.length > rootGraphItemsPerPage) ? 'flex' : 'none';
                        }
                    } else {
                        document.body.classList.remove('graph-fullscreen-active');
                        graphContainerWrapper.classList.remove('fullscreen-graph');
                        if (header) header.style.display = '';
                        if (sidebar) sidebar.style.display = '';
                        mainContent.style.overflowY = 'auto';
                        graphContainerWrapper.classList.remove('active-view');
                        graphContainerWrapper.style.display = 'none';
                        occurrencesListElement.classList.add('active-view');
                        occurrencesListElement.style.display = 'block';
                        document.getElementById('root-graph-pagination-controls').style.display = 'none';
                        const analyzedRootTermText = document.getElementById('analyzed-root-term').textContent;
                        if (analyzedRootTermText !== 'N/A' && allRootOccurrencesCache.length > 0) {
                            occurrencesListElement.innerHTML = '';
                            allRootOccurrencesCache.forEach(occ => {
                                const li = document.createElement('li');
                                li.innerHTML = `<strong>Surah ${occ.surah}:${occ.ayah}</strong> - Word: <span lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.word}</span><div class="result-context" lang="ar" dir="rtl" style="font-family: var(--font-arabic);">${occ.context}</div>`;
                                occurrencesListElement.appendChild(li);
                            });
                        } else if (analyzedRootTermText === 'N/A' || analyzedRootTermText.trim() === '') {
                            occurrencesListElement.innerHTML = '<li>Enter a root word and click "Analyze Root".</li>';
                        } else {
                            occurrencesListElement.innerHTML = '<li>No occurrences found or error in analysis.</li>';
                        }
                    }
                });
            });
            window.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' && document.body.classList.contains('graph-fullscreen-active')) {
                    if (graphCloseButton) {
                        graphCloseButton.click();
                    }
                }
            });
            window.addEventListener('beforeunload', handlePageUnload);
            eventListenersInitialized = true;
        }
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await openDB();
                await loadThemePreference();
                loadTranslationPreference();
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.addEventListener('click', (event) => {
                        event.preventDefault();
                        const sectionId = event.currentTarget.dataset.section;
                        if (sectionId && typeof showSection === 'function') {
                            showSection(sectionId);
                        }
                    });
                });
                setupEventListeners();
                await loadQuranData();
                displayThemesList();
                setupTafsirDocxButton();
                setupGameModal();
                initializeReportingModule_Enhanced(); // Your reporting module init
                window.rootNodePopupEl = document.getElementById('root-node-popup');
                if (!window.rootNodePopupEl) {
                    console.error("CRITICAL: Popup element #root-node-popup not found!");
                }
            } catch (error) {
                console.error("App initialization failed:", error);
                hideLoading();
                alert("Failed to initialize: " + error.message + "\nPlease clear website data and refresh.");
            }
        });
        let currentQuranView = 'single';
        let tooltipTimeout;
        function setupQuranViewSwitcher() {
            document.querySelectorAll('input[name="quran-view-mode"]').forEach(radio => {
                radio.addEventListener('change', function () {
                    currentQuranView = this.value;
                    document.getElementById('quran-display').style.display = (currentQuranView === 'single') ? 'block' : 'none';
                    document.getElementById('quran-continuous-display').style.display = (currentQuranView === 'continuous') ? 'block' : 'none';
                    document.getElementById('word-translation-area').style.display = (currentQuranView === 'single') ? 'block' : 'none';
                    loadAyah(currentSurah, currentAyah);
                });
            });
        }
        async function updateTafsirAndThemeViews() {
            if (!db || !currentSurah || !currentAyah) return;
            const tafsirAyahDisplay = document.getElementById('current-ayah-tafsir');
            const themeAyahDisplay = document.getElementById('current-ayah-theme-text');
            const tafsirNotes = document.getElementById('tafsir-notes');
            const themeAyahRef = document.getElementById('current-ayah-theme-ref');
            try {
                const quran = await getData(STORE_QURAN, [currentSurah, currentAyah]);
                const tafsir = await getData(STORE_TAFSIR, [currentSurah, currentAyah]);
                if (quran) {
                    const ayahElement = document.createElement('div');
                    ayahElement.classList.add('ayah');
                    ayahElement.innerHTML = `
                <div class="ayah-number">Surah ${currentSurah}:${currentAyah} (${surahNames[currentSurah - 1]})</div>
                <div class="ayah-arabic">${quran.arabic}</div>
            `;
                    tafsirAyahDisplay.innerHTML = '';
                    tafsirAyahDisplay.appendChild(ayahElement.cloneNode(true));
                    tafsirNotes.value = tafsir ? tafsir.notes : '';
                    themeAyahDisplay.innerHTML = '';
                    themeAyahDisplay.appendChild(ayahElement.cloneNode(true));
                    themeAyahRef.textContent = `${currentSurah}:${currentAyah}`;
                    await displayLinkedAyahsForCurrentTheme();
                }
            } catch (error) {
                console.error("Error updating secondary views:", error);
            }
        }
        async function loadAyah(surah, ayah) {
            const selectedTranslationKey = document.getElementById('translation-select').value;
            if (selectedTranslationKey === 'pashto') {
                showPashtoNoticeOnce();
            }
            if (!db) {
                console.error("Database not open for loadAyah.");
                document.getElementById('quran-display').innerHTML = `<p class="text-center" style="color: var(--color-error);">Database not ready. Please try again later.</p>`;
                return;
            }
            showLoading(`Loading Ayah ${surah}:${ayah}...`);
            try {
                const quran = await getData(STORE_QURAN, [surah, ayah]);
                if (quran) {
                    currentSurah = surah;
                    currentAyah = ayah;
                    updateAyahSelect(surah);
                    document.getElementById('surah-select').value = surah;
                    document.getElementById('ayah-select').value = ayah;
                    if (currentQuranView === 'single') {
                        await renderSingleAyahView(surah, ayah);
                    } else {
                        await renderContinuousView(surah, ayah);
                    }
                    await updateTafsirAndThemeViews();
                } else {
                    document.getElementById('quran-display').innerHTML = `<p class="text-center" style="color: var(--color-error);">Ayah ${surah}:${ayah} not found in data.</p>`;
                }
            } catch (error) {
                console.error("Error loading ayah:", error);
                document.getElementById('quran-display').innerHTML = `<p class="text-center" style="color: var(--color-error);">Error loading Ayah: ${error.message}</p>`;
            } finally {
                hideLoading();
            }
        }
        function getAllDataInRange(storeName, range, indexName) {
            return new Promise((resolve, reject) => {
                const source = indexName ? getObjectStore(storeName, 'readonly').index(indexName) : getObjectStore(storeName, 'readonly');
                const request = source.getAll(range);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (e) => reject(e.target.error);
            });
        }
        async function renderSingleAyahView(surah, ayah) {
            const displayArea = document.getElementById('quran-display');
            showLoading(`Loading Ayah ${surah}:${ayah}...`);
            try {
                const quran = await getData(STORE_QURAN, [surah, ayah]);
                if (!quran) { /* ... error handling ... */ return; }
                const words = quran.arabic.split(/\s+/).filter(w => w.trim());
                const wordMetadata = await getAllDataInRange(STORE_WORD_METADATA, IDBKeyRange.bound([surah, ayah, 0], [surah, ayah, Infinity]), 'location_idx');
                const metadataMap = new Map(wordMetadata.map(m => [m.word_position, m.word_id]));
                let wordsHTML = words.map((word, index) => {
                    const wordId = metadataMap.get(index) || 'null'; // Get ID from map using index
                    return `<span class="arabic-word" data-word-text="${word.trim()}" data-word-id="${wordId}" tabindex="0" role="button">${word}</span>`;
                }).join(' ');
                currentSurah = surah; currentAyah = ayah;
                document.getElementById('surah-select').value = surah;
                updateAyahSelect(surah);
                document.getElementById('ayah-select').value = ayah;
                const translationInfo = getTranslationConfig(document.getElementById('translation-select').value);
                displayArea.innerHTML = `
            <div class="ayah" data-surah="${surah}" data-ayah="${ayah}">
                <div class="ayah-number">Surah ${surah}:${ayah} (${surahNames[surah - 1]})</div>
                <div class="ayah-arabic">${wordsHTML}</div>
                <div class="ayah-translation" lang="${translationInfo.lang}" dir="${translationInfo.dir}" style="font-family:${translationInfo.font}">${quran[translationInfo.key] || "Translation not available."}</div>
            </div>`;
                addWordClickListeners();
            } catch (e) { console.error(e); } finally { hideLoading(); }
        }
        async function renderContinuousView(surah, targetAyah) {
            const displayArea = document.getElementById('quran-continuous-display');
            showLoading(`Loading Surah ${surah}...`);
            displayArea.innerHTML = '';
            try {
                const allAyahsInSurah = await getAllDataInRange(STORE_QURAN, IDBKeyRange.bound([surah, 1], [surah, surahAyahCounts[surah]]));
                const allMetadataForSurah = await getAllDataInRange(STORE_WORD_METADATA, IDBKeyRange.bound([surah, 1, 0], [surah, surahAyahCounts[surah], Infinity]), 'location_idx');
                const translationInfo = getTranslationConfig(document.getElementById('translation-select').value);
                allAyahsInSurah.forEach(quran => {
                    const words = quran.arabic.split(/\s+/).filter(w => w.trim());
                    const metadataMap = new Map(allMetadataForSurah.filter(m => m.ayah === quran.ayah).map(m => [m.word_position, m.word_id]));
                    let wordsHTML = words.map((word, index) => {
                        const wordId = metadataMap.get(index) || 'null';
                        return `<span class="arabic-word" data-word-text="${word.trim()}" data-word-id="${wordId}">${word}</span>`;
                    }).join(' ');
                    const ayahDiv = document.createElement('div');
                    ayahDiv.id = `s${quran.surah}a${quran.ayah}`;
                    ayahDiv.className = 'ayah';
                    ayahDiv.innerHTML = `
                <div class="ayah-number">Surah ${quran.surah}:${quran.ayah}</div>
                <div class="ayah-arabic">${wordsHTML}</div>
                <div class="ayah-translation" lang="${translationInfo.lang}" dir="${translationInfo.dir}" style="font-family:${translationInfo.font}">${quran[translationInfo.key] || "Translation not available."}</div>
            `;
                    displayArea.appendChild(ayahDiv);
                });
                addWordTooltipListeners();
                const targetElement = document.getElementById(`s${surah}a${targetAyah}`);
                if (targetElement) targetElement.scrollIntoView({ behavior: 'auto', block: 'center' });
            } catch (e) { console.error(e); } finally { hideLoading(); }
        }
        function addWordTooltipListeners() {
            document.querySelectorAll('#quran-continuous-display .arabic-word').forEach(span => {
                span.addEventListener('mouseenter', showWordTooltip);
                span.addEventListener('mouseleave', hideWordTooltip);
                span.addEventListener('click', (e) => {
                    e.preventDefault();
                    showWordTooltip(e, true);
                });
            });
        }
        async function showWordTooltip(event, isClick = false) {
            clearTimeout(tooltipTimeout);
            const span = event.target;
            const tooltip = document.getElementById('word-tooltip');
            const wordId = parseInt(span.dataset.wordId, 10);
            if (isNaN(wordId)) {
                tooltip.innerHTML = 'No translation data.';
            } else {
                const trans = await getData(STORE_WORD_TRANSLATIONS, wordId);
                tooltip.innerHTML = `
            <strong lang="ar" dir="rtl">${span.dataset.wordText}</strong><br>
            <span lang="ur" dir="rtl">Urdu: ${trans?.ur_meaning || "N/A"}</span><br>
            <span lang="ps" dir="rtl">Pashto: ${trans?.pashto_text || "N/A"}</span><br>
            <span lang="en" dir="ltr">English: ${trans?.en_meaning || "N/A"}</span>
        `;
            }
            tooltip.style.left = `${event.pageX + 10}px`;
            tooltip.style.top = `${event.pageY + 10}px`;
            tooltip.style.display = 'block';
            if (isClick) {
                tooltipTimeout = setTimeout(() => { tooltip.style.display = 'none'; }, 2000);
            }
        }
        function hideWordTooltip() {
            tooltipTimeout = setTimeout(() => {
                document.getElementById('word-tooltip').style.display = 'none';
            }, 300);
        }
        setupQuranViewSwitcher();
    </script>
    <div id="word-tooltip"
        style="display:none; position:absolute; background:var(--color-bg-secondary); border:1px solid var(--color-border); padding:10px; border-radius:var(--border-radius); z-index:1001; max-width:300px; pointer-events:none;">
    </div>
</body>

</html>
<script>
    async function loadDocxJs() {
        return new Promise((resolve, reject) => {
            if (window.docx) { // Check if already loaded
                console.log("docx.js already loaded.");
                resolve(window.docx);
                return;
            }
            console.log("Loading docx.js library...");
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/docx@9.5.0/dist/index.iife.min.js';
            script.onload = () => {
                console.log("docx.js loaded successfully.");
                resolve(window.docx); // The library attaches itself to window.docx
            };
            script.onerror = (err) => {
                console.error("Failed to load docx.js library:", err);
                reject("Failed to load DOCX library. Please check your internet connection.");
            };
            document.head.appendChild(script);
        });
    }
    async function exportTafsirToDocx() {
        setStatusMessage('export-tafsir-docx-status', 'Initializing DOCX export...', false);
        showLoading("Preparing Tafsir for DOCX export...");
        let docx;
        try {
            docx = await loadDocxJs();
            if (!docx || !docx.Document || !docx.Packer || !docx.Paragraph || !docx.TextRun || !docx.HeadingLevel) {
                throw new Error("DOCX library not loaded correctly or is an incompatible version.");
            }
        } catch (error) {
            console.error("Error loading DOCX library:", error);
            setStatusMessage('export-tafsir-docx-status', typeof error === 'string' ? error : 'Failed to load DOCX library.', true);
            hideLoading();
            return;
        }
        if (!db) {
            setStatusMessage('export-tafsir-docx-status', 'Database not ready.', true);
            hideLoading();
            return;
        }
        try {
            const allTafsirEntries = await getAllData(STORE_TAFSIR);
            if (!allTafsirEntries || allTafsirEntries.length === 0) {
                setStatusMessage('export-tafsir-docx-status', 'No Tafsir notes found to export.', false);
                hideLoading();
                return;
            }
            allTafsirEntries.sort((a, b) => {
                if (a.surah !== b.surah) return a.surah - b.surah;
                return a.ayah - b.ayah;
            });
            const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, ShadingType, convertInchesToTwip } = docx;
            const children = [];
            children.push(
                new Paragraph({
                    text: "My Personal Quran Tafsir",
                    heading: HeadingLevel.TITLE,
                    alignment: AlignmentType.CENTER,
                })
            );
            children.push(new Paragraph(" ")); // Spacer
            let currentProcessingSurah = -1;
            for (const tafsirEntry of allTafsirEntries) {
                if (tafsirEntry.surah !== currentProcessingSurah) {
                    currentProcessingSurah = tafsirEntry.surah;
                    const surahNameStr = surahNames[currentProcessingSurah - 1] || `Surah ${currentProcessingSurah}`;
                    children.push(
                        new Paragraph({
                            children: [
                                new TextRun({
                                    text: `Surah ${currentProcessingSurah}: ${surahNameStr}`,
                                    bold: true,
                                    size: 32, // 16pt font size (2 * 16)
                                    color: "2E74B5", // A blue color
                                }),
                            ],
                            heading: HeadingLevel.HEADING_1,
                            spacing: { before: convertInchesToTwip(0.2), after: convertInchesToTwip(0.1) },
                        })
                    );
                }
                const quranAyahData = await getData(STORE_QURAN, [tafsirEntry.surah, tafsirEntry.ayah]);
                const arabicText = quranAyahData ? quranAyahData.arabic : "Arabic text not found.";
                children.push(
                    new Paragraph({
                        children: [
                            new TextRun({
                                text: `Ayah ${tafsirEntry.ayah}`,
                                bold: true,
                                size: 28, // 14pt
                                color: "1F4E79", // Darker blue
                            }),
                        ],
                        spacing: { before: convertInchesToTwip(0.15), after: convertInchesToTwip(0.05) },
                    })
                );
                children.push(
                    new Paragraph({
                        children: [
                            new TextRun({
                                text: arabicText,
                                font: "Scheherazade New", // Specify an Arabic font
                                size: 36, // 18pt
                                rightToLeft: true, // Crucial for Arabic
                            }),
                        ],
                        alignment: AlignmentType.RIGHT,
                        bidirectional: true, // Important for mixed LTR/RTL content handling in Word
                        shading: { // Basic background color
                            type: ShadingType.SOLID,
                            color: "E8F5E9", // Light green (hex without #)
                            fill: "E8F5E9",
                        },
                        spacing: { after: convertInchesToTwip(0.1) },
                    })
                );
                const notesLines = tafsirEntry.notes.split('\n');
                notesLines.forEach((line, index) => {
                    children.push(
                        new Paragraph({
                            children: [
                                new TextRun({
                                    text: line,
                                    size: 24, // 12pt
                                }),
                            ],
                            indentation: { left: convertInchesToTwip(0.25) }, // Indent Tafsir notes
                            spacing: { after: (index === notesLines.length - 1) ? convertInchesToTwip(0.15) : convertInchesToTwip(0.02) },
                        })
                    );
                });
                children.push(new Paragraph(" ")); // Spacer after each tafsir entry
            }
            const doc = new Document({
                sections: [{
                    properties: {
                        page: {
                            margin: {
                                top: convertInchesToTwip(0.75),
                                right: convertInchesToTwip(0.75),
                                bottom: convertInchesToTwip(0.75),
                                left: convertInchesToTwip(0.75),
                            },
                        },
                    },
                    children: children,
                }],
                styles: {
                    default: {
                        document: {
                            run: {
                                font: "Calibri", // Default LTR font
                                size: 22, // 11pt default
                            },
                            paragraph: {
                                spacing: { line: 276 } // approx 1.15 line spacing
                            }
                        },
                    },
                    paragraphStyles: [
                        {
                            id: "arabicStyle",
                            name: "Arabic Text",
                            basedOn: "Normal",
                            next: "Normal",
                            run: {
                                font: "Scheherazade New",
                                size: 36,
                                rightToLeft: true,
                            },
                            paragraph: {
                                alignment: AlignmentType.RIGHT,
                                bidirectional: true,
                            }
                        }
                    ]
                }
            });
            Packer.toBlob(doc).then(blob => {
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = `Personal-Tafsir-${new Date().toISOString().split('T')[0]}.docx`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                setStatusMessage('export-tafsir-docx-status', 'Tafsir DOCX file generated.', false);
            }).catch(packError => {
                console.error("Error packing DOCX:", packError);
                setStatusMessage('export-tafsir-docx-status', 'Failed to generate DOCX file.', true);
            });
        } catch (error) {
            console.error("Error exporting Tafsir to DOCX:", error);
            setStatusMessage('export-tafsir-docx-status', 'Failed to export Tafsir to DOCX.', true);
        } finally {
            hideLoading();
        }
    }
    function setupTafsirDocxButton() {
        const exportDocxBtn = document.getElementById('export-tafsir-to-docx-btn');
        if (exportDocxBtn) {
            exportDocxBtn.addEventListener('click', exportTafsirToDocx);
        } else {
            console.warn("Export Tafsir to DOCX button not found.");
        }
    }
    function exitBrowserFullscreen() {
        if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
            if (document.exitFullscreen) {
                document.exitFullscreen().catch(err => console.error("Error exiting fullscreen:", err.message, err.name));
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) { /* Firefox */
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
            return true; // Indicate an exit was attempted
        }
        return false; // Indicate not in fullscreen or no attempt made
    }
    function requestBrowserFullscreenForDocument() {
        const docEl = document.documentElement;
        if (docEl.requestFullscreen) {
            docEl.requestFullscreen().catch(err => console.warn("FS Doc: Request failed:", err.message, err.name));
        } else if (docEl.webkitRequestFullscreen) { /* Safari */
            docEl.webkitRequestFullscreen();
        } else if (docEl.mozRequestFullScreen) { /* Firefox */
            docEl.mozRequestFullScreen();
        } else if (docEl.msRequestFullscreen) { /* IE/Edge */
            docEl.msRequestFullscreen();
        } else {
            console.warn("FS Doc: Browser Fullscreen API not supported for documentElement.");
        }
    }
    function loadTranslationPreference() {
        const selectElement = document.getElementById('translation-select');
        const storageKey = 'selectedTranslation';
        if (!selectElement) {
            console.error("Translation select element not found.");
            return;
        }
        selectElement.addEventListener('change', () => {
            localStorage.setItem(storageKey, selectElement.value);
        });
        const savedValue = localStorage.getItem(storageKey);
        if (savedValue) {
            if (selectElement.querySelector(`option[value="${savedValue}"]`)) {
                selectElement.value = savedValue;
            }
        }
    }
    function setupGameModal() {
        const gameModalHTML = `
    <div id="quranGameModal" class="modal game-modal" role="dialog" aria-modal="true" aria-labelledby="gameModalTitle" style="display: none;">
        <div class="modal-content game-modal-content">
            <span class="close-button game-close-button" aria-label="Close Game">×</span>
            <h2 id="gameModalTitle">Quranic Games</h2>
            <div class="game-selection-area"> <!-- Using class here -->
                <p>Choose a game to play:</p>
                <button id="startGameWordWhiz" class="game-select-btn">Lughat-ul-Nur</button>
                <button id="startGameAyahJumble" class="game-select-btn">Nazm-ul-Ayah</button>
            </div>
            <div id="gamePlayArea" class="game-play-area" style="display: none;">
                <!-- Game content will be loaded here -->
            </div>
                <div id="gameScoreArea" class="game-score-area" style="display: none;">
                    <p>Score: <span id="gameCurrentScore">0</span></p>
                    <p>High Score: <span id="gameHighScore">0</span> (for this session)</p>
                </div>
                <div class="game-controls">
                     <button id="quitGameButton" style="display:none; background-color: var(--color-error); margin-top:15px;">Quit Current Game</button>
                </div>
            </div>
        </div>
    `;
        document.body.insertAdjacentHTML('beforeend', gameModalHTML);
        const gameModalCSS = `
        .game-modal .modal-content {
            max-width: 90%;
            width: 700px; /* Adjust as needed */
            max-height: 90vh;
            overflow-y: auto;
            background-color: var(--color-bg-primary); /* Use theme colors */
            color: var(--color-text-primary);
        }
        .game-modal-content h2 {
            text-align: center;
            color: var(--color-text-secondary);
            margin-bottom: 0px;
        }
        .game-selection-area {
            text-align: center;
            margin-bottom: -3px;
        }
        .game-select-btn {
            margin: 10px;
            padding: 12px 20px;
            font-size: 1.1rem;
        }
        .game-play-area {
            padding: 8px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-secondary);
            min-height: fit-content;
            text-align: center;
        }
        .game-question-arabic {
            font-family: var(--font-arabic);
            font-size: 2rem;
            margin-bottom: 13px;
            direction: rtl;
        }
        .game-options-list {
            list-style: none;
            padding: 0;
            margin: 0 auto;
            max-width: 400px; /* Or adjust based on content */
        }
        .game-options-list li button {
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 12px;
            background-color: var(--color-accent);
            border: 1px solid var(--color-accent-dark);
            color: white;
            font-family: var(--font-general); /* Or specific language font */
        }
        .game-options-list li button:hover {
            background-color: var(--color-accent-dark);
        }
        .game-options-list li button.correct {
            background-color: #1050c5 !important;
        }
        .game-options-list li button.incorrect {
            background-color: var(--color-error) !important;
        }
        .game-feedback {
            margin-top: 15px;
            font-weight: bold;
        }
        .game-score-area {
            text-align: center;
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid var(--color-border);
        }
        .game-controls {
            text-align: center;
            margin-top: 20px;
        }
        .jumble-word-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            min-height: 50px; /* So it doesn't collapse */
            padding: 10px;
            border: 1px dashed var(--color-border);
            border-radius: var(--border-radius);
        }
        .jumble-word {
            font-family: var(--font-arabic);
            font-size: 1.8rem;
            padding: 8px 12px;
            background-color: var(--color-bg-primary);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            cursor: grab;
            user-select: none; /* Prevent text selection during drag */
            direction: rtl;
        }
        .jumble-word.dragging {
            opacity: 0.5;
            background-color: var(--color-highlight);
        }
        .jumble-target-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start; /* RTL friendly start */
            gap: 5px; /* Small gap for visual separation */
            padding: 10px;
            border: 2px solid var(--color-accent);
            border-radius: var(--border-radius);
            min-height: 70px;
            background-color: var(--color-bg-secondary);
            direction: rtl; /* Important for correct ordering display */
        }
        .jumble-target-area .jumble-word {
             cursor: default; /* No longer grabbable once placed */
        }
        #jumbleSubmitAnswer { margin-top: 15px; }
        .game-modal.fullscreen {
            padding: 0;
        }
        .game-modal.fullscreen .modal-content {
            width: 100%;
            max-width: 100%;
            height: 100vh;
            max-height: 100vh;
            border-radius: 0;
            display: flex;
            flex-direction: column;
        }
        .game-modal.fullscreen .game-play-area {
            flex-grow: 1;
            overflow-y: auto;
        }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.type = "text/css";
        styleSheet.innerText = gameModalCSS;
        document.head.appendChild(styleSheet);
        const gameModal = document.getElementById('quranGameModal');
        const closeButton = gameModal.querySelector('.game-close-button');
        const startGameWordWhizBtn = document.getElementById('startGameWordWhiz');
        const startGameAyahJumbleBtn = document.getElementById('startGameAyahJumble');
        const quitGameButton = document.getElementById('quitGameButton');
        function performModalCloseActions(switchToQuranViewer = true) {
            if (gameModal.style.display !== 'none') {
                const wasGameModalTheFullscreenElement = (
                    document.fullscreenElement === gameModal ||
                    document.webkitFullscreenElement === gameModal ||
                    document.mozFullScreenElement === gameModal || // Note: Older Firefox used mozFullScreenElement
                    document.msFullscreenElement === gameModal
                );
                gameModal.style.display = 'none';
                gameModal.classList.remove('fullscreen'); // CSS class for styling
                resetGameUI(); // This will also call restoreModalInteractivity
                activeGame = null;
                if (typeof recitationGame_State !== 'undefined' && recitationGame_State.gameActive) {
                    if (typeof stopReferenceAudio_Engine === 'function') stopReferenceAudio_Engine();
                    if (recitationGame_State.isRecording && typeof stopUserRecording_Recitation_Engine === 'function') stopUserRecording_Recitation_Engine();
                    if (recitationGame_State.speechRecognition && typeof recitationGame_State.speechRecognition.abort === 'function') recitationGame_State.speechRecognition.abort();
                    recitationGame_State.gameActive = false;
                    recitationGame_State.isRecording = false;
                }
                if (typeof ayahTypingGameActive !== 'undefined' && ayahTypingGameActive) {
                    if (typeof ayahTypingTimerInterval !== 'undefined' && ayahTypingTimerInterval) {
                        clearInterval(ayahTypingTimerInterval);
                        ayahTypingTimerInterval = null;
                    }
                    ayahTypingGameActive = false;
                }
                if (switchToQuranViewer && typeof showSection === 'function') {
                    showSection('quran');
                    const quranViewerSection = document.getElementById('quran');
                    if (quranViewerSection) {
                        quranViewerSection.setAttribute('tabindex', '-1'); // Make it focusable
                        quranViewerSection.focus();
                    }
                }
                if (wasGameModalTheFullscreenElement) {
                    if (exitBrowserFullscreen()) { // Check if exit was actually attempted
                        setTimeout(() => {
                            requestBrowserFullscreenForDocument();
                        }, 150); // Adjust delay if needed, 100-200ms usually okay
                    } else {
                        console.log("exitBrowserFullscreen reported not in FS, but wasGameModalTheFullscreenElement was true. This is odd. Focusing Quran viewer.");
                        const quranViewerSection = document.getElementById('quran');
                        if (quranViewerSection) quranViewerSection.focus();
                    }
                }
            }
        }
        function restoreModalInteractivity() {
            if (gameModal) {
                gameModal.style.pointerEvents = ''; // Or 'auto'
            }
        }
        function resetGameUI() {
            restoreModalInteractivity();
            setTimeout(() => {
                const gamePlayArea = document.getElementById('gamePlayArea');
                const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
                const gameScoreArea = document.getElementById('gameScoreArea');
                const quitGameButton = document.getElementById('quitGameButton');
                const gameModalTitle = document.getElementById('gameModalTitle');
                if (gameSelectionArea) {
                    gameSelectionArea.style.display = 'block';
                } else {
                    console.error("[MainGameModal] resetGameUI: gameSelectionArea (.game-selection-area) not found.");
                }
                if (gamePlayArea) {
                    gamePlayArea.style.display = 'none';
                    gamePlayArea.innerHTML = '';
                } else {
                    console.error("[MainGameModal] resetGameUI: gamePlayArea not found");
                }
                if (gameScoreArea) {
                    gameScoreArea.style.display = 'none';
                } else {
                    console.error("[MainGameModal] resetGameUI: gameScoreArea not found");
                }
                if (quitGameButton) {
                    quitGameButton.style.display = 'none';
                } else {
                    console.error("[MainGameModal] resetGameUI: quitGameButton not found");
                }
                if (gameModalTitle) {
                    gameModalTitle.textContent = "Quranic Games";
                } else {
                    console.error("[MainGameModal] resetGameUI: gameModalTitle not found");
                }
            }, 400);
        }
        function showGamePlayUI(gameTitle) {
            restoreModalInteractivity();
            const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
            const gamePlayArea = document.getElementById('gamePlayArea');
            const gameScoreArea = document.getElementById('gameScoreArea');
            const quitGameButton = document.getElementById('quitGameButton');
            const gameModalTitle = document.getElementById('gameModalTitle');
            if (gameSelectionArea) {
                gameSelectionArea.style.display = 'none';
            } else {
                console.error("[MainGameModal] showGamePlayUI: game-selection-area (.game-selection-area) not found.");
            }
            if (gamePlayArea) {
                gamePlayArea.style.display = 'block';
            } else {
                console.error("[MainGameModal] showGamePlayUI: gamePlayArea not found");
            }
            if (gameScoreArea) {
                gameScoreArea.style.display = 'block';
                if (typeof updateScoreDisplay === "function") updateScoreDisplay();
            } else {
                console.error("[MainGameModal] showGamePlayUI: gameScoreArea not found");
            }
            if (quitGameButton) {
                quitGameButton.style.display = 'block';
            } else {
                console.error("[MainGameModal] showGamePlayUI: quitGameButton not found");
            }
            if (gameModalTitle) {
                gameModalTitle.textContent = gameTitle;
            } else {
                console.error("[MainGameModal] showGamePlayUI: gameModalTitle not found");
            }
        }
        closeButton.addEventListener('click', () => {
            performModalCloseActions(true);
        });
        window.addEventListener('click', (event) => {
            if (event.target === gameModal) {
                performModalCloseActions(true);
            }
        });
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && gameModal.style.display === 'flex') {
                performModalCloseActions(true);
            }
        });
        startGameWordWhizBtn.addEventListener('click', () => startWordWhizGame());
        startGameAyahJumbleBtn.addEventListener('click', () => startAyahJumbleGame());
        quitGameButton.addEventListener('click', () => {
            activeGame = null;
            resetGameUI(); // Go back to game selection within the modal
        });
        const sidebarNav = document.querySelector('.sidebar nav ul');
        if (sidebarNav) {
            const gameLi = document.createElement('li');
            const gameLink = document.createElement('a');
            gameLink.href = "#games";
            gameLink.textContent = "Quranic Games";
            gameLink.id = "openGamesModalBtn"; // Important for your fullscreen IIFE
            gameLi.appendChild(gameLink);
            sidebarNav.appendChild(gameLi);
            gameLink.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('.nav-link.active').forEach(l => l.classList.remove('active'));
                gameLink.classList.add('active');
                restoreModalInteractivity();
                gameModal.style.display = 'flex';
                gameModal.classList.add('fullscreen'); // CSS class for styling the modal content
                resetGameUI(); // Show game selection screen
            });
        }
        addFlashcardSuiteButtonToModal();
        addAyahTypingGameButtonToModal();
        addEnhancedFullScreenReaderLaunchButton();
    }
    let activeGame = null; // To track which game is running
    let gameScore = 0;
    let gameHighScore = 0; // Session high score
    let wordWhizQuestions = [];
    let currentWordWhizQuestionIndex = 0;
    let ayahJumbleQuestion = null;
    function resetGameUI() {
        setTimeout(() => {
            const gamePlayArea = document.getElementById('gamePlayArea');
            const gameSelectionArea = document.getElementById('game-selection-area'); // THIS IS KEY
            const gameScoreArea = document.getElementById('gameScoreArea');
            const quitGameButton = document.getElementById('quitGameButton');
            const gameModalTitle = document.getElementById('gameModalTitle');
            if (!gameSelectionArea) {
                if (!gamePlayArea) {
                }
                const modalContent = document.querySelector('#quranGameModal .modal-content');
                if (modalContent && !gameSelectionArea) { // Check modalContent exists and gameSelectionArea is still missing
                }
            } else {
                gameSelectionArea.style.display = 'block';
            }
            if (gamePlayArea) {
                gamePlayArea.style.display = 'none';
                gamePlayArea.innerHTML = ''; // Clear any specific game content
            } else {
            }
            if (gameScoreArea) {
                gameScoreArea.style.display = 'none';
            } else {
                console.error("[MainGameModal] resetGameUI: gameScoreArea not found");
            }
            if (quitGameButton) {
                quitGameButton.style.display = 'none';
            } else {
                console.error("[MainGameModal] resetGameUI: quitGameButton not found");
            }
            if (gameModalTitle) {
                gameModalTitle.textContent = "Quranic Games"; // Default title
            } else {
                console.error("[MainGameModal] resetGameUI: gameModalTitle not found");
            }
        }, 400); // 400 millisecond timeout
    }
    function showGamePlayUI(gameTitle) {
        console.log(`[MainGameModal] showGamePlayUI called for title: "${gameTitle}".`);
        const gameSelectionArea = document.getElementById('game-selection-area'); // THIS IS KEY
        const gamePlayArea = document.getElementById('gamePlayArea');
        const gameScoreArea = document.getElementById('gameScoreArea');
        const quitGameButton = document.getElementById('quitGameButton');
        const gameModalTitle = document.getElementById('gameModalTitle');
        if (gameSelectionArea) {
            gameSelectionArea.style.display = 'none';
        } else {
            console.error("[MainGameModal] CRITICAL in showGamePlayUI: game-selection-area NOT FOUND.");
        }
        if (gamePlayArea) {
            gamePlayArea.style.display = 'block'; // Or 'flex' if your games use flex layout
        } else {
            console.error("[MainGameModal] showGamePlayUI: gamePlayArea not found");
        }
        if (gameScoreArea) {
            gameScoreArea.style.display = 'block';
            updateScoreDisplay();
        } else {
            console.error("[MainGameModal] showGamePlayUI: gameScoreArea not found");
        }
        if (quitGameButton) {
            quitGameButton.style.display = 'block';
        } else {
            console.error("[MainGameModal] showGamePlayUI: quitGameButton not found");
        }
        if (gameModalTitle) {
            gameModalTitle.textContent = gameTitle;
        } else {
            console.error("[MainGameModal] showGamePlayUI: gameModalTitle not found");
        }
    }
    function showGamePlayUI(gameTitle) {
        const gameSelectionArea = document.getElementById('game-selection-area');
        const gamePlayArea = document.getElementById('gamePlayArea');
        const gameScoreArea = document.getElementById('gameScoreArea');
        const quitGameButton = document.getElementById('quitGameButton');
        const gameModalTitle = document.getElementById('gameModalTitle');
        if (gameSelectionArea) {
            gameSelectionArea.style.display = 'none';
        } else {
        }
        if (gamePlayArea) {
            gamePlayArea.style.display = 'block';
        } else {
        }
        if (gameScoreArea) {
            gameScoreArea.style.display = 'block';
            updateScoreDisplay(); // Call this only if gameScoreArea exists
        } else {
        }
        if (quitGameButton) {
            quitGameButton.style.display = 'block';
        } else {
        }
        if (gameModalTitle) {
            gameModalTitle.textContent = gameTitle;
        } else {
        }
    }
    function updateScoreDisplay() {
        const gameCurrentScoreEl = document.getElementById('gameCurrentScore');
        const gameHighScoreEl = document.getElementById('gameHighScore');
        if (gameCurrentScoreEl) {
            gameCurrentScoreEl.textContent = gameScore;
        } else {
            console.error("updateScoreDisplay: gameCurrentScore element not found");
        }
        if (gameHighScoreEl) {
            gameHighScoreEl.textContent = gameHighScore;
        } else {
            console.error("updateScoreDisplay: gameHighScore element not found");
        }
    }
    function updateScoreDisplay() {
        document.getElementById('gameCurrentScore').textContent = gameScore;
        document.getElementById('gameHighScore').textContent = gameHighScore;
    }
    function getDynamicLanguageData(entry, langKey) {
        const config = getTranslationConfig(langKey);
        if (!entry || !config) {
            return { meaningText: null, meaningFont: 'var(--font-general)', meaningLangDir: 'ltr' };
        }
        const keyMap = {
            'urdu': 'ur_meaning',
            'english': 'en_meaning',
            'pashto': 'pashto_text',
            'Bangali': 'bn_meaning'
        };
        let meaningText = null;
        if (langKey === 'urdu' && entry.ur_meaning) {
            meaningText = entry.ur_meaning;
        } else if (langKey === 'english' && entry.en_meaning) {
            meaningText = entry.en_meaning;
        } else if (langKey === 'pashto' && entry.pashto_text) {
            meaningText = entry.pashto_text;
        } else if (langKey === 'Bangali' && entry.bn_meaning) {
            meaningText = entry.bn_meaning;
        } else {
            meaningText = entry.en_meaning || entry.ur_meaning || entry.pashto_text || entry.bn_meaning || null;
        }
        if (meaningText && meaningText.trim() === "") {
            meaningText = null;
        }
        return {
            meaningText,
            meaningFont: config.font,
            meaningLangDir: config.dir
        };
    }
    async function startWordWhizGame() {
        activeGame = 'wordWhiz';
        gameScore = 0;
        updateScoreDisplay();
        showGamePlayUI("Word Whiz Challenge");
        document.getElementById('gamePlayArea').innerHTML = '<p>Loading questions...</p>';
        try {
            const allWordMetadata = await getAllData(STORE_WORD_METADATA);
            const allWordTranslations = await getAllData(STORE_WORD_TRANSLATIONS);
            if (allWordMetadata.length < 10 || allWordTranslations.length < 10) {
                document.getElementById('gamePlayArea').innerHTML = '<p>Not enough word data to start the game. Please load Quran data first.</p>';
                return;
            }
            const translationMap = new Map();
            allWordTranslations.forEach(wt => translationMap.set(wt.word_id, wt));
            wordWhizQuestions = [];
            const selectedWordIds = new Set();
            const selectedLangKey = document.getElementById('translation-select').value;
            for (let i = 0; i < 10; i++) {
                let attempt = 0;
                let randomMetaEntry, quranAyah, wordText, translationEntry;
                while (attempt < 50) {
                    randomMetaEntry = allWordMetadata[Math.floor(Math.random() * allWordMetadata.length)];
                    if (selectedWordIds.has(randomMetaEntry.word_id)) {
                        attempt++; continue;
                    }
                    translationEntry = translationMap.get(randomMetaEntry.word_id);
                    if (!translationEntry || (!translationEntry.en_meaning && !translationEntry.ur_meaning && !translationEntry.bn_meaning && !translationEntry.pashto_text)) {
                        attempt++; continue;
                    }
                    quranAyah = await getData(STORE_QURAN, [randomMetaEntry.surah, randomMetaEntry.ayah]);
                    if (!quranAyah) {
                        attempt++; continue;
                    }
                    const wordsInAyah = quranAyah.arabic.split(/\s+/);
                    if (randomMetaEntry.word_position < wordsInAyah.length) {
                        wordText = wordsInAyah[randomMetaEntry.word_position];
                        if (wordText && wordText.trim() !== "") break;
                    }
                    attempt++;
                }
                if (!wordText) continue;
                selectedWordIds.add(randomMetaEntry.word_id);
                const { meaningText: correctAnswerText, meaningFont: fontPreference, meaningLangDir: langDir } = getDynamicLanguageData(translationEntry, selectedLangKey);
                if (!correctAnswerText || correctAnswerText.trim() === "") continue;
                const options = [correctAnswerText];
                let distractorCount = 0;
                while (distractorCount < 3 && options.length < allWordTranslations.length) {
                    const randomDistractorTrans = allWordTranslations[Math.floor(Math.random() * allWordTranslations.length)];
                    const { meaningText: distractorText } = getDynamicLanguageData(randomDistractorTrans, selectedLangKey);
                    if (distractorText && distractorText.trim() !== "" && !options.includes(distractorText) && distractorText !== correctAnswerText) {
                        options.push(distractorText);
                        distractorCount++;
                    }
                }
                shuffleArray(options);
                wordWhizQuestions.push({
                    word_id: randomMetaEntry.word_id,
                    arabicWord: wordText,
                    options: options,
                    correctAnswer: correctAnswerText,
                    fontPreference: fontPreference,
                    translationLangDir: langDir
                });
            }
            if (wordWhizQuestions.length === 0) {
                document.getElementById('gamePlayArea').innerHTML = '<p>Could not generate questions. Try again or check data.</p>';
                return;
            }
            currentWordWhizQuestionIndex = 0;
            displayWordWhizQuestion();
        } catch (error) {
            console.error("Error starting WordWhiz game:", error);
            document.getElementById('gamePlayArea').innerHTML = `<p>Error loading game: ${error.message}</p>`;
        }
    }
    function displayWordWhizQuestion() {
        if (currentWordWhizQuestionIndex >= wordWhizQuestions.length) {
            endWordWhizGame();
            return;
        }
        const q = wordWhizQuestions[currentWordWhizQuestionIndex];
        let optionsHTML = '<ul class="game-options-list">';
        q.options.forEach(option => {
            optionsHTML += `<li><button data-answer="${option}" style="font-family: ${q.fontPreference}; direction: ${q.translationLangDir}; text-align: ${q.translationLangDir === 'rtl' ? 'right' : 'left'};">${option}</button></li>`;
        });
        optionsHTML += '</ul>';
        const gamePlayArea = document.getElementById('gamePlayArea');
        gamePlayArea.innerHTML = `
        <p>What is the meaning of this word(in Quran)?</p>
        <div class="game-question-arabic">${q.arabicWord}</div>
        ${optionsHTML}
        <div class="game-feedback" id="wordWhizFeedback"></div>
        <button id="nextWordWhizQuestion" style="display:none; margin-top: 10px;">Next Question</button>
    `;
        gamePlayArea.querySelectorAll('.game-options-list button').forEach(button => {
            button.addEventListener('click', handleWordWhizAnswer);
        });
        document.getElementById('nextWordWhizQuestion').addEventListener('click', () => {
            currentWordWhizQuestionIndex++;
            displayWordWhizQuestion();
        });
    }
    function handleWordWhizAnswer(event) {
        const selectedButton = event.target;
        const selectedAnswer = selectedButton.dataset.answer;
        const q = wordWhizQuestions[currentWordWhizQuestionIndex];
        const feedbackEl = document.getElementById('wordWhizFeedback');
        const nextButton = document.getElementById('nextWordWhizQuestion');
        document.querySelectorAll('.game-options-list button').forEach(btn => {
            btn.disabled = true; // Disable all options
            if (btn.dataset.answer === q.correctAnswer) {
                btn.classList.add('correct');
            }
        });
        if (selectedAnswer === q.correctAnswer) {
            feedbackEl.textContent = "Correct!";
            feedbackEl.style.color = 'var(--color-success)';
            gameScore += 10;
            if (gameScore > gameHighScore) gameHighScore = gameScore;
            updateScoreDisplay();
        } else {
            feedbackEl.textContent = `Incorrect. The correct answer is: ${q.correctAnswer}`;
            feedbackEl.style.color = 'var(--color-error)';
            selectedButton.classList.add('incorrect'); // Mark the specific wrong choice
        }
        nextButton.style.display = 'inline-block';
    }
    function endWordWhizGame() {
        document.getElementById('gamePlayArea').innerHTML = `
        <h3>Game Over!</h3>
        <p>Your final score: ${gameScore}</p>
        <button id="playWordWhizAgain">Play Again</button>
    `;
        document.getElementById('playWordWhizAgain').addEventListener('click', startWordWhizGame);
        activeGame = null;
    }
    let jumbledWords = [];
    let correctOrderWords = [];
    let draggedItem = null;
    async function startAyahJumbleGame() {
        activeGame = 'ayahJumble';
        gameScore = 0; // Reset score for this game type
        updateScoreDisplay();
        showGamePlayUI("Ayah Jumble Challenge");
        document.getElementById('gamePlayArea').innerHTML = '<p>Loading Ayah...</p>';
        try {
            let randomAyahData, words;
            let attempts = 0;
            const MAX_ATTEMPTS = 20;
            const MIN_WORDS = 4;
            const MAX_WORDS = 10; // Keep ayahs relatively short for jumbling
            while (attempts < MAX_ATTEMPTS) {
                const randomSurah = Math.floor(Math.random() * 114) + 1;
                const randomAyahNum = Math.floor(Math.random() * surahAyahCounts[randomSurah]) + 1;
                randomAyahData = await getData(STORE_QURAN, [randomSurah, randomAyahNum]);
                if (randomAyahData && randomAyahData.arabic) {
                    words = randomAyahData.arabic.trim().split(/\s+/).filter(w => w.length > 0);
                    if (words.length >= MIN_WORDS && words.length <= MAX_WORDS) {
                        break; // Found a suitable Ayah
                    }
                }
                attempts++;
            }
            if (!words || words.length < MIN_WORDS) {
                document.getElementById('gamePlayArea').innerHTML = '<p>Could not find a suitable Ayah for the game. Please try again.</p>';
                return;
            }
            correctOrderWords = [...words]; // Store the correct order
            jumbledWords = shuffleArray([...words]); // Shuffle a copy for display
            ayahJumbleQuestion = {
                originalAyah: randomAyahData.arabic,
                words: words,
                surah: randomAyahData.surah,
                ayah: randomAyahData.ayah
            };
            displayAyahJumbleQuestion();
        } catch (error) {
            console.error("Error starting AyahJumble game:", error);
            document.getElementById('gamePlayArea').innerHTML = `<p>Error loading game: ${error.message}</p>`;
        }
    }
    function displayAyahJumbleQuestion() {
        const gamePlayArea = document.getElementById('gamePlayArea');
        let jumbledWordsHTML = '';
        jumbledWords.forEach((word, index) => {
            jumbledWordsHTML += `<div class="jumble-word" draggable="true" data-index="${index}" data-word="${word}">${word}</div>`;
        });
        gamePlayArea.innerHTML = `
        <p>Arrange the words to form the correct Ayah (Drag or Click):</p>
        <div id="jumbleSourceContainer" class="jumble-word-container">
            ${jumbledWordsHTML}
        </div>
        <p style="margin-top: 20px;">Your arrangement:</p>
        <div id="jumbleTargetContainer" class="jumble-target-area">
            <!-- Dropped/Clicked words will appear here -->
        </div>
        <button id="jumbleSubmitAnswer">Check Answer</button>
        <button id="jumbleResetArrangement" style="margin-left:10px;">Reset</button>
        <div class="game-feedback" id="ayahJumbleFeedback"></div>
        <button id="nextAyahJumbleQuestion" style="display:none; margin-top: 10px;">Next Ayah</button>
    `;
        addJumbleDragDropListeners(); // Sets up drag/drop
        const jumbleArea = gamePlayArea; // Or a more specific parent of both containers
        jumbleArea.removeEventListener('click', handleJumbleWordClick); // Remove old if any
        jumbleArea.addEventListener('click', handleJumbleWordClick);
        document.getElementById('jumbleSubmitAnswer').addEventListener('click', handleAyahJumbleSubmit);
        document.getElementById('jumbleResetArrangement').addEventListener('click', resetJumbleArrangement);
        document.getElementById('nextAyahJumbleQuestion').addEventListener('click', () => startAyahJumbleGame());
    }
    function addJumbleDragDropListeners() {
        const sourceContainer = document.getElementById('jumbleSourceContainer');
        const targetContainer = document.getElementById('jumbleTargetContainer');
        const attachListenersToWords = (containerSelector) => {
            document.querySelectorAll(`${containerSelector} .jumble-word`).forEach(draggable => {
                draggable.removeEventListener('dragstart', dragStartHandler); // Example of removing first
                draggable.addEventListener('dragstart', dragStartHandler);
                draggable.removeEventListener('dragend', dragEndHandler);
                draggable.addEventListener('dragend', dragEndHandler);
            });
        };
        const dragStartHandler = (e) => {
            draggedItem = e.target;
            setTimeout(() => draggedItem.classList.add('dragging'), 0);
        };
        const dragEndHandler = () => {
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
            }
            draggedItem = null;
        };
        attachListenersToWords('#jumbleSourceContainer');
        attachListenersToWords('#jumbleTargetContainer'); // If you want to drag within target too
        [sourceContainer, targetContainer].forEach(container => {
            container.removeEventListener('dragover', dragOverHandler);
            container.addEventListener('dragover', dragOverHandler);
            container.removeEventListener('drop', dropHandler);
            container.addEventListener('drop', dropHandler);
        });
    }
    const dragOverHandler = (e) => {
        e.preventDefault(); // Allow drop
    };
    const dropHandler = (e) => {
        e.preventDefault();
        const targetDropContainer = e.target.closest('.jumble-word-container, .jumble-target-area');
        if (draggedItem && targetDropContainer) { // Ensure draggedItem exists and drop is on a valid container
            const afterElement = getDragAfterElement(targetDropContainer, e.clientY, e.clientX);
            if (afterElement == null) {
                targetDropContainer.appendChild(draggedItem);
            } else {
                targetDropContainer.insertBefore(draggedItem, afterElement);
            }
            const feedbackEl = document.getElementById('ayahJumbleFeedback');
            const submitButton = document.getElementById('jumbleSubmitAnswer');
            if (feedbackEl) feedbackEl.textContent = '';
            if (submitButton) submitButton.disabled = false;
        }
    }
    function handleJumbleWordClick(event) {
        const clickedWord = event.target.closest('.jumble-word');
        if (!clickedWord) return;
        const sourceContainer = document.getElementById('jumbleSourceContainer');
        const targetContainer = document.getElementById('jumbleTargetContainer');
        const feedbackEl = document.getElementById('ayahJumbleFeedback');
        const submitButton = document.getElementById('jumbleSubmitAnswer');
        if (clickedWord.parentNode === sourceContainer) {
            targetContainer.appendChild(clickedWord);
        } else if (clickedWord.parentNode === targetContainer) {
            sourceContainer.appendChild(clickedWord); // Temporarily append
            const wordsInSource = [...sourceContainer.children];
            wordsInSource.sort((a, b) => parseInt(a.dataset.index) - parseInt(b.dataset.index));
            wordsInSource.forEach(word => sourceContainer.appendChild(word)); // Re-append in sorted order
        }
        if (feedbackEl) feedbackEl.textContent = '';
        if (submitButton) submitButton.disabled = false;
    }
    function getDragAfterElement(container, y, x) {
        const draggableElements = [...container.querySelectorAll('.jumble-word:not(.dragging)')];
        const containerDir = getComputedStyle(container).direction;
        for (const child of draggableElements) {
            const box = child.getBoundingClientRect();
            const childMidY = box.top + box.height / 2;
            const childMidX = box.left + box.width / 2; // Horizontal midpoint of the child element
            if (Math.abs(y - childMidY) < box.height) { // Is drop y-coordinate within the vertical span of the child?
                if (containerDir === 'rtl') {
                    if (x > childMidX) { // << REVERSED THIS COMPARISON for RTL
                        return child;
                    }
                } else { // LTR
                    if (x < childMidX) {
                        return child;
                    }
                }
            } else if (y < childMidY) {
                return child;
            }
        }
        return null; // If no element is found to insert before, append to the end of the container.
    }
    function resetJumbleArrangement() {
        const targetContainer = document.getElementById('jumbleTargetContainer');
        const sourceContainer = document.getElementById('jumbleSourceContainer');
        [...targetContainer.children].forEach(child => sourceContainer.appendChild(child));
        const wordsInSource = [...sourceContainer.children];
        wordsInSource.sort((a, b) => parseInt(a.dataset.index) - parseInt(b.dataset.index));
        wordsInSource.forEach(word => sourceContainer.appendChild(word)); // Re-append in sorted order
        if (document.getElementById('ayahJumbleFeedback')) {
            document.getElementById('ayahJumbleFeedback').textContent = '';
        }
        const submitButton = document.getElementById('jumbleSubmitAnswer');
        if (submitButton) {
            submitButton.disabled = false;
        }
        const nextButton = document.getElementById('nextAyahJumbleQuestion');
        if (nextButton) {
            nextButton.style.display = 'none';
        }
    }
    function handleAyahJumbleSubmit() {
        const targetContainer = document.getElementById('jumbleTargetContainer');
        const userAnswerWords = [...targetContainer.children].map(el => el.textContent.trim());
        const feedbackEl = document.getElementById('ayahJumbleFeedback');
        const nextButton = document.getElementById('nextAyahJumbleQuestion');
        const submitButton = document.getElementById('jumbleSubmitAnswer');
        if (userAnswerWords.join(' ') === correctOrderWords.join(' ')) {
            feedbackEl.textContent = "Correct! Masha'Allah!";
            feedbackEl.style.color = 'var(--color-success)';
            gameScore += 20; // Jumble might be harder
            if (gameScore > gameHighScore) gameHighScore = gameScore;
            updateScoreDisplay();
            nextButton.style.display = 'inline-block';
            submitButton.disabled = true;
            [...targetContainer.children].forEach(child => child.style.backgroundColor = 'var(--color-success)');
        } else {
            feedbackEl.textContent = `Not quite. Try again or reset. The correct Ayah is: ${ayahJumbleQuestion.originalAyah}`;
            feedbackEl.style.color = 'var(--color-error)';
            nextButton.style.display = 'none'; // Don't show next if wrong, encourage retry
            [...targetContainer.children].forEach(child => child.style.backgroundColor = 'var(--color-error)');
            setTimeout(() => { // Reset color after a bit
                [...targetContainer.children].forEach(child => child.style.backgroundColor = '');
            }, 2000);
        }
    }
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    let flashcardQuestions = [];
    let currentFlashcardIndex = 0;
    let flashcardShowAnswer = false;
    let memoryMatchCardsArray = []; // Renamed to avoid conflict if 'memoryMatchCards' is used elsewhere
    let memoryFirstCardFlipped = null; // Renamed
    let memorySecondCardFlipped = null; // Renamed
    let memoryLockBoardActive = false; // Renamed
    let memoryPairsFoundCount = 0; // Renamed
    let memoryAttemptCount = 0; // Renamed
    let memoryWordPairsForGame = []; // Renamed
    function injectFlashcardGameCSS_Suite() {
        const cssId = "flashcardGameStylesSuite"; // Unique ID
        if (document.getElementById(cssId)) return;
        const styles = `
        .flashcard-game-area { display: flex; flex-direction: column; align-items: center; width: 100%; padding: 10px; }
        .flashcard-container { perspective: 1000px; width: 90%; max-width: 320px; min-height: 180px; height: auto; aspect-ratio: 3 / 2; margin: 15px auto; cursor: pointer; }
        .flashcard { width: 100%; height: 100%; position: relative; transform-style: preserve-3d; transition: transform 0.6s; border: 1px solid var(--color-border); border-radius: var(--border-radius); }
        .flashcard.is-flipped { transform: rotateY(180deg); }
        .flashcard-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 15px; text-align: center; border-radius: var(--border-radius); background-color: var(--color-bg-secondary); color: var(--color-text-primary); overflow-wrap: break-word; word-break: break-word; }
        .flashcard-front { font-family: var(--font-arabic); font-size: clamp(1.8rem, 6vw, 2.8rem); direction: rtl; }
        .flashcard-back { transform: rotateY(180deg); font-size: clamp(1rem, 4vw, 1.4rem); }
        .flashcard-controls { margin-top: 15px; text-align: center; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; }
        .flashcard-controls button { min-width: 100px; }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
    }
    function injectMemoryMatchGameCSS_Suite() {
        const cssId = "memoryMatchGameStylesSuite"; // Unique ID
        if (document.getElementById(cssId)) return;
        const styles = `
        .memory-match-info { text-align: center; margin-bottom: 10px; font-size: 1.1rem; }
        .memory-match-attempts { font-weight: bold; color: var(--color-text-secondary); }
        .memory-match-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 10px; padding: 10px; max-width: 500px; margin: 15px auto; }
        .memory-card { aspect-ratio: 1 / 1; background-color: var(--color-accent); border: 1px solid var(--color-accent-dark); border-radius: var(--border-radius); display: flex; justify-content: center; align-items: center; cursor: pointer; font-size: 1rem; color: white; user-select: none; transform-style: preserve-3d; transition: transform 0.3s, background-color 0.3s; }
        .memory-card .card-content { display: none; text-align: center; overflow-wrap: break-word; word-break: break-word; padding: 5px; }
        .memory-card.arabic-text .card-content { font-family: var(--font-arabic); direction: rtl; font-size: clamp(1.1rem, 3.5vw, 1.6rem); }
        .memory-card.meaning-text .card-content { font-size: clamp(0.7rem, 2.5vw, 1rem); }
        .memory-card.is-flipped .card-content { display: block; }
        .memory-card.is-flipped { background-color: var(--color-bg-secondary); color: var(--color-text-primary); }
        .memory-card.is-matched { background-color: var(--color-success) !important; color: white !important; cursor: default; opacity: 0.8; }
        .memory-card.is-matched .card-content { display: block; }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
    }
    async function startFlashcardGame_Suite() {
        activeGame = 'flashcards_suite';
        showGamePlayUI("Flashcard Frenzy");
        injectFlashcardGameCSS_Suite();
        const gamePlayArea = document.getElementById('gamePlayArea');
        if (!gamePlayArea) { console.error("Flashcard: gamePlayArea not found!"); return; }
        gamePlayArea.innerHTML = '<p style="text-align:center; padding:20px;">Loading flashcards...</p>';
        try {
            const allWordMetadata = await getAllData(STORE_WORD_METADATA);
            const allWordTranslations = await getAllData(STORE_WORD_TRANSLATIONS);
            if (!allWordMetadata || allWordMetadata.length < 3 || !allWordTranslations || allWordTranslations.length < 3) {
                gamePlayArea.innerHTML = '<p style="text-align:center; padding:20px; color:var(--color-error);">Not enough word data for flashcards.</p>';
                return;
            }
            const translationMap = new Map(allWordTranslations.map(wt => [wt.word_id, wt]));
            flashcardQuestions = [];
            const selectedWordIds = new Set();
            const maxCards = 10;
            const selectedLangKey = document.getElementById('translation-select').value;
            for (let i = 0; i < maxCards * 2 && flashcardQuestions.length < maxCards; i++) {
                let attempt = 0;
                let randomMetaEntry, quranAyah, wordText, translationEntry;
                while (attempt < 20) {
                    randomMetaEntry = allWordMetadata[Math.floor(Math.random() * allWordMetadata.length)];
                    if (selectedWordIds.has(randomMetaEntry.word_id)) { attempt++; continue; }
                    translationEntry = translationMap.get(randomMetaEntry.word_id);
                    if (!translationEntry || (!translationEntry.en_meaning && !translationEntry.ur_meaning && !translationEntry.bn_meaning && !translationEntry.pashto_text)) { attempt++; continue; }
                    quranAyah = await getData(STORE_QURAN, [randomMetaEntry.surah, randomMetaEntry.ayah]);
                    if (!quranAyah || !quranAyah.arabic) { attempt++; continue; }
                    const wordsInAyah = quranAyah.arabic.split(/\s+/);
                    if (randomMetaEntry.word_position < wordsInAyah.length) {
                        wordText = wordsInAyah[randomMetaEntry.word_position];
                        if (wordText && wordText.trim() !== "") break;
                    }
                    attempt++;
                }
                if (!wordText) continue;
                selectedWordIds.add(randomMetaEntry.word_id);
                const { meaningText, meaningLangDir, meaningFont } = getDynamicLanguageData(translationEntry, selectedLangKey);
                if (!meaningText || meaningText.trim() === "" || meaningText.trim().toLowerCase() === "n/a") {
                    selectedWordIds.delete(randomMetaEntry.word_id); continue;
                }
                flashcardQuestions.push({ arabicWord: wordText, meaning: meaningText, meaningLangDir, meaningFont });
            }
            if (flashcardQuestions.length === 0) {
                gamePlayArea.innerHTML = '<p style="text-align:center; padding:20px; color:var(--color-error);">Could not generate any flashcards.</p>';
                return;
            }
            currentFlashcardIndex = 0;
            displayFlashcard_Suite();
        } catch (error) {
            console.error("Error starting Flashcard game (Suite):", error);
            gamePlayArea.innerHTML = `<p style="text-align:center; padding:20px; color:var(--color-error);">Error loading game: ${error.message}.</p>`;
        }
    }
    function displayFlashcard_Suite() {
        if (currentFlashcardIndex >= flashcardQuestions.length) {
            endFlashcardGame_Suite();
            return;
        }
        flashcardShowAnswer = false;
        const cardData = flashcardQuestions[currentFlashcardIndex];
        const gamePlayArea = document.getElementById('gamePlayArea');
        gamePlayArea.innerHTML = '';
        const gameAreaWrapper = document.createElement('div'); // Wrapper for content
        gameAreaWrapper.className = 'flashcard-game-area';
        const container = document.createElement('div');
        container.className = 'flashcard-container';
        const card = document.createElement('div');
        card.className = 'flashcard';
        const frontFace = document.createElement('div');
        frontFace.className = 'flashcard-face flashcard-front';
        frontFace.textContent = cardData.arabicWord;
        const backFace = document.createElement('div');
        backFace.className = 'flashcard-face flashcard-back';
        backFace.textContent = cardData.meaning;
        backFace.style.fontFamily = cardData.meaningFont;
        backFace.style.direction = cardData.meaningLangDir;
        backFace.style.textAlign = cardData.meaningLangDir === 'rtl' ? 'right' : 'left';
        card.append(frontFace, backFace);
        container.appendChild(card);
        gameAreaWrapper.appendChild(container);
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'flashcard-controls';
        const flipButton = document.createElement('button');
        flipButton.textContent = 'Flip Card';
        const gotItButton = document.createElement('button');
        gotItButton.textContent = 'Got it!';
        gotItButton.style.display = 'none';
        const notYetButton = document.createElement('button');
        notYetButton.textContent = 'Not Yet';
        notYetButton.style.display = 'none';
        controlsDiv.append(flipButton, gotItButton, notYetButton);
        gameAreaWrapper.appendChild(controlsDiv);
        gamePlayArea.appendChild(gameAreaWrapper);
        container.addEventListener('click', () => toggleFlashcardFlip_Suite(card, gotItButton, notYetButton, flipButton));
        flipButton.addEventListener('click', () => toggleFlashcardFlip_Suite(card, gotItButton, notYetButton, flipButton));
        gotItButton.addEventListener('click', () => handleFlashcardResponse_Suite(true));
        notYetButton.addEventListener('click', () => handleFlashcardResponse_Suite(false));
    }
    function toggleFlashcardFlip_Suite(cardEl, gotItBtn, notYetBtn, flipBtn) {
        cardEl.classList.toggle('is-flipped');
        flashcardShowAnswer = cardEl.classList.contains('is-flipped');
        gotItBtn.style.display = flashcardShowAnswer ? 'inline-block' : 'none';
        notYetBtn.style.display = flashcardShowAnswer ? 'inline-block' : 'none';
        flipBtn.textContent = flashcardShowAnswer ? 'Show Question' : 'Flip Card';
    }
    function handleFlashcardResponse_Suite(knewIt) {
        if (knewIt) {
        } else {
            const currentCardData = flashcardQuestions[currentFlashcardIndex]; // Get before incrementing
            flashcardQuestions.push(currentCardData); // Re-add to end
        }
        currentFlashcardIndex++;
        displayFlashcard_Suite();
    }
    function endFlashcardGame_Suite() {
        const gamePlayArea = document.getElementById('gamePlayArea');
        if (!gamePlayArea) return;
        const originalFlashcardSet = flashcardQuestions.slice(0, currentFlashcardIndex);
        const uniqueWordsForMemory = [];
        const seenArabicWords = new Set();
        for (const card of originalFlashcardSet) {
            if (!seenArabicWords.has(card.arabicWord) && uniqueWordsForMemory.length < 6) { // Max 6 pairs for memory game
                uniqueWordsForMemory.push(card);
                seenArabicWords.add(card.arabicWord);
            }
            if (uniqueWordsForMemory.length >= 6) break;
        }
        const canPlayMemory = uniqueWordsForMemory.length >= 2;
        let memoryBtnHTML = canPlayMemory ? `<button id="startMemoryMatchGameBtn_Suite">Test Your Memory!</button>` : `<p style="font-size:0.9em; margin-top:10px;">(Not enough unique cards seen for a memory game.)</p>`;
        gamePlayArea.innerHTML = `
        <div style="text-align:center; padding: 20px;">
            <h3>Flashcard Session Over!</h3>
            <p style="font-size:0.9em;">(Cards marked "Not Yet" are re-added to the end for more practice in the next flashcard round.)</p>
            <div style="margin-top: 20px; display:flex; flex-direction:column; align-items:center; gap:10px;">
                <button id="playFlashcardsAgain_Suite">Practice Flashcards Again</button>
                ${memoryBtnHTML}
            </div>
        </div>
    `;
        const playAgainFCBtn = document.getElementById('playFlashcardsAgain_Suite');
        if (playAgainFCBtn) playAgainFCBtn.addEventListener('click', startFlashcardGame_Suite);
        if (canPlayMemory) {
            const startMemoryBtn = document.getElementById('startMemoryMatchGameBtn_Suite');
            if (startMemoryBtn) startMemoryBtn.addEventListener('click', () => startMemoryMatchGame_Suite(uniqueWordsForMemory));
        }
        activeGame = null;
    }
    async function startMemoryMatchGame_Suite(wordDataForGame) {
        activeGame = 'memoryMatch_suite';
        showGamePlayUI("Memory Match Challenge");
        injectMemoryMatchGameCSS_Suite();
        const gamePlayArea = document.getElementById('gamePlayArea');
        if (!gamePlayArea) { console.error("Memory Match: gamePlayArea not found!"); return; }
        gamePlayArea.innerHTML = '<p style="text-align:center; padding:20px;">Setting up the memory board...</p>';
        memoryWordPairsForGame = [...wordDataForGame];
        memoryMatchCardsArray = [];
        memoryPairsFoundCount = 0;
        memoryAttemptCount = 0;
        memoryLockBoardActive = false;
        memoryFirstCardFlipped = null;
        memorySecondCardFlipped = null;
        memoryWordPairsForGame.forEach((pair, index) => {
            memoryMatchCardsArray.push({ id: `arabic-${index}`, type: 'arabic', content: pair.arabicWord, pairId: index, isFlipped: false, isMatched: false });
            memoryMatchCardsArray.push({ id: `meaning-${index}`, type: 'meaning', content: pair.meaning, pairId: index, font: pair.meaningFont, dir: pair.meaningLangDir, isFlipped: false, isMatched: false });
        });
        shuffleArray(memoryMatchCardsArray); // Your global shuffle function
        renderMemoryBoard_Suite();
        updateMemoryGameInfo_Suite();
    }
    function renderMemoryBoard_Suite() {
        const gamePlayArea = document.getElementById('gamePlayArea');
        gamePlayArea.innerHTML = '';
        const infoDiv = document.createElement('div');
        infoDiv.className = 'memory-match-info';
        infoDiv.innerHTML = `Pairs Found: <span id="memoryPairsFoundEl_Suite">0</span>/${memoryWordPairsForGame.length} | Attempts: <span id="memoryAttemptsEl_Suite" class="memory-match-attempts">0</span>`;
        gamePlayArea.appendChild(infoDiv);
        const grid = document.createElement('div');
        grid.className = 'memory-match-grid';
        const numCards = memoryMatchCardsArray.length;
        let columns = (numCards <= 6) ? 3 : (numCards <= 8) ? 4 : (numCards <= 12) ? 4 : 4;
        grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
        memoryMatchCardsArray.forEach(cardData => {
            const cardElement = document.createElement('div');
            cardElement.className = 'memory-card';
            cardElement.dataset.id = cardData.id;
            const contentSpan = document.createElement('span');
            contentSpan.className = 'card-content';
            contentSpan.textContent = cardData.content;
            if (cardData.type === 'arabic') cardElement.classList.add('arabic-text');
            else {
                cardElement.classList.add('meaning-text');
                contentSpan.style.fontFamily = cardData.font;
                contentSpan.style.direction = cardData.dir;
                contentSpan.style.textAlign = cardData.dir === 'rtl' ? 'right' : 'left';
            }
            cardElement.appendChild(contentSpan);
            if (cardData.isFlipped) cardElement.classList.add('is-flipped');
            if (cardData.isMatched) cardElement.classList.add('is-matched', 'is-flipped');
            cardElement.addEventListener('click', () => handleMemoryCardClick_Suite(cardElement, cardData));
            grid.appendChild(cardElement);
        });
        gamePlayArea.appendChild(grid);
    }
    function handleMemoryCardClick_Suite(cardEl, cardData) {
        if (memoryLockBoardActive || cardData.isFlipped || cardData.isMatched) return;
        cardData.isFlipped = true;
        cardEl.classList.add('is-flipped');
        if (!memoryFirstCardFlipped) {
            memoryFirstCardFlipped = cardData;
            return;
        }
        memorySecondCardFlipped = cardData;
        memoryLockBoardActive = true;
        memoryAttemptCount++;
        updateMemoryGameInfo_Suite();
        checkForMemoryMatch_Suite();
    }
    function checkForMemoryMatch_Suite() {
        const isMatch = memoryFirstCardFlipped.pairId === memorySecondCardFlipped.pairId;
        if (isMatch) {
            memoryFirstCardFlipped.isMatched = true;
            memorySecondCardFlipped.isMatched = true;
            memoryPairsFoundCount++;
            updateMemoryGameInfo_Suite();
            document.querySelector(`.memory-card[data-id="${memoryFirstCardFlipped.id}"]`)?.classList.add('is-matched');
            document.querySelector(`.memory-card[data-id="${memorySecondCardFlipped.id}"]`)?.classList.add('is-matched');
            resetMemoryTurn_Suite();
            if (memoryPairsFoundCount === memoryWordPairsForGame.length) {
                setTimeout(endMemoryMatchGame_Suite, 600);
            }
        } else {
            setTimeout(() => {
                if (memoryFirstCardFlipped) memoryFirstCardFlipped.isFlipped = false; // Check if nullified by rapid clicks
                if (memorySecondCardFlipped) memorySecondCardFlipped.isFlipped = false;
                document.querySelector(`.memory-card[data-id="${memoryFirstCardFlipped?.id}"]`)?.classList.remove('is-flipped');
                document.querySelector(`.memory-card[data-id="${memorySecondCardFlipped?.id}"]`)?.classList.remove('is-flipped');
                resetMemoryTurn_Suite();
            }, 1200);
        }
    }
    function resetMemoryTurn_Suite() {
        memoryFirstCardFlipped = null;
        memorySecondCardFlipped = null;
        memoryLockBoardActive = false;
    }
    function updateMemoryGameInfo_Suite() {
        const pairsEl = document.getElementById('memoryPairsFoundEl_Suite');
        const attemptsEl = document.getElementById('memoryAttemptsEl_Suite');
        if (pairsEl) pairsEl.textContent = memoryPairsFoundCount;
        if (attemptsEl) attemptsEl.textContent = memoryAttemptCount;
    }
    function endMemoryMatchGame_Suite() {
        const gamePlayArea = document.getElementById('gamePlayArea');
        if (!gamePlayArea) return;
        gamePlayArea.innerHTML = `
        <div style="text-align:center; padding: 20px;">
            <h3>Memory Game Cleared!</h3>
            <p>You found all ${memoryPairsFoundCount} pairs in ${memoryAttemptCount} attempts!</p>
            <div style="margin-top:15px; display:flex; justify-content:center; gap:10px;">
                <button id="playMemoryMatchAgainBtn_Suite">Play Memory Again</button>
                <button id="backToGameSelectionBtn_Suite">Game Selection</button>
            </div>
        </div>
    `;
        const playAgainMMBtn = document.getElementById('playMemoryMatchAgainBtn_Suite');
        if (playAgainMMBtn) playAgainMMBtn.addEventListener('click', () => startMemoryMatchGame_Suite(memoryWordPairsForGame)); // Restart with same words
        const backBtn = document.getElementById('backToGameSelectionBtn_Suite');
        if (backBtn) backBtn.addEventListener('click', () => { activeGame = null; resetGameUI(); });
        activeGame = null;
    }
    function addFlashcardSuiteButtonToModal() {
        const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
        const buttonId = 'startGameFlashcardSuiteBtn';
        if (gameSelectionArea && !document.getElementById(buttonId)) {
            const suiteButton = document.createElement('button');
            suiteButton.id = buttonId;
            suiteButton.className = 'game-select-btn';
            suiteButton.textContent = 'Flashcard & Memory'; // Combined name
            suiteButton.addEventListener('click', startFlashcardGame_Suite);
            const existingButtons = gameSelectionArea.querySelectorAll('.game-select-btn');
            if (existingButtons.length > 0) {
                existingButtons[existingButtons.length - 1].insertAdjacentElement('afterend', suiteButton);
            } else {
                gameSelectionArea.appendChild(suiteButton);
            }
        }
    }
    function updateVisualReadingProgress(currentS, currentA) {
        if (!visualReadingSession.active) return;
        visualReadingSession.endSurah = parseInt(currentS);
        visualReadingSession.endAyah = parseInt(currentA);
    }
    async function logVisualReadingSession() {
        if (!visualReadingSession.active || !visualReadingSession.startSurah || !visualReadingSession.endSurah) {
            visualReadingSession = { active: false, startSurah: null, startAyah: null, endSurah: null, endAyah: null };
            return;
        }

        const { startSurah, startAyah, endSurah, endAyah } = visualReadingSession;
        if (startSurah === endSurah && startAyah === endAyah) {
            visualReadingSession = { active: false, startSurah: null, startAyah: null, endSurah: null, endAyah: null };
            return;
        }

        const logPromises = [];
        const qariName = "Visual/Self Reading";
        for (let s = startSurah; s <= endSurah; s++) {
            const currentStartAyah = (s === startSurah) ? startAyah : 1;
            const currentEndAyah = (s === endSurah) ? endAyah : surahAyahCounts[s];

            const logEntry = {
                surah: s,
                ayahStart: currentStartAyah,
                ayahEnd: currentEndAyah,
                qari: qariName,
                date: new Date().toISOString().split('T')[0],
                notes: `Auto-logged reading session for Surah ${s}.`
            };

            logPromises.push(addData(STORE_RECITATIONS, logEntry));
        }

        try {
            await Promise.all(logPromises);
            console.log(`Successfully logged reading for ${logPromises.length} separate Surah(s).`);
        } catch (error) {
            console.error("Failed to auto-log one or more visual reading sessions:", error);
        }
        visualReadingSession = { active: false, startSurah: null, startAyah: null, endSurah: null, endAyah: null };
    }
    let isFullScreenReaderActive = false;
    let isDailyReadingSessionActive = false;
    let visualReadingSession = { active: false, startSurah: null, startAyah: null, endSurah: null, endAyah: null };
    let fullScreenReaderCurrentPage = 1; // For 15-line Taj Company style pages
    let fullScreenReaderCurrentSurah = 1;
    let fullScreenReaderCurrentAyah = 1;
    let fullScreenReaderViewMode = 'paged'; // 'paged' or 'continuous-scroll'
    let fullScreenReaderAudioPlayer = null;
    let fullScreenReaderAudioQueue = []; // For continuous play
    let fullScreenReaderIsPlayingAudio = false;
    let fullScreenReaderContinuousAudioMode = false; // New setting
    function getQuranAudioUrl(languageCode) {
        let edition, bitrate;
        if (languageCode === 'en') {
            edition = 'en.walk';
            bitrate = 192;
        } else if (languageCode === 'ur') {
            edition = 'ur.khan';
            bitrate = 64;
        } else {
            throw new Error("Invalid languageCode: must be 'en' or 'ur'");
        }
        return function (ayahNumber) {
            if (
                typeof ayahNumber !== 'number' ||
                !Number.isInteger(ayahNumber) ||
                ayahNumber <= 0
            ) {
                throw new Error('Ayah number must be a positive integer');
            }
            return `https://cdn.islamic.network/quran/audio/${bitrate}/${edition}/${ayahNumber}.mp3`;
        };
    }
    let fullScreenReaderSettings = {
        arabicFont: 'Scheherazade New',
        fontSize: '2.5rem',
        linesPerPage: 15,
        showTransliteration: false,
        autoScrollAudio: true,
        highlightColor: 'rgba(255, 255, 150, 0.4)',
        continuousAudio: false,
        audioSource: 'quran',
        showTajweedColors: false,
    };
    const TAJ_COMPANY_PAGES = 604;
    let tajMushafPageData = []; // Populated by loadTajMushafPageData()
    let continuousScrollNextSurahToLoad = 1;
    let continuousScrollNextAyahToLoad = 1;
    const CONTINUOUS_SCROLL_LOAD_COUNT = 60; // Ayahs to load at a time
    let isLoadingMoreAyahs = false;
    let continuousScrollSurahContainer = null; // The main div holding all surah content
    function injectEnhancedFullScreenReaderCSS() {
        const cssId = "enhancedFullScreenReaderStyles";
        if (document.getElementById(cssId)) return;
        const styles = `
        #fullScreenReaderOverlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: var(--color-bg-primary, #f0f0f0); /* Lighter bg for reader */
            z-index: 10000; display: flex; flex-direction: column; overflow: hidden;
            font-family: var(--font-arabic);
        }
        #fsReaderHeader, #fsReaderFooter {
            padding: 8px 12px; background-color: var(--color-bg-secondary, #e0e0e0);
            border-bottom: 1px solid var(--color-border, #ccc); flex-shrink: 0;
            display: flex; justify-content: space-between; align-items: center;
        }
        #fsReaderFooter { border-top: 1px solid var(--color-border, #ccc); border-bottom: none; }
        #fsReaderHeader .title-page-container { text-align: center; flex-grow: 1; }
        #fsReaderHeader .title { font-size: 1.1rem; font-weight: bold; color: var(--color-text-primary); }
        #fsReaderHeader .page-info { font-size: 0.9rem; color: var(--color-text-secondary); }
        #fsReaderContent {
            flex-grow: 1; overflow-y: auto; overflow-x: hidden; padding: 5px;
            display: flex; flex-direction: column; align-items: center; /* Centers paged view */
        }
        .fsReaderPage {
            background-color: #fff; border: 1px solid #ddd; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 15px 20px; margin-bottom: 15px; width: 96%; /* max-width: 750px; */ direction: rtl;
        }
        #continuousScrollSurahContainer { width: 96%; /* Centered */ margin: 0 auto; }
        .continuousSurahBlock {
            padding: 10px 15px; margin-bottom: 20px; direction: rtl;
            border-bottom: 2px solid var(--color-accent, #4caf50); /* Separator */
        }
        .continuousSurahBlock h2.surahNameHeader { /* For Surah Name in Continuous */
            text-align: center; font-size: 1.8em; /* Relative to parent font-size */
            color: var(--color-accent-dark, #388e3c); margin-bottom: 0.8em;
            padding: 5px; border-bottom: 1px solid var(--color-border);
        }
        .bismillahText {
            text-align: center; font-size: 1.5em; /* Relative */ margin: 1em 0;
            font-family: 'KFGQPC Uthman Taha Naskh', var(--font-arabic); /* Often specific font for Bismillah */
        }
        .fsReaderAyah {
            display: inline; margin-right: 0.1em; line-height: 2.3; /* Increased line-height */
            transition: background-color 0.2s; cursor: pointer; /* Click to play Ayah */
        }
        .fsReaderAyahNumber {
            font-size: 0.65em; color: var(--color-accent-dark, #388e3c);
            padding: 0px 0.25em; margin: 0 0.15em;
            border: 1px solid var(--color-accent, #4caf50); border-radius: 50%;
            display: inline-block; line-height: 1.2; vertical-align: middle;
        }
        .fsReaderTransliteration {
            display: block; font-size: 0.7em; color: #666;
            font-family: var(--font-english); direction: ltr; text-align: right;
            margin-top: -1em; margin-bottom: 0.6em; padding-right: 2em; /* Indent under Arabic */
        }
        .highlighted-ayah { border-radius: 3px; } /* Background set by JS */
        #fsReaderFooter button, #fsReaderHeader button { font-size: 1.4rem; padding: 6px 8px; }
        #fsReaderScrubSlider { flex-grow:1; margin:0 10px; accent-color: var(--color-accent); }
        .fsReaderSlidingPanel {
            position: absolute; top: 33px; /* Below header */
            width: 258px; max-width: 90%; background-color: var(--color-bg-primary);
            border: 1px solid var(--color-border); box-shadow: 0 3px 10px rgba(0,0,0,0.15);
            padding: 15px; z-index: 10001; display: none;
            color: var(--color-text-primary); overflow-y:auto;
        }
        #fsReaderSettingsPanel { right: 0; border-radius: 0 0 0 var(--border-radius); }
        #fsReaderIndexPanel { left: 0; border-radius: 0 0 var(--border-radius) 0; }
        .fsReaderSlidingPanel h4 { margin-top: 0; margin-bottom:12px; color: var(--color-text-secondary); border-bottom: 1px solid var(--color-border); padding-bottom: 8px;}
        .fsReaderSlidingPanel label { display: block; margin-top: 8px; margin-bottom: 2px; font-size:0.95em; font-weight:normal; color: var(--color-text-secondary); }
        .fsReaderSlidingPanel select, .fsReaderSlidingPanel input[type=range], .fsReaderSlidingPanel input[type=checkbox], .fsReaderSlidingPanel input[type=color] { 
            width: 100%; margin-bottom:12px; 
        }
        .fsReaderSlidingPanel input[type=range] { padding: 0; }
        .fsReaderSlidingPanel .panel-section { margin-bottom:15px; }
        .fsReaderSlidingPanel .panel-section h5 { margin-bottom:5px; font-size:1em; color: var(--color-text-primary); }
        #fsReaderIndexPanel .index-tabs { display:flex; margin-bottom:10px; border-bottom: 1px solid var(--color-border); }
        #fsReaderIndexPanel .index-tab { padding: 8px 12px; cursor:pointer; border-radius: 4px 4px 0 0; }
        #fsReaderIndexPanel .index-tab.active-tab { background-color: var(--color-bg-secondary); border: 1px solid var(--color-border); border-bottom:1px solid var(--color-bg-secondary); }
        .index-list { list-style: none; padding-left: 0; max-height: calc(100vh - 200px); overflow-y: auto;}
        .index-list li a { display: block; padding: 7px 5px; color: var(--color-text-primary); font-size:0.95em; border-bottom: 1px dotted var(--color-border); }
        .index-list li a:hover { background-color: var(--color-bg-secondary); text-decoration:none; }
        .index-list-item-num { color: var(--color-accent-dark); font-weight:bold; margin-right:8px; display:inline-block; width:25px; text-align:right;}
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
    }
    async function launchFullScreenQuranReaderEnhanced() {
        if (isFullScreenReaderActive) return;
        isDailyReadingSessionActive = false;
        isFullScreenReaderActive = true;
        document.body.style.overflow = 'hidden';
        injectEnhancedFullScreenReaderCSS();
        const overlay = document.createElement('div');
        overlay.id = 'fullScreenReaderOverlay';
        overlay.innerHTML = `
    <div id="fsReaderHeader">
        <button id="fsReaderIndexToggleBtn" title="Index">☰</button>
        <div class="title-page-container">
            <div id="fsReaderSurahTitle" class="title">Loading...</div>
            <div id="fsReaderPageInfo" class="page-info">Page ...</div>
        </div>
        <button id="fsReaderBookmarkBtn" title="Go to your daily reading spot (Ctrl+Click to set current spot)">📑</button>
        <button id="fsReaderSettingsToggleBtn" title="Settings">⚙️</button>
    </div>
    <div id="fsReaderContent" style="font-size: ${fullScreenReaderSettings.fontSize};">
        <p>Loading Quran content...</p>
    </div>
    <div id="fsReaderFooter">
        <button id="fsReaderPrevBtn" title="Previous">◀</button>
        <input type="range" id="fsReaderScrubSlider" min="1" max="${TAJ_COMPANY_PAGES}" value="1" title="Navigate">
        <button id="fsReaderNextBtn" title="Next">▶</button>
        <button id="fsReaderPlayPauseBtn" title="Play/Pause">🔊</button>
        <button id="fsReaderCloseBtnEnhanced" title="Close Reader">✕</button>
    </div>
    <div id="fsReaderSettingsPanel" class="fsReaderSlidingPanel">
        <h4>Reader Settings</h4>
        <div class="panel-section">
            <h5>Appearance</h5>
            <label for="fsArabicFontSelect">Arabic Font:</label>
            <select id="fsArabicFontSelect">
                <option value="Scheherazade New" data-google-font="Scheherazade+New:wght@400;700">Scheherazade New</option>
                <option value="KFGQPC Uthman Taha Naskh">KFGQPC Uthman Naskh</option>
                <option value="Amiri" data-google-font="Amiri:wght@400;700">Amiri</option>
                <option value="Lateef" data-google-font="Lateef">Lateef</option>
                <option value="Noto Naskh Arabic" data-google-font="Noto+Naskh+Arabic:wght@400;700">Noto Naskh Arabic</option>
                <option value="var(--font-arabic)">App Default Arabic</option>
            </select>
            <label for="fsFontSizeSlider">Base Font Size (<span id="fsFontSizeValue">${fullScreenReaderSettings.fontSize}</span>):</label>
            <input type="range" id="fsFontSizeSlider" min="1.3" max="11.0" step="0.1" value="${parseFloat(fullScreenReaderSettings.fontSize)}">
            <div id="fsLinesPerPageSettingDiv">
                <label for="fsLinesPerPageSlider">Lines Per Page (Paged View) (<span id="fsLinesPerPageValue">${fullScreenReaderSettings.linesPerPage}</span>):</label>
                <input type="range" id="fsLinesPerPageSlider" min="8" max="35" step="1" value="${fullScreenReaderSettings.linesPerPage}">
            </div>
            <label><input type="checkbox" id="fsShowTransliterationCheck"> Show Transliteration</label>
            <label><input type="checkbox" id="fsShowTajweedCheck"> Show Tajweed Colors</label>
        </div>
        <div class="panel-section">
            <h5>Audio</h5>
            <label for="fsAudioSourceSelect">Audio Source:</label>
            <select id="fsAudioSourceSelect">
                <option value="quran">Quran Recitation (Alafasy)</option>
                <option value="en">English Translation (Ibrahim Walk)</option>
                <option value="ur">Urdu Translation (Fateh Jalandhri)</option>
            </select>
            <label><input type="checkbox" id="fsContinuousAudioCheck"> Continuous Audio Playback</label>
            <label><input type="checkbox" id="fsAutoScrollAudioCheck"> Auto-scroll with Audio</label>
            <label for="fsHighlightColorPicker">Highlight Color:</label>
            <input type="color" id="fsHighlightColorPicker" value="${fullScreenReaderSettings.highlightColor.startsWith('rgba') ? '#ffff96' : fullScreenReaderSettings.highlightColor}">
        </div>
        <div class="panel-section">
            <h5>Navigation</h5>
            <label for="fsViewModeSelect">View Mode:</label>
            <select id="fsViewModeSelect">
                <option value="paged">Paged (Mushaf Style)</option>
                <option value="continuous-scroll">Continuous Scroll</option>
            </select>
        </div>
    </div>
    <div id="fsReaderIndexPanel" class="fsReaderSlidingPanel">
        <h4>Index</h4>
        <div class="index-tabs">
            <span class="index-tab active-tab" data-tab="surahs">Surahs</span>
            <span class="index-tab" data-tab="juz">Juz (Parahs)</span>
            <span class="index-tab" data-tab="themes">Themes</span>
        </div>
        <div id="fsIndexContentSurahs" class="index-content-panel">
            <ul class="index-list" id="fsIndexSurahList"></ul>
        </div>
        <div id="fsIndexContentJuz" class="index-content-panel" style="display:none;">
            <ul class="index-list" id="fsIndexJuzList"></ul>
        </div>
        <div id="fsIndexContentThemes" class="index-content-panel" style="display:none;">
             <input type="text" id="fsThematicIndexSearchInput" placeholder="Search themes..." style="width:100%; margin-bottom:10px;">
            <ul class="index-list" id="fsIndexThemeList">
                <li><a href="#" data-s="2" data-a="255">Ayat al-Kursi</a></li>
            </ul>
        </div>
    </div>
`;
        document.body.appendChild(overlay);
        loadLastReadPosition();
        loadFullScreenReaderSettings();
        await loadTajMushafPageDataIfNeeded();

        visualReadingSession = {
            active: true,
            startSurah: fullScreenReaderCurrentSurah,
            startAyah: fullScreenReaderCurrentAyah,
            endSurah: fullScreenReaderCurrentSurah,
            endAyah: fullScreenReaderCurrentAyah
        };

        setupEnhancedFullScreenReaderEventListeners();
        populateIndexLists();
        if (fullScreenReaderViewMode === 'paged') {
            document.getElementById('fsLinesPerPageSettingDiv').style.display = 'block';
            await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
        } else {
            document.getElementById('fsLinesPerPageSettingDiv').style.display = 'none';
            await initializeContinuousScroll();
        }
        updateReaderHeaderInfo();
        updateScrubSliderRangeAndValue();
    }

    function closeFullScreenQuranReaderEnhanced() {
        const overlay = document.getElementById('fullScreenReaderOverlay');
        if (overlay) {
            document.body.removeChild(overlay);
        }
        document.body.style.overflow = 'auto';
        isFullScreenReaderActive = false;
        if (isDailyReadingSessionActive) {
            saveLastReadPosition();
            logVisualReadingSession();
        }
        stopAndClearAudio();
        saveLastReadPosition();
        saveFullScreenReaderSettings();
    }
    async function loadTajMushafPageDataIfNeeded() {
        tajMushafPageData = [];
        let currentS = 1, currentA = 1;
        let currentJuz = 1;

        for (let page = 1; page <= TAJ_COMPANY_PAGES; page++) {
            const pageStartS = currentS;
            const pageStartA = currentA;
            let lineCountApproximation = 0;
            let pageEndS = currentS;
            let pageEndA = currentA;

            if (juzBoundariesData[currentJuz - 1] && pageStartS >= juzBoundariesData[currentJuz - 1].startSurah) {
                currentJuz = getJuzFromSurahAyah(pageStartS, pageStartA);
            }

            while (lineCountApproximation < fullScreenReaderSettings.linesPerPage && currentS <= 114) {
                lineCountApproximation++;
                pageEndS = currentS;
                pageEndA = currentA;

                currentA++;
                if (currentA > surahAyahCounts[currentS]) {
                    currentS++;
                    currentA = 1;
                    if (currentS > 114) break;
                }
            }

            tajMushafPageData.push({
                page: page,
                startSurah: pageStartS, startAyah: pageStartA,
                endSurah: pageEndS, endAyah: pageEndA,
                juz: currentJuz
            });

            if (currentS > 114) break;
        }
        console.log(`Taj Mushaf Page Data Loaded/Recalculated: ${tajMushafPageData.length} pages based on ${fullScreenReaderSettings.linesPerPage} lines/page.`);
    }

    async function renderQuranPageEnhanced(pageNumber) {
        const contentDiv = document.getElementById('fsReaderContent');
        if (!contentDiv || !tajMushafPageData.length) {
            if (contentDiv) contentDiv.innerHTML = "<p style='color:red;text-align:center;'>Error rendering page.</p>";
            return;
        }
        contentDiv.innerHTML = '';
        contentDiv.style.alignItems = 'center';
        contentDiv.style.fontSize = fullScreenReaderSettings.fontSize;
        const pageData = tajMushafPageData.find(p => p.page === pageNumber);
        if (!pageData) {
            contentDiv.innerHTML = `<div class="fsReaderPage" style="text-align:center; padding: 50px;">Page ${pageNumber} data not found.</div>`;
            return;
        }
        fullScreenReaderCurrentPage = pageNumber;
        fullScreenReaderCurrentSurah = pageData.startSurah;
        fullScreenReaderCurrentAyah = pageData.startAyah;
        const pageDiv = document.createElement('div');
        pageDiv.className = 'fsReaderPage';
        let currentS_loop_var = pageData.startSurah;
        let currentA_loop_var = pageData.startAyah;
        while (true) {
            if (currentS_loop_var > pageData.endSurah || (currentS_loop_var === pageData.endSurah && currentA_loop_var > pageData.endAyah)) {
                break;
            }

            if (currentS_loop_var > 114) break;

            const ayahHTML = await getAyahHTML(currentS_loop_var, currentA_loop_var);

            if (ayahHTML) {
                if (currentA_loop_var === 1 && currentS_loop_var !== 1 && currentS_loop_var !== 9) {
                    const bismDiv = document.createElement('div');
                    bismDiv.className = 'bismillahText';
                    bismDiv.style.fontFamily = fullScreenReaderSettings.arabicFont;
                    bismDiv.textContent = "بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ";
                    pageDiv.appendChild(bismDiv);
                }
                const ayahSpan = document.createElement('span');
                ayahSpan.className = 'fsReaderAyah';
                ayahSpan.dataset.surah = currentS_loop_var;
                ayahSpan.dataset.ayah = currentA_loop_var;
                ayahSpan.style.fontFamily = fullScreenReaderSettings.arabicFont;
                ayahSpan.innerHTML = ayahHTML;

                const s_for_click = currentS_loop_var;
                const a_for_click = currentA_loop_var;
                ayahSpan.addEventListener('click', () => {
                    handleAyahSpanClick(s_for_click, a_for_click);
                });
                pageDiv.appendChild(ayahSpan);
                const ayahNumSpan = document.createElement('span');
                ayahNumSpan.className = 'fsReaderAyahNumber';
                ayahNumSpan.textContent = arabicNumber(currentA_loop_var);
                pageDiv.appendChild(ayahNumSpan);
                if (fullScreenReaderSettings.showTransliteration) {
                    const translitText = await getAyahTransliteration(currentS_loop_var, currentA_loop_var);
                    if (translitText) {
                        const translitSpan = document.createElement('span');
                        translitSpan.className = 'fsReaderTransliteration';
                        translitSpan.textContent = translitText;
                        pageDiv.appendChild(translitSpan);
                    }
                }
            }

            currentA_loop_var++;
            if (currentA_loop_var > surahAyahCounts[currentS_loop_var]) {
                currentS_loop_var++;
                currentA_loop_var = 1;
            }
        }

        contentDiv.appendChild(pageDiv);
        contentDiv.scrollTop = 0;
        updateReaderHeaderInfo();
        updateScrubSliderRangeAndValue();
    }


    async function initializeContinuousScroll() {
        const contentDiv = document.getElementById('fsReaderContent');
        if (!contentDiv) {
            console.error("initializeContinuousScroll: fsReaderContent not found.");
            return;
        }
        contentDiv.innerHTML = '';
        contentDiv.style.alignItems = 'stretch';
        contentDiv.style.fontSize = fullScreenReaderSettings.fontSize;
        continuousScrollSurahContainer = document.createElement('div');
        continuousScrollSurahContainer.id = 'continuousScrollSurahContainer';
        contentDiv.appendChild(continuousScrollSurahContainer);
        continuousScrollNextSurahToLoad = parseInt(fullScreenReaderCurrentSurah);
        continuousScrollNextAyahToLoad = parseInt(fullScreenReaderCurrentAyah);
        if (isNaN(continuousScrollNextSurahToLoad) || continuousScrollNextSurahToLoad < 1 || continuousScrollNextSurahToLoad > 114) {
            continuousScrollNextSurahToLoad = 1;
        }
        const maxAyahsForInitS = (continuousScrollNextSurahToLoad >= 1 && continuousScrollNextSurahToLoad <= 114 && surahAyahCounts[continuousScrollNextSurahToLoad]) ? surahAyahCounts[continuousScrollNextSurahToLoad] : 0;
        if (isNaN(continuousScrollNextAyahToLoad) || continuousScrollNextAyahToLoad < 1 || (maxAyahsForInitS > 0 && continuousScrollNextAyahToLoad > maxAyahsForInitS)) {
            continuousScrollNextAyahToLoad = 1;
        }
        isLoadingMoreAyahs = false;
        await loadMoreAyahsForContinuousScroll();
        const initialTargetS = continuousScrollNextSurahToLoad; // Use the validated start values
        const initialTargetA = continuousScrollNextAyahToLoad;
        if (initialTargetS > 1 || initialTargetA > 1) {
            setTimeout(() => {
                const targetAyahEl = continuousScrollSurahContainer.querySelector(
                    `.fsReaderAyah[data-surah="${initialTargetS}"][data-ayah="${initialTargetA}"]`
                );
                if (targetAyahEl) {
                    targetAyahEl.scrollIntoView({ behavior: "auto", block: "start" });
                    highlightAyahEnhanced(initialTargetS, initialTargetA);
                }
                updateReaderHeaderInfo();
                updateScrubSliderRangeAndValue();
            }, 200); // Timeout allows DOM to render
        } else {
            updateReaderHeaderInfo();
            updateScrubSliderRangeAndValue();
        }
    }
    async function loadMoreAyahsForContinuousScroll() {
        if (!continuousScrollSurahContainer || !document.body.contains(continuousScrollSurahContainer)) {
            isLoadingMoreAyahs = false; return;
        }
        if (isLoadingMoreAyahs || continuousScrollNextSurahToLoad > 114) {
            if (continuousScrollNextSurahToLoad > 114) isLoadingMoreAyahs = false;
            return;
        }
        isLoadingMoreAyahs = true;
        let ayahsLoadedInBatch = 0;
        let currentRenderingSurah = -1;
        let surahBlockDiv = null;
        while (ayahsLoadedInBatch < CONTINUOUS_SCROLL_LOAD_COUNT && continuousScrollNextSurahToLoad <= 114) {
            if (!continuousScrollSurahContainer || !document.body.contains(continuousScrollSurahContainer)) {
                isLoadingMoreAyahs = false; return;
            }
            const s_loop = parseInt(continuousScrollNextSurahToLoad);
            const a_loop = parseInt(continuousScrollNextAyahToLoad);
            if (isNaN(s_loop) || isNaN(a_loop) || s_loop < 1 || s_loop > 114 || a_loop < 1) {
                isLoadingMoreAyahs = false; break;
            }
            if (s_loop !== currentRenderingSurah) {
                currentRenderingSurah = s_loop;
                surahBlockDiv = continuousScrollSurahContainer.querySelector(`.continuousSurahBlock[data-surah-num="${s_loop}"]`);
                if (!surahBlockDiv) {
                    surahBlockDiv = document.createElement('div');
                    surahBlockDiv.className = 'continuousSurahBlock';
                    surahBlockDiv.dataset.surahNum = s_loop;
                    const surahNameHeader = document.createElement('h2');
                    surahNameHeader.className = 'surahNameHeader';
                    surahNameHeader.style.fontFamily = fullScreenReaderSettings.arabicFont;
                    surahNameHeader.textContent = `${s_loop}. Surah ${surahNames[s_loop - 1] || `Surah ${s_loop}`}`;
                    surahBlockDiv.appendChild(surahNameHeader);
                    if (s_loop !== 1 && s_loop !== 9) {
                        const bismDiv = document.createElement('div');
                        bismDiv.className = 'bismillahText';
                        bismDiv.style.fontFamily = fullScreenReaderSettings.arabicFont;
                        bismDiv.textContent = "بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ";
                        surahBlockDiv.appendChild(bismDiv);
                    }
                    continuousScrollSurahContainer.appendChild(surahBlockDiv);
                }
            }
            if (!surahBlockDiv || !document.body.contains(surahBlockDiv)) {
                isLoadingMoreAyahs = false; return;
            }
            const ayahHTML = await getAyahHTML(s_loop, a_loop);
            const ayahSpan = document.createElement('span');
            ayahSpan.className = 'fsReaderAyah';
            ayahSpan.dataset.surah = s_loop;
            ayahSpan.dataset.ayah = a_loop;
            ayahSpan.style.fontFamily = fullScreenReaderSettings.arabicFont;
            ayahSpan.innerHTML = ayahHTML;
            const s_for_click = s_loop;
            const a_for_click = a_loop;
            ayahSpan.addEventListener('click', () => {
                handleAyahSpanClick(s_for_click, a_for_click);
            });
            surahBlockDiv.appendChild(ayahSpan);
            const ayahNumSpan = document.createElement('span');
            ayahNumSpan.className = 'fsReaderAyahNumber';
            ayahNumSpan.textContent = arabicNumber(a_loop);
            surahBlockDiv.appendChild(ayahNumSpan);
            ayahsLoadedInBatch++;
            if (fullScreenReaderSettings.showTransliteration) {
                const translitText = await getAyahTransliteration(s_loop, a_loop);
                if (translitText) {
                    const translitSpan = document.createElement('span');
                    translitSpan.className = 'fsReaderTransliteration';
                    translitSpan.textContent = translitText;
                    surahBlockDiv.appendChild(translitSpan);
                }
            }
            continuousScrollNextAyahToLoad++;
            const maxAyahsThisSurah = (s_loop >= 1 && s_loop <= 114 && surahAyahCounts[s_loop]) ? surahAyahCounts[s_loop] : 0;
            if (maxAyahsThisSurah > 0 && continuousScrollNextAyahToLoad > maxAyahsThisSurah) {
                if (s_loop < 114) {
                    continuousScrollNextSurahToLoad = s_loop + 1;
                    continuousScrollNextAyahToLoad = 1;
                } else {
                    continuousScrollNextSurahToLoad = 115;
                    break;
                }
            } else if (maxAyahsThisSurah === 0 && s_loop <= 114) {
                isLoadingMoreAyahs = false; break;
            }
        }
        isLoadingMoreAyahs = false;
    }
    function populateIndexLists() {
        const surahListEl = document.getElementById('fsIndexSurahList');
        const juzListEl = document.getElementById('fsIndexJuzList');
        if (!surahListEl || !juzListEl) return;
        surahListEl.innerHTML = '';
        juzListEl.innerHTML = '';
        for (let i = 1; i <= 114; i++) {
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = '#';
            a.dataset.surah = i;
            a.innerHTML = `<span class="index-list-item-num">${arabicNumber(i)}</span> ${surahNames[i - 1] || `Surah ${i}`}`; // Fallback
            a.addEventListener('click', handleIndexSurahClick);
            li.appendChild(a);
            surahListEl.appendChild(li);
        }
        juzBoundariesData.forEach(juzInfo => {
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = '#';
            a.dataset.juz = juzInfo.juz;
            a.dataset.startSurah = juzInfo.startSurah;
            a.dataset.startAyah = juzInfo.startAyah;
            a.innerHTML = `<span class="index-list-item-num">${arabicNumber(juzInfo.juz)}</span> ${juzInfo.name}`;
            a.addEventListener('click', handleIndexJuzClick);
            li.appendChild(a);
            juzListEl.appendChild(li);
        });
        populateThemesIndexList();
    }
    async function handleIndexSurahClick(event) {
        event.preventDefault();
        const surahNum = parseInt(event.currentTarget.dataset.surah) || 1;
        const indexPanel = document.getElementById('fsReaderIndexPanel');
        if (indexPanel) indexPanel.style.display = 'none';
        const contentDiv = document.getElementById('fsReaderContent');
        if (!contentDiv) {
            console.error("handleIndexSurahClick: fsReaderContent not found.");
            return;
        }
        stopAndClearAudio();
        fullScreenReaderCurrentSurah = surahNum;
        fullScreenReaderCurrentAyah = 1;
        if (fullScreenReaderViewMode === 'paged') {
            const page = surahToPageEnhanced(surahNum, 1);
            fullScreenReaderCurrentPage = page;
            await renderQuranPageEnhanced(page);
        } else {
            continuousScrollNextSurahToLoad = surahNum;
            continuousScrollNextAyahToLoad = 1;
            await initializeContinuousScroll();
        }
    }
    async function handleIndexJuzClick(event) {
        event.preventDefault();
        const startS = parseInt(event.currentTarget.dataset.startSurah);
        const startA = parseInt(event.currentTarget.dataset.startAyah);
        const indexPanel = document.getElementById('fsReaderIndexPanel');
        if (indexPanel) indexPanel.style.display = 'none';
        const contentDiv = document.getElementById('fsReaderContent');
        if (!contentDiv) {
            console.error("handleIndexJuzClick: fsReaderContent not found.");
            return;
        }
        stopAndClearAudio(); // Stop any currently playing audio
        fullScreenReaderCurrentSurah = startS;
        fullScreenReaderCurrentAyah = startA;
        if (fullScreenReaderViewMode === 'paged') {
            const page = surahToPageEnhanced(startS, startA);
            fullScreenReaderCurrentPage = page;
            await renderQuranPageEnhanced(page);
            setTimeout(() => highlightAndScrollToAyahInPage(startS, startA), 250);
        } else {
            if (continuousScrollSurahContainer) {
                continuousScrollSurahContainer.innerHTML = '';
            }
            continuousScrollNextSurahToLoad = startS;
            continuousScrollNextAyahToLoad = startA;
            await initializeContinuousScroll();
        }
        updateReaderHeaderInfo();
        updateScrubSliderRangeAndValue();
    }
    function highlightAndScrollToAyahInPage(surah, ayah) {
        const targetAyahEl = document.querySelector(`#fsReaderContent .fsReaderAyah[data-surah="${surah}"][data-ayah="${ayah}"]`);
        if (targetAyahEl) {
            targetAyahEl.scrollIntoView({ behavior: "smooth", block: "center" });
            highlightAyahEnhanced(surah, ayah);
        }
    }
    function updateReaderHeaderInfo() {
        const surahTitleEl = document.getElementById('fsReaderSurahTitle');
        const pageInfoEl = document.getElementById('fsReaderPageInfo');
        if (!surahTitleEl || !pageInfoEl) return;
        let displayS = parseInt(fullScreenReaderCurrentSurah);
        let displayA = parseInt(fullScreenReaderCurrentAyah);
        let displayPage = parseInt(fullScreenReaderCurrentPage);
        if (isNaN(displayS) || displayS < 1 || displayS > 114) displayS = 1;
        const maxAyahsForCurrentDisplayS = (displayS >= 1 && displayS <= 114 && surahAyahCounts[displayS]) ? surahAyahCounts[displayS] : 0;
        if (isNaN(displayA) || displayA < 1 || (maxAyahsForCurrentDisplayS > 0 && displayA > maxAyahsForCurrentDisplayS)) displayA = 1;
        if (isNaN(displayPage) || displayPage < 1) displayPage = 1;
        if (fullScreenReaderViewMode === 'continuous-scroll' && continuousScrollSurahContainer) {
            const firstVisibleAyah = findFirstVisibleAyah();
            if (firstVisibleAyah) {
                let sFromDOM = parseInt(firstVisibleAyah.dataset.surah);
                let aFromDOM = parseInt(firstVisibleAyah.dataset.ayah);
                if (!isNaN(sFromDOM) && sFromDOM >= 1 && sFromDOM <= 114) {
                    displayS = sFromDOM;
                    fullScreenReaderCurrentSurah = sFromDOM; // Update global state
                }
                const maxAyahsForDomS = (sFromDOM >= 1 && sFromDOM <= 114 && surahAyahCounts[sFromDOM]) ? surahAyahCounts[sFromDOM] : 0;
                if (!isNaN(aFromDOM) && aFromDOM >= 1 && (maxAyahsForDomS > 0 && aFromDOM <= maxAyahsForDomS)) {
                    displayA = aFromDOM;
                    fullScreenReaderCurrentAyah = aFromDOM; // Update global state
                }
            }
        } else if (fullScreenReaderViewMode === 'paged') {
            const pageData = tajMushafPageData.find(p => p.page === displayPage);
            if (pageData) {
                displayS = pageData.startSurah;
                displayA = pageData.startAyah;
            } else {
                displayS = 1; displayA = 1; displayPage = 1;
            }
        }
        let displayJuz = getJuzFromSurahAyah(displayS, displayA);
        if (isNaN(displayJuz) || displayJuz < 1 || displayJuz > 30) displayJuz = 1;
        const surahNameText = (displayS >= 1 && displayS <= 114 && surahNames[displayS - 1])
            ? surahNames[displayS - 1]
            : `Surah ${displayS}`;
        surahTitleEl.textContent = `Surah ${displayS}: ${surahNameText}`;
        let pageText = `Juz ${displayJuz}`;
        if (fullScreenReaderViewMode === 'paged') {
            pageText = `Page ${displayPage}/${TAJ_COMPANY_PAGES} (Juz ${displayJuz})`;
        } else {
            pageText = `(S:${displayS} A:${displayA}) Juz ${displayJuz}`;
        }
        pageInfoEl.textContent = pageText;
        updateVisualReadingProgress(displayS, displayA);
    }
    function handlePageUnload() {
        if (isFullScreenReaderActive) {
            if (isDailyReadingSessionActive) {
                saveLastReadPosition();
                logVisualReadingSession();
            }
            logAutoRecitationSession();
        }
    }
    function findFirstVisibleAyah() {
        const contentDiv = document.getElementById('fsReaderContent');
        if (!contentDiv) return null;
        const ayahs = contentDiv.querySelectorAll('.fsReaderAyah');
        for (let ayahEl of ayahs) {
            const rect = ayahEl.getBoundingClientRect();
            const contentRect = contentDiv.getBoundingClientRect();
            if (rect.top >= contentRect.top && rect.top <= contentRect.bottom - 50) { // 50px buffer
                return ayahEl;
            }
        }
        return ayahs.length > 0 ? ayahs[0] : null; // Fallback to first loaded
    }
    function updateScrubSliderRangeAndValue() {
        const slider = document.getElementById('fsReaderScrubSlider');
        if (!slider) return;
        if (fullScreenReaderViewMode === 'paged') {
            slider.min = 1;
            slider.max = TAJ_COMPANY_PAGES;
            slider.value = fullScreenReaderCurrentPage;
        } else { // continuous-scroll, slider represents Surah
            slider.min = 1;
            slider.max = 114;
            slider.value = fullScreenReaderCurrentSurah; // Or the dominant Surah on screen
        }
    }
    async function goToNextEnhanced() {
        stopAndClearAudio();
        if (fullScreenReaderViewMode === 'paged') {
            if (fullScreenReaderCurrentPage < TAJ_COMPANY_PAGES) {
                fullScreenReaderCurrentPage++;
                await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
            }
        } else { // continuous-scroll
            const contentDiv = document.getElementById('fsReaderContent');
            contentDiv.scrollTop += contentDiv.clientHeight * 0.8; // Scroll down by 80% of viewport
            if (contentDiv.scrollTop + contentDiv.clientHeight >= contentDiv.scrollHeight - 200) {
                await loadMoreAyahsForContinuousScroll();
            }
            setTimeout(updateReaderHeaderInfo, 300); // After scroll settles
        }
    }
    async function goToPrevEnhanced() {
        stopAndClearAudio();
        if (fullScreenReaderViewMode === 'paged') {
            if (fullScreenReaderCurrentPage > 1) {
                fullScreenReaderCurrentPage--;
                await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
            }
        } else { // continuous-scroll
            const contentDiv = document.getElementById('fsReaderContent');
            contentDiv.scrollTop -= contentDiv.clientHeight * 0.8;
            setTimeout(updateReaderHeaderInfo, 300);
        }
    }
    function surahToPageEnhanced(surah, ayah = 1) {
        if (!tajMushafPageData || tajMushafPageData.length === 0) return 1;
        for (const pageInfo of tajMushafPageData) {
            if (surah === pageInfo.startSurah && surah === pageInfo.endSurah) { // Single surah on page
                if (ayah >= pageInfo.startAyah && ayah <= pageInfo.endAyah) return pageInfo.page;
            } else if (surah === pageInfo.startSurah && ayah >= pageInfo.startAyah) { // Starts on this page
                return pageInfo.page;
            } else if (surah === pageInfo.endSurah && ayah <= pageInfo.endAyah) { // Ends on this page
                return pageInfo.page;
            } else if (surah > pageInfo.startSurah && surah < pageInfo.endSurah) { // Entirely within this page (multi-surah page)
                return pageInfo.page;
            }
        }
        const firstPageOfSurah = tajMushafPageData.find(p => p.startSurah === surah || p.endSurah === surah);
        return firstPageOfSurah ? firstPageOfSurah.page : 1;
    }
    async function applyFullScreenReaderSettingsChanges() {
        const contentDiv = document.getElementById('fsReaderContent');
        if (contentDiv) {
            contentDiv.style.fontSize = fullScreenReaderSettings.fontSize;
        }

        if (fullScreenReaderViewMode === 'paged') {
            tajMushafPageData = [];
            await loadTajMushafPageDataIfNeeded();
            await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
        } else {
            continuousScrollSurahContainer.innerHTML = '';
            continuousScrollNextSurahToLoad = fullScreenReaderCurrentSurah;
            continuousScrollNextAyahToLoad = fullScreenReaderCurrentAyah;
            await initializeContinuousScroll();
        }
        saveFullScreenReaderSettings();
    }
    function saveFullScreenReaderSettings() { // Unchanged, ensure it saves all relevant settings
        localStorage.setItem('fsReaderSettingsEnhanced', JSON.stringify(fullScreenReaderSettings));
    }
    function loadFullScreenReaderSettings() {
        const saved = localStorage.getItem('fsReaderSettingsEnhanced');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                Object.assign(fullScreenReaderSettings, parsed);
            } catch (e) { console.error("Error parsing saved reader settings", e); }
        }
        const audioSourceSelect = document.getElementById('fsAudioSourceSelect');
        if (audioSourceSelect) audioSourceSelect.value = fullScreenReaderSettings.audioSource;

        const fontSelect = document.getElementById('fsArabicFontSelect');
        if (fontSelect) fontSelect.value = fullScreenReaderSettings.arabicFont;

        const sizeSlider = document.getElementById('fsFontSizeSlider');
        const sizeValueEl = document.getElementById('fsFontSizeValue');
        if (sizeSlider && sizeValueEl) {
            sizeSlider.value = parseFloat(fullScreenReaderSettings.fontSize);
            sizeValueEl.textContent = fullScreenReaderSettings.fontSize;
        }
        const linesSlider = document.getElementById('fsLinesPerPageSlider');
        const linesValueEl = document.getElementById('fsLinesPerPageValue');
        if (linesSlider && linesValueEl) {
            linesSlider.value = fullScreenReaderSettings.linesPerPage;
            linesValueEl.textContent = fullScreenReaderSettings.linesPerPage;
        }
        const translitCheck = document.getElementById('fsShowTransliterationCheck');
        if (translitCheck) translitCheck.checked = fullScreenReaderSettings.showTransliteration;

        const tajweedCheck = document.getElementById('fsShowTajweedCheck');
        if (tajweedCheck) tajweedCheck.checked = fullScreenReaderSettings.showTajweedColors;

        const contAudioCheck = document.getElementById('fsContinuousAudioCheck');
        if (contAudioCheck) contAudioCheck.checked = fullScreenReaderSettings.continuousAudio;

        const autoScrollCheck = document.getElementById('fsAutoScrollAudioCheck');
        if (autoScrollCheck) autoScrollCheck.checked = fullScreenReaderSettings.autoScrollAudio;

        const highlightPicker = document.getElementById('fsHighlightColorPicker');
        if (highlightPicker) {
            highlightPicker.value = fullScreenReaderSettings.highlightColor.startsWith('rgba') ?
                rgbToHex(fullScreenReaderSettings.highlightColor) :
                fullScreenReaderSettings.highlightColor;
        }

        const viewModeSelect = document.getElementById('fsViewModeSelect');
        if (viewModeSelect) viewModeSelect.value = fullScreenReaderViewMode;
        loadAndApplyDynamicFont(fullScreenReaderSettings.arabicFont);
    }


    function rgbToHex(rgba) {
        if (rgba.startsWith('#')) return rgba; // Already hex
        const parts = rgba.substring(rgba.indexOf('(') + 1, rgba.lastIndexOf(')')).split(/,\s*/);
        if (parts.length < 3) return '#ffff96'; // Fallback
        const r = parseInt(parts[0]).toString(16).padStart(2, '0');
        const g = parseInt(parts[1]).toString(16).padStart(2, '0');
        const b = parseInt(parts[2]).toString(16).padStart(2, '0');
        return `#${r}${g}${b}`;
    }
    function loadLastReadPosition() {
        const saved = localStorage.getItem('fsReaderLastPosEnhanced');
        let page = 1, surah = 1, ayah = 1, viewMode = 'paged';
        if (saved) {
            try {
                const pos = JSON.parse(saved);
                page = parseInt(pos.page);
                surah = parseInt(pos.surah); // `surah` could be NaN here if pos.surah is not a number string
                ayah = parseInt(pos.ayah);
                viewMode = pos.viewMode === 'continuous-scroll' ? 'continuous-scroll' : 'paged'; // Validate viewMode
                if (isNaN(page) || page < 1 || page > TAJ_COMPANY_PAGES) page = 1;
                if (isNaN(surah) || surah < 1 || surah > 114) {
                    surah = 1; // Default surah
                }
                const maxAyahsForSurah = (surah >= 1 && surah <= 114 && surahAyahCounts[surah]) ? surahAyahCounts[surah] : 0;
                if (isNaN(ayah) || ayah < 1 || (maxAyahsForSurah > 0 && ayah > maxAyahsForSurah)) {
                    ayah = 1; // Default ayah
                }
                if (surah === 1 && ayah > 7) ayah = 1; // Max 7 for Al-Fatihah, or reset to 1 if out of bounds
            } catch (e) {
                console.error("Error parsing last read position, resetting to defaults.", e);
                page = 1; surah = 1; ayah = 1; viewMode = 'paged';
            }
        } else {
            page = 1; surah = 1; ayah = 1; viewMode = 'paged';
        }
        fullScreenReaderCurrentPage = page;
        fullScreenReaderCurrentSurah = surah;
        fullScreenReaderCurrentAyah = ayah;
        fullScreenReaderViewMode = viewMode;
        const viewModeSelect = document.getElementById('fsViewModeSelect');
        if (viewModeSelect) {
            viewModeSelect.value = fullScreenReaderViewMode;
        }
    }
    function saveLastReadPosition() { // Revised
        localStorage.setItem('fsReaderLastPosEnhanced', JSON.stringify({
            page: fullScreenReaderCurrentPage,
            surah: fullScreenReaderCurrentSurah,
            ayah: fullScreenReaderCurrentAyah,
            viewMode: fullScreenReaderViewMode
        }));
    }
    async function playAudioForAyahEnhanced(surah, ayah) {
        const sNum = parseInt(surah);
        const aNum = parseInt(ayah);
        if (isNaN(sNum) || isNaN(aNum) || sNum < 1 || sNum > 114 || aNum < 1 ||
            (surahAyahCounts[sNum] && aNum > surahAyahCounts[sNum])) {
            if (fullScreenReaderIsPlayingAudio) stopAndClearAudio();
            return;
        }
        if (!fullScreenReaderSettings.continuousAudio) {
            await logAutoRecitationSession();
        }
        stopAndClearAudio();
        if (!autoLogSession.active) {
            autoLogSession.active = true;
            autoLogSession.startSurah = sNum;
            autoLogSession.startAyah = aNum;
        } else {
            autoLogSession.endSurah = sNum;
            autoLogSession.endAyah = aNum;
        }
        let audioSrc;
        const audioSourceMode = fullScreenReaderSettings.audioSource || 'quran';
        if (audioSourceMode === 'en' || audioSourceMode === 'ur') {
            let absoluteAyahNum = 0;
            for (let i = 1; i < sNum; i++) {
                absoluteAyahNum += surahAyahCounts[i];
            }
            absoluteAyahNum += aNum;
            audioSrc = getQuranAudioUrl(audioSourceMode)(absoluteAyahNum);
        } else {
            const surahPadded = String(sNum).padStart(3, '0');
            const ayahPadded = String(aNum).padStart(3, '0');
            audioSrc = `https://everyayah.com/data/Alafasy_128kbps/${surahPadded}${ayahPadded}.mp3`;
        }
        fullScreenReaderAudioPlayer = new Audio(audioSrc);
        fullScreenReaderAudioPlayer.currentSrcAyahS = sNum;
        fullScreenReaderAudioPlayer.currentSrcAyahA = aNum;
        try {
            await fullScreenReaderAudioPlayer.play();
            fullScreenReaderIsPlayingAudio = true;
            const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
            if (playPauseBtn) playPauseBtn.textContent = '❚❚';
            highlightAyahEnhanced(sNum, aNum);
            fullScreenReaderAudioPlayer.onended = async () => {
                fullScreenReaderIsPlayingAudio = false;
                const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
                if (playPauseBtn) playPauseBtn.textContent = '🔊';
                if (fullScreenReaderSettings.continuousAudio) {
                    let nextS = sNum;
                    let nextA = aNum + 1;
                    if (surahAyahCounts[nextS] && nextA > surahAyahCounts[nextS]) {
                        if (nextS < 114) {
                            nextS++;
                            nextA = 1;
                        } else {
                            removeHighlightEnhanced();
                            await logAutoRecitationSession(); // Log session at the very end of Quran
                            return;
                        }
                    } else if (!surahAyahCounts[nextS]) {
                        removeHighlightEnhanced();
                        await logAutoRecitationSession(); // Log session if data is invalid
                        return;
                    }
                    fullScreenReaderCurrentSurah = nextS;
                    fullScreenReaderCurrentAyah = nextA;
                    updateReaderHeaderInfo();
                    playAudioForAyahEnhanced(nextS, nextA);
                } else {
                    removeHighlightEnhanced();
                    await logAutoRecitationSession(); // Log after single ayah playback
                }
            };
            fullScreenReaderAudioPlayer.onerror = (e) => {
                console.error("Audio playback error", e);
                logAutoRecitationSession(); // Log what was played before the error
            };
        } catch (err) {
            console.error("Could not play audio:", err);
            logAutoRecitationSession(); // Log on failure to play
        }
    }
    function toggleAudioPlaybackEnhanced() {
        const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
        if (!fullScreenReaderAudioPlayer || fullScreenReaderAudioPlayer.src === '' || fullScreenReaderAudioPlayer.src === window.location.href || fullScreenReaderAudioPlayer.ended) {
            let targetS = parseInt(fullScreenReaderCurrentSurah);
            let targetA = parseInt(fullScreenReaderCurrentAyah);
            if (isNaN(targetS) || targetS < 1 || targetS > 114) targetS = 1;
            const maxAyahsForGlobalS = (targetS >= 1 && targetS <= 114 && surahAyahCounts[targetS]) ? surahAyahCounts[targetS] : 0;
            if (isNaN(targetA) || targetA < 1 || (maxAyahsForGlobalS > 0 && targetA > maxAyahsForGlobalS)) targetA = 1;
            if (fullScreenReaderViewMode === 'continuous-scroll') {
                const firstVisible = findFirstVisibleAyah(); // This finds the Ayah at the top of the viewport
                if (firstVisible && firstVisible.dataset.surah && firstVisible.dataset.ayah) {
                    let sFromDOM = parseInt(firstVisible.dataset.surah);
                    let aFromDOM = parseInt(firstVisible.dataset.ayah);
                    if (!isNaN(sFromDOM) && sFromDOM >= 1 && sFromDOM <= 114) {
                        const maxAyahsForDomS = (sFromDOM >= 1 && sFromDOM <= 114 && surahAyahCounts[sFromDOM]) ? surahAyahCounts[sFromDOM] : 0;
                        if (!isNaN(aFromDOM) && aFromDOM >= 1 && (maxAyahsForDomS > 0 && aFromDOM <= maxAyahsForDomS)) {
                            targetS = sFromDOM;
                            targetA = aFromDOM;
                        } else {
                        }
                    } else {
                    }
                } else {
                }
            } else { // Paged view
            }
            fullScreenReaderCurrentSurah = targetS;
            fullScreenReaderCurrentAyah = targetA;
            updateReaderHeaderInfo(); // Reflect this in the header
            playAudioForAyahEnhanced(targetS, targetA);
        } else if (fullScreenReaderIsPlayingAudio) {
            fullScreenReaderAudioPlayer.pause();
            fullScreenReaderIsPlayingAudio = false;
            if (playPauseBtn) playPauseBtn.textContent = '🔊';
        } else {
            fullScreenReaderAudioPlayer.play().then(() => {
                fullScreenReaderIsPlayingAudio = true;
                if (playPauseBtn) playPauseBtn.textContent = '❚❚';
                highlightAyahEnhanced(parseInt(fullScreenReaderAudioPlayer.currentSrcAyahS) || fullScreenReaderCurrentSurah,
                    parseInt(fullScreenReaderAudioPlayer.currentSrcAyahA) || fullScreenReaderCurrentAyah);
            }).catch(err => {
                console.error("Error resuming audio:", err);
                if (playPauseBtn) playPauseBtn.textContent = '🔊';
            });
        }
    }
    function stopAndClearAudio() {
        logAutoRecitationSession();
        if (fullScreenReaderAudioPlayer) {
            fullScreenReaderAudioPlayer.pause();
            fullScreenReaderAudioPlayer.onended = null;
            fullScreenReaderAudioPlayer.onerror = null;
            fullScreenReaderAudioPlayer.src = '';
            fullScreenReaderAudioPlayer.load();
            fullScreenReaderAudioPlayer = null;
        }
        fullScreenReaderIsPlayingAudio = false;
        removeHighlightEnhanced();
        const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
        if (playPauseBtn) playPauseBtn.textContent = '🔊';
    }
    function highlightAyahEnhanced(surah, ayah) {
        removeHighlightEnhanced();
        const contentDiv = document.getElementById('fsReaderContent');
        const ayahEl = contentDiv.querySelector(`.fsReaderAyah[data-surah="${surah}"][data-ayah="${ayah}"]`);
        if (ayahEl) {
            ayahEl.style.backgroundColor = fullScreenReaderSettings.highlightColor;
            ayahEl.classList.add('highlighted-ayah');
            if (fullScreenReaderSettings.autoScrollAudio) {
                const rect = ayahEl.getBoundingClientRect();
                const contentRect = contentDiv.getBoundingClientRect();
                const isVisible = rect.top >= contentRect.top && rect.bottom <= contentRect.bottom;
                if (!isVisible) {
                    ayahEl.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
                }
            }
        }
    }
    function removeHighlightEnhanced() {
        const highlighted = document.querySelector('#fsReaderContent .highlighted-ayah');
        if (highlighted) {
            highlighted.style.backgroundColor = '';
            highlighted.classList.remove('highlighted-ayah');
        }
    }
    function arabicNumber(num) {
        const arabicNumerals = ['٠', '١', '٢', '٣', '٤', '٥', '٦', '٧', '٨', '٩'];
        return String(num).split('').map(digit => arabicNumerals[parseInt(digit)]).join('');
    }
    async function getAyahTransliteration(surah, ayah) { return null; }
    let isReaderChromeVisible = true; // To track visibility of header/footer/panels
    function applyFontChangeToView() {
        const newFont = fullScreenReaderSettings.arabicFont;
        document.querySelectorAll(
            '#fsReaderContent .fsReaderAyah, #fsReaderContent .bismillahText, #fsReaderContent .surahNameHeader'
        ).forEach(el => {
            el.style.fontFamily = newFont;
        });
    }
    function setupEnhancedFullScreenReaderEventListeners() {
        const closeBtn = document.getElementById('fsReaderCloseBtnEnhanced');
        const nextBtn = document.getElementById('fsReaderNextBtn');
        const prevBtn = document.getElementById('fsReaderPrevBtn');
        const playPauseBtn = document.getElementById('fsReaderPlayPauseBtn');
        const settingsToggleBtn = document.getElementById('fsReaderSettingsToggleBtn');
        const indexToggleBtn = document.getElementById('fsReaderIndexToggleBtn');
        const settingsPanel = document.getElementById('fsReaderSettingsPanel');
        const indexPanel = document.getElementById('fsReaderIndexPanel');
        const contentDiv = document.getElementById('fsReaderContent');
        const headerDiv = document.getElementById('fsReaderHeader');
        const footerDiv = document.getElementById('fsReaderFooter');
        const audioSourceSelect = document.getElementById('fsAudioSourceSelect');
        if (audioSourceSelect) {
            audioSourceSelect.addEventListener('change', (e) => {
                fullScreenReaderSettings.audioSource = e.target.value;
                stopAndClearAudio();
                saveFullScreenReaderSettings();
            });
        }
        const bookmarkBtn = document.getElementById('fsReaderBookmarkBtn');
        if (bookmarkBtn) {
            bookmarkBtn.addEventListener('click', async (event) => {
                if (event.ctrlKey || event.metaKey) {
                    saveLastReadPosition();
                    event.target.style.transition = 'transform 0.2s';
                    event.target.style.transform = 'scale(1.4)';
                    setTimeout(() => { event.target.style.transform = 'scale(1)'; }, 250);
                } else {
                    isDailyReadingSessionActive = true;
                    visualReadingSession = {
                        active: true,
                        startSurah: fullScreenReaderCurrentSurah,
                        startAyah: fullScreenReaderCurrentAyah,
                        endSurah: fullScreenReaderCurrentSurah,
                        endAyah: fullScreenReaderCurrentAyah
                    };
                    event.target.style.backgroundColor = 'var(--color-success)';
                    setTimeout(() => { event.target.style.backgroundColor = ''; }, 1000);
                    loadLastReadPosition();
                    if (fullScreenReaderViewMode === 'paged') {
                        await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
                    } else {
                        await initializeContinuousScroll();
                    }
                }
            });
        }
        const scrubSlider = document.getElementById('fsReaderScrubSlider');
        if (closeBtn) closeBtn.addEventListener('click', closeFullScreenQuranReaderEnhanced);
        if (nextBtn) nextBtn.addEventListener('click', goToNextEnhanced);
        if (prevBtn) prevBtn.addEventListener('click', goToPrevEnhanced);
        if (playPauseBtn) playPauseBtn.addEventListener('click', toggleAudioPlaybackEnhanced);
        if (settingsToggleBtn && settingsPanel && indexPanel) {
            settingsToggleBtn.addEventListener('click', () => {
                const isSettingsVisible = settingsPanel.style.display === 'block';
                settingsPanel.style.display = isSettingsVisible ? 'none' : 'block';
                indexPanel.style.display = 'none';
            });
        }
        if (indexToggleBtn && indexPanel && settingsPanel) {
            indexToggleBtn.addEventListener('click', () => {
                const isIndexVisible = indexPanel.style.display === 'block';
                indexPanel.style.display = isIndexVisible ? 'none' : 'block';
                settingsPanel.style.display = 'none';
            });
        }
        if (contentDiv && headerDiv && footerDiv && settingsPanel && indexPanel) {
            contentDiv.addEventListener('click', (e) => {
                if (e.target === contentDiv && settingsPanel.style.display === 'none' && indexPanel.style.display === 'none') {
                    toggleReaderChromeVisibility();
                } else if (settingsPanel.style.display === 'block' && !settingsPanel.contains(e.target) && e.target !== settingsToggleBtn) {
                    settingsPanel.style.display = 'none';
                } else if (indexPanel.style.display === 'block' && !indexPanel.contains(e.target) && e.target !== indexToggleBtn) {
                    indexPanel.style.display = 'none';
                }
            });
        }
        const arabicFontSelect = document.getElementById('fsArabicFontSelect');
        const fontSizeSlider = document.getElementById('fsFontSizeSlider');
        const fontSizeValueEl = document.getElementById('fsFontSizeValue');
        const linesPerPageSlider = document.getElementById('fsLinesPerPageSlider');
        const linesPerPageValueEl = document.getElementById('fsLinesPerPageValue');
        const showTransliterationCheck = document.getElementById('fsShowTransliterationCheck');
        const continuousAudioCheck = document.getElementById('fsContinuousAudioCheck');
        const autoScrollAudioCheck = document.getElementById('fsAutoScrollAudioCheck');
        const highlightColorPicker = document.getElementById('fsHighlightColorPicker');
        const viewModeSelect = document.getElementById('fsViewModeSelect');
        const showTajweedCheck = document.getElementById('fsShowTajweedCheck');
        if (showTajweedCheck) {
            showTajweedCheck.checked = fullScreenReaderSettings.showTajweedColors;
            showTajweedCheck.addEventListener('change', (e) => {
                fullScreenReaderSettings.showTajweedColors = e.target.checked;
                applyFullScreenReaderSettingsChanges();
            });
        }
        if (arabicFontSelect) {
            arabicFontSelect.addEventListener('change', (e) => {
                loadAndApplyDynamicFont(e.target.value);
                applyFontChangeToView();
                saveFullScreenReaderSettings();
            });
        }

        if (fontSizeSlider && fontSizeValueEl) {
            fontSizeSlider.addEventListener('input', (e) => {
                fullScreenReaderSettings.fontSize = `${e.target.value}rem`;
                fontSizeValueEl.textContent = fullScreenReaderSettings.fontSize;
                const contentDiv = document.getElementById('fsReaderContent');
                if (contentDiv) contentDiv.style.fontSize = fullScreenReaderSettings.fontSize;
            });
            fontSizeSlider.addEventListener('change', applyFullScreenReaderSettingsChanges);
        }
        if (linesPerPageSlider && linesPerPageValueEl) {
            linesPerPageSlider.addEventListener('input', (e) => {
                fullScreenReaderSettings.linesPerPage = parseInt(e.target.value, 10);
                linesPerPageValueEl.textContent = fullScreenReaderSettings.linesPerPage;
            });
            linesPerPageSlider.addEventListener('change', applyFullScreenReaderSettingsChanges);
        }
        if (showTransliterationCheck) showTransliterationCheck.addEventListener('change', (e) => {
            fullScreenReaderSettings.showTransliteration = e.target.checked;
            applyFullScreenReaderSettingsChanges();
        });
        if (continuousAudioCheck) continuousAudioCheck.addEventListener('change', (e) => {
            fullScreenReaderSettings.continuousAudio = e.target.checked;
            saveFullScreenReaderSettings();
        });
        if (autoScrollAudioCheck) autoScrollAudioCheck.addEventListener('change', (e) => {
            fullScreenReaderSettings.autoScrollAudio = e.target.checked;
            saveFullScreenReaderSettings();
        });
        if (highlightColorPicker) highlightColorPicker.addEventListener('change', (e) => {
            fullScreenReaderSettings.highlightColor = e.target.value;
            saveFullScreenReaderSettings();
        });
        if (viewModeSelect) {
            viewModeSelect.addEventListener('change', async (e) => {
                fullScreenReaderViewMode = e.target.value;
                saveFullScreenReaderSettings();
                document.getElementById('fsLinesPerPageSettingDiv').style.display = (fullScreenReaderViewMode === 'paged') ? 'block' : 'none';
                stopAndClearAudio();
                if (fullScreenReaderViewMode === 'paged') {
                    fullScreenReaderCurrentPage = surahToPageEnhanced(fullScreenReaderCurrentSurah, fullScreenReaderCurrentAyah);
                    await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
                } else {
                    continuousScrollNextSurahToLoad = fullScreenReaderCurrentSurah;
                    continuousScrollNextAyahToLoad = 1;
                    await initializeContinuousScroll();
                }
                updateReaderHeaderInfo();
                updateScrubSliderRangeAndValue();
            });
        }
        document.querySelectorAll('#fsReaderIndexPanel .index-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                document.querySelectorAll('#fsReaderIndexPanel .index-tab').forEach(t => t.classList.remove('active-tab'));
                e.target.classList.add('active-tab');
                document.querySelectorAll('#fsReaderIndexPanel .index-content-panel').forEach(p => p.style.display = 'none');
                document.getElementById(`fsIndexContent${e.target.dataset.tab.charAt(0).toUpperCase() + e.target.dataset.tab.slice(1)}`).style.display = 'block';
            });
        });
        if (scrubSlider) {
            scrubSlider.addEventListener('input', () => {
                if (fullScreenReaderViewMode === 'paged') {
                    const page = parseInt(scrubSlider.value, 10);
                    const pageData = tajMushafPageData.find(p => p.page === page);
                    if (pageData) {
                        document.getElementById('fsReaderSurahTitle').textContent = `Surah ${pageData.startSurah}: ${surahNames[pageData.startSurah - 1]}`;
                        document.getElementById('fsReaderPageInfo').textContent = `Page ${page}/${TAJ_COMPANY_PAGES} (Juz ${pageData.juz || getJuzFromSurahAyah(pageData.startSurah, pageData.startAyah)})`;
                    }
                } else {
                    const surah = parseInt(scrubSlider.value, 10);
                    document.getElementById('fsReaderSurahTitle').textContent = `Surah ${surah}: ${surahNames[surah - 1]}`;
                    document.getElementById('fsReaderPageInfo').textContent = `Juz ${getJuzFromSurahAyah(surah, 1)}`;
                }
            });
            scrubSlider.addEventListener('change', async () => {
                stopAndClearAudio();
                if (fullScreenReaderViewMode === 'paged') {
                    fullScreenReaderCurrentPage = parseInt(scrubSlider.value, 10);
                    await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
                } else {
                    fullScreenReaderCurrentSurah = parseInt(scrubSlider.value, 10);
                    fullScreenReaderCurrentAyah = 1;
                    continuousScrollNextSurahToLoad = fullScreenReaderCurrentSurah;
                    continuousScrollNextAyahToLoad = 1;
                    await initializeContinuousScroll();
                }
                updateReaderHeaderInfo();
            });
        }
        if (contentDiv) {
            contentDiv.addEventListener('scroll', async () => {
                if (fullScreenReaderViewMode === 'continuous-scroll' && !isLoadingMoreAyahs) {
                    const scrollThreshold = contentDiv.scrollHeight - contentDiv.clientHeight - 700;
                    if (contentDiv.scrollTop >= scrollThreshold) {
                        await loadMoreAyahsForContinuousScroll();
                    }
                    updateReaderHeaderInfo();
                }
            });
        }
        setupKeyboardAndTapNavigation();
    }

    function loadAndApplyDynamicFont(fontValue) {
        fullScreenReaderSettings.arabicFont = fontValue;
    }
    let autoLogSession = { active: false, startSurah: null, startAyah: null, endSurah: null, endAyah: null };
    function saveDailyBookmarkPosition() {
        const bookmark = {
            surah: fullScreenReaderCurrentSurah,
            ayah: fullScreenReaderCurrentAyah,
            page: fullScreenReaderCurrentPage,
            viewMode: fullScreenReaderViewMode
        };
        localStorage.setItem('fsReaderDailyBookmark', JSON.stringify(bookmark));
        const btn = document.getElementById('fsReaderBookmarkBtn');
        if (btn) {
            btn.style.transition = 'transform 0.2s ease-out';
            btn.style.transform = 'scale(1.4)';
            setTimeout(() => { btn.style.transform = 'scale(1)'; }, 250);
        }
    }
    /* 
    async function getAyahHTML(surah, ayah) {
        if (fullScreenReaderSettings.showTajweedColors) {
            try {
                const response = await fetch(`https://api.quran.com/api/v4/quran/verses/uthmani_tajweed?verse_key=${surah}:${ayah}`);
                if (!response.ok) {
                    throw new Error(`API fetch failed with status ${response.status}`);
                }
                const data = await response.json();
                if (data.verses && data.verses.length > 0) {
                    const originalHtml = data.verses[0].text_uthmani_tajweed;
            const htmlWithoutVerseNumber = originalHtml.replace(/\s*﴿[٠-٩]+﴾\s*\/g, ''); // remove the slash which was added for comment
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlWithoutVerseNumber;
                    const tajweedElements = tempDiv.querySelectorAll('tajweed');
                    tajweedElements.forEach(el => {
                        const span = document.createElement('span');
                        span.className = `tajweed ${el.getAttribute('class')}`;
                        span.innerHTML = el.innerHTML;
                        el.parentNode.replaceChild(span, el);
                    });
                    return tempDiv.innerHTML;
                }
            } catch (error) {
                console.warn(`Tajweed API fetch failed for ${surah}:${ayah}. Falling back to plain text.`, error);
            }
        }
        const ayahData = await getData(STORE_QURAN, [surah, ayah]);
        return ayahData ? ayahData.arabic.trim() : `[Ayah ${surah}:${ayah} not found]`;
    } */

    async function getAyahHTML(surah, ayah) {
        if (fullScreenReaderSettings.showTajweedColors) {
            try {
                const response = await fetch(`tajweed_data/${surah}/${ayah}.html`);
                if (!response.ok) {
                    throw new Error(`Local file not found: ${response.statusText}`);
                }
                const originalHtml = await response.text();

                const htmlWithoutVerseNumber = originalHtml.replace(/\s*﴿[٠-٩]+﴾\s*/g, '');
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlWithoutVerseNumber;

                tempDiv.querySelectorAll('tajweed').forEach(el => {
                    const span = document.createElement('span');
                    span.className = `tajweed ${el.getAttribute('class')}`;
                    span.innerHTML = el.innerHTML;
                    el.parentNode.replaceChild(span, el);
                });
                return tempDiv.innerHTML;

            } catch (error) {
                console.warn(`Local Tajweed fetch failed for ${surah}:${ayah}. Falling back.`, error);
            }
        }
        const ayahData = await getData(STORE_QURAN, [surah, ayah]);
        return ayahData ? ayahData.arabic.trim() : `[Ayah ${surah}:${ayah} not found]`;
    }
    async function loadAndGoToDailyBookmark() {
        const saved = localStorage.getItem('fsReaderDailyBookmark');
        if (!saved) {
            console.warn("Daily bookmark not set. Use Ctrl+Click on the bookmark icon to set it.");
            const btn = document.getElementById('fsReaderBookmarkBtn');
            if (btn) { // Give feedback that it's not set
                btn.style.transition = 'transform 0.1s ease-in-out';
                btn.style.transform = 'translateX(-3px)';
                setTimeout(() => { btn.style.transform = 'translateX(3px)'; }, 100);
                setTimeout(() => { btn.style.transform = 'translateX(0px)'; }, 200);
            }
            return;
        }
        await logAutoRecitationSession(); // Log any pending session before jumping
        stopAndClearAudio();
        const bookmark = JSON.parse(saved);
        fullScreenReaderCurrentSurah = bookmark.surah;
        fullScreenReaderCurrentAyah = bookmark.ayah;
        fullScreenReaderCurrentPage = bookmark.page;
        fullScreenReaderViewMode = bookmark.viewMode;
        const viewModeSelect = document.getElementById('fsViewModeSelect');
        if (viewModeSelect) viewModeSelect.value = fullScreenReaderViewMode;
        if (fullScreenReaderViewMode === 'paged') {
            document.getElementById('fsLinesPerPageSettingDiv').style.display = 'block';
            await renderQuranPageEnhanced(fullScreenReaderCurrentPage);
        } else {
            document.getElementById('fsLinesPerPageSettingDiv').style.display = 'none';
            await initializeContinuousScroll();
        }
        updateReaderHeaderInfo();
        updateScrubSliderRangeAndValue();
    }
    async function logAutoRecitationSession() {
        if (!autoLogSession.active) return;
        const { startSurah, startAyah, endSurah, endAyah } = autoLogSession;
        const finalEndAyah = endAyah || startAyah;
        const finalEndSurah = endSurah || startSurah;
        const qariMap = {
            'quran': 'Mishary Alafasy (FS Reader)',
            'en': 'Ibrahim Walk (FS Reader)',
            'ur': 'Fateh Jalandhri (FS Reader)'
        };
        const qariName = qariMap[fullScreenReaderSettings.audioSource] || 'FS Reader';
        const logEntry = {
            surah: startSurah,
            ayahStart: startAyah,
            ayahEnd: finalEndAyah,
            qari: qariName,
            date: new Date().toISOString().split('T')[0],
            notes: `Auto-logged from full-screen reader. Listened to S${startSurah}:${startAyah} through S${finalEndSurah}:${finalEndAyah}.`
        };
        try {
            await addData(STORE_RECITATIONS, logEntry);
            console.log("Auto-logged recitation session:", logEntry);
        } catch (error) {
            console.error("Failed to auto-log recitation session:", error);
        }
        autoLogSession = { active: false, startSurah: null, startAyah: null, endSurah: null, endAyah: null };
    }
    function toggleReaderChromeVisibility(forceShow) {
        const headerDiv = document.getElementById('fsReaderHeader');
        const footerDiv = document.getElementById('fsReaderFooter');
        const settingsPanel = document.getElementById('fsReaderSettingsPanel');
        const indexPanel = document.getElementById('fsReaderIndexPanel');
        if (forceShow !== undefined) {
            isReaderChromeVisible = !forceShow; // Set to opposite so toggle flips it to desired state
        }
        isReaderChromeVisible = !isReaderChromeVisible; // Toggle state
        if (headerDiv) headerDiv.style.display = isReaderChromeVisible ? 'flex' : 'none';
        if (footerDiv) footerDiv.style.display = isReaderChromeVisible ? 'flex' : 'none';
        if (!isReaderChromeVisible) {
            if (settingsPanel) settingsPanel.style.display = 'none';
            if (indexPanel) indexPanel.style.display = 'none';
        }
    }
    function addEnhancedFullScreenReaderLaunchButton() {
        const quranViewerSection = document.getElementById('quran');
        if (!quranViewerSection) { console.error("Quran viewer section not found for launch button."); return; }
        const buttonId = 'launchFullScreenReaderBtnEnhanced';
        if (document.getElementById(buttonId)) return; // Already added
        const launchButton = document.createElement('button');
        launchButton.id = buttonId;
        launchButton.innerHTML = '📖 <span class="sr-only">Open Full Screen Reader</span>'; // Icon + SR text
        launchButton.title = 'Open Immersive Quran Reader';
        launchButton.style.padding = '5px 10px';
        launchButton.style.fontSize = '1.2rem';
        launchButton.style.marginLeft = '10px'; // Space from other controls
        launchButton.style.verticalAlign = 'middle';
        launchButton.addEventListener('click', () => {
            fullScreenReaderCurrentSurah = window.currentSurah || 1;
            fullScreenReaderCurrentAyah = window.currentAyah || 1;
            if (fullScreenReaderViewMode === 'paged') { // Use the reader's current view mode preference
                fullScreenReaderCurrentPage = surahToPageEnhanced(fullScreenReaderCurrentSurah, fullScreenReaderCurrentAyah);
            }
            launchFullScreenQuranReaderEnhanced();
            setTimeout(() => {
                document.getElementById('fsReaderSettingsToggleBtn').click(); // Open settings panel on launch
                setTimeout(() => {
                    document.getElementById('fsReaderSettingsToggleBtn').click(); // off settings panel on launch
                }, 200);
                document.querySelector("#fsReaderSettingsPanel").style.right = "66px"
                document.querySelector("#fsReaderSettingsPanel").style.top = "4px"
                document.querySelector("#fsReaderSettingsPanel").style.maxHeight = "100%"
            }, 200);
        });
        const quranControls = quranViewerSection.querySelector('.quran-controls:first-of-type .flex-group'); // Target the flex-group in first controls div
        if (quranControls) {
            quranControls.appendChild(launchButton); // Add to existing controls
        } else { // Fallback
            const header = quranViewerSection.querySelector('h2');
            if (header) header.insertAdjacentElement('afterend', launchButton);
            else quranViewerSection.insertBefore(launchButton, quranViewerSection.firstChild);
        }
    }
    function handleAyahSpanClick(clickedSurah, clickedAyah) {
        fullScreenReaderCurrentSurah = parseInt(clickedSurah);
        fullScreenReaderCurrentAyah = parseInt(clickedAyah);
        updateReaderHeaderInfo();
        playAudioForAyahEnhanced(fullScreenReaderCurrentSurah, fullScreenReaderCurrentAyah);
    }
    function setupKeyboardAndTapNavigation() {
        const readerOverlay = document.getElementById('fullScreenReaderOverlay');
        const contentArea = document.getElementById('fsReaderContent'); // For tap events
        if (!readerOverlay) {
            console.warn("Keyboard/Tap Nav: fullScreenReaderOverlay not found.");
            return;
        }
        const handleKeyDown = (event) => {
            if (!isFullScreenReaderActive ||
                (document.activeElement && ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName))) {
                return;
            }
            const settingsPanel = document.getElementById('fsReaderSettingsPanel');
            const indexPanel = document.getElementById('fsReaderIndexPanel');
            if ((settingsPanel && settingsPanel.style.display === 'block') ||
                (indexPanel && indexPanel.style.display === 'block')) {
                if (event.key === 'Escape') {
                    if (settingsPanel && settingsPanel.style.display === 'block') settingsPanel.style.display = 'none';
                    if (indexPanel && indexPanel.style.display === 'block') indexPanel.style.display = 'none';
                    event.preventDefault(); // Prevent other escape actions if any
                }
                return;
            }
            switch (event.key) {
                case 'ArrowLeft':
                    if (typeof goToPrevEnhanced === "function") {
                        goToPrevEnhanced();
                        event.preventDefault(); // Prevent default browser scroll
                    }
                    break;
                case 'ArrowRight':
                    if (typeof goToNextEnhanced === "function") {
                        goToNextEnhanced();
                        event.preventDefault(); // Prevent default browser scroll
                    }
                    break;
                case 'Escape': // Also allow Esc to close reader if no panels are open
                    if (typeof closeFullScreenQuranReaderEnhanced === "function") {
                        closeFullScreenQuranReaderEnhanced();
                        event.preventDefault();
                    }
                    break;
            }
        };
        document.addEventListener('keydown', handleKeyDown);
        if (contentArea) {
            let touchStartY = 0;
            let touchEndY = 0;
            const tapThreshold = 50; // Min pixels to be considered a swipe/meaningful tap movement
            const screenPortionThreshold = 0.33; // Tap in top 33% or bottom 33%
            const handleTouchStart = (event) => {
                if (event.touches.length === 1) { // Single touch
                    touchStartY = event.touches[0].clientY;
                }
            };
            const handleTouchEnd = (event) => {
                if (event.changedTouches.length === 1) { // Single touch ended
                    touchEndY = event.changedTouches[0].clientY;
                    const verticalDiff = touchEndY - touchStartY;
                    const screenHeight = window.innerHeight; // or contentArea.clientHeight
                    if (Math.abs(verticalDiff) > tapThreshold * 1.5) { // If it was a noticeable swipe
                        return;
                    }
                    const tapYPosition = touchStartY; // Where the tap initiated
                    if (tapYPosition < screenHeight * screenPortionThreshold) {
                        if (typeof goToPrevEnhanced === "function") {
                            goToPrevEnhanced();
                        }
                    } else if (tapYPosition > screenHeight * (1 - screenPortionThreshold)) {
                        if (typeof goToNextEnhanced === "function") {
                            goToNextEnhanced();
                        }
                    } else {
                    }
                }
            };
            const handleContentClickForTap = (event) => {
                if (event.target.closest('.fsReaderAyah, button, select, input, a')) {
                    return; // Don't interpret clicks on interactive elements as page turns
                }
                const settingsPanel = document.getElementById('fsReaderSettingsPanel');
                const indexPanel = document.getElementById('fsReaderIndexPanel');
                if ((settingsPanel && settingsPanel.style.display === 'block') ||
                    (indexPanel && indexPanel.style.display === 'block')) {
                    return; // Don't trigger tap navigation if a panel is open
                }
                const contentRect = contentArea.getBoundingClientRect();
                const clickYRelativeToContent = event.clientY - contentRect.top;
                const contentHeight = contentArea.clientHeight;
                if (clickYRelativeToContent < contentHeight * screenPortionThreshold) {
                    if (typeof goToPrevEnhanced === "function") {
                        goToPrevEnhanced();
                    }
                } else if (clickYRelativeToContent > contentHeight * (1 - screenPortionThreshold)) {
                    if (typeof goToNextEnhanced === "function") {
                        goToNextEnhanced();
                    }
                }
            };
            contentArea.addEventListener('touchstart', handleTouchStart, { passive: true });
            contentArea.addEventListener('touchend', handleTouchEnd, { passive: true });
            contentArea.addEventListener('click', handleContentClickForTap);
            readerOverlay.readerKeyDownHandler = handleKeyDown;
            contentArea.readerTouchStartHandler = handleTouchStart;
            contentArea.readerTouchEndHandler = handleTouchEnd;
            contentArea.readerContentClickHandler = handleContentClickForTap;
        }
    }
    let ayahTypingTargetText = "";
    let ayahTypingTargetCleanText = ""; // Target text without diacritics
    let ayahTypingTargetSpans = [];
    let ayahTypingCurrentIndex = 0; // Index in the TARGET Ayah
    let ayahTypingErrors = 0;
    let ayahTypingCorrectStrokes = 0;
    let ayahTypingTotalStrokesAttemptedByPlayer = 0; // How many chars player tried to type for current Ayah
    let ayahTypingStartTime = 0;
    let ayahTypingTimerInterval = null;
    let ayahTypingGameActive = false;
    let ayahTypingDiacriticMode = 'ignore'; // 'ignore' or 'strict'
    let ayahTypingSessionHighScoreWPM = 0;
    let ayahTypingSessionHighScoreAcc = 0;
    let ayahTypingCurrentAyahData = null; // To store {surah, ayah} for audio
    function normalizeArabicCharForTyping(char) {
        if (!char) return "";
        let nfdNormalizedChar = char.normalize('NFD');
        let marksRemovedChar = nfdNormalizedChar.replace(/\p{M}/gu, '');
        let tatweelRemovedChar = marksRemovedChar.replace(/\u0640/g, '');
        let letterNormalizedChar = tatweelRemovedChar;
        letterNormalizedChar = letterNormalizedChar.replace(/[آأإٱ]/g, 'ا');
        letterNormalizedChar = letterNormalizedChar.replace(/[ؤو]/g, 'و');
        letterNormalizedChar = letterNormalizedChar.replace(/[ىیي]/g, 'ي');
        letterNormalizedChar = letterNormalizedChar.replace(/[ہھةۃه]/g, 'ه'); // Teh Marbuta, HEH DOACHASHMEE, HEH GOAL to standard HEH
        letterNormalizedChar = letterNormalizedChar.replace(/[كک]/g, 'ك');
        letterNormalizedChar = letterNormalizedChar.replace(/[لٰل]/g, 'ل'); // Lam with Hamza to standard Lam
        letterNormalizedChar = letterNormalizedChar.replace(/[ڤ]/g, 'ف'); // V to F
        letterNormalizedChar = letterNormalizedChar.replace(/[مٰم]/g, 'م'); // V to F
        return letterNormalizedChar;
    }
    function injectAyahTypingGameCSS_Engine() {
        const cssId = "ayahTypingGameStylesEngine";
        if (document.getElementById(cssId)) return;
        const styles = `
        .ayah-typing-game-area { display: flex; flex-direction: column; align-items: center; width: 100%; padding: 10px; height: 100%; }
        .typing-options-bar { display: flex; justify-content: space-around; align-items: center; width: 100%; max-width: 600px; margin-bottom: 15px; padding: 8px; background-color: var(--color-bg-secondary); border-radius: var(--border-radius); }
        .typing-options-bar label { font-size: 0.9em; display:flex; align-items:center; gap: 5px;}
        .typing-options-bar select, .typing-options-bar button { font-size: 0.9em; padding: 5px 8px; }
        #ayahDisplayContainer_Engine {
            font-family: var(--font-arabic);
            font-size: 2.2rem; /* Will be adjusted by main reader settings */
            line-height: 2.5;
            direction: rtl;
            text-align: right;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            width: 100%;
            max-width: 90%; /* Or set a fixed max-width like 700px */
            min-height: 100px; /* Adjust based on typical ayah length */
            overflow-wrap: break-word;
        }
        #ayahDisplayContainer_Engine span {
            transition: background-color 0.1s, color 0.1s;
            padding: 0; /* === MODIFIED: Removed padding === */
            letter-spacing: normal; 
        }
        #ayahDisplayContainer_Engine .char-correct { background-color: #d4edda; color: #155724; } /* Light green */
        #ayahDisplayContainer_Engine .char-incorrect { background-color: #f8d7da; color: #721c24; } /* Light red */
        #ayahDisplayContainer_Engine .char-current { background-color: var(--color-highlight); box-shadow: 0 0 0 2px var(--color-accent); }
        #ayahDisplayContainer_Engine .char-pending { color: var(--color-text-secondary); opacity: 0.7; }
        #typingInputArea_Engine {
            font-family: var(--font-arabic);
            font-size: 2rem; /* Match display somewhat */
            direction: rtl;
            text-align: right;
            width: 100%;
            max-width: 90%; /* Match display */
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid var(--color-accent);
            border-radius: var(--border-radius);
            min-height: 60px;
            resize: none; /* Or vertical */
        }
        #typingInputArea_Engine:focus { outline: 2px solid var(--color-accent-dark); }
        .typing-stats-container { display: flex; justify-content: space-around; width: 100%; max-width: 600px; margin-bottom: 15px; font-size: 1.1rem; }
        .typing-stats-container div { background-color: var(--color-bg-secondary); padding: 8px 12px; border-radius: var(--border-radius); text-align: center; }
        .typing-stats-container strong { color: var(--color-accent-dark); display:block; font-size: 1.3em; }
        .typing-controls-area { margin-top: 15px; }
        .typing-controls-area button { margin: 0 5px; }
        .typing-results-area { text-align: center; padding: 20px; }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
    }
    async function startAyahTyping_Engine() {
        activeGame = 'ayahTyping_engine';
        injectAyahTypingGameCSS_Engine(); // Ensure CSS is injected
        const mainGameModal = document.getElementById('quranGameModal');
        const gamePlayArea = document.getElementById('gamePlayArea'); // Get the gamePlayArea
        if (!gamePlayArea) {
            console.error("Ayah Typing: gamePlayArea element not found in the modal!");
            return;
        }
        if (!mainGameModal) {
            console.error("Ayah Typing: Main game modal not found!");
            return;
        }
        mainGameModal.style.display = 'none';
        gamePlayArea.innerHTML = `
        <div class="ayah-typing-game-area">
            <div class="typing-options-bar">
                <label for="diacriticModeSelect_Engine">Diacritics:
                    <select id="diacriticModeSelect_Engine">
                        <option value="ignore">Ignore (Type Base Letters)</option>
                        <option value="strict">Strict (Match Exactly)</option>
                    </select>
                </label>
                <button id="playAyahAudioBtn_Engine" title="Play Ayah Recitation" style="display:none;">🔊</button>
            </div>
            <div id="ayahDisplayContainer_Engine">Press "Start" to load an Ayah.</div>
            <textarea id="typingInputArea_Engine" rows="2" placeholder="ابدأ الكتابة هنا..." disabled></textarea>
            <div class="typing-stats-container">
                <div>Timer: <strong id="typingTimer_Engine">0s</strong></div>
                <div>WPM: <strong id="typingWPM_Engine">0</strong></div>
                <div>Accuracy: <strong id="typingAccuracy_Engine">0%</strong></div>
            </div>
            <div class="typing-controls-area">
                <button id="startTypingGameBtn_Engine">Start</button>
                <button id="resetTypingGameBtn_Engine" style="display:none;">Next Ayah</button>
            </div>
            <div id="typingResultsArea_Engine" class="typing-results-area" style="display:none;"></div>
        </div>
    `;
        const ayahDisplay = document.getElementById('ayahDisplayContainer_Engine');
        if (isFullScreenReaderActive && fullScreenReaderSettings && fullScreenReaderSettings.fontSize) {
            ayahDisplay.style.fontSize = fullScreenReaderSettings.fontSize;
        }
        document.getElementById('startTypingGameBtn_Engine').addEventListener('click', loadNextAyahForTyping_Engine);
        document.getElementById('resetTypingGameBtn_Engine').addEventListener('click', loadNextAyahForTyping_Engine);
        document.getElementById('diacriticModeSelect_Engine').addEventListener('change', (e) => {
            ayahTypingDiacriticMode = e.target.value;
        });
        document.getElementById('playAyahAudioBtn_Engine').addEventListener('click', () => {
            if (ayahTypingCurrentAyahData && typeof playAudioForAyahEnhanced === 'function') {
                playAudioForAyahEnhanced(ayahTypingCurrentAyahData.surah, ayahTypingCurrentAyahData.ayah);
            } else {
                console.warn("Cannot play audio: Ayah data missing or audio player function not available.");
            }
        });
        document.getElementById('typingInputArea_Engine').addEventListener('input', handleTypingInput_Engine);
        ayahTypingSessionHighScoreWPM = parseInt(localStorage.getItem('ayahTypingHighScoreWPM') || '0');
        ayahTypingSessionHighScoreAcc = parseInt(localStorage.getItem('ayahTypingHighScoreAcc') || '0');
        requestAyahTypingFullscreen(gamePlayArea);
    }
    async function loadNextAyahForTyping_Engine() {
        resetTypingGameState_Engine();
        const ayahDisplay = document.getElementById('ayahDisplayContainer_Engine');
        const typingInput = document.getElementById('typingInputArea_Engine');
        ayahDisplay.innerHTML = '<p>Loading new Ayah...</p>';
        typingInput.disabled = true;
        typingInput.value = '';
        document.getElementById('startTypingGameBtn_Engine').style.display = 'none';
        document.getElementById('resetTypingGameBtn_Engine').style.display = 'inline-block';
        document.getElementById('resetTypingGameBtn_Engine').textContent = 'Loading...';
        document.getElementById('resetTypingGameBtn_Engine').disabled = true;
        document.getElementById('playAyahAudioBtn_Engine').style.display = 'none';
        document.getElementById('typingResultsArea_Engine').style.display = 'none';
        try {
            let randomAyahObj;
            let attempts = 0;
            const MIN_CHARS = 15; // Adjusted min characters slightly
            const MAX_CHARS = 180; // Adjusted max characters slightly
            do {
                const randomSurah = Math.floor(Math.random() * 114) + 1;
                const randomAyahNum = Math.floor(Math.random() * (surahAyahCounts[randomSurah] || 1)) + 1;
                console.log(`[loadNextAyahForTyping_Engine] Attempt ${attempts + 1}: Trying S${randomSurah}:A${randomAyahNum}`);
                randomAyahObj = await getData(STORE_QURAN, [randomSurah, randomAyahNum]);
                if (randomAyahObj && randomAyahObj.arabic) {
                    console.log(`[loadNextAyahForTyping_Engine] Fetched Ayah (raw): '${randomAyahObj.arabic}' (Length: ${randomAyahObj.arabic.length})`);
                } else {
                    console.log(`[loadNextAyahForTyping_Engine] Ayah S${randomSurah}:A${randomAyahNum} not found or no Arabic text.`);
                }
                attempts++;
            } while ((!randomAyahObj || !randomAyahObj.arabic || randomAyahObj.arabic.trim().length < MIN_CHARS || randomAyahObj.arabic.trim().length > MAX_CHARS) && attempts < 50);
            if (!randomAyahObj || !randomAyahObj.arabic) {
                const errorMsg = "[loadNextAyahForTyping_Engine] Could not load a suitable Ayah after 50 attempts.";
                console.error(errorMsg);
                ayahDisplay.innerHTML = `<p style="color:red;">${errorMsg}</p>`;
                document.getElementById('startTypingGameBtn_Engine').style.display = 'inline-block';
                document.getElementById('resetTypingGameBtn_Engine').style.display = 'none';
                return;
            }
            ayahTypingCurrentAyahData = { surah: randomAyahObj.surah, ayah: randomAyahObj.ayah };
            ayahTypingTargetText = randomAyahObj.arabic.trim(); // Crucial: Use the trimmed version
            console.log(`[loadNextAyahForTyping_Engine] FINAL ayahTypingTargetText for rendering: '${ayahTypingTargetText}' (Length: ${ayahTypingTargetText.length})`);
            ayahTypingTargetCleanText = normalizeArabicCharForTyping(ayahTypingTargetText); // Normalize the final target text
            console.log(`[loadNextAyahForTyping_Engine] Normalized (Clean) Target Text: '${ayahTypingTargetCleanText}'`);
            renderAyahForTyping_Engine(ayahTypingTargetText); // Render the original (trimmed) text
            typingInput.disabled = false;
            typingInput.placeholder = "ابدأ الكتابة هنا عند الجاهزية";
            setTimeout(() => typingInput.focus(), 100);
            document.getElementById('resetTypingGameBtn_Engine').textContent = 'Next Ayah';
            document.getElementById('resetTypingGameBtn_Engine').disabled = false;
            document.getElementById('playAyahAudioBtn_Engine').style.display = 'inline-block';
        } catch (error) {
            console.error("[loadNextAyahForTyping_Engine] Error loading Ayah for typing:", error);
            ayahDisplay.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
            document.getElementById('startTypingGameBtn_Engine').style.display = 'inline-block';
            document.getElementById('resetTypingGameBtn_Engine').style.display = 'none';
        }
    }
    function renderAyahForTyping_Engine(ayahText) {
        const ayahDisplay = document.getElementById('ayahDisplayContainer_Engine');
        ayahDisplay.innerHTML = '';
        ayahTypingTargetSpans = [];
        for (let i = 0; i < ayahText.length; i++) {
            const charSpan = document.createElement('span');
            charSpan.textContent = ayahText[i];
            charSpan.className = 'char-pending';
            ayahDisplay.appendChild(charSpan);
            ayahTypingTargetSpans.push(charSpan);
        }
        if (ayahTypingTargetSpans.length > 0) {
            ayahTypingTargetSpans[0].classList.add('char-current'); // Highlight first char
        }
    }
    function resetTypingGameState_Engine() {
        if (ayahTypingTimerInterval) clearInterval(ayahTypingTimerInterval);
        ayahTypingGameActive = false;
        ayahTypingCurrentIndex = 0;
        ayahTypingErrors = 0;
        ayahTypingCorrectStrokes = 0;
        ayahTypingTotalStrokesAttemptedByPlayer = 0;
        ayahTypingStartTime = 0;
        ayahTypingTimerInterval = null;
        ayahTypingCurrentAyahData = null;
        document.getElementById('typingTimer_Engine').textContent = "0s";
        document.getElementById('typingWPM_Engine').textContent = "0";
        document.getElementById('typingAccuracy_Engine').textContent = "0%";
        const resultsArea = document.getElementById('typingResultsArea_Engine');
        if (resultsArea) resultsArea.style.display = 'none';
        const typingInput = document.getElementById('typingInputArea_Engine');
        if (typingInput) {
            typingInput.value = '';
            typingInput.disabled = true; // Disable until new Ayah is loaded
        }
    }
    function handleTypingInput_Engine() {
        const typingInput = document.getElementById('typingInputArea_Engine');
        if (!typingInput) { /* ... error handling ... */ return; }
        const userInput = typingInput.value; // What the user has ACTUALLY typed so far
        if (!ayahTypingGameActive && ayahTypingTargetSpans.length > 0 && userInput.length > 0) {
            ayahTypingGameActive = true;
            ayahTypingStartTime = Date.now();
            if (ayahTypingTimerInterval) clearInterval(ayahTypingTimerInterval);
            ayahTypingTimerInterval = setInterval(updateTypingTimer_Engine, 1000);
        }
        if (ayahTypingTargetSpans.length === 0) return;
        let currentEffectiveInputIndex = 0; // Tracks position in userInput
        let MismatchEncountered = false;
        for (let targetIdx = 0; targetIdx < ayahTypingTargetSpans.length; targetIdx++) {
            const span = ayahTypingTargetSpans[targetIdx];
            const targetCharOriginal = ayahTypingTargetText[targetIdx];
            span.className = ''; // Reset classes
            if (MismatchEncountered) { // If a mismatch already happened, all subsequent are pending
                span.classList.add('char-pending');
                continue;
            }
            const normalizedTargetChar = normalizeArabicCharForTyping(targetCharOriginal);
            if (ayahTypingDiacriticMode === 'ignore' && normalizedTargetChar === '') {
                span.classList.add('char-correct'); // Visually mark it as "handled"
                if (targetIdx === userInput.length && currentEffectiveInputIndex === userInput.length) {
                }
                continue; // Move to the next target character
            }
            const userTypedCharOriginal = userInput[currentEffectiveInputIndex];
            if (currentEffectiveInputIndex < userInput.length) { // User has typed a character for this position
                const normalizedUserChar = normalizeArabicCharForTyping(userTypedCharOriginal);
                if (targetIdx === currentEffectiveInputIndex && !MismatchEncountered) { // Log for current comparison point
                    console.log(`[Compare Char TargetIdx #${targetIdx} / InputIdx #${currentEffectiveInputIndex}] TargetOrig: '${targetCharOriginal}', UserTypedOrig: '${userTypedCharOriginal}'`);
                    if (ayahTypingDiacriticMode === 'ignore') {
                        console.log(`    NormTarget: '${normalizedTargetChar}', NormUser: '${normalizedUserChar}'`);
                    }
                }
                if (normalizedUserChar === normalizedTargetChar) {
                    span.classList.add('char-correct');
                } else {
                    if (ayahTypingDiacriticMode === 'ignore' && normalizedTargetChar.trim() === '' && normalizedUserChar.trim() === '') {
                        span.classList.add('char-correct');
                    } else {
                        span.classList.add('char-incorrect');
                        MismatchEncountered = true; // Stop further correct marking
                        if (targetIdx === currentEffectiveInputIndex) {
                            console.log(`    MISMATCH. UserNorm: '${normalizedUserChar}' vs TargetNorm: '${normalizedTargetChar}'`);
                        }
                    }
                }
                currentEffectiveInputIndex++;
            } else { // User hasn't typed up to this base character yet
                if (!MismatchEncountered) { // Only mark as current if no prior mismatch
                    span.classList.add('char-current');
                    MismatchEncountered = true; // From here on, subsequent chars are pending until this 'current' is typed
                } else {
                    span.classList.add('char-pending');
                }
            }
        }
        ayahTypingCurrentIndex = currentEffectiveInputIndex; // This is now the count of BASE characters matched/attempted
        if (ayahTypingGameActive) {
            updateLiveTypingStats_Engine(userInput); // userInput still reflects raw typed data
        }
        let baseTargetLength = 0;
        for (let char of ayahTypingTargetText) {
            if (normalizeArabicCharForTyping(char) !== '') baseTargetLength++;
        }
        if (currentEffectiveInputIndex >= baseTargetLength && !MismatchEncountered && ayahTypingGameActive) {
            endTypingRound_Engine(userInput); // Pass the raw user input for stat calculation
        }
    }
    function updateLiveTypingStats_Engine(currentUserInput) {
        if (!ayahTypingGameActive) {
            document.getElementById('typingWPM_Engine').textContent = "0";
            document.getElementById('typingAccuracy_Engine').textContent = "0%";
            return;
        }
        let liveCorrectChars = 0; // Use local variable for this function's calculations
        let liveErrors = 0;       // Use local variable for this function's calculations
        const typedLength = currentUserInput.length;
        const comparisonLength = Math.min(typedLength, ayahTypingTargetText.length);
        for (let i = 0; i < comparisonLength; i++) {
            const targetOriginal = ayahTypingTargetText[i];
            const userTypedOriginal = currentUserInput[i];
            if (ayahTypingDiacriticMode === 'ignore') {
                if (normalizeArabicCharForTyping(userTypedOriginal) === normalizeArabicCharForTyping(targetOriginal)) {
                    liveCorrectChars++;
                } else {
                    if (targetOriginal.trim() === '' && userTypedOriginal && userTypedOriginal.trim() === '') { // Lenient space
                        liveCorrectChars++;
                    } else {
                        liveErrors++;
                    }
                }
            } else { // 'strict' mode
                if (userTypedOriginal === targetOriginal) {
                    liveCorrectChars++;
                } else {
                    liveErrors++;
                }
            }
        }
        if (typedLength > ayahTypingTargetText.length) {
            liveErrors += (typedLength - ayahTypingTargetText.length);
        }
        ayahTypingCorrectStrokes = liveCorrectChars;
        ayahTypingErrors = liveErrors;
        ayahTypingTotalStrokesAttemptedByPlayer = typedLength;
        const currentTime = Date.now();
        const timeElapsedSeconds = (currentTime - ayahTypingStartTime) / 1000;
        let wpm = 0;
        if (timeElapsedSeconds > 0.5) {
            const wordsTypedCorrectly = liveCorrectChars / 5;
            const minutesElapsed = timeElapsedSeconds / 60;
            wpm = minutesElapsed > 0 ? Math.round(wordsTypedCorrectly / minutesElapsed) : 0;
        }
        let accuracy = 0;
        if (typedLength > 0) {
            accuracy = Math.round((liveCorrectChars / typedLength) * 100);
        }
        if (accuracy < 0) accuracy = 0;
        document.getElementById('typingWPM_Engine').textContent = wpm;
        document.getElementById('typingAccuracy_Engine').textContent = `${accuracy}%`;
    }
    function endTypingRound_Engine(finalUserInput) { // finalUserInput is passed
        if (!ayahTypingGameActive) {
            console.warn("[endTypingRound_Engine] Called when game not active. Ignoring.");
            return;
        }
        ayahTypingGameActive = false; // Set game to inactive
        if (ayahTypingTimerInterval) {
            clearInterval(ayahTypingTimerInterval);
            ayahTypingTimerInterval = null;
        }
        const typingInputEl = document.getElementById('typingInputArea_Engine');
        if (typingInputEl) typingInputEl.disabled = true;
        const timeElapsedSeconds = (Date.now() - ayahTypingStartTime) / 1000;
        console.log(`[endTypingRound_Engine] Time elapsed: ${timeElapsedSeconds.toFixed(2)}s`);
        let finalCorrectStrokes = 0;
        let finalErrors = 0;
        const finalComparisonLength = Math.min(finalUserInput.length, ayahTypingTargetText.length);
        for (let i = 0; i < finalComparisonLength; i++) {
            const targetOriginal = ayahTypingTargetText[i];
            const userTypedOriginal = finalUserInput[i];
            if (ayahTypingDiacriticMode === 'ignore') {
                if (normalizeArabicCharForTyping(userTypedOriginal) === normalizeArabicCharForTyping(targetOriginal)) {
                    finalCorrectStrokes++;
                } else {
                    if (targetOriginal.trim() === '' && userTypedOriginal && userTypedOriginal.trim() === '') { // Lenient space
                        finalCorrectStrokes++;
                    } else {
                        finalErrors++;
                    }
                }
            } else { // 'strict' mode
                if (userTypedOriginal === targetOriginal) {
                    finalCorrectStrokes++;
                } else {
                    finalErrors++;
                }
            }
        }
        console.log(`[endTypingRound_Engine] Final Calculated Correct Strokes: ${finalCorrectStrokes}`);
        console.log(`[endTypingRound_Engine] Final Calculated Errors (within typed length): ${finalErrors}`);
        let finalAccuracy = 0;
        if (finalUserInput.length > 0) { // Avoid division by zero
            finalAccuracy = Math.round((finalCorrectStrokes / finalUserInput.length) * 100);
        }
        finalAccuracy = Math.max(0, Math.min(100, finalAccuracy)); // Clamp between 0 and 100
        console.log(`[endTypingRound_Engine] Final Accuracy: ${finalAccuracy}% (Correct: ${finalCorrectStrokes}, Typed: ${finalUserInput.length})`);
        let finalWPM = 0;
        if (timeElapsedSeconds > 0.5) { // Only calculate if some meaningful time has passed
            const correctlyTypedWords = finalCorrectStrokes / 5; // Standard 5 characters per "word" for WPM
            const minutesElapsed = timeElapsedSeconds / 60;
            finalWPM = minutesElapsed > 0 ? Math.round(correctlyTypedWords / minutesElapsed) : 0;
        }
        finalWPM = Math.max(0, finalWPM); // Ensure WPM is not negative
        console.log(`[endTypingRound_Engine] Final WPM: ${finalWPM}`);
        document.getElementById('typingWPM_Engine').textContent = finalWPM;
        document.getElementById('typingAccuracy_Engine').textContent = `${finalAccuracy}%`;
        document.getElementById('typingTimer_Engine').textContent = `${timeElapsedSeconds.toFixed(1)}s`; // Show final time
        if (finalWPM > ayahTypingSessionHighScoreWPM) {
            ayahTypingSessionHighScoreWPM = finalWPM;
            localStorage.setItem('ayahTypingHighScoreWPM', ayahTypingSessionHighScoreWPM);
        }
        if (finalAccuracy > ayahTypingSessionHighScoreAcc) {
            ayahTypingSessionHighScoreAcc = finalAccuracy;
            localStorage.setItem('ayahTypingHighScoreAcc', ayahTypingSessionHighScoreAcc);
        }
        const resultsArea = document.getElementById('typingResultsArea_Engine');
        resultsArea.innerHTML = `
        <h4>Ayah Complete!</h4>
        <p>Your WPM: ${finalWPM}</p>
        <p>Accuracy: ${finalAccuracy}%</p>
        <p>Correct Characters: ${finalCorrectStrokes} / ${finalUserInput.length} (typed)</p>
        <p>Errors (in what you typed): ${finalErrors}</p>
        <p>Time: ${timeElapsedSeconds.toFixed(1)}s</p>
        <p><em>Session High: ${ayahTypingSessionHighScoreWPM} WPM, ${ayahTypingSessionHighScoreAcc}% Acc</em></p>
    `;
        resultsArea.style.display = 'block';
        const resetButton = document.getElementById('resetTypingGameBtn_Engine');
        if (resetButton) resetButton.focus();
    }
    function updateTypingTimer_Engine() {
        if (!ayahTypingGameActive) return;
        const currentTime = Date.now();
        const timeElapsed = Math.round((currentTime - ayahTypingStartTime) / 1000);
        document.getElementById('typingTimer_Engine').textContent = `${timeElapsed}s`;
    }
    function addAyahTypingGameButtonToModal() {
        const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
        const buttonId = 'startGameAyahTypingEngineBtn';
        if (gameSelectionArea && !document.getElementById(buttonId)) {
            const typingGameButton = document.createElement('button');
            typingGameButton.id = buttonId;
            typingGameButton.className = 'game-select-btn';
            typingGameButton.textContent = 'Ayah Typing Challenge';
            typingGameButton.addEventListener('click', () => {
                const gamePlayArea = document.getElementById('gamePlayArea');
                const gameSelectionArea = document.getElementById('game-selection-area');
                if (gameSelectionArea) gameSelectionArea.style.display = 'none';
                if (gamePlayArea) gamePlayArea.style.display = 'flex';
                setTimeout(() => {
                    startAyahTyping_Engine();
                }, 50); // Small delay, e.g., 50-100ms
            });
            const existingButtons = gameSelectionArea.querySelectorAll('.game-select-btn');
            if (existingButtons.length > 0) {
                existingButtons[existingButtons.length - 1].insertAdjacentElement('afterend', typingGameButton);
            } else {
                const pElement = gameSelectionArea.querySelector('p');
                if (pElement) {
                    pElement.insertAdjacentElement('afterend', typingGameButton);
                } else {
                    gameSelectionArea.appendChild(typingGameButton);
                }
            }
        }
    }
    let ayahTypingGameOriginalParent = null; // To store where gamePlayArea was before fullscreen
    let ayahTypingGameCloseButtonFS = null; // The dedicated close button for fullscreen
    function requestAyahTypingFullscreen(gamePlayAreaElement) {
        if (!gamePlayAreaElement) {
            console.error("requestAyahTypingFullscreen: gamePlayAreaElement is null.");
            return;
        }
        const fullscreenContainer = document.createElement('div');
        fullscreenContainer.id = 'ayahTypingFullscreenContainer';
        fullscreenContainer.style.position = 'fixed';
        fullscreenContainer.style.top = '0';
        fullscreenContainer.style.left = '0';
        fullscreenContainer.style.width = '100vw';
        fullscreenContainer.style.height = '100vh';
        fullscreenContainer.style.backgroundColor = 'var(--color-bg-primary, #e8f5e9)'; // Use your theme's primary bg
        fullscreenContainer.style.zIndex = '20000'; // Very high z-index
        fullscreenContainer.style.display = 'flex';
        fullscreenContainer.style.flexDirection = 'column';
        fullscreenContainer.style.justifyContent = 'center';
        fullscreenContainer.style.alignItems = 'center';
        fullscreenContainer.style.padding = '20px'; // Some padding around the game area
        fullscreenContainer.style.boxSizing = 'border-box';
        ayahTypingGameOriginalParent = gamePlayAreaElement.parentNode;
        fullscreenContainer.appendChild(gamePlayAreaElement); // Move gamePlayArea into our new container
        gamePlayAreaElement.style.width = '100%'; // Or a specific max-width like '90vw', '1200px'
        gamePlayAreaElement.style.height = '100%'; // Or '90vh'
        gamePlayAreaElement.style.maxWidth = '1200px'; // Example constraint
        gamePlayAreaElement.style.maxHeight = '95vh';
        gamePlayAreaElement.style.overflow = 'auto'; // If content overflows
        gamePlayAreaElement.style.backgroundColor = 'var(--color-bg-secondary, #c8e6c9)'; // Content background
        gamePlayAreaElement.style.borderRadius = 'var(--border-radius, 8px)';
        gamePlayAreaElement.style.boxShadow = '0 0 20px rgba(0,0,0,0.2)';
        ayahTypingGameCloseButtonFS = document.createElement('button');
        ayahTypingGameCloseButtonFS.id = 'ayahTypingCloseFullscreenBtn';
        ayahTypingGameCloseButtonFS.textContent = '✕';
        ayahTypingGameCloseButtonFS.style.position = 'absolute';
        ayahTypingGameCloseButtonFS.style.top = '20px';
        ayahTypingGameCloseButtonFS.style.right = '20px';
        ayahTypingGameCloseButtonFS.style.fontSize = '1.8rem';
        ayahTypingGameCloseButtonFS.style.padding = '5px 12px';
        ayahTypingGameCloseButtonFS.style.backgroundColor = 'var(--color-error, #ef5350)';
        ayahTypingGameCloseButtonFS.style.color = 'white';
        ayahTypingGameCloseButtonFS.style.border = 'none';
        ayahTypingGameCloseButtonFS.style.borderRadius = '50%';
        ayahTypingGameCloseButtonFS.style.cursor = 'pointer';
        ayahTypingGameCloseButtonFS.style.zIndex = '20001'; // Above gamePlayArea
        ayahTypingGameCloseButtonFS.title = "Exit Fullscreen Typing (Esc)";
        ayahTypingGameCloseButtonFS.onclick = exitAyahTypingFullscreen;
        fullscreenContainer.appendChild(ayahTypingGameCloseButtonFS);
        document.body.appendChild(fullscreenContainer);
        document.body.style.overflow = 'hidden'; // Prevent body scroll
        if (fullscreenContainer.requestFullscreen) {
            fullscreenContainer.requestFullscreen().catch(err => {
                console.warn(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        } else if (fullscreenContainer.webkitRequestFullscreen) { /* Safari */
            fullscreenContainer.webkitRequestFullscreen();
        } else if (fullscreenContainer.msRequestFullscreen) { /* IE11 */
            fullscreenContainer.msRequestFullscreen();
        }
        document.addEventListener('fullscreenchange', handleBrowserFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleBrowserFullscreenChange); // Safari
        document.addEventListener('mozfullscreenchange', handleBrowserFullscreenChange);    // Firefox
        document.addEventListener('MSFullscreenChange', handleBrowserFullscreenChange);   // IE
    }
    function exitAyahTypingFullscreen() {
        const gamePlayAreaElement = document.getElementById('gamePlayArea');
        const fullscreenContainer = document.getElementById('ayahTypingFullscreenContainer');
        if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) { /* Firefox */
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
        }
        cleanupAyahTypingCustomFullscreenOverlay(gamePlayAreaElement, fullscreenContainer);
    }
    function cleanupAyahTypingCustomFullscreenOverlay(gamePlayAreaElement, fullscreenContainer) {
        if (fullscreenContainer && fullscreenContainer.parentNode) {
            if (gamePlayAreaElement && ayahTypingGameOriginalParent) {
                gamePlayAreaElement.style.width = '';
                gamePlayAreaElement.style.height = '';
                gamePlayAreaElement.style.maxWidth = '';
                gamePlayAreaElement.style.maxHeight = '';
                gamePlayAreaElement.style.overflow = '';
                gamePlayAreaElement.style.backgroundColor = ''; // Let original CSS take over
                gamePlayAreaElement.style.borderRadius = '';
                gamePlayAreaElement.style.boxShadow = '';
                ayahTypingGameOriginalParent.appendChild(gamePlayAreaElement);
            }
            fullscreenContainer.parentNode.removeChild(fullscreenContainer);
        }
        if (ayahTypingGameCloseButtonFS && ayahTypingGameCloseButtonFS.parentNode) {
            ayahTypingGameCloseButtonFS.parentNode.removeChild(ayahTypingGameCloseButtonFS);
            ayahTypingGameCloseButtonFS = null;
        }
        document.body.style.overflow = ''; // Restore body scroll
        document.removeEventListener('fullscreenchange', handleBrowserFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', handleBrowserFullscreenChange);
        document.removeEventListener('mozfullscreenchange', handleBrowserFullscreenChange);
        document.removeEventListener('MSFullscreenChange', handleBrowserFullscreenChange);
        activeGame = null; // Mark no game as active
        resetGameUI(); // Your existing function to show game selection
        const mainGameModal = document.getElementById('quranGameModal');
        if (mainGameModal && mainGameModal.style.display === 'none') {
            mainGameModal.style.display = 'flex'; // Or whatever its default display is
        }
    }
    function handleBrowserFullscreenChange() {
        const fullscreenContainer = document.getElementById('ayahTypingFullscreenContainer');
        if (!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
            if (fullscreenContainer) { // If our container exists, it means we initiated this
                console.log("Browser fullscreen exited, cleaning up custom overlay.");
                cleanupAyahTypingCustomFullscreenOverlay(
                    document.getElementById('gamePlayArea'),
                    fullscreenContainer
                );
            }
        }
    }
    function enterSimpleImmersiveView() {
        const gameModalTitleEl = document.getElementById('gameModalTitle');
        if (gameModalTitleEl) {
            originalTitleDisplay_SimpleImmersive = gameModalTitleEl.style.display;
            gameModalTitleEl.style.display = 'none';
        } else {
            console.warn("[SimpleImmersive] gameModalTitleEl not found for hiding.");
        }
        isSimpleImmersiveActive = true;
    }
    function exitSimpleImmersiveView() {
        if (!isSimpleImmersiveActive) return;
        const gameModalTitleEl = document.getElementById('gameModalTitle');
        if (gameModalTitleEl) {
            gameModalTitleEl.style.display = originalTitleDisplay_SimpleImmersive;
        }
        isSimpleImmersiveActive = false;
    }
    let recitationGame_UI = {
        surahSelect: null,
        ayahStartSelect: null,
        ayahEndSelect: null,
        loadAyahButton: null,
        ayahDisplayArea: null,
        referencePlayButton: null,
        recordButton: null,
        analysisFeedbackArea: null,
        recordingStatusText: null,
        currentScoreDisplay: null,
        bestScoreDisplay: null
    };
    let recitationGame_State = {
        currentSurah: 1,
        currentAyahStart: 1,
        currentAyahEnd: 1,
        targetAyahText: "", // Concatenated text if range
        targetAyahWords: [], // Array of words for highlighting
        referenceAudio: null,
        referenceAudioDuration: 0,
        referenceHighlightInterval: null,
        userAudioRecorder: null,
        userAudioChunks: [],
        isRecording: false,
        speechRecognition: null,
        currentReferenceHighlightIndex: 0,
        gameActive: false, // Is the game screen for recitation practice active
        ayahKey: "" // e.g., "s1a1" or "s1a1-a3"
    };
    const STORE_RECITATION_GAME_PROGRESS = 'recitationGameProgress_v1'; // For user scores
    function injectRecitationPracticeGameCSS_Engine() {
        const cssId = "recitationPracticeGameStylesEngine";
        if (document.getElementById(cssId)) return;
        const styles = `
        .recitation-practice-game-area { display: flex; flex-direction: column; align-items: center; width: 100%; padding: 10px; height:100%; box-sizing: border-box; }
        .recitation-controls-bar { display: flex; flex-wrap: wrap; justify-content: space-around; align-items: center; width: 100%; max-width: 700px; margin-bottom: 15px; padding: 10px; background-color: var(--color-bg-secondary); border-radius: var(--border-radius); gap: 10px; }
        .recitation-controls-bar label { font-size: 0.9em; margin-right: 5px;}
        .recitation-controls-bar select, .recitation-controls-bar button { font-size: 0.9em; padding: 6px 10px; }
        #recitationAyahDisplay_Engine {
            font-family: var(--font-arabic); /* Ensure this is your primary Arabic font */
            font-size: 2.4rem; /* Adjust as needed, can be linked to reader settings */
            line-height: 2.8; /* Generous line height for Arabic */
            direction: rtl;
            text-align: right;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            width: 100%;
            max-width: 95%;
            min-height: 150px;
            overflow-y: auto; /* If Ayah is very long */
            cursor: default; /* Indicate it's display text */
        }
        #recitationAyahDisplay_Engine .highlight-word {
            background-color: var(--color-highlight, yellow); /* Theme highlight */
            border-radius: 3px;
            padding: 0 0.1em; /* Slight padding for better visual */
            transition: background-color 0.15s ease-in-out;
        }
        #recitationAyahDisplay_Engine .diff-correct { color: var(--color-success, green); font-weight: bold; }
        #recitationAyahDisplay_Engine .diff-incorrect { color: var(--color-error, red); text-decoration: line-through; }
        #recitationAyahDisplay_Engine .diff-missing { color: var(--color-text-secondary, gray); font-style: italic; }
        .recitation-action-buttons { display: flex; justify-content: center; align-items: center; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; }
        .recitation-action-buttons button { padding: 10px 18px; font-size: 1.1rem; }
        #recordUserAyah_Engine.is-recording { background-color: var(--color-error); }
        #recordingStatus_Engine { font-size: 1em; color: var(--color-text-secondary); min-height: 1.5em; margin-bottom: 10px; text-align: center;}
        #analysisFeedbackArea_Engine { width: 100%; max-width: 95%; padding: 15px; border: 1px dashed var(--color-border); border-radius: var(--border-radius); background-color: var(--color-bg-secondary); min-height: 80px; text-align: center; margin-top:15px; }
        #analysisFeedbackArea_Engine h4 { margin-top: 0; color: var(--color-text-primary); }
        #analysisFeedbackArea_Engine p { margin-bottom: 8px; }
        .recitation-game-scores { text-align: center; margin-top: 15px; font-size: 1rem; }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
        if (db && !db.objectStoreNames.contains(STORE_RECITATION_GAME_PROGRESS)) {
        }
    }
    async function startRecitationPracticeGame_Engine() {
        activeGame = 'recitationPractice_engine';
        injectRecitationPracticeGameCSS_Engine();
        recitationGame_State.gameActive = true;
        const gamePlayArea = document.getElementById('gamePlayArea');
        if (!gamePlayArea) {
            const mainModal = document.getElementById('quranGameModal');
            if (mainModal) mainModal.innerHTML = "<p style='color:red; text-align:center; padding:20px;'>Error: Game area component missing. Cannot start recitation practice.</p>";
            return;
        }
        showGamePlayUI("Recitation Practice");
        const gameHTML = `
        <div class="recitation-practice-game-area">
            <div class="recitation-controls-bar">
                <div>
                    <label for="recitationSurahSelect_Engine">Surah:</label>
                    <select id="recitationSurahSelect_Engine"></select>
                </div>
                <div>
                    <label for="recitationAyahStartSelect_Engine">From Ayah:</label>
                    <select id="recitationAyahStartSelect_Engine"></select>
                </div>
                <div>
                    <label for="recitationAyahEndSelect_Engine">To Ayah (Optional):</label>
                    <select id="recitationAyahEndSelect_Engine"><option value="">Single Ayah</option></select>
                </div>
                <button id="loadRecitationAyah_Engine">Load Ayah(s)</button>
            </div>
            <div id="recitationAyahDisplay_Engine">Select Surah and Ayah, then click "Load Ayah(s)".</div>
            <div class="recitation-action-buttons">
                <button id="playReferenceAyah_Engine" disabled>▶️ Play Reference</button>
                <button id="recordUserAyah_Engine" disabled>🎤 Record My Recitation</button>
            </div>
            <div id="recordingStatus_Engine"></div>
            <div id="analysisFeedbackArea_Engine" style="display:none;">
                <h4>Analysis Feedback</h4>
                <p id="feedbackTextAccuracy_Engine">Accuracy: -</p>
                <p id="feedbackTiming_Engine">Timing: -</p>
                <p id="feedbackRecognizedText_Engine" style="font-family: var(--font-arabic); direction:rtl;"></p>
            </div>
            <div class="recitation-game-scores">
                Current Ayah Accuracy: <strong id="currentRecitationScore_Engine">-</strong>%<br>
                Best Accuracy for this Ayah: <strong id="bestRecitationScore_Engine">-</strong>%
            </div>
        </div>
    `;
        gamePlayArea.innerHTML = gameHTML;
        if (!document.getElementById('feedbackTextAccuracy_Engine')) {
        } else {
        }
        if (!document.getElementById('feedbackRecognizedText_Engine')) {
        }
        if (!document.getElementById('feedbackTiming_Engine')) {
        }
        recitationGame_UI.surahSelect = document.getElementById('recitationSurahSelect_Engine');
        recitationGame_UI.ayahStartSelect = document.getElementById('recitationAyahStartSelect_Engine');
        recitationGame_UI.ayahEndSelect = document.getElementById('recitationAyahEndSelect_Engine');
        recitationGame_UI.loadAyahButton = document.getElementById('loadRecitationAyah_Engine');
        recitationGame_UI.ayahDisplayArea = document.getElementById('recitationAyahDisplay_Engine');
        recitationGame_UI.referencePlayButton = document.getElementById('playReferenceAyah_Engine');
        recitationGame_UI.recordButton = document.getElementById('recordUserAyah_Engine');
        recitationGame_UI.analysisFeedbackArea = document.getElementById('analysisFeedbackArea_Engine');
        recitationGame_UI.recordingStatusText = document.getElementById('recordingStatus_Engine');
        recitationGame_UI.currentScoreDisplay = document.getElementById('currentRecitationScore_Engine');
        recitationGame_UI.bestScoreDisplay = document.getElementById('bestRecitationScore_Engine');
        if (recitationGame_UI.surahSelect) {
            for (let i = 1; i <= 114; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${i}. ${surahNames[i - 1]}`; // Ensure surahNames is globally available
                recitationGame_UI.surahSelect.appendChild(option);
            }
        } else {
        }
        if (recitationGame_UI.surahSelect) recitationGame_UI.surahSelect.addEventListener('change', updateRecitationAyahSelectors_Engine);
        if (recitationGame_UI.ayahStartSelect) recitationGame_UI.ayahStartSelect.addEventListener('change', () => {
            const startAyah = parseInt(recitationGame_UI.ayahStartSelect.value);
            const endAyahSelect = recitationGame_UI.ayahEndSelect;
            if (endAyahSelect) { // Null check
                const currentEndValue = parseInt(endAyahSelect.value);
                if (currentEndValue && currentEndValue < startAyah) {
                    endAyahSelect.value = "";
                }
                populateRecitationAyahEndSelect_Engine(parseInt(recitationGame_UI.surahSelect.value), startAyah);
            }
        });
        if (recitationGame_UI.loadAyahButton) recitationGame_UI.loadAyahButton.addEventListener('click', loadAyahForRecitationPractice_Engine);
        if (recitationGame_UI.referencePlayButton) recitationGame_UI.referencePlayButton.addEventListener('click', playReferenceAudioWithHighlighting_Engine);
        if (recitationGame_UI.recordButton) recitationGame_UI.recordButton.addEventListener('click', toggleUserRecording_Recitation_Engine);
        updateRecitationAyahSelectors_Engine();
        setupSpeechRecognition_Engine();
    }
    function updateRecitationAyahSelectors_Engine() {
        const surahNum = parseInt(recitationGame_UI.surahSelect.value);
        const totalAyahs = surahAyahCounts[surahNum] || 0;
        recitationGame_UI.ayahStartSelect.innerHTML = '';
        for (let i = 1; i <= totalAyahs; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = i;
            recitationGame_UI.ayahStartSelect.appendChild(option);
        }
        populateRecitationAyahEndSelect_Engine(surahNum, 1); // Populate end based on surah and default start ayah 1
    }
    function populateRecitationAyahEndSelect_Engine(surahNum, startAyahNum) {
        const totalAyahs = surahAyahCounts[surahNum] || 0;
        const endSelect = recitationGame_UI.ayahEndSelect;
        const currentEndValue = endSelect.value; // Preserve selection if possible
        endSelect.innerHTML = '<option value="">Single Ayah Mode</option>'; // Default
        for (let i = startAyahNum; i <= totalAyahs; i++) { // Start from the selected startAyahNum
            const option = document.createElement('option');
            option.value = i;
            option.textContent = i;
            endSelect.appendChild(option);
        }
        if (currentEndValue && parseInt(currentEndValue) >= startAyahNum && parseInt(currentEndValue) <= totalAyahs) {
            endSelect.value = currentEndValue;
        } else {
            endSelect.value = ""; // Default to single if previous selection invalid
        }
    }
    async function loadAyahForRecitationPractice_Engine() {
        recitationGame_State.currentSurah = parseInt(recitationGame_UI.surahSelect.value);
        recitationGame_State.currentAyahStart = parseInt(recitationGame_UI.ayahStartSelect.value);
        const endAyahValue = recitationGame_UI.ayahEndSelect.value;
        recitationGame_State.currentAyahEnd = endAyahValue ? parseInt(endAyahValue) : recitationGame_State.currentAyahStart;
        if (recitationGame_State.currentAyahEnd < recitationGame_State.currentAyahStart) {
            alert("End Ayah cannot be before Start Ayah.");
            recitationGame_State.currentAyahEnd = recitationGame_State.currentAyahStart; // Correct it
            recitationGame_UI.ayahEndSelect.value = ""; // Reset UI
        }
        recitationGame_State.targetAyahText = "";
        recitationGame_State.targetAyahWords = [];
        recitationGame_UI.ayahDisplayArea.innerHTML = "Loading...";
        recitationGame_UI.analysisFeedbackArea.style.display = 'none';
        recitationGame_UI.currentScoreDisplay.textContent = '-';
        recitationGame_State.ayahKey = `s${recitationGame_State.currentSurah}a${recitationGame_State.currentAyahStart}`;
        if (recitationGame_State.currentAyahStart !== recitationGame_State.currentAyahEnd) {
            recitationGame_State.ayahKey += `-a${recitationGame_State.currentAyahEnd}`;
        }
        for (let i = recitationGame_State.currentAyahStart; i <= recitationGame_State.currentAyahEnd; i++) {
            const ayahData = await getData(STORE_QURAN, [recitationGame_State.currentSurah, i]);
            if (ayahData && ayahData.arabic) {
                const ayahTextClean = ayahData.arabic.trim();
                recitationGame_State.targetAyahText += ayahTextClean + (i < recitationGame_State.currentAyahEnd ? " " : ""); // Add space if not last ayah in range
                recitationGame_State.targetAyahWords.push(...ayahTextClean.split(/\s+/).filter(w => w.length > 0));
            }
        }
        if (recitationGame_State.targetAyahText) {
            renderLoadedAyahForRecitation_Engine();
            recitationGame_UI.referencePlayButton.disabled = false;
            recitationGame_UI.recordButton.disabled = false;
        } else {
            recitationGame_UI.ayahDisplayArea.innerHTML = "Error loading Ayah text.";
            recitationGame_UI.referencePlayButton.disabled = true;
            recitationGame_UI.recordButton.disabled = true;
        }
        loadBestScore_Recitation_Engine();
    }
    function renderLoadedAyahForRecitation_Engine() {
        recitationGame_UI.ayahDisplayArea.innerHTML = '';
        recitationGame_State.targetAyahWords.forEach(word => {
            const span = document.createElement('span');
            span.textContent = word + " "; // Add space for display separation
            recitationGame_UI.ayahDisplayArea.appendChild(span);
        });
    }
    async function playReferenceAudioWithHighlighting_Engine() {
        if (recitationGame_State.isRecording) {
            alert("Please stop recording first.");
            return;
        }
        stopReferenceAudio_Engine(); // Stop any previous audio
        recitationGame_UI.referencePlayButton.textContent = "🔄 Loading...";
        recitationGame_UI.referencePlayButton.disabled = true;
        recitationGame_UI.recordButton.disabled = true;
        let combinedAudioBufferSources = [];
        let totalDuration = 0;
        try {
            for (let i = recitationGame_State.currentAyahStart; i <= recitationGame_State.currentAyahEnd; i++) {
                const surahPadded = String(recitationGame_State.currentSurah).padStart(3, '0');
                const ayahPadded = String(i).padStart(3, '0');
                const audioSrcUrl = `https://everyayah.com/data/Alafasy_128kbps/${surahPadded}${ayahPadded}.mp3`;
                const response = await fetch(audioSrcUrl);
                const arrayBuffer = await response.arrayBuffer();
                const tempAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const decodedBuffer = await tempAudioCtx.decodeAudioData(arrayBuffer);
                combinedAudioBufferSources.push({ src: audioSrcUrl, duration: decodedBuffer.duration });
                totalDuration += decodedBuffer.duration;
                await tempAudioCtx.close(); // Close temporary context
            }
        } catch (error) {
            console.error("Error fetching reference audio segment durations:", error);
            recitationGame_UI.ayahDisplayArea.innerHTML = "Error loading reference audio data.";
            recitationGame_UI.referencePlayButton.textContent = "▶️ Play Reference";
            recitationGame_UI.referencePlayButton.disabled = false;
            recitationGame_UI.recordButton.disabled = false;
            return;
        }
        recitationGame_State.referenceAudioDuration = totalDuration;
        recitationGame_State.currentReferenceHighlightIndex = 0;
        recitationGame_State.referenceAudio = new Audio();
        let currentSegmentIndex = 0;
        const playNextSegment = () => {
            if (currentSegmentIndex >= combinedAudioBufferSources.length) {
                stopReferenceAudio_Engine();
                return;
            }
            recitationGame_State.referenceAudio.src = combinedAudioBufferSources[currentSegmentIndex].src;
            recitationGame_State.referenceAudio.play().catch(e => {
                console.error("Error playing segment:", e);
                stopReferenceAudio_Engine();
            });
            currentSegmentIndex++;
        };
        recitationGame_State.referenceAudio.onended = playNextSegment;
        recitationGame_State.referenceAudio.onerror = () => {
            console.error("Error with reference audio playback.");
            stopReferenceAudio_Engine();
        };
        playNextSegment(); // Start playing the first segment
        const wordsToHighlight = recitationGame_UI.ayahDisplayArea.querySelectorAll('span');
        if (wordsToHighlight.length > 0 && totalDuration > 0) {
            const timePerWord = totalDuration / wordsToHighlight.length;
            let highlightIdx = 0;
            wordsToHighlight.forEach(s => s.classList.remove('highlight-word')); // Clear previous
            recitationGame_State.referenceHighlightInterval = setInterval(() => {
                if (highlightIdx < wordsToHighlight.length) {
                    if (highlightIdx > 0) wordsToHighlight[highlightIdx - 1].classList.remove('highlight-word');
                    wordsToHighlight[highlightIdx].classList.add('highlight-word');
                    highlightIdx++;
                } else {
                    clearInterval(recitationGame_State.referenceHighlightInterval);
                    if (wordsToHighlight.length > 0) wordsToHighlight[wordsToHighlight.length - 1].classList.remove('highlight-word');
                }
            }, timePerWord * 1000); // Convert timePerWord to ms
        }
        recitationGame_UI.referencePlayButton.textContent = "⏹️ Stop Reference";
        recitationGame_UI.referencePlayButton.disabled = false;
    }
    function stopReferenceAudio_Engine() {
        if (recitationGame_State.referenceAudio) {
            recitationGame_State.referenceAudio.pause();
            recitationGame_State.referenceAudio.src = ""; // Clear source
            recitationGame_State.referenceAudio.onended = null;
            recitationGame_State.referenceAudio.onerror = null;
            recitationGame_State.referenceAudio = null;
        }
        if (recitationGame_State.referenceHighlightInterval) {
            clearInterval(recitationGame_State.referenceHighlightInterval);
            recitationGame_State.referenceHighlightInterval = null;
        }
        recitationGame_UI.ayahDisplayArea.querySelectorAll('span.highlight-word').forEach(s => s.classList.remove('highlight-word'));
        recitationGame_UI.referencePlayButton.textContent = "▶️ Play Reference";
        if (recitationGame_State.targetAyahText) { // Only enable if an Ayah is loaded
            recitationGame_UI.referencePlayButton.disabled = false;
            recitationGame_UI.recordButton.disabled = false;
        }
    }
    async function toggleUserRecording_Recitation_Engine() {
        if (recitationGame_State.isRecording) {
            stopUserRecording_Recitation_Engine();
        } else {
            if (recitationGame_State.referenceAudio && !recitationGame_State.referenceAudio.paused) {
                stopReferenceAudio_Engine();
            }
            await startUserRecording_Recitation_Engine();
        }
    }
    function setupSpeechRecognition_Engine() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            alert("Desktop speech recognition is not supported in this browser. Please try Google Chrome or Microsoft Edge.");
            if (recitationGame_UI.recordButton) recitationGame_UI.recordButton.disabled = true;
            return;
        }
        recitationGame_State.speechRecognition = new SpeechRecognition();
        const recognition = recitationGame_State.speechRecognition;
        recognition.lang = 'ar-SA';
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.onstart = () => {
            recitationGame_State.userTranscript = '';
            if (recitationGame_UI.recordingStatusText) recitationGame_UI.recordingStatusText.textContent = "Listening...";
        };
        recognition.onresult = (event) => {
            let final_transcript = '';
            for (let i = 0; i < event.results.length; ++i) {
                final_transcript += event.results[i][0].transcript;
            }
            recitationGame_State.userTranscript = final_transcript.trim();
        };
        recognition.onerror = (event) => {
            console.error("Speech Recognition Error:", event.error);
            if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                alert("Microphone access was denied. Please allow microphone access in your browser settings to use this feature.");
            } else {
                alert(`An error occurred during speech recognition: ${event.error}`);
            }
            if (recitationGame_State.isRecording) stopUserRecording_Recitation_Engine();
        };
        recognition.onend = () => {
            recitationGame_State.speechResultReceived = true;
            tryFinalizeAnalysis_Engine();
        };
    }
    async function startUserRecording_Recitation_Engine() {
        recitationGame_State.mediaRecordingStopped = false;
        recitationGame_State.speechResultReceived = false;
        recitationGame_State.analysisTriggeredThisRound = false;
        recitationGame_State.userTranscript = "";
        recitationGame_State.isRecording = true;
        recitationGame_UI.recordButton.textContent = "🛑 Stop Recording";
        recitationGame_UI.recordButton.classList.add('is-recording');
        recitationGame_UI.referencePlayButton.disabled = true;
        recitationGame_UI.analysisFeedbackArea.style.display = 'none';
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            recitationGame_State.userAudioRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
            recitationGame_State.userAudioRecorder.onstop = () => {
                recitationGame_State.mediaRecordingStopped = true;
                stream.getTracks().forEach(track => track.stop());
                tryFinalizeAnalysis_Engine();
            };
            recitationGame_State.userAudioRecorder.start();
            if (recitationGame_State.speechRecognition) {
                recitationGame_State.speechRecognition.start();
            }
        } catch (err) {
            console.error("Error starting native recording:", err);
            alert("Could not start recording. Please grant microphone permission and try again.");
            recitationGame_State.isRecording = false;
            recitationGame_UI.recordButton.textContent = "🎤 Record My Recitation";
            recitationGame_UI.recordButton.classList.remove('is-recording');
            recitationGame_UI.referencePlayButton.disabled = false;
        }
    }
    function stopUserRecording_Recitation_Engine() {
        if (!recitationGame_State.isRecording) return;
        recitationGame_State.isRecording = false;
        recitationGame_UI.recordButton.textContent = "⏳ Processing...";
        recitationGame_UI.recordButton.disabled = true;
        if (recitationGame_State.userAudioRecorder && recitationGame_State.userAudioRecorder.state === "recording") {
            recitationGame_State.userAudioRecorder.stop();
        }
        if (recitationGame_State.speechRecognition) {
            setTimeout(() => {
                recitationGame_State.speechRecognition.stop();
            }, 300);
        }
    }
    function tryFinalizeAnalysis_Engine() {
        if (recitationGame_State.analysisTriggeredThisRound) return;
        if (recitationGame_State.mediaRecordingStopped && recitationGame_State.speechResultReceived) {
            recitationGame_State.analysisTriggeredThisRound = true;
            const audioBlob = new Blob(recitationGame_State.userAudioChunks, { type: 'audio/webm' });
            analyzeUserRecitation_Engine(audioBlob);
            recitationGame_UI.recordButton.disabled = false;
            recitationGame_UI.recordButton.textContent = "🎤 Record My Recitation";
            recitationGame_UI.recordButton.classList.remove('is-recording');
            recitationGame_UI.referencePlayButton.disabled = false;
        }
    }
    async function analyzeUserRecitation_Engine(audioBlob) {
        if (!recitationGame_State.gameActive) {
            return;
        }
        if (recitationGame_UI.recordingStatusText) {
            recitationGame_UI.recordingStatusText.textContent = "Analyzing...";
        }
        const feedbackArea = recitationGame_UI.analysisFeedbackArea;
        if (feedbackArea) {
            feedbackArea.style.display = 'block';
            feedbackArea.innerHTML = `
            <h4>Analysis Feedback</h4>
            <p id="feedbackTextAccuracy_Engine">Accuracy: Calculating...</p>
            <div style="text-align:right; direction:rtl; margin-top:10px; padding-top:10px; border-top: 1px dotted var(--color-border);">
                <strong>الآية المستهدفة (Target):</strong>
                <p style="font-family: var(--font-arabic); font-size: 1.2em;">${recitationGame_State.targetAyahText}</p>
            </div>
            <div style="text-align:right; direction:rtl; margin-top:10px; padding-top:10px; border-top: 1px dotted var(--color-border);">
                <strong>ما تم التعرف عليه (Recognized):</strong>
                <p id="feedbackRecognizedText_Engine" style="font-family: var(--font-arabic); font-size: 1.2em; color: var(--color-accent-dark);">(...)</p>
            </div>
             <div style="text-align:right; direction:rtl; margin-top:10px; padding-top:10px; border-top: 1px dotted var(--color-border);">
                <strong>المقارنة البصرية (Visual Diff):</strong>
                <p id="feedbackDiff_Engine" style="font-family: var(--font-arabic); font-size: 1.2em;"></p>
            </div>
        `;
        }
        const recognizedText = recitationGame_State.userTranscript || "";
        const targetTextNorm = normalizeArabicForComparison_Engine(recitationGame_State.targetAyahText);
        const recognizedTextNorm = normalizeArabicForComparison_Engine(recognizedText);
        const { accuracy, diffHTML } = calculateTextAccuracyAndDiff_Engine(targetTextNorm, recognizedTextNorm);
        console.log(`[RecitationGame] Calculated Accuracy: ${accuracy}%, Diff HTML generated.`);
        const feedbackAccuracyEl = document.getElementById('feedbackTextAccuracy_Engine');
        const feedbackRecognizedEl = document.getElementById('feedbackRecognizedText_Engine');
        const feedbackDiffEl = document.getElementById('feedbackDiff_Engine');
        if (feedbackAccuracyEl) feedbackAccuracyEl.textContent = `Text Accuracy: ${accuracy.toFixed(1)}%`;
        if (feedbackRecognizedEl) feedbackRecognizedEl.textContent = recognizedText || "(No speech recognized)";
        if (feedbackDiffEl) feedbackDiffEl.innerHTML = diffHTML;
        if (recitationGame_UI.currentScoreDisplay) {
            recitationGame_UI.currentScoreDisplay.textContent = `${accuracy.toFixed(0)}`;
        }
        if (recitationGame_UI.recordingStatusText) {
            recitationGame_UI.recordingStatusText.textContent = "Analysis complete.";
        }
        saveScore_Recitation_Engine(accuracy);
    }
    function normalizeArabicForComparison_Engine(text) {
        if (!text) return "";
        let str = text;
        str = str.normalize('NFD').replace(/[\u064B-\u065F\u0670\u08D4-\u08E1\u08E3-\u08FF]/g, ''); // More comprehensive diacritic removal
        str = str.replace(/\u0640/g, '');
        str = str.replace(/[إأآٱ]/g, 'ا'); // All Alifs to plain Alif
        str = str.replace(/[ؤ]/g, 'و');   // Waw with Hamza above to plain Waw
        str = str.replace(/[ئ]/g, 'ي');   // Ya with Hamza above to plain Ya (often contextually a Yaa sound)
        str = str.replace(/[ى]/g, 'ي');   // Alif Maqsurah to Yaa
        str = str.replace(/[ة]/g, 'ه');   // Teh Marbuta to Heh (common in spoken informal or for comparison)
        str = str.replace(/[كک]/g, 'ك');  // Persian Kaf to Arabic Kaf
        str = str.replace(/[.,!?:;"'()\[\]{}0-9٠-٩]/g, '');
        text = text.trim().replace(/\s+/g, ' ');
        return str;
    }
    function levenshteinDistance_Engine(s1, s2) {
        s1 = s1.toLowerCase(); s2 = s2.toLowerCase();
        const costs = [];
        for (let i = 0; i <= s1.length; i++) {
            let lastValue = i;
            for (let j = 0; j <= s2.length; j++) {
                if (i === 0) costs[j] = j;
                else if (j > 0) {
                    let newValue = costs[j - 1];
                    if (s1[i - 1] !== s2[j - 1]) newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                    costs[j - 1] = lastValue;
                    lastValue = newValue;
                }
            }
            if (i > 0) costs[s2.length] = lastValue;
        }
        return costs[s2.length];
    }
    function normalizeArabicForComparison_Engine(text) {
        if (!text) return "";
        let str = text;
        str = str.normalize('NFD').replace(/[\u064B-\u065F\u0670\u0610-\u061A\u06D6-\u06DC\u06DF-\u06E8\u06EA-\u06ED\u08E4-\u08FF]/g, '');
        str = str.replace(/[أإآٱ]/g, 'ا');
        str = str.replace(/[ى]/g, 'ي'); // Alif Maqsura to Yaa
        str = str.replace(/[ؤ]/g, 'و');
        str = str.replace(/[ة]/g, 'ه');
        str = str.replace(/[ک]/g, 'ك');
        str = str.replace(/\u0640/g, '');
        str = str.replace(/\s+/g, ' ').trim();
        return str;
    }
    function calculateTextAccuracyAndDiff_Engine(targetNormalized, recognizedNormalized) {
        if (!targetNormalized) return { accuracy: 0, diffHTML: "<p>(Target text was empty)</p>" };
        const targetWords = targetNormalized.split(' ').filter(w => w);
        const recognizedWords = recognizedNormalized ? recognizedNormalized.split(' ').filter(w => w) : [];
        const dmp = new diff_match_patch();
        const diff = dmp.diff_main(recognizedNormalized, targetNormalized);
        dmp.diff_cleanupSemantic(diff);
        let diffHTML = "";
        let correctChars = 0;
        diff.forEach(part => {
            const operation = part[0]; // 0 for equal, -1 for delete (in recognized), 1 for insert (in target)
            const text = part[1];
            switch (operation) {
                case 0: // DIFF_EQUAL
                    diffHTML += `<span class="diff-correct">${text}</span>`;
                    correctChars += text.length;
                    break;
                case 1: // DIFF_INSERT (Word is in target, but not in recognized -> Missing)
                    diffHTML += `<span class="diff-missing" title="Missing: ${text}">${text}</span>`;
                    break;
                case -1: // DIFF_DELETE (Word is in recognized, but not in target -> Extra/Incorrect)
                    diffHTML += `<span class="diff-incorrect" title="Incorrect/Extra: ${text}">${text}</span>`;
                    break;
            }
        });
        const targetLength = targetNormalized.length;
        const accuracy = targetLength > 0 ? (correctChars / targetLength) * 100 : 0;
        return {
            accuracy: Math.max(0, Math.min(100, accuracy)),
            diffHTML: diffHTML || "(No recognized text to compare)"
        };
    }
    async function saveScore_Recitation_Engine(accuracy) {
        if (!recitationGame_State.ayahKey) {
            console.warn("saveScore_Recitation_Engine: Ayah key is not set. Cannot save score.");
            return;
        }
        try {
            const key = `recitationPractice_${recitationGame_State.ayahKey}_bestAccuracy`;
            const existingBestAccuracyText = localStorage.getItem(key);
            const existingBestAccuracy = existingBestAccuracyText ? parseFloat(existingBestAccuracyText) : 0;
            const newBestAccuracy = Math.max(existingBestAccuracy, accuracy);
            localStorage.setItem(key, newBestAccuracy.toString());
            localStorage.setItem(`recitationPractice_${recitationGame_State.ayahKey}_lastAttemptDate`, new Date().toISOString());
            localStorage.setItem(`recitationPractice_${recitationGame_State.ayahKey}_lastScore`, accuracy.toString());
            if (recitationGame_UI.bestScoreDisplay) {
                recitationGame_UI.bestScoreDisplay.textContent = `${newBestAccuracy.toFixed(0)}`;
            } else {
                console.warn("saveScore_Recitation_Engine: bestScoreDisplay UI element not found.");
            }
        } catch (error) {
            console.error("Error saving recitation game score to localStorage:", error);
        }
    }
    async function loadBestScore_Recitation_Engine() {
        if (recitationGame_UI.bestScoreDisplay) {
            recitationGame_UI.bestScoreDisplay.textContent = '-'; // Default
        } else {
            console.warn("loadBestScore_Recitation_Engine: bestScoreDisplay UI element not found, cannot set default.");
        }
        if (!recitationGame_State.ayahKey) {
            console.warn("loadBestScore_Recitation_Engine: Ayah key is not set. Cannot load score.");
            return;
        }
        try {
            const key = `recitationPractice_${recitationGame_State.ayahKey}_bestAccuracy`;
            const bestAccuracyText = localStorage.getItem(key);
            const bestAccuracy = bestAccuracyText ? parseFloat(bestAccuracyText) : 0;
            if (recitationGame_UI.bestScoreDisplay) {
                recitationGame_UI.bestScoreDisplay.textContent = `${bestAccuracy.toFixed(0)}`;
            }
        } catch (error) {
            console.error("Error loading best recitation game score from localStorage:", error);
        }
    }
    function addRecitationPracticeGameButtonToModal() {
        const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
        const buttonId = 'startRecitationPracticeGameBtn';
        if (gameSelectionArea && !document.getElementById(buttonId)) {
            const recitationGameButton = document.createElement('button');
            recitationGameButton.id = buttonId;
            recitationGameButton.className = 'game-select-btn';
            recitationGameButton.textContent = 'Recitation Practice';
            recitationGameButton.addEventListener('click', startRecitationPracticeGame_Engine);
            const existingButtons = gameSelectionArea.querySelectorAll('.game-select-btn');
            if (existingButtons.length > 0) {
                existingButtons[existingButtons.length - 1].insertAdjacentElement('afterend', recitationGameButton);
            } else {
                const pElement = gameSelectionArea.querySelector('p');
                if (pElement) pElement.insertAdjacentElement('afterend', recitationGameButton);
                else gameSelectionArea.appendChild(recitationGameButton);
            }
        }
    }
    if (document.getElementById('quranGameModal')) {
        addRecitationPracticeGameButtonToModal();
    } else {
        const observer = new MutationObserver((mutationsList, obs) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'childList') {
                    const modal = document.getElementById('quranGameModal');
                    if (modal) {
                        addRecitationPracticeGameButtonToModal();
                        obs.disconnect(); // Stop observing once added
                        return;
                    }
                }
            }
        });
        observer.observe(document.body, { childList: true, subtree: true });
    }
    const mainGameModalForRecitationCleanup = document.getElementById('quranGameModal');
    if (mainGameModalForRecitationCleanup) {
        const originalCloseHandler = () => { // Assuming you have similar logic in your main game modal
            if (recitationGame_State.gameActive) {
                stopReferenceAudio_Engine();
                if (recitationGame_State.isRecording) stopUserRecording_Recitation_Engine();
                if (recitationGame_State.speechRecognition) recitationGame_State.speechRecognition.abort();
                recitationGame_State.gameActive = false;
                console.log("Recitation practice game state reset due to modal close.");
            }
        };
        const gameModalCloseBtn = mainGameModalForRecitationCleanup.querySelector('.game-close-button');
        if (gameModalCloseBtn) {
            gameModalCloseBtn.addEventListener('click', () => {
                if (recitationGame_State.gameActive) {
                    stopReferenceAudio_Engine();
                    if (recitationGame_State.isRecording && recitationGame_State.userAudioRecorder) {
                        recitationGame_State.userAudioRecorder.stop(); // Will try to process
                    }
                    if (recitationGame_State.speechRecognition) recitationGame_State.speechRecognition.abort();
                    recitationGame_State.gameActive = false;
                    recitationGame_State.isRecording = false;
                }
            });
        }
    }
    (function () {
        const GAME_MODAL_LAUNCH_BUTTON_ID = 'openGamesModalBtn';
        const TARGET_ELEMENT_FOR_FULLSCREEN_ID = 'quranGameModal'; // The modal itself
        const INITIALIZATION_DELAY_MS = 600; // Delay after window load to find the button
        function requestFullscreenForElement(elementId) {
            const targetElement = document.getElementById(elementId);
            if (!targetElement) {
                console.error(`Fullscreen Targeter: Element with ID "${elementId}" not found. Cannot go fullscreen.`);
                return;
            }
            if (targetElement.style.display === 'none' || getComputedStyle(targetElement).display === 'none') {
            }
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                return;
            }
            if (targetElement.requestFullscreen) {
                targetElement.requestFullscreen().catch(err => console.warn("Fullscreen Targeter: Fullscreen request failed:", err.message, err.name));
            } else if (targetElement.webkitRequestFullscreen) { // Safari
                targetElement.webkitRequestFullscreen().catch(err => console.warn("Fullscreen Targeter: Fullscreen request failed (webkit):", err.message, err.name));
            } else if (targetElement.mozRequestFullScreen) { // Older Firefox
                targetElement.mozRequestFullScreen(); // Note: Older Firefox API might not return a Promise
            } else if (targetElement.msRequestFullscreen) { // IE11
                targetElement.msRequestFullscreen();
            } else {
            }
        }
        function setupLaunchButtonListenerForFullscreen() {
            const launchButton = document.getElementById(GAME_MODAL_LAUNCH_BUTTON_ID);
            if (launchButton) {
                launchButton.addEventListener('click', (event) => {
                    setTimeout(() => {
                        requestFullscreenForElement(TARGET_ELEMENT_FOR_FULLSCREEN_ID);
                    }, 200); // 50ms delay, adjust if needed for your modal's display logic
                });
            } else {
            }
        }
        window.addEventListener('load', () => {
            setTimeout(() => {
                setupLaunchButtonListenerForFullscreen();
            }, INITIALIZATION_DELAY_MS);
        });
        function logFullscreenExit(event) {
            if (!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
            }
        }
        document.addEventListener('fullscreenchange', logFullscreenExit);
        document.addEventListener('webkitfullscreenchange', logFullscreenExit);
        document.addEventListener('mozfullscreenchange', logFullscreenExit);
        document.addEventListener('MSFullscreenChange', logFullscreenExit);
    })();
    (function () { // IIFE to keep it self-contained
        const READER_LAUNCH_BUTTON_ID = 'launchFullScreenReaderBtnEnhanced';
        const READER_OVERLAY_ID = 'fullScreenReaderOverlay';
        const INITIALIZATION_DELAY_MS = 500; // Increased slightly for safety
        const FULLSCREEN_REQUEST_DELAY_MS = 200; // Delay to wait for overlay creation
        function requestFullscreenForReaderOverlay(elementId) {
            const targetElement = document.getElementById(elementId);
            if (!targetElement) {
                console.error(`Reader FS Overlay: Element with ID "${elementId}" not found. Cannot go fullscreen.`);
                return;
            }
            if (targetElement.style.display === 'none' || getComputedStyle(targetElement).display === 'none') {
                console.warn(`Reader FS Overlay: Target overlay "${elementId}" is not visible. Fullscreen might not work as expected. Ensure launchFullScreenQuranReaderEnhanced() makes it visible.`);
            }
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                console.log("Reader FS Overlay: Already in browser fullscreen mode with some element. Will not re-request for overlay.");
                return;
            }
            if (targetElement.requestFullscreen) {
                targetElement.requestFullscreen().catch(err => console.warn("Reader FS Overlay: Fullscreen request failed:", err.message, err.name));
            } else if (targetElement.webkitRequestFullscreen) { // Safari
                targetElement.webkitRequestFullscreen().catch(err => console.warn("Reader FS Overlay: Fullscreen request failed (webkit):", err.message, err.name));
            } else if (targetElement.mozRequestFullScreen) { // Older Firefox
                targetElement.mozRequestFullScreen();
            } else if (targetElement.msRequestFullscreen) { // IE11
                targetElement.msRequestFullscreen();
            } else {
                console.warn(`Reader FS Overlay: Browser Fullscreen API not supported for the element "${elementId}".`);
            }
        }
        function setupReaderFullscreenLaunchListener() {
            const launchButton = document.getElementById(READER_LAUNCH_BUTTON_ID);
            if (launchButton) {
                launchButton.addEventListener('click', () => {
                    setTimeout(() => {
                        requestFullscreenForReaderOverlay(READER_OVERLAY_ID);
                    }, FULLSCREEN_REQUEST_DELAY_MS);
                });
            } else {
            }
        }
        window.addEventListener('load', () => {
            setTimeout(() => {
                setupReaderFullscreenLaunchListener();
            }, INITIALIZATION_DELAY_MS);
        });
        function logReaderFullscreenExit(event) {
            const readerOverlayElement = document.getElementById(READER_OVERLAY_ID);
            if (!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
            }
        }
        document.addEventListener('fullscreenchange', logReaderFullscreenExit);
        document.addEventListener('webkitfullscreenchange', logReaderFullscreenExit);
        document.addEventListener('mozfullscreenchange', logReaderFullscreenExit);
        document.addEventListener('MSFullscreenChange', logReaderFullscreenExit);
    })();
    let currentReportingUserData = null; // DECLARED GLOBALLY (or top of this script block) and INITIALIZED
    function injectReportingModuleStyles_Enhanced() {
        const cssId = "reportingModuleStylesEnhanced";
        if (document.getElementById(cssId)) return;
        const styles = `
        /* Existing Reporting Styles (assumed from previous response, slightly condensed) */
        .reporting-dashboard { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 25px; padding: 15px; background-color: var(--color-bg-secondary); border-radius: var(--border-radius); }
        .dashboard-card { background-color: var(--color-bg-primary); padding: 15px; border-radius: var(--border-radius); box-shadow: 0 1px 3px var(--color-shadow); text-align: center; }
        .dashboard-card h4 { margin-top: 0; margin-bottom: 8px; color: var(--color-text-secondary); font-size: 1.1em; }
        .dashboard-card .stat-value { font-size: 1.8em; font-weight: bold; color: var(--color-accent-dark); display: block; }
        .reporting-filters-container { margin-bottom: 20px; padding: 15px; background-color: var(--color-bg-secondary); border-radius: var(--border-radius); }
        .reporting-filters-container h3 { margin-top:0; margin-bottom: 10px; }
        .reporting-filters-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px; align-items: end; }
        .reporting-filters-grid label { font-size: 0.9em; margin-bottom: 3px; }
        .reporting-filters-grid select, .reporting-filters-grid input[type="date"], .reporting-filters-grid input[type="text"] { width: 100%; max-width: none; }
        .reporting-quick-date-filters { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; margin-bottom: 10px; }
        .reporting-quick-date-filters button { padding: 6px 10px; font-size: 0.85em; background-color: var(--color-accent-dark); flex-grow:1; min-width: 80px;}
        .reporting-quick-date-filters button:hover { background-color: var(--color-accent); }
        .reporting-content-area { margin-top: 20px; }
        .report-section { margin-bottom: 25px; padding: 15px; background-color: var(--color-bg-primary); border: 1px solid var(--color-border); border-radius: var(--border-radius); }
        .report-section h4 { margin-top: 0; margin-bottom: 10px; color: var(--color-text-secondary); border-bottom: 1px solid var(--color-border); padding-bottom: 5px; }
        .report-list { list-style: none; padding: 0; }
        .report-list li { padding: 8px 0; border-bottom: 1px dotted var(--color-border); font-size: 0.95em; }
        .report-list li:last-child { border-bottom: none; }
        .report-list .item-ref { font-weight: bold; color: var(--color-accent-dark); }
        .report-list .item-date { font-size: 0.9em; color: var(--color-text-secondary); }
        .report-list .item-notes { display: block; font-style: italic; color: var(--color-text-secondary); margin-top: 3px; padding-left: 10px; font-size: 0.9em; }
        .report-list .item-surah-ayah { cursor: pointer; text-decoration: underline; }
        .report-list .item-surah-ayah:hover { color: var(--color-accent); }
        .simple-bar-chart-container { padding:10px; border: 1px solid var(--color-border); border-radius: var(--border-radius); background-color: var(--color-bg-secondary); }
        .bar-chart-title { text-align:center; font-weight:bold; margin-bottom:10px; color:var(--color-text-secondary); }
        .bar-chart { display: flex; align-items: flex-end; height: 200px; border-bottom: 1px solid var(--color-text-secondary); padding-bottom: 5px; gap: 2px; }
        .bar-chart .bar { flex-grow: 1; background-color: var(--color-accent); text-align: center; position: relative; min-width: 20px; border-radius: 3px 3px 0 0; }
        .bar-chart .bar:hover { background-color: var(--color-accent-dark); }
        .bar-chart .bar .bar-label { position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 0.7em; color: var(--color-text-primary); white-space: nowrap; }
        .bar-chart .bar .bar-value { position: absolute; top: -18px; left: 50%; transform: translateX(-50%); font-size: 0.75em; font-weight: bold; color: var(--color-text-primary); }
        #noReportDataMessage { text-align: center; padding: 20px; font-style: italic; }
        /* Fullscreen Reporting Styles */
        body.body-reporting-fullscreen { overflow: hidden !important; } /* Prevent body scroll */
        body.body-reporting-fullscreen > header,
        body.body-reporting-fullscreen > .container > .sidebar,
        body.body-reporting-fullscreen > .container > .main-content > .section:not(#reporting) {
            display: none !important;
        }
        body.body-reporting-fullscreen > .container {
            padding: 0 !important;
            margin: 0 !important;
            max-width: 100% !important;
            height: 100vh;
            display: flex; /* Ensure container takes full height */
            flex-direction: column;
        }
        body.body-reporting-fullscreen > .container > .main-content {
             padding: 0 !important; margin: 0 !important; height: 100%;
             flex-grow: 1; /* Ensure main-content fills container */
             display: flex; /* Allow reporting section to fill it */
             flex-direction: column;
        }
        #reporting.reporting-fullscreen-active {
            /* Ensure it behaves like a top-level page */
            width: 100%;
            height: 100%;
            overflow-y: auto;
            background-color: var(--color-bg-primary);
            padding: var(--padding-main); 
            box-sizing: border-box;
            display: flex; /* Use flex for internal layout if needed */
            flex-direction: column;
            flex-grow: 1;
        }
        #exitReportFullscreenBtn {
            position: absolute; /* Changed from fixed to be relative to #reporting or its container if #reporting isn't fixed */
            top: 10px; /* Adjusted for padding of #reporting */
            right: 10px; /* Adjusted for padding of #reporting */
            z-index: 1001; 
            padding: 8px 12px;
            background-color: var(--color-error);
            color: white;
            border-radius: var(--border-radius);
            border:none;
            cursor:pointer;
        }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
    }
    function createReportingSectionStructure_Enhanced() {
        const mainContent = document.querySelector('.main-content');
        if (!mainContent || document.getElementById('reporting')) return;
        const reportingSection = document.createElement('section');
        reportingSection.id = 'reporting';
        reportingSection.className = 'section';
        reportingSection.setAttribute('role', 'region');
        reportingSection.setAttribute('aria-labelledby', 'reporting-heading');
        reportingSection.innerHTML = `
        <h2 id="reporting-heading">My Contributions & Progress</h2>
        <!-- Exit button will be prepended by addExitReportFullscreenButton_Enhanced -->
        <div id="reportingDashboard" class="reporting-dashboard">
            <p>Loading dashboard...</p>
        </div>
        <div class="reporting-filters-container">
            <h3>Filter Reports</h3>
            <div class="reporting-quick-date-filters">
                <button data-period="today">Today</button>
                <button data-period="this_week">This Week</button>
                <button data-period="this_month">This Month</button>
                <button data-period="this_year">This Year</button>
                <button data-period="all_time">All Time</button>
            </div>
            <div class="reporting-filters-grid">
                <div>
                    <label for="reportTypeFilter">Report Type:</label>
                    <select id="reportTypeFilter">
                        <option value="all">All My Contributions</option>
                        <option value="tafsir">Personal Tafsir</option>
                        <option value="hifz">Memorization (Hifz)</option>
                        <option value="themes">Thematic Links</option>
                        <option value="roots">Root Word Notes</option>
                        <option value="recitations">Recitation Logs</option>
                    </select>
                </div>
                <div>
                    <label for="reportSurahFilter">Surah:</label>
                    <select id="reportSurahFilter">
                        <option value="">All Surahs</option>
                    </select>
                </div>
                <div>
                    <label for="reportDateFromFilter">Date From:</label>
                    <input type="date" id="reportDateFromFilter">
                </div>
                <div>
                    <label for="reportDateToFilter">Date To:</label>
                    <input type="date" id="reportDateToFilter">
                </div>
                <div>
                    <label for="reportKeywordSearch">Keyword Search (Notes):</label>
                    <input type="text" id="reportKeywordSearch" placeholder="Search in notes...">
                </div>
                <div>
                    <button id="applyReportFiltersBtn" style="width:100%;">Apply Filters</button>
                </div>
            </div>
        </div>
        <div id="reportingContent" class="reporting-content-area">
            <p>Select filters and apply to view reports.</p>
        </div>
    `;
        mainContent.appendChild(reportingSection);
        const surahFilterSelect = document.getElementById('reportSurahFilter');
        if (surahFilterSelect && typeof surahNames !== 'undefined' && surahNames.length > 0) {
            surahNames.forEach((name, index) => {
                const option = document.createElement('option');
                option.value = index + 1;
                option.textContent = `${index + 1}. ${name}`;
                surahFilterSelect.appendChild(option);
            });
        }
    }
    function enterReportingFullscreen() {
        document.body.classList.add('body-reporting-fullscreen');
        const reportingSection = document.getElementById('reporting');
        if (reportingSection) {
            reportingSection.classList.add('reporting-fullscreen-active');
            addExitReportFullscreenButton_Enhanced(); // Add button when entering
            reportingSection.scrollTop = 0;
        }
    }
    function exitReportingFullscreen() {
        document.body.classList.remove('body-reporting-fullscreen');
        const reportingSection = document.getElementById('reporting');
        if (reportingSection) {
            reportingSection.classList.remove('reporting-fullscreen-active');
        }
        removeExitReportFullscreenButton_Enhanced(); // Remove button when exiting
    }
    function addExitReportFullscreenButton_Enhanced() {
        removeExitReportFullscreenButton_Enhanced();
        const reportingSection = document.getElementById('reporting');
        if (!reportingSection) return;
        const btn = document.createElement('button');
        btn.id = 'exitReportFullscreenBtn';
        btn.textContent = 'Exit Fullscreen Report';
        btn.onclick = () => {
            exitReportingFullscreen();
            if (typeof window.showSection_Patched === 'function') window.showSection_Patched('quran');
            else if (typeof window.showSection === 'function') window.showSection('quran');
        };
        reportingSection.insertBefore(btn, reportingSection.firstChild); // Prepend to reporting section
    }
    function removeExitReportFullscreenButton_Enhanced() {
        const btn = document.getElementById('exitReportFullscreenBtn');
        if (btn && btn.parentNode) {
            btn.parentNode.removeChild(btn);
        }
    }
    function getISODateString(date) {
        return date.getFullYear() + '-' +
            ('0' + (date.getMonth() + 1)).slice(-2) + '-' +
            ('0' + date.getDate()).slice(-2);
    }
    function getTodayDateRange_Enhanced() {
        const today = new Date();
        return { start: getISODateString(today), end: getISODateString(today) };
    }
    function getThisWeekDateRange_Enhanced() {
        const today = new Date();
        const dayOfWeek = today.getDay(); // Sunday - 0, Monday - 1, ..., Saturday - 6
        const startDate = new Date(today);
        startDate.setDate(today.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1));
        const endDate = new Date(startDate);
        endDate.setDate(startDate.getDate() + 6); // Sunday of the current week
        return { start: getISODateString(startDate), end: getISODateString(endDate) };
    }
    function getThisMonthDateRange_Enhanced() {
        const today = new Date();
        const y = today.getFullYear();
        const m = today.getMonth();
        const startDate = new Date(y, m, 1);
        const endDate = new Date(y, m + 1, 0);
        return { start: getISODateString(startDate), end: getISODateString(endDate) };
    }
    function getThisYearDateRange_Enhanced() {
        const today = new Date();
        const y = today.getFullYear();
        const startDate = new Date(y, 0, 1);
        const endDate = new Date(y, 11, 31);
        return { start: getISODateString(startDate), end: getISODateString(endDate) };
    }
    function setupReportingFiltersEventListeners_Enhanced(userData) {
        const applyBtn = document.getElementById('applyReportFiltersBtn');
        const dateFromInput = document.getElementById('reportDateFromFilter');
        const dateToInput = document.getElementById('reportDateToFilter');
        if (applyBtn) {
            applyBtn.onclick = () => {
                const filters = {
                    reportType: document.getElementById('reportTypeFilter').value,
                    surah: document.getElementById('reportSurahFilter').value,
                    dateFrom: dateFromInput.value,
                    dateTo: dateToInput.value,
                    keyword: document.getElementById('reportKeywordSearch').value,
                };
                renderReportDetails(userData, filters);
            };
        }
        document.querySelectorAll('.reporting-quick-date-filters button').forEach(button => {
            button.addEventListener('click', () => {
                const period = button.dataset.period;
                let range;
                switch (period) {
                    case 'today': range = getTodayDateRange_Enhanced(); break;
                    case 'this_week': range = getThisWeekDateRange_Enhanced(); break;
                    case 'this_month': range = getThisMonthDateRange_Enhanced(); break;
                    case 'this_year': range = getThisYearDateRange_Enhanced(); break;
                    case 'all_time':
                        dateFromInput.value = '';
                        dateToInput.value = '';
                        if (applyBtn) applyBtn.click();
                        return;
                }
                if (range) {
                    dateFromInput.value = range.start;
                    dateToInput.value = range.end;
                }
                if (applyBtn) applyBtn.click();
            });
        });
    }
    async function loadAllUserDataForReports() {
        if (!db) {
            console.error("DB not available for loading report data.");
            currentReportingUserData = null; // Ensure it's null if DB not ready
            return null;
        }
        try {
            const [
                tafsir, themes, themeAyahs, roots,
                recitations, hifz, quran
            ] = await Promise.all([
                getAllData(STORE_TAFSIR),
                getAllData(STORE_THEMES),
                getAllData(STORE_THEME_AYAHS),
                getAllData(STORE_ROOTS),
                getAllData(STORE_RECITATIONS),
                getAllData(STORE_HIFZ),
                getAllData(STORE_QURAN)
            ]);
            const quranMap = new Map();
            if (quran) {
                quran.forEach(item => quranMap.set(`${item.surah}-${item.ayah}`, item.arabic));
            }
            currentReportingUserData = { tafsir, themes, themeAyahs, roots, recitations, hifz, quranMap };
            return currentReportingUserData;
        } catch (error) {
            console.error("Error fetching all user data for reports:", error);
            currentReportingUserData = null;
            return null;
        }
    }
    function renderReportingDashboard(userData) {
        const dashboardArea = document.getElementById('reportingDashboard');
        if (!dashboardArea || !userData) {
            if (dashboardArea) dashboardArea.innerHTML = "<p>Error loading dashboard data.</p>";
            return;
        }
        const { tafsir, themes, roots, recitations, hifz } = userData;
        const totalTafsir = tafsir ? tafsir.length : 0;
        const totalThemes = themes ? themes.length : 0;
        const totalRootNotes = roots ? roots.filter(r => r.description && r.description.trim() !== '').length : 0;
        const totalRecitations = recitations ? recitations.length : 0;
        const totalHifzAyahs = hifz ? hifz.filter(h => h.status === 'memorized').length : 0;
        const totalHifzInProgress = hifz ? hifz.filter(h => h.status === 'in-progress').length : 0;
        dashboardArea.innerHTML = `
        <div class="dashboard-card"><h4>Personal Tafsir</h4><span class="stat-value">${totalTafsir}</span><span>Ayahs with Notes</span></div>
        <div class="dashboard-card"><h4>Memorized Ayahs</h4><span class="stat-value">${totalHifzAyahs}</span><span>Status: Memorized</span></div>
        <div class="dashboard-card"><h4>Themes Created</h4><span class="stat-value">${totalThemes}</span><span>Custom Themes</span></div>
        <div class="dashboard-card"><h4>Recitation Logs</h4><span class="stat-value">${totalRecitations}</span><span>Listening Sessions</span></div>
        <div class="dashboard-card"><h4>Root Word Notes</h4><span class="stat-value">${totalRootNotes}</span><span>Roots with Descriptions</span></div>
        <div class="dashboard-card"><h4>Hifz In Progress</h4><span class="stat-value">${totalHifzInProgress}</span><span>Ayahs In Progress</span></div>`;
    }
    function renderReportDetails(userData, filters) {
        const contentArea = document.getElementById('reportingContent');
        if (!contentArea || !userData) {
            if (contentArea) contentArea.innerHTML = "<p>Error loading report details.</p>";
            return;
        }
        contentArea.innerHTML = '';
        const reportType = filters.reportType || 'all';
        const filterSurah = filters.surah ? parseInt(filters.surah) : null;
        const dateFrom = filters.dateFrom ? new Date(filters.dateFrom) : null;
        const dateTo = filters.dateTo ? new Date(filters.dateTo) : null;
        if (dateTo) dateTo.setHours(23, 59, 59, 999);
        const keyword = filters.keyword ? filters.keyword.toLowerCase() : null;
        let dataFound = false;
        const createSection = (title, items) => {
            if (items.length === 0) return '';
            dataFound = true;
            let listHTML = '<ul class="report-list">' + items.join('') + '</ul>';
            return `<div class="report-section"><h4>${title}</h4>${listHTML}</div>`;
        };
        const makeAyahClickable = (s, a, txt) => `<span class="item-surah-ayah" data-surah="${s}" data-ayah="${a}" title="Go to S${s}:A${a}">${txt}</span>`;
        if (reportType === 'all' || reportType === 'tafsir') {
            const items = (userData.tafsir || []).filter(t =>
                (!filterSurah || t.surah === filterSurah) &&
                (!keyword || (t.notes && t.notes.toLowerCase().includes(keyword)))
            ).map(t => `<li>${makeAyahClickable(t.surah, t.ayah, `S ${t.surah}:${t.ayah}`)}<span class="item-notes">${(t.notes || '').substring(0, 150)}...</span></li>`);
            contentArea.innerHTML += createSection('Personal Tafsir Notes', items);
        }
        if (reportType === 'all' || reportType === 'hifz') {
            const items = (userData.hifz || []).filter(h =>
                (!filterSurah || h.surah === filterSurah) &&
                (!keyword || (h.notes && h.notes.toLowerCase().includes(keyword)))
            ).map(h => {
                let d = `Status: <span class="hifz-ayah-status status-${h.status}">${h.status.replace('-', ' ')}</span>`;
                if (h.nextReviewDate) d += ` | Next Review: ${h.nextReviewDate}`;
                if (h.notes) d += `<span class="item-notes">${h.notes.substring(0, 100)}...</span>`;
                return `<li>${makeAyahClickable(h.surah, h.ayah, `S ${h.surah}:${h.ayah}`)} - ${d}</li>`;
            });
            contentArea.innerHTML += createSection('Memorization (Hifz) Progress', items);
            if (items.length > 0 && (reportType === 'all' || reportType === 'hifz')) {
                const chartData = Object.entries((userData.hifz || []).filter(h => h.status === 'memorized').reduce((acc, h) => { acc[h.surah] = (acc[h.surah] || 0) + 1; return acc; }, {}))
                    .map(([s, c]) => ({ label: `S${s}`, count: c, fullLabel: `${surahNames[parseInt(s) - 1] || 'S' + s}: ${c} Ayahs` }))
                    .sort((a, b) => parseInt(a.label.substring(1)) - parseInt(b.label.substring(1)));
                if (chartData.length > 0) {
                    const id = 'hifzProgressChart'; contentArea.innerHTML += `<div class="report-section"><h4>Hifz Progress (Memorized)</h4><div id="${id}"></div></div>`;
                    setTimeout(() => createSimpleBarChart(chartData, id, "Ayahs Memorized per Surah", 'count', 'label', 'var(--color-success)'), 0); dataFound = true;
                }
            }
        }
        if (reportType === 'all' || reportType === 'themes') {
            const themeNotes = (userData.themes || []).filter(th => !keyword || (th.name.toLowerCase().includes(keyword) || (th.description && th.description.toLowerCase().includes(keyword))))
                .map(th => `<li>Theme: <span class="item-ref">${th.name}</span><span class="item-notes">${th.description ? th.description.substring(0, 150) + '...' : 'No description.'}</span></li>`);
            contentArea.innerHTML += createSection('Theme Notes & Descriptions', themeNotes);
            const themeLinks = (userData.themeAyahs || []).filter(ta => {
                const theme = userData.themes.find(t => t.id === ta.themeId);
                return (!filterSurah || ta.surah === filterSurah) && (!keyword || (ta.notes && ta.notes.toLowerCase().includes(keyword)) || (theme && theme.name.toLowerCase().includes(keyword)));
            }).map(ta => {
                const theme = userData.themes.find(t => t.id === ta.themeId);
                return `<li>${makeAyahClickable(ta.surah, ta.ayah, `S ${ta.surah}:${ta.ayah}`)} linked to <span class="item-ref">${theme ? theme.name : 'Unknown'}</span>${ta.notes ? `<span class="item-notes">Note: ${ta.notes.substring(0, 100)}...</span>` : ''}</li>`;
            });
            contentArea.innerHTML += createSection('Ayahs Linked to Themes', themeLinks);
        }
        if (reportType === 'all' || reportType === 'roots') {
            const items = (userData.roots || []).filter(r => !keyword || (r.root.toLowerCase().includes(keyword) || (r.description && r.description.toLowerCase().includes(keyword))))
                .map(r => `<li>Root: <span class="item-ref" lang="ar" dir="rtl">${r.root}</span><span class="item-notes">${r.description ? r.description.substring(0, 150) + '...' : 'No notes.'}</span></li>`);
            contentArea.innerHTML += createSection('Root Word Notes', items);
        }
        if (reportType === 'all' || reportType === 'recitations') {
            const filteredRecitationItems = (userData.recitations || [])
                .filter(r => {
                    const recDate = r.date ? new Date(r.date) : null;
                    if (!recDate) return false;
                    if (filterSurah && r.surah !== filterSurah) return false;
                    if (dateFrom && recDate < dateFrom) return false;
                    if (dateTo && recDate > dateTo) return false;
                    if (keyword && ((!r.qari || !r.qari.toLowerCase().includes(keyword)) && (!r.notes || !r.notes.toLowerCase().includes(keyword)))) return false;
                    return true;
                });
            const recitationListItems = filteredRecitationItems
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .map(r => {
                    let ayahCount = 0;
                    if (r.ayahStart && r.ayahEnd) {
                        ayahCount = (r.ayahEnd - r.ayahStart) + 1;
                    } else if (r.ayahStart) { // Single ayah logged
                        ayahCount = 1;
                    } else { // Full Surah assumed if no specific ayahs
                        ayahCount = surahAyahCounts[r.surah] || 0;
                    }
                    const range = r.ayahStart && r.ayahEnd ? `Ayahs ${r.ayahStart}-${r.ayahEnd}` : r.ayahStart ? `Ayah ${r.ayahStart}` : 'Full Surah';
                    return `<li>Surah ${r.surah} (${surahNames[r.surah - 1]}) - ${range} (${ayahCount} Ayah${ayahCount !== 1 ? 's' : ''})
                            <span class="item-date"> - ${r.qari || 'N/A'} on ${r.date || 'N/A'}</span>
                            ${r.notes ? `<span class="item-notes">${r.notes.substring(0, 150)}...</span>` : ''}</li>`;
                });
            contentArea.innerHTML += createSection('Recitation Logs', recitationListItems);
            if (filteredRecitationItems.length > 0) {
                const ayahsRecitedByMonth = {};
                const ayahsRecitedByDay = {};
                filteredRecitationItems.forEach(r => {
                    if (r.date) {
                        let countOfAyahsInLog = 0;
                        if (r.ayahStart && r.ayahEnd) {
                            countOfAyahsInLog = (parseInt(r.ayahEnd) - parseInt(r.ayahStart)) + 1;
                        } else if (r.ayahStart) { // Single ayah logged
                            countOfAyahsInLog = 1;
                        } else { // Full Surah assumed
                            countOfAyahsInLog = surahAyahCounts[r.surah] || 0;
                        }
                        if (countOfAyahsInLog <= 0) return; // Skip if no ayahs calculated
                        const monthYear = new Date(r.date).toLocaleDateString(navigator.language || 'en-US', { year: 'numeric', month: 'short' });
                        ayahsRecitedByMonth[monthYear] = (ayahsRecitedByMonth[monthYear] || 0) + countOfAyahsInLog;
                        const dayKey = getISODateString(new Date(r.date));
                        ayahsRecitedByDay[dayKey] = (ayahsRecitedByDay[dayKey] || 0) + countOfAyahsInLog;
                    }
                });
                const monthlyChartData = Object.entries(ayahsRecitedByMonth)
                    .map(([month, count]) => ({
                        label: month,
                        count: count, // 'count' here means ayahs recited
                        fullLabel: `${month}: ${count} Ayahs Recited`
                    }))
                    .sort((a, b) => new Date(a.label) - new Date(b.label));
                if (monthlyChartData.length > 0) {
                    const monthlyChartContainerId = 'recitationLogsMonthlyChart';
                    let sectionEl = contentArea.querySelector('#recitationLogsMonthlyChartSection');
                    if (!sectionEl) {
                        sectionEl = document.createElement('div');
                        sectionEl.className = 'report-section';
                        sectionEl.id = 'recitationLogsMonthlyChartSection';
                        contentArea.appendChild(sectionEl);
                    }
                    sectionEl.innerHTML = `<h4>Ayahs Recited (Monthly)</h4><div id="${monthlyChartContainerId}"></div>`;
                    setTimeout(() => createSimpleBarChart(monthlyChartData, monthlyChartContainerId, null, 'count', 'label', 'var(--color-accent)'), 0);
                    dataFound = true;
                }
                const dailyChartData = Object.entries(ayahsRecitedByDay)
                    .map(([day, count]) => ({
                        label: new Date(day).toLocaleDateString(navigator.language || 'en-US', { month: 'short', day: 'numeric' }),
                        date: day,
                        count: count, // 'count' here means ayahs recited
                        fullLabel: `${new Date(day).toLocaleDateString(navigator.language || 'en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' })}: ${count} Ayahs Recited`
                    }))
                    .sort((a, b) => new Date(a.date) - new Date(b.date));
                if (dailyChartData.length > 0) {
                    let showDailyChart = true;
                    if (dateFrom && dateTo) {
                        const diffTime = Math.abs(dateTo - dateFrom);
                        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                        if (diffDays > 62) {
                            showDailyChart = false;
                        }
                    } else if (!dateFrom && !dateTo && dailyChartData.length > 62) {
                        showDailyChart = false;
                    }
                    if (showDailyChart) {
                        const dailyChartContainerId = 'recitationLogsDailyChart';
                        let sectionElDaily = contentArea.querySelector('#recitationLogsDailyChartSection');
                        if (!sectionElDaily) {
                            sectionElDaily = document.createElement('div');
                            sectionElDaily.className = 'report-section';
                            sectionElDaily.id = 'recitationLogsDailyChartSection';
                            contentArea.appendChild(sectionElDaily);
                        }
                        sectionElDaily.innerHTML = `<h4>Ayahs Recited (Daily - Filtered Period)</h4><div id="${dailyChartContainerId}"></div>`;
                        setTimeout(() => createSimpleBarChart(dailyChartData, dailyChartContainerId, null, 'count', 'label', 'var(--color-accent-dark)'), 0);
                        dataFound = true;
                    }
                }
            }
        }
        contentArea.querySelectorAll('.item-surah-ayah').forEach(el => el.addEventListener('click', e => {
            const s = parseInt(e.currentTarget.dataset.surah), a = parseInt(e.currentTarget.dataset.ayah);
            if (s && a && typeof loadAyah === 'function' && typeof window.showSection === 'function') { loadAyah(s, a); window.showSection('quran'); }
        }));
        if (!dataFound) contentArea.innerHTML = '<p id="noReportDataMessage">No data matches criteria.</p>';
    }
    function createSimpleBarChart(data, containerId, title, valueKey = 'count', labelKey = 'label', barColor = 'var(--color-accent)') {
        const container = document.getElementById(containerId);
        if (!container) {
            console.error(`Chart container #${containerId} not found.`);
            return;
        }
        container.innerHTML = ''; // Clear previous content like "No data for chart."
        if (!data || data.length === 0) {
            container.innerHTML = "<p>No data to display in chart.</p>";
            return;
        }
        if (title) {
            const titleEl = document.createElement('div');
            titleEl.className = 'bar-chart-title';
            titleEl.textContent = title;
            container.appendChild(titleEl);
        }
        const chartEl = document.createElement('div');
        chartEl.className = 'bar-chart';
        if (data.length > 15) { // Example threshold
            chartEl.style.overflowX = 'auto';
            chartEl.style.minWidth = `${data.length * 30}px`; // Estimate width
        }
        const maxValue = Math.max(...data.map(item => item[valueKey]), 0);
        if (maxValue === 0 && data.every(item => item[valueKey] === 0)) { // Check if all values are strictly zero
            container.innerHTML += "<p>All values are zero for this period.</p>";
            return;
        }
        data.forEach(item => {
            const barWrapper = document.createElement('div');
            barWrapper.className = 'bar';
            const numericValue = Number(item[valueKey]) || 0;
            const percentageHeight = maxValue > 0 ? (numericValue / maxValue) * 100 : 0;
            barWrapper.style.height = `${Math.max(percentageHeight, 5)}%`; // Min height 5% for visibility
            barWrapper.style.backgroundColor = barColor;
            barWrapper.title = item.fullLabel || `${item[labelKey]}: ${numericValue}`;
            const valueSpan = document.createElement('span');
            valueSpan.className = 'bar-value';
            valueSpan.textContent = numericValue; // Display the numeric value
            barWrapper.appendChild(valueSpan);
            const labelSpan = document.createElement('span');
            labelSpan.className = 'bar-label';
            labelSpan.textContent = item[labelKey];
            barWrapper.appendChild(labelSpan);
            chartEl.appendChild(barWrapper);
        });
        container.appendChild(chartEl);
    }
    let reportingModuleInitialized = false;
    function initializeReportingModule_Enhanced() {
        if (reportingModuleInitialized) return;
        createReportingSectionStructure_Enhanced();
        injectReportingModuleStyles_Enhanced();
        const sidebarNav = document.querySelector('.sidebar nav ul');
        const existingReportLink = document.querySelector('a[data-section="reporting"]');
        if (sidebarNav && !existingReportLink) {
            const reportLi = document.createElement('li');
            const reportLink = document.createElement('a');
            reportLink.href = "#reporting";
            reportLink.className = "nav-link";
            reportLink.dataset.section = "reporting";
            reportLink.textContent = "Reporting";
            reportLi.appendChild(reportLink);
            const dataManagementLink = sidebarNav.querySelector('a[data-section="data"]');
            if (dataManagementLink && dataManagementLink.parentElement) {
                sidebarNav.insertBefore(reportLi, dataManagementLink.parentElement);
            } else {
                sidebarNav.appendChild(reportLi);
            }
            reportLink.addEventListener('click', (event) => {
                event.preventDefault();
                if (typeof window.showSection === 'function') {
                    window.showSection('reporting');
                } else {
                    console.error("Global window.showSection function not found for reporting link.");
                }
            });
        }
        reportingModuleInitialized = true;
    }
    async function loadAndDisplayReportData_Enhanced() {
        const reportingContent = document.getElementById('reportingContent');
        const dashboardArea = document.getElementById('reportingDashboard');
        if (dashboardArea) dashboardArea.innerHTML = '<p>Loading dashboard...</p>';
        if (reportingContent) reportingContent.innerHTML = '<p>Loading report data...</p>';
        try {
            await loadAllUserDataForReports();
            if (!currentReportingUserData) {
                if (dashboardArea) dashboardArea.innerHTML = "<p>Failed to load data for dashboard.</p>";
                if (reportingContent) reportingContent.innerHTML = "<p>Failed to load report data. Check console for errors.</p>";
                return;
            }
            renderReportingDashboard(currentReportingUserData);
            renderReportDetails(currentReportingUserData, { reportType: 'all' });
            setupReportingFiltersEventListeners_Enhanced(currentReportingUserData);
        } catch (error) {
            console.error("Error loading/displaying report data:", error);
            if (dashboardArea) dashboardArea.innerHTML = "<p style='color:red;'>Error loading dashboard. See console.</p>";
            if (reportingContent) reportingContent.innerHTML = "<p style='color:red;'>Error loading reports. See console.</p>";
        }
    }
    if (!window.originalAppDOMContentLoaded && typeof window.originalDOMContentLoadedHandler === 'function') {
        window.originalAppDOMContentLoaded = window.originalDOMContentLoadedHandler;
    } else if (!window.originalAppDOMContentLoaded) {
    }
    (function () { // IIFE to manage scope and ensure patching happens correctly
        let originalDOMContentLoadedHandler = null;
        let originalShowSectionHandler = null;
        if (typeof window.originalDOMContentLoadedHandler === 'function') { // From previous attempts
            originalDOMContentLoadedHandler = window.originalDOMContentLoadedHandler;
        }
        if (typeof window.showSection === 'function') {
            originalShowSectionHandler = window.showSection;
        }
        const patchedDOMLoadHandler = async () => {
            if (typeof originalDOMContentLoadedHandler === 'function' && originalDOMContentLoadedHandler !== patchedDOMLoadHandler) {
                await originalDOMContentLoadedHandler();
            } else {
                if (typeof openDB === 'function') await openDB(); else console.error("openDB not found");
                if (typeof loadThemePreference === 'function') await loadThemePreference();
                if (typeof setupEventListeners === 'function') setupEventListeners(); else console.error("setupEventListeners not found");
                if (typeof loadQuranData === 'function') await loadQuranData();
                if (typeof displayThemesList === 'function') displayThemesList();
                if (typeof setupTafsirDocxButton === 'function') setupTafsirDocxButton();
                if (typeof document !== 'undefined' && !window.rootNodePopupEl) window.rootNodePopupEl = document.getElementById('root-node-popup');
            }
            initializeReportingModule_Enhanced(); // Initialize our reporting module AFTER original/basic setup
        };
        if (typeof window.originalDOMContentLoadedHandler === 'function') {
            document.removeEventListener('DOMContentLoaded', window.originalDOMContentLoadedHandler);
        }
        window.originalDOMContentLoadedHandler = patchedDOMLoadHandler; // Store our patched one globally
        document.addEventListener('DOMContentLoaded', window.originalDOMContentLoadedHandler);
        const patchedShowSection = function (sectionId) {
            if (typeof originalShowSectionHandler === 'function' && originalShowSectionHandler !== patchedShowSection) {
                originalShowSectionHandler(sectionId); // Call original display logic
            } else {
                if (typeof document !== 'undefined') {
                    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                    const activeS = document.getElementById(sectionId);
                    if (activeS) activeS.classList.add('active');
                    document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                    const activeL = document.querySelector(`.nav-link[data-section="${sectionId}"]`);
                    if (activeL) activeL.classList.add('active');
                }
            }
            const activeSectionElement = typeof document !== 'undefined' ? document.getElementById(sectionId) : null;
            if (sectionId === 'reporting') {
                if (activeSectionElement && activeSectionElement.classList.contains('active')) {
                    enterReportingFullscreen();
                    if (!currentReportingUserData) {
                        loadAndDisplayReportData_Enhanced();
                    } else {
                        renderReportingDashboard(currentReportingUserData); // Re-render dashboard
                        renderReportDetails(currentReportingUserData, { reportType: 'all' }); // Re-render details with default filter
                        setupReportingFiltersEventListeners_Enhanced(currentReportingUserData);
                    }
                }
            } else {
                if (typeof document !== 'undefined' && document.body.classList.contains('body-reporting-fullscreen')) {
                    exitReportingFullscreen();
                }
            }
            if (typeof document !== 'undefined') { // Ensure document is available
                if (sectionId === 'themes' && typeof populateThemeSelects === 'function' && typeof displayLinkedAyahsForCurrentTheme === 'function') {
                    populateThemeSelects(); displayLinkedAyahsForCurrentTheme();
                } else if (sectionId === 'recitation' && typeof loadRecitationLogs === 'function') {
                    loadRecitationLogs();
                } else if (sectionId === 'hifz' && typeof loadHifzForSurah === 'function') {
                    const hifzSurahSelect = document.getElementById('hifz-surah-select');
                    if (hifzSurahSelect && hifzSurahSelect.value) loadHifzForSurah(parseInt(hifzSurahSelect.value, 10));
                } else if (sectionId === 'roots' && typeof window.rootNetwork !== 'undefined' && window.rootNetwork && typeof window.rootNetwork.fit === 'function') {
                    setTimeout(() => window.rootNetwork.fit(), 100);
                }
            }
        };
        window.showSection = patchedShowSection; // This is now the global showSection
    })();
    function detectDirection(text) {
        const rtlPattern = /[\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/;
        return rtlPattern.test(text) ? 'rtl' : 'ltr';
    }
    const textarea = document.getElementById('tafsir-notes');
    ['input', 'change', 'keyup', 'paste'].forEach(eventType => {
        textarea.addEventListener(eventType, () => {
            const dir = detectDirection(textarea.value);
            textarea.setAttribute('dir', dir);
        });
    });
    const originalDescriptor = Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, 'value');
    Object.defineProperty(textarea, 'value', {
        get() {
            return originalDescriptor.get.call(this);
        },
        set(val) {
            originalDescriptor.set.call(this, val);
            const dir = detectDirection(val);
            textarea.setAttribute('dir', dir);
        }
    });
    const initialDir = detectDirection(textarea.value);
    textarea.setAttribute('dir', initialDir);
    let jigsawState = {
        difficulty: 'easy', // 'easy', 'medium', 'hard'
        piecesCorrect: 0,
        totalPieces: 0,
        currentAyahRef: '',
        draggedPiece: null,
    };
    function injectVerseJigsawCSS_Engine() {
        const cssId = "verseJigsawGameStylesEngine";
        if (document.getElementById(cssId)) return;
        const styles = `
        .jigsaw-game-wrapper { display: flex; flex-direction: column; align-items: center; width: 100%; height: 100%; padding: 5px; box-sizing: border-box; }
        .jigsaw-controls { display: flex; justify-content: center; align-items: center; gap: 15px; margin-bottom: 10px; width: 100%; flex-wrap: wrap; }
        .jigsaw-controls label { font-size: 0.9em; }
        .jigsaw-main-area { display: flex; flex-direction: column; align-items: center; gap: 15px; width: 100%; }
        #jigsawBoard_Engine {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 10px;
            width: 95%;
            min-height: 100px;
            border: 2px solid var(--color-accent-dark);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            direction: rtl;
        }
        .jigsaw-slot {
            flex-grow: 1;
            min-width: 80px;
            height: 60px;
            border: 1px dashed var(--color-border);
            background-color: var(--color-bg-secondary);
            transition: background-color 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: var(--font-arabic);
            font-size: 1.8rem;
        }
        .jigsaw-slot.over { background-color: var(--color-highlight); }
        .jigsaw-slot.filled { border-style: solid; background-color: var(--color-success); color: white; }
        #jigsawPieceTray_Engine {
            display: flex; flex-wrap: wrap; gap: 8px;
            width: 95%;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-secondary);
            justify-content: center;
            min-height: 70px;
        }
        .jigsaw-piece {
            padding: 8px 12px;
            border: 1px solid var(--color-accent);
            border-radius: var(--border-radius);
            background-color: var(--color-bg-primary);
            cursor: grab;
            transition: opacity 0.2s;
            font-family: var(--font-arabic);
            font-size: 1.8rem;
            direction: rtl;
            user-select: none;
        }
        .jigsaw-piece.dragging { opacity: 0.4; cursor: grabbing; }
        #jigsawCompletionMessage_Engine {
            text-align: center; margin-top: 15px; font-size: 1.2rem; color: var(--color-success); font-weight: bold;
        }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId; styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
    }
    function startVerseJigsawGame_Engine() {
        activeGame = 'verseJigsaw_engine';
        showGamePlayUI("Verse Jigsaw Puzzle");
        injectVerseJigsawCSS_Engine();
        const gamePlayArea = document.getElementById('gamePlayArea');
        gamePlayArea.innerHTML = `
        <div class="jigsaw-game-wrapper">
            <div class="jigsaw-controls">
                <label for="jigsawDifficultySelect">Ayah Length:</label>
                <select id="jigsawDifficultySelect">
                    <option value="easy">Short (4-6 Words)</option>
                    <option value="medium">Medium (7-10 Words)</option>
                    <option value="hard">Long (11-15 Words)</option>
                </select>
                <button id="newJigsawPuzzleBtn">New Puzzle</button>
            </div>
            <p id="jigsawAyahRef" style="text-align:center; font-style:italic; color:var(--color-text-secondary);"></p>
            <div class="jigsaw-main-area">
                <div id="jigsawPieceTray_Engine"><p>Loading Puzzle...</p></div>
                <div id="jigsawBoard_Engine"></div>
            </div>
            <div id="jigsawCompletionMessage_Engine"></div>
        </div>
    `;
        document.getElementById('jigsawDifficultySelect').addEventListener('change', (e) => {
            jigsawState.difficulty = e.target.value;
            generateNewJigsawPuzzle_Engine();
        });
        document.getElementById('newJigsawPuzzleBtn').addEventListener('click', generateNewJigsawPuzzle_Engine);
        generateNewJigsawPuzzle_Engine();
    }
    async function generateNewJigsawPuzzle_Engine() {
        const tray = document.getElementById('jigsawPieceTray_Engine');
        const board = document.getElementById('jigsawBoard_Engine');
        const msg = document.getElementById('jigsawCompletionMessage_Engine');
        const ref = document.getElementById('jigsawAyahRef');
        tray.innerHTML = '<p>Searching for a suitable Ayah...</p>';
        board.innerHTML = '';
        msg.textContent = '';
        ref.textContent = '';
        const difficultyMap = {
            easy: { min: 4, max: 6 },
            medium: { min: 7, max: 10 },
            hard: { min: 11, max: 15 }
        };
        const { min, max } = difficultyMap[jigsawState.difficulty];
        let attempts = 0;
        let words = [];
        let ayahData;
        try {
            while (attempts < 50) {
                const randomSurah = Math.floor(Math.random() * 114) + 1;
                const randomAyahNum = Math.floor(Math.random() * surahAyahCounts[randomSurah]) + 1;
                const fetchedData = await getData(STORE_QURAN, [randomSurah, randomAyahNum]);
                if (fetchedData && fetchedData.arabic) {
                    const fetchedWords = fetchedData.arabic.trim().split(/\s+/).filter(w => w);
                    if (fetchedWords.length >= min && fetchedWords.length <= max) {
                        words = fetchedWords;
                        ayahData = fetchedData;
                        break;
                    }
                }
                attempts++;
            }
        } catch (err) {
            board.innerHTML = `<p style='color:red'>Error accessing database.</p>`;
            return;
        }
        if (words.length === 0) {
            tray.innerHTML = `<p style='color:red'>Could not find a suitable Ayah. Please try another difficulty.</p>`;
            return;
        }
        jigsawState.totalPieces = words.length;
        jigsawState.piecesCorrect = 0;
        jigsawState.currentAyahRef = `Surah ${ayahData.surah}:${ayahData.ayah}`;
        ref.textContent = `Assemble the verse from: ${jigsawState.currentAyahRef}`;
        tray.innerHTML = '';
        let pieces = [];
        for (let i = 0; i < words.length; i++) {
            const slot = document.createElement('div');
            slot.classList.add('jigsaw-slot');
            slot.dataset.slotIndex = i;
            board.appendChild(slot);
            const piece = document.createElement('div');
            piece.id = `piece-${i}`;
            piece.dataset.wordIndex = i;
            piece.classList.add('jigsaw-piece');
            piece.draggable = true;
            piece.textContent = words[i];
            pieces.push(piece);
        }
        shuffleArray(pieces).forEach(p => tray.appendChild(p));
        addJigsawDragDropListeners_Engine();
    }
    function addJigsawDragDropListeners_Engine() {
        document.querySelectorAll('.jigsaw-piece').forEach(piece => {
            piece.addEventListener('dragstart', e => {
                jigsawState.draggedPiece = e.target;
                setTimeout(() => e.target.classList.add('dragging'), 0);
            });
            piece.addEventListener('dragend', e => e.target.classList.remove('dragging'));
        });
        document.querySelectorAll('.jigsaw-slot').forEach(slot => {
            slot.addEventListener('dragover', e => {
                e.preventDefault();
                if (!slot.hasChildNodes()) slot.classList.add('over');
            });
            slot.addEventListener('dragleave', () => slot.classList.remove('over'));
            slot.addEventListener('drop', e => {
                e.preventDefault();
                slot.classList.remove('over');
                if (jigsawState.draggedPiece && !slot.hasChildNodes() && slot.dataset.slotIndex === jigsawState.draggedPiece.dataset.wordIndex) {
                    slot.textContent = ''; // Clear any placeholder text
                    slot.appendChild(jigsawState.draggedPiece);
                    jigsawState.draggedPiece.draggable = false;
                    jigsawState.draggedPiece.style.cursor = 'default';
                    slot.classList.add('filled');
                    jigsawState.draggedPiece = null;
                    jigsawState.piecesCorrect++;
                    if (jigsawState.piecesCorrect === jigsawState.totalPieces) {
                        document.getElementById('jigsawCompletionMessage_Engine').textContent = "Masha'Allah! Verse Assembled!";
                    }
                }
            });
        });
    }
    function addVerseJigsawGameButtonToModal() {
        const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
        const buttonId = 'startVerseJigsawBtn';
        if (gameSelectionArea && !document.getElementById(buttonId)) {
            const jigsawButton = document.createElement('button');
            jigsawButton.id = buttonId;
            jigsawButton.className = 'game-select-btn';
            jigsawButton.textContent = 'Takmil al-Ayah';
            jigsawButton.addEventListener('click', startVerseJigsawGame_Engine);
            const existingButtons = gameSelectionArea.querySelectorAll('.game-select-btn');
            if (existingButtons.length > 0) {
                existingButtons[existingButtons.length - 1].insertAdjacentElement('afterend', jigsawButton);
            } else {
                gameSelectionArea.appendChild(jigsawButton);
            }
        }
    }
    if (typeof setupGameModal.isPatchedForJigsaw === 'undefined') {
        const originalSetupGameModal = setupGameModal;
        setupGameModal = function () {
            originalSetupGameModal.apply(this, arguments);
            addVerseJigsawGameButtonToModal(); // Add our new game button
        };
        setupGameModal.isPatchedForJigsaw = true;
    }
    (function () {
        'use strict';
        let ayahmatState = { // State for Ayah-Match game
            currentQuestion: null, totalQuestions: 5, currentQuestionIndex: 0, score: 0,
        };
        function injectAyahMatchCSS_Engine() {
            const cssId = "ayahMatchGameStylesEngine";
            if (document.getElementById(cssId)) return;
            const styles = `
            .ayah-match-wrapper { display: flex; flex-direction: column; align-items: center; width: 100%; padding: 10px; text-align: center; }
            .ayah-match-question-arabic {
                font-size: 2rem; line-height: 2.5; margin: 20px 0; padding: 20px;
                background-color: var(--color-bg-primary); border-radius: var(--border-radius);
                color: var(--color-text-primary); border: 1px solid var(--color-border);
                font-family: var(--font-arabic); direction: rtl;
            }
            .ayah-match-options-container { display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 600px; margin: 0 auto; }
            .ayah-match-option-btn {
                padding: 15px; font-size: 1.2rem; text-align: left; line-height: 1.6;
            }
            .ayah-match-option-btn.correct { background-color: var(--color-success) !important; color: white !important; }
            .ayah-match-option-btn.incorrect { background-color: var(--color-error) !important; color: white !important; }
            .ayah-match-feedback { margin-top: 15px; font-weight: bold; min-height: 1.5em; }
            .ayah-match-controls button { margin-top: 10px; }
        `;
            const styleSheet = document.createElement("style");
            styleSheet.id = cssId; styleSheet.type = "text/css"; styleSheet.innerText = styles;
            document.head.appendChild(styleSheet);
        }
        async function startAyahMatchGame_Engine() {
            activeGame = 'ayahMatch_engine';
            showGamePlayUI("Ayah-Translation Match");
            injectAyahMatchCSS_Engine();
            ayahmatState.currentQuestionIndex = 0;
            ayahmatState.score = 0;
            updateScoreDisplay();
            const gamePlayArea = document.getElementById('gamePlayArea');
            gamePlayArea.innerHTML = `<div class="ayah-match-wrapper"><p>Loading a new question...</p></div>`;
            await displayNextAyahMatchQuestion();
        }
        async function displayNextAyahMatchQuestion() {
            const gamePlayArea = document.getElementById('gamePlayArea');
            if (ayahmatState.currentQuestionIndex >= ayahmatState.totalQuestions) {
                endAyahMatchGame_Engine();
                return;
            }
            gamePlayArea.innerHTML = `<div class="ayah-match-wrapper"><p>Searching for a suitable Ayah...</p></div>`;
            const question = await fetchAyahMatchQuestion_Engine();
            if (!question) {
                gamePlayArea.innerHTML = `<div class="ayah-match-wrapper"><p style="color:red;">Could not generate a question. Please try again.</p><div class="ayah-match-controls"><button id="ayahMatchNextBtn">Try Again</button></div></div>`;
                document.getElementById('ayahMatchNextBtn').addEventListener('click', displayNextAyahMatchQuestion);
                return;
            }
            ayahmatState.currentQuestion = question;
            let optionsHTML = '';
            question.options.forEach(opt => {
                optionsHTML += `<button class="ayah-match-option-btn" data-answer="${opt.translation}" style="font-family:${opt.font}; direction:${opt.dir}; text-align:${opt.textAlign};">${opt.translation}</button>`;
            });
            gamePlayArea.innerHTML = `
            <div class="ayah-match-wrapper">
                <p>Which is the correct translation for the following Ayah?</p>
                <div class="ayah-match-question-arabic">${question.arabicQuestion}</div>
                <div class="ayah-match-options-container">${optionsHTML}</div>
                <div class="ayah-match-feedback"></div>
                <div class="ayah-match-controls"><button id="ayahMatchNextBtn" style="display:none;">Next Question</button></div>
            </div>`;
            document.querySelectorAll('.ayah-match-option-btn').forEach(btn => btn.addEventListener('click', handleAyahMatchAnswer_Engine));
            document.getElementById('ayahMatchNextBtn').addEventListener('click', displayNextAyahMatchQuestion);
        }
        async function fetchAyahMatchQuestion_Engine() {
            let attempts = 0;
            console.log("[AyahMatch v9] Starting robust search for question set...");
            while (attempts < 100) { // High attempt count to ensure success
                attempts++;
                try {
                    let candidateAyahs = [];
                    let seenKeys = new Set();
                    while (candidateAyahs.length < 3) {
                        const rSurah = Math.floor(Math.random() * 114) + 1;
                        const rAyah = Math.floor(Math.random() * (surahAyahCounts[rSurah] || 1)) + 1;
                        const key = `${rSurah}:${rAyah}`;
                        if (seenKeys.has(key)) continue;
                        const ayahData = await getData(STORE_QURAN, [rSurah, rAyah]);
                        seenKeys.add(key);
                        if (!ayahData || !ayahData.arabic || ayahData.arabic.trim() === "") continue;
                        const hasTranslation = ['english', 'urdu', 'Bangali', 'pashto'].some(lang => ayahData[lang] && ayahData[lang].trim() !== "");
                        if (!hasTranslation) continue;
                        candidateAyahs.push(ayahData);
                    }
                    const correctAnswerRecord = candidateAyahs[0];
                    const distractor1Record = candidateAyahs[1];
                    const distractor2Record = candidateAyahs[2];
                    const getDisplayTranslation = (record) => {
                        const selectedLangKey = document.getElementById('translation-select').value;
                        const fallbackOrder = ['english', 'urdu', 'Bangali', 'pashto'];
                        const prioritizedOrder = [selectedLangKey, ...fallbackOrder.filter(k => k !== selectedLangKey)];
                        for (const lang of prioritizedOrder) {
                            if (record[lang] && record[lang].trim() !== "") {
                                return { translation: record[lang], config: getTranslationConfig(lang) };
                            }
                        }
                        return null; // Should not happen due to our earlier check
                    };
                    const correctAnswerOption = getDisplayTranslation(correctAnswerRecord);
                    const distractor1Option = getDisplayTranslation(distractor1Record);
                    const distractor2Option = getDisplayTranslation(distractor2Record);
                    if (!correctAnswerOption || !distractor1Option || !distractor2Option) {
                        console.error("[AyahMatch] Failed to get display translations even after validation. Retrying.");
                        continue;
                    }
                    const options = [
                        { translation: correctAnswerOption.translation, font: correctAnswerOption.config.font, dir: correctAnswerOption.config.dir, textAlign: correctAnswerOption.config.dir === 'rtl' ? 'right' : 'left' },
                        { translation: distractor1Option.translation, font: distractor1Option.config.font, dir: distractor1Option.config.dir, textAlign: distractor1Option.config.dir === 'rtl' ? 'right' : 'left' },
                        { translation: distractor2Option.translation, font: distractor2Option.config.font, dir: distractor2Option.config.dir, textAlign: distractor2Option.config.dir === 'rtl' ? 'right' : 'left' },
                    ];
                    console.log(`[AyahMatch v9] SUCCESS! Generated a valid question from S${correctAnswerRecord.surah}:A${correctAnswerRecord.ayah}.`);
                    return {
                        arabicQuestion: correctAnswerRecord.arabic,
                        options: shuffleArray(options),
                        correctAnswer: correctAnswerOption.translation,
                    };
                } catch (error) {
                    console.warn(`[AyahMatch] Error during attempt ${attempts}:`, error);
                }
            }
            console.error("[AyahMatch v9] CRITICAL FAILURE: Failed to generate a question after all attempts.");
            return null;
        }
        function handleAyahMatchAnswer_Engine(event) {
            const selectedButton = event.target;
            const selectedAnswer = selectedButton.dataset.answer;
            const correctAnswer = ayahmatState.currentQuestion.correctAnswer;
            const feedbackEl = document.querySelector('.ayah-match-feedback');
            document.querySelectorAll('.ayah-match-option-btn').forEach(btn => {
                btn.disabled = true;
                if (btn.dataset.answer === correctAnswer) {
                    btn.classList.add('correct');
                }
            });
            if (selectedAnswer === correctAnswer) {
                feedbackEl.textContent = "Correct! Masha'Allah!";
                feedbackEl.style.color = 'var(--color-success)';
                ayahmatState.score += 10;
                gameScore = ayahmatState.score;
                if (gameScore > gameHighScore) gameHighScore = gameScore;
                updateScoreDisplay();
            } else {
                selectedButton.classList.add('incorrect');
                feedbackEl.textContent = "Not quite. The correct translation is highlighted in green.";
                feedbackEl.style.color = 'var(--color-error)';
            }
            ayahmatState.currentQuestionIndex++;
            document.getElementById('ayahMatchNextBtn').style.display = 'inline-block';
        }
        function endAyahMatchGame_Engine() {
            const gamePlayArea = document.getElementById('gamePlayArea');
            gamePlayArea.innerHTML = `
            <div class="ayah-match-wrapper">
                <h3>Game Over!</h3>
                <p>Your final score: ${ayahmatState.score} / ${ayahmatState.totalQuestions * 10}</p>
                <div class="ayah-match-controls"><button id="playAyahMatchAgainBtn">Play Again</button></div>
            </div>`;
            document.getElementById('playAyahMatchAgainBtn').addEventListener('click', startAyahMatchGame_Engine);
            activeGame = null;
        }
        function addAyahMatchGameButtonToModal() {
            const gameSelectionArea = document.querySelector('#quranGameModal .game-selection-area');
            const oldButton = document.getElementById('startContextualCluesBtn');
            if (oldButton) oldButton.remove();
            const buttonId = 'startAyahMatchBtn';
            if (gameSelectionArea && !document.getElementById(buttonId)) {
                const matchButton = document.createElement('button');
                matchButton.id = buttonId;
                matchButton.className = 'game-select-btn';
                matchButton.textContent = 'Ayah-Translation Match'; // New Name
                matchButton.addEventListener('click', startAyahMatchGame_Engine);
                gameSelectionArea.appendChild(matchButton);
            }
        }
        if (typeof setupGameModal !== 'undefined' && typeof setupGameModal.isPatchedForAyahMatch_v9 === 'undefined') {
            const originalSetupGameModal = setupGameModal;
            window.setupGameModal = function () {
                originalSetupGameModal.apply(this, arguments);
                addAyahMatchGameButtonToModal();
            };
            window.setupGameModal.isPatchedForAyahMatch_v9 = true;
        }
    })(); // End of self-contained patch



    function initializeGoalsModule() {
        if (window.goalsModuleInitialized) return;

        injectGoalsCSS();
        addGoalsNavLink();
        createGoalsSectionHTML();
        setupGoalsFormListener();
        patchShowSectionForGoals();

        window.goalsModuleInitialized = true;
    }

    function injectGoalsCSS() {
        const cssId = "studyGoalsStyles";
        if (document.getElementById(cssId)) document.getElementById(cssId).remove();

        const styles = `
        .goals-container { padding: 10px; }
        .add-goal-form { background-color: var(--color-bg-secondary); padding: 20px; border-radius: var(--border-radius); margin-bottom: 25px; box-shadow: 0 2px 5px var(--color-shadow); }
        .add-goal-form h3 { margin-top: 0; }
        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px; align-items: end; }
        .form-grid label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--color-text-secondary); }
        .form-grid input, .form-grid select { width: 100%; max-width: 100%; }
        .goals-tabs { display: flex; border-bottom: 2px solid var(--color-border); margin-bottom: 20px; }
        .goal-tab { padding: 10px 20px; cursor: pointer; font-size: 1.1em; color: var(--color-text-secondary); }
        .goal-tab.active { color: var(--color-text-primary); border-bottom: 3px solid var(--color-accent); font-weight: bold; }
        .goals-list-panel { display: none; }
        .goals-list-panel.active { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px; }
        .goal-card { background-color: var(--color-bg-primary); border: 1px solid var(--color-border); border-left: 5px solid var(--color-accent); border-radius: var(--border-radius); padding: 20px; display: flex; flex-direction: column; }
        .goal-card.completed { border-left-color: var(--color-success); opacity: 0.8; }
        .goal-card h4 { margin-top: 0; color: var(--color-accent-dark); }
        .goal-card .goal-meta { font-size: 0.9em; color: var(--color-text-secondary); margin-bottom: 15px; }
        .progress-container { margin-bottom: 10px; }
        .progress-label { display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 5px; }
        .progress-bar-bg { background-color: var(--color-bg-secondary); border-radius: 5px; overflow: hidden; height: 22px; }
        .progress-bar { background-color: var(--color-accent); height: 100%; width: 0%; transition: width 0.5s ease-in-out; text-align: center; color: white; font-weight: bold; font-size: 0.8em; line-height: 22px; }
        .goal-actions { margin-top: 20px; text-align: right; display: flex; gap: 10px; justify-content: flex-end; }
        .goal-actions button { font-size: 0.85em; padding: 6px 12px; }
        .delete-goal-btn { background-color: var(--color-error); }
        .view-details-btn { background-color: var(--color-accent-dark); }
        .goal-details-modal .modal-content { max-width: 800px; max-height: 90vh; display: flex; flex-direction: column; }
        .goal-details-modal h3 { border-bottom: 1px solid var(--color-border); padding-bottom: 10px; margin-bottom: 15px; }
        .goal-details-content { overflow-y: auto; flex-grow: 1; }
        .detail-list { list-style-type: none; padding: 0; }
        .detail-item { padding: 10px; border-bottom: 1px dotted var(--color-border); }
        .detail-item a { color: var(--color-accent-dark); cursor: pointer; font-weight: bold; }
        .detail-item-meta { font-size: 0.85em; color: var(--color-text-secondary); margin-left: 10px;}
        .detail-item-notes { font-style: italic; display: block; margin-top: 5px; padding-left: 15px; font-size: 0.9em; }
        .detail-item-status { font-size: 0.8em; padding: 3px 8px; border-radius: var(--border-radius); float: right; }
        .status-complete { background-color: var(--color-success); color: white; }
        .status-incomplete { background-color: #e0e0e0; color: #424242; }
    `;
        const styleSheet = document.createElement("style");
        styleSheet.id = cssId;
        styleSheet.type = "text/css";
        styleSheet.innerText = styles;
        document.head.appendChild(styleSheet);
    }

    function addGoalsNavLink() {
        const sidebarNav = document.querySelector('.sidebar nav ul');
        if (!sidebarNav || document.querySelector('a[data-section="goals"]')) return;
        const goalsLi = document.createElement('li');
        const goalsLink = document.createElement('a');
        goalsLink.href = "#goals";
        goalsLink.className = "nav-link";
        goalsLink.dataset.section = "goals";
        goalsLink.textContent = "My Goals";
        goalsLi.appendChild(goalsLink);
        goalsLink.addEventListener('click', (e) => { e.preventDefault(); window.showSection('goals'); });
        const reportingLink = sidebarNav.querySelector('a[data-section="reporting"]');
        if (reportingLink) {
            sidebarNav.insertBefore(goalsLi, reportingLink.parentElement);
        } else {
            const dataManagementLink = sidebarNav.querySelector('a[data-section="data"]');
            if (dataManagementLink) {
                sidebarNav.insertBefore(goalsLi, dataManagementLink.parentElement);
            } else {
                sidebarNav.appendChild(goalsLi);
            }
        }
    }

    function createGoalsSectionHTML() {
        const mainContent = document.querySelector('.main-content');
        if (!mainContent || document.getElementById('goals')) return;

        const goalsSection = document.createElement('section');
        goalsSection.id = 'goals';
        goalsSection.className = 'section';
        goalsSection.setAttribute('role', 'region');
        goalsSection.setAttribute('aria-labelledby', 'goals-heading');

        let surahOptions = surahNames.map((name, i) => `<option value="${i + 1}">${i + 1}. ${name}</option>`).join('');

        goalsSection.innerHTML = `
        <div class="goals-container">
            <h2 id="goals-heading">My Quran Goals</h2>
            <div class="add-goal-form">
                <h3>Add a New Goal</h3>
                <form id="goal-form">
                    <div class="form-grid">
                        <div>
                            <label for="goal-title">Goal Title:</label>
                            <input type="text" id="goal-title" required placeholder="e.g., Complete First Khatam">
                        </div>
                        <div>
                            <label for="goal-type">Goal Type:</label>
                            <select id="goal-type" required>
                                <option value="">-- Select Type --</option>
                                <option value="read_surah">Read a Surah</option>
                                <option value="listen_surah">Listen to a Surah</option>
                                <option value="read_quran">Read Entire Quran</option>
                                <option value="listen_quran">Listen to Entire Quran</option>
                                <option value="read_ayahs_daily">Read Ayahs Daily</option>
                                <option value="listen_ayahs_daily">Listen to Ayahs Daily</option>
                                <option value="memorize_surah">Memorize a Surah</option>
                                <option value="tafsir_juz">Complete Tafsir for a Juz</option>
                                <option value="link_theme">Link Ayahs to a Theme</option>
                                <option value="recurring_surah_daily">Recite Surah Daily (Habit)</option>
                                <option value="recurring_surah_weekly">Recite Surah Weekly (Habit)</option>
                            </select>
                        </div>
                        <div id="goal-target-wrapper"></div>
                        <div id="goal-count-wrapper"></div>
                        <div>
                            <label for="goal-date">Target Date (for completion goals):</label>
                            <input type="date" id="goal-date">
                        </div>
                        <div>
                            <button type="submit">Add Goal</button>
                        </div>
                    </div>
                </form>
            </div>
            <div class="goals-tabs">
                <span class="goal-tab active" data-tab="active">Active Goals</span>
                <span class="goal-tab" data-tab="completed">Completed Goals</span>
            </div>
            <div id="goals-list-active" class="goals-list-panel active"></div>
            <div id="goals-list-completed" class="goals-list-panel"></div>
        </div>
        <div id="goalDetailsModal" class="modal goal-details-modal"><div class="modal-content"><span class="close-button" onclick="this.parentElement.parentElement.style.display='none'">×</span><h3 id="modalGoalTitle"></h3><div id="modalGoalContent" class="goal-details-content"></div></div></div>
    `;
        mainContent.appendChild(goalsSection);

        document.getElementById('goal-type').addEventListener('change', async (e) => {
            const targetWrapper = document.getElementById('goal-target-wrapper');
            const countWrapper = document.getElementById('goal-count-wrapper');
            const type = e.target.value;
            targetWrapper.innerHTML = '';
            countWrapper.innerHTML = '';

            switch (type) {
                case 'read_surah':
                case 'listen_surah':
                case 'memorize_surah':
                case 'recurring_surah_daily':
                    targetWrapper.innerHTML = `<label for="goal-target-surah">Select Surah:</label><select id="goal-target-surah" required>${surahOptions}</select>`;
                    break;
                case 'recurring_surah_weekly':
                    const dayOptions = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
                        .map((day, i) => `<option value="${i}">${day}</option>`).join('');
                    targetWrapper.innerHTML = `<label for="goal-target-surah">Select Surah:</label><select id="goal-target-surah" required>${surahOptions}</select>`;
                    countWrapper.innerHTML = `<label for="goal-target-day">On which day?</label><select id="goal-target-day" required>${dayOptions}</select>`;
                    break;
                case 'read_ayahs_daily':
                case 'listen_ayahs_daily':
                    countWrapper.innerHTML = `<label for="goal-count">How many Ayahs per day?</label><input type="number" id="goal-count" min="1" value="10" required>`;
                    break;
                case 'read_quran':
                case 'listen_quran':
                    break;
                case 'tafsir_juz':
                    const juzOptions = juzBoundariesData.map(j => `<option value="${j.juz}">Juz ${j.juz}</option>`).join('');
                    targetWrapper.innerHTML = `<label for="goal-target-juz">Select Juz:</label><select id="goal-target-juz" required>${juzOptions}</select>`;
                    break;
                case 'link_theme':
                    const themes = await getAllData('themes');
                    const themeOptions = themes.map(t => `<option value="${t.id}">${t.name}</option>`).join('');
                    targetWrapper.innerHTML = `<label for="goal-target-theme">Select Theme:</label><select id="goal-target-theme" required>${themeOptions || '<option disabled>No themes created</option>'}</select>`;
                    countWrapper.innerHTML = `<label for="goal-count">Link how many Ayahs?</label><input type="number" id="goal-count" min="1" value="10" required>`;
                    break;
            }
        });

        document.querySelectorAll('.goal-tab').forEach(tab => tab.addEventListener('click', (e) => {
            document.querySelectorAll('.goal-tab, .goals-list-panel').forEach(el => el.classList.remove('active'));
            e.target.classList.add('active');
            document.getElementById(`goals-list-${e.target.dataset.tab}`).classList.add('active');
        }));
    }

    function setupGoalsFormListener() {
        const form = document.getElementById('goal-form');
        if (form && !form.dataset.listenerAttached) {
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newGoal = {
                    title: document.getElementById('goal-title').value,
                    type: document.getElementById('goal-type').value,
                    targetDate: document.getElementById('goal-date').value,
                    creationDate: new Date().toISOString().split('T')[0],
                    isComplete: false
                };

                const type = newGoal.type;
                if (type === 'read_surah' || type === 'listen_surah' || type === 'memorize_surah' || type === 'recurring_surah_daily') {
                    newGoal.targetSurah = parseInt(document.getElementById('goal-target-surah').value);
                } else if (type === 'recurring_surah_weekly') {
                    newGoal.targetSurah = parseInt(document.getElementById('goal-target-surah').value);
                    newGoal.targetDay = parseInt(document.getElementById('goal-target-day').value); // 0=Sun
                } else if (type === 'read_ayahs_daily' || type === 'listen_ayahs_daily') {
                    newGoal.targetCount = parseInt(document.getElementById('goal-count').value);
                } else if (type === 'tafsir_juz') {
                    newGoal.targetJuz = parseInt(document.getElementById('goal-target-juz').value);
                } else if (type === 'link_theme') {
                    newGoal.targetTheme = parseInt(document.getElementById('goal-target-theme').value);
                    newGoal.targetCount = parseInt(document.getElementById('goal-count').value);
                }

                await addData('goals', newGoal);
                form.reset();
                document.getElementById('goal-target-wrapper').innerHTML = '';
                document.getElementById('goal-count-wrapper').innerHTML = '';
                await renderGoalsUI();
            });
            form.dataset.listenerAttached = 'true';
        }
    }

    async function renderGoalsUI() {
        const activeList = document.getElementById('goals-list-active');
        const completedList = document.getElementById('goals-list-completed');
        if (!activeList || !completedList) return;

        activeList.innerHTML = '<p>Loading active goals...</p>';
        completedList.innerHTML = '<p>Loading completed goals...</p>';

        const allGoals = await getAllData('goals');
        const userData = {
            hifz: await getAllData('hifz'),
            tafsir: await getAllData('tafsir'),
            recitations: await getAllData('recitations'),
            themeAyahs: await getAllData('theme_ayahs')
        };

        let activeHTML = '';
        let completedHTML = '';

        for (const goal of allGoals) {
            const { progress, progressText } = await calculateGoalProgress(goal, userData);
            const isNowComplete = progress >= 100 && (goal.type !== 'read_ayahs_daily' && goal.type !== 'listen_ayahs_daily' && goal.type !== 'recurring_surah_daily' && goal.type !== 'recurring_surah_weekly');

            if (isNowComplete && !goal.isComplete) {
                goal.isComplete = true;
                await putData('goals', goal);
            }

            const goalCardHTML = createGoalCardHTML(goal, progress, progressText);
            if (goal.isComplete) {
                completedHTML += goalCardHTML;
            } else {
                activeHTML += goalCardHTML;
            }
        }

        activeList.innerHTML = activeHTML || '<p>No active goals. Add one above!</p>';
        completedList.innerHTML = completedHTML || '<p>No goals completed yet. Keep going!</p>';

        document.querySelectorAll('.delete-goal-btn').forEach(btn => btn.addEventListener('click', handleDeleteGoal));
        document.querySelectorAll('.view-details-btn').forEach(btn => btn.addEventListener('click', handleViewGoalDetails));
    }

    async function calculateGoalProgress(goal, userData) {
        let progress = 0;
        let progressText = '0/0';
        const allReadingLogs = userData.recitations; // Use ALL recitation logs now

        switch (goal.type) {
            case 'read_surah':
            case 'listen_surah': {
                const total = surahAyahCounts[goal.targetSurah];
                const ayahsReadInSurah = new Set();
                allReadingLogs.filter(r => r.surah === goal.targetSurah).forEach(r => {
                    const start = r.ayahStart || 1;
                    const end = r.ayahEnd || (r.ayahStart ? r.ayahStart : surahAyahCounts[r.surah]);
                    for (let i = start; i <= end; i++) {
                        ayahsReadInSurah.add(i);
                    }
                });
                const completed = ayahsReadInSurah.size;
                progress = total > 0 ? (completed / total) * 100 : 100;
                progressText = `${completed}/${total} Ayahs`;
                break;
            }
            case 'read_quran':
            case 'listen_quran': {
                const total = 6236; // Total Ayahs
                const ayahsRead = new Set();
                allReadingLogs.forEach(r => {
                    const start = r.ayahStart || 1;
                    const end = r.ayahEnd || (r.ayahStart ? r.ayahStart : surahAyahCounts[r.surah]);
                    for (let i = start; i <= end; i++) {
                        ayahsRead.add(`${r.surah}:${i}`);
                    }
                });
                const completed = ayahsRead.size;
                progress = (completed / total) * 100;
                progressText = `${completed}/${total} Ayahs`;
                break;
            }
            case 'read_ayahs_daily':
            case 'listen_ayahs_daily': {
                const total = 7; // Track last 7 days for habit
                const dailyCounts = getDailyReadingCounts(allReadingLogs);
                let completed = 0;
                for (let i = 0; i < 7; i++) {
                    const d = new Date();
                    d.setDate(d.getDate() - i);
                    const dayKey = d.toISOString().split('T')[0];
                    if ((dailyCounts[dayKey] || 0) >= goal.targetCount) {
                        completed++;
                    }
                }
                progress = (completed / total) * 100;
                progressText = `${completed}/${total} Days Met`;
                break;
            }
            case 'recurring_surah_weekly': {
                const total = 4; // Track last 4 weeks
                let completed = 0;
                const recitationLogsForSurah = allReadingLogs.filter(r => r.surah === goal.targetSurah);
                for (let i = 0; i < total; i++) {
                    const checkDate = new Date();
                    checkDate.setDate(checkDate.getDate() - (i * 7));
                    const dayOfWeek = checkDate.getDay();
                    checkDate.setDate(checkDate.getDate() - (dayOfWeek - goal.targetDay));
                    const dayKey = checkDate.toISOString().split('T')[0];
                    if (recitationLogsForSurah.some(log => log.date === dayKey)) {
                        completed++;
                    }
                }
                progress = (completed / total) * 100;
                progressText = `${completed}/${total} Weeks Met`;
                break;
            }
            case 'recurring_surah_daily': {
                const total = 7; // Track last 7 days
                let completed = 0;
                const recitationLogsForSurah = allReadingLogs.filter(r => r.surah === goal.targetSurah);
                for (let i = 0; i < total; i++) {
                    const checkDate = new Date();
                    checkDate.setDate(checkDate.getDate() - i);
                    const dayKey = checkDate.toISOString().split('T')[0];
                    if (recitationLogsForSurah.some(log => log.date === dayKey)) {
                        completed++;
                    }
                }
                progress = (completed / total) * 100;
                progressText = `${completed}/${total} Days Met`;
                break;
            }
            case 'memorize_surah': {
                const total = surahAyahCounts[goal.targetSurah];
                const completed = userData.hifz.filter(h => h.surah === goal.targetSurah && h.status === 'memorized').length;
                progress = total > 0 ? (completed / total) * 100 : 100;
                progressText = `${completed}/${total} Ayahs`;
                break;
            }
            case 'tafsir_juz': {
                const ayahsInJuz = getAyahsForJuz(goal.targetJuz);
                const total = ayahsInJuz.length;
                const tafsirKeys = new Set(userData.tafsir.map(t => `${t.surah}:${t.ayah}`));
                const completed = ayahsInJuz.filter(a => tafsirKeys.has(`${a.surah}:${a.ayah}`)).length;
                progress = total > 0 ? (completed / total) * 100 : 100;
                progressText = `${completed}/${total} Ayahs`;
                break;
            }
            case 'link_theme': {
                const total = goal.targetCount;
                const completed = userData.themeAyahs.filter(ta => ta.themeId === goal.targetTheme).length;
                progress = total > 0 ? (completed / total) * 100 : 100;
                progressText = `${completed}/${total} Ayahs`;
                break;
            }
        }
        return { progress: Math.min(progress, 100), progressText };
    }

    function getDailyReadingCounts(allReadingLogs) {
        const dailyCounts = {};
        allReadingLogs.forEach(r => {
            const dayKey = r.date;
            if (!dayKey) return;
            if (!dailyCounts[dayKey]) dailyCounts[dayKey] = 0;
            const start = r.ayahStart || 1;
            const end = r.ayahEnd || (r.ayahStart ? r.ayahStart : (surahAyahCounts[r.surah] || 0));
            dailyCounts[dayKey] += Math.max(0, (end - start + 1));
        });
        return dailyCounts;
    }


    function createGoalCardHTML(goal, progress, progressText) {
        const progressPercent = progress.toFixed(0);
        const isHabitGoal = goal.type.includes('daily') || goal.type.includes('weekly');
        const deadlineText = !isHabitGoal && goal.targetDate ? `Target: ${new Date(goal.targetDate).toLocaleDateString()}` : 'Habit Goal';
        const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

        let goalDescription = '';
        if (goal.type === 'read_surah') goalDescription = `Read Surah ${goal.targetSurah}: ${surahNames[goal.targetSurah - 1]}`;
        else if (goal.type === 'listen_surah') goalDescription = `Listen to Surah ${goal.targetSurah}: ${surahNames[goal.targetSurah - 1]}`;
        else if (goal.type === 'read_quran') goalDescription = `Complete Full Reading of Quran`;
        else if (goal.type === 'listen_quran') goalDescription = `Complete Full Listening of Quran`;
        else if (goal.type === 'read_ayahs_daily') goalDescription = `Read ${goal.targetCount} Ayahs Daily`;
        else if (goal.type === 'listen_ayahs_daily') goalDescription = `Listen to ${goal.targetCount} Ayahs Daily`;
        else if (goal.type === 'memorize_surah') goalDescription = `Memorize Surah ${goal.targetSurah}: ${surahNames[goal.targetSurah - 1]}`;
        else if (goal.type === 'tafsir_juz') goalDescription = `Tafsir for Juz ${goal.targetJuz}`;
        else if (goal.type === 'link_theme') goalDescription = `Link Ayahs to a theme`;
        else if (goal.type === 'recurring_surah_weekly') goalDescription = `Recite Surah ${goal.targetSurah} (${surahNames[goal.targetSurah - 1]}) every ${days[goal.targetDay]}`;
        else if (goal.type === 'recurring_surah_daily') goalDescription = `Recite Surah ${goal.targetSurah} (${surahNames[goal.targetSurah - 1]}) every day`;

        return `
        <div class="goal-card ${goal.isComplete ? 'completed' : ''}">
            <div>
                <h4>${goal.title}</h4>
                <div class="goal-meta">${goalDescription} | ${deadlineText}</div>
                <div class="progress-container">
                    <div class="progress-label"><span>Progress</span><span>${progressText}</span></div>
                    <div class="progress-bar-bg"><div class="progress-bar" style="width: ${progressPercent}%;">${progressPercent}%</div></div>
                </div>
            </div>
            <div class="goal-actions">
                <button class="view-details-btn" data-goal-id="${goal.id}">View Details</button>
                <button class="delete-goal-btn" data-goal-id="${goal.id}">Delete</button>
            </div>
        </div>`;
    }

    async function handleViewGoalDetails(e) {
        const goalId = parseInt(e.target.dataset.goalId);
        const goal = await getData('goals', goalId);
        if (!goal) return;

        const modal = document.getElementById('goalDetailsModal');
        document.getElementById('modalGoalTitle').textContent = `Details for: ${goal.title}`;
        const contentEl = document.getElementById('modalGoalContent');
        contentEl.innerHTML = '<p>Loading details...</p>';
        modal.style.display = 'flex';

        let detailHTML = '<ul class="detail-list">';
        const allReadingLogs = (await getAllData('recitations'));

        switch (goal.type) {
            case 'read_surah':
            case 'listen_surah':
            case 'read_quran':
            case 'listen_quran': {
                const isFullQuran = goal.type.includes('quran');
                const ayahsRead = new Set();
                allReadingLogs.forEach(r => {
                    const start = r.ayahStart || 1;
                    const end = r.ayahEnd || (r.ayahStart ? r.ayahStart : (surahAyahCounts[r.surah] || 0));
                    for (let i = start; i <= end; i++) {
                        if (isFullQuran || r.surah === goal.targetSurah) {
                            ayahsRead.add(`${r.surah}:${i}`);
                        }
                    }
                });

                let ayahsToRead = [];
                if (isFullQuran) {
                    detailHTML += `<li><p>Total unique Ayahs read/listened to: ${ayahsRead.size} / 6236</p></li>`;
                } else {
                    for (let i = 1; i <= surahAyahCounts[goal.targetSurah]; i++) ayahsToRead.push(`${goal.targetSurah}:${i}`);
                    const remaining = ayahsToRead.filter(key => !ayahsRead.has(key));
                    if (remaining.length > 0) {
                        detailHTML += remaining.slice(0, 100).map(key => {
                            const [s, a] = key.split(':');
                            return `<li class="detail-item"><a onclick="jumpToTafsir(${s}, ${a})">Remaining: Surah ${s}:${a}</a></li>`;
                        }).join('');
                        if (remaining.length > 100) detailHTML += `<li>And ${remaining.length - 100} more...</li>`;
                    } else {
                        detailHTML += '<li><p>All Ayahs have been read/listened to. Congratulations!</p></li>';
                    }
                }
                break;
            }
            case 'read_ayahs_daily':
            case 'listen_ayahs_daily': {
                const dailyCounts = getDailyReadingCounts(allReadingLogs);
                for (let i = 0; i < 30; i++) {
                    const d = new Date();
                    d.setDate(d.getDate() - i);
                    const dayKey = d.toISOString().split('T')[0];
                    const count = dailyCounts[dayKey] || 0;
                    const isComplete = count >= goal.targetCount;
                    detailHTML += `<li class="detail-item"><span>${d.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' })}</span><span class="detail-item-status status-${isComplete ? 'complete' : 'incomplete'}">${count} / ${goal.targetCount} Ayahs</span></li>`;
                }
                break;
            }
            case 'recurring_surah_daily':
            case 'recurring_surah_weekly': {
                const isWeekly = goal.type.includes('weekly');
                const logsForSurah = allReadingLogs.filter(r => r.surah === goal.targetSurah);
                const daysToCheck = isWeekly ? 4 * 7 : 30; // 4 weeks or 30 days

                for (let i = 0; i < daysToCheck; i++) {
                    const checkDate = new Date();
                    checkDate.setDate(checkDate.getDate() - i);

                    if (isWeekly && checkDate.getDay() !== goal.targetDay) continue;

                    const dayKey = checkDate.toISOString().split('T')[0];
                    const wasMet = logsForSurah.some(log => log.date === dayKey);

                    detailHTML += `<li class="detail-item"><span>${checkDate.toLocaleDateString(undefined, { weekday: 'long', month: 'short', day: 'numeric' })}</span><span class="detail-item-status status-${wasMet ? 'complete' : 'incomplete'}">${wasMet ? 'Done' : 'Pending'}</span></li>`;
                }
                break;
            }
            default:
                detailHTML += '<li><p>Detailed progress view is not available for this goal type yet.</p></li>';
        }

        detailHTML += '</ul>';
        contentEl.innerHTML = detailHTML;
    }

    async function handleDeleteGoal(e) {
        const goalId = parseInt(e.target.dataset.goalId);
        if (confirm("Are you sure you want to delete this goal?")) {
            await deleteData('goals', goalId);
            await renderGoalsUI();
        }
    }

    async function jumpToTafsir(surah, ayah) {
        const modal = document.getElementById('goalDetailsModal');
        if (modal) modal.style.display = 'none';
        await loadAyah(surah, ayah);
        showSection('tafsir');
    }

    function getAyahsForJuz(juzNum) {
        const ayahs = [];
        const startJuzData = juzBoundariesData[juzNum - 1];
        const endJuzData = juzBoundariesData[juzNum] || { startSurah: 115, startAyah: 1 }; // sentinel

        for (let s = startJuzData.startSurah; s < endJuzData.startSurah; s++) {
            const startAyah = (s === startJuzData.startSurah) ? startJuzData.startAyah : 1;
            for (let a = startAyah; a <= surahAyahCounts[s]; a++) {
                ayahs.push({ surah: s, ayah: a });
            }
        }
        if (endJuzData.startSurah <= 114) {
            const startAyahLastSurah = (endJuzData.startSurah === startJuzData.startSurah) ? startJuzData.startAyah : 1;
            for (let a = startAyahLastSurah; a < endJuzData.startAyah; a++) {
                ayahs.push({ surah: endJuzData.startSurah, ayah: a });
            }
        }
        return ayahs;
    }

    function patchShowSectionForGoals() {
        if (window.showSection.isPatchedForGoals) return;
        const originalShowSection = window.showSection;
        window.showSection = function (sectionId) {
            originalShowSection.apply(this, arguments); // Call original function
            if (sectionId === 'goals') {
                renderGoalsUI();
            }
        };
        window.showSection.isPatchedForGoals = true;
    }

    document.addEventListener('DOMContentLoaded', initializeGoalsModule);

</script>


<script>
    (function () {
        const JSZIP_CDN_URL = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        let jszipLoaded = false;
        let dataFilesManifestCache = null;

        function loadJSZip() {
            return new Promise((resolve, reject) => {
                if (typeof JSZip !== 'undefined') {
                    jszipLoaded = true;
                    resolve(window.JSZip);
                    return;
                }
                const script = document.createElement('script');
                script.src = JSZIP_CDN_URL;
                script.onload = () => {
                    jszipLoaded = true;
                    resolve(window.JSZip);
                };
                script.onerror = () => reject(new Error('Failed to load JSZip library.'));
                document.head.appendChild(script);
            });
        }

        async function fetchAndParseManifest() {
            if (dataFilesManifestCache) {
                return dataFilesManifestCache;
            }
            if (typeof MANIFEST_URL === 'undefined') {
                console.error("MANIFEST_URL is not defined. Cannot fetch data files from manifest.");
                throw new Error("Manifest URL (info.csv) not defined.");
            }
            try {
                const response = await fetch(MANIFEST_URL, { cache: "no-store" });
                if (!response.ok) throw new Error(`Failed to fetch manifest (${MANIFEST_URL}): ${response.statusText}`);
                const text = await response.text();
                const lines = text.trim().split('\n');
                if (lines.length < 2) { // Headers + at least one data line
                    console.warn(`Manifest file '${MANIFEST_URL}' is empty or has no data rows.`);
                    dataFilesManifestCache = [];
                    return dataFilesManifestCache;
                }

                const headers = lines.shift().trim().split(',').map(h => h.trim());
                const urlHeaderIndex = headers.indexOf('url');
                if (urlHeaderIndex === -1) throw new Error(`Manifest CSV ('${MANIFEST_URL}') must contain a 'url' header.`);

                dataFilesManifestCache = lines.map(line => {
                    const values = line.trim().split(',');
                    let fileUrl = values[urlHeaderIndex] ? values[urlHeaderIndex].trim() : null;
                    // Filter for files listed *inside* the manifest (typically .AM, but keep .csv for flexibility)
                    if (fileUrl && (fileUrl.endsWith('.AM') || fileUrl.endsWith('.csv'))) {
                        return { name: fileUrl, url: fileUrl };
                    }
                    return null;
                }).filter(Boolean);

                if (dataFilesManifestCache.length === 0) {
                    console.warn(`No .AM or .csv files found listed inside the manifest '${MANIFEST_URL}' after filtering.`);
                }
                return dataFilesManifestCache;
            } catch (error) {
                console.error(`Error fetching or parsing manifest '${MANIFEST_URL}':`, error);
                dataFilesManifestCache = [];
                throw error;
            }
        }

        async function fetchFileAsBlob(url, fileNameForError) {
            try {
                const response = await fetch(url, { cache: "no-store" });
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status} for ${fileNameForError || url}`);
                }
                return response.blob();
            } catch (error) {
                console.warn(`Failed to fetch ${fileNameForError || url}: ${error.message}. File will be skipped.`);
                return null;
            }
        }

        function triggerDownload(blob, filename) {
            const downloadUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = downloadUrl;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(downloadUrl);
        }

        async function handleZippedAppDownload(button) {
            const originalButtonContent = 'Zip 📦'; // Updated icon
            button.disabled = true;
            button.innerHTML = 'Zipping... ⏳';

            try {
                if (!jszipLoaded) {
                    await loadJSZip();
                }
                if (typeof JSZip === 'undefined') {
                    throw new Error("JSZip library failed to load correctly.");
                }

                const zip = new JSZip();

                // 1. Add index.html
                const currentHtmlContent = document.documentElement.outerHTML;
                zip.file('index.html', currentHtmlContent);

                // 2. Add info.csv (the manifest file itself)
                let filesAddedToZip = 0;
                if (typeof MANIFEST_URL !== 'undefined') {
                    const manifestBlob = await fetchFileAsBlob(MANIFEST_URL, MANIFEST_URL);
                    if (manifestBlob) {
                        zip.file(MANIFEST_URL, manifestBlob); // Use MANIFEST_URL as filename (e.g., 'info.csv')
                        filesAddedToZip++;
                    } else {
                        console.warn(`Manifest file '${MANIFEST_URL}' could not be fetched for the zip.`);
                    }
                } else {
                    console.warn("MANIFEST_URL not defined; cannot add manifest file to zip.");
                }


                // 3. Add files listed in the manifest
                let manifestFiles = [];
                try {
                    manifestFiles = await fetchAndParseManifest();
                } catch (manifestError) {
                    console.warn("Could not load files from manifest for zipping due to manifest error. Zip will contain index.html and potentially info.csv if fetched.", manifestError);
                    // Continue to create zip with what we have
                }

                if (manifestFiles && manifestFiles.length > 0) {
                    const filePromises = manifestFiles.map(fileInfo =>
                        fetchFileAsBlob(fileInfo.url, fileInfo.name)
                            .then(blob => blob ? ({ name: fileInfo.name, blob }) : null)
                    );
                    const fetchedDataFiles = await Promise.all(filePromises);
                    fetchedDataFiles.forEach(fileResult => {
                        if (fileResult && fileResult.blob) {
                            zip.file(fileResult.name, fileResult.blob);
                            filesAddedToZip++;
                        }
                    });
                }

                if (filesAddedToZip === 0) { // This counts index.html, info.csv, and data files
                    //alert(`Warning: No files (including index.html or data files) could be added to the zip. An empty or minimal zip will be downloaded.`);
                } else if (manifestFiles && filesAddedToZip < (manifestFiles.length + (typeof MANIFEST_URL !== 'undefined' ? 2 : 1))) { // +2 for index.html and info.csv
                    //alert(`Warning: Some files might be missing from the zip. Check console. The app might not work correctly offline.`);
                }


                const zipBlob = await zip.generateAsync({ type: 'blob' });
                triggerDownload(zipBlob, 'NurAlQuran_OfflineApp.zip');
                button.innerHTML = originalButtonContent;

            } catch (error) {
                console.error('Error during zipped app download:', error);
                alert(`Failed to prepare zipped app for download: ${error.message}. Check console for details.`);
                button.innerHTML = 'Error! Retry Zip 📦';
            } finally {
                button.disabled = false;
            }
        }

        async function handleUnzippedAppDownload(button) {
            const originalButtonContent = 'Files 📁'; // Updated icon
            button.disabled = true;
            button.innerHTML = 'Preparing... ⏳';

            try {
                // 1. Download index.html
                const currentHtmlContent = document.documentElement.outerHTML;
                const htmlBlob = new Blob([currentHtmlContent], { type: 'text/html' });
                triggerDownload(htmlBlob, 'index.html');
                await new Promise(resolve => setTimeout(resolve, 500)); // Give browser a moment

                // 2. Download info.csv (the manifest file itself)
                let filesDownloadedCount = 0;
                if (typeof MANIFEST_URL !== 'undefined') {
                    button.innerHTML = `Downloading ${MANIFEST_URL}...`;
                    const manifestBlob = await fetchFileAsBlob(MANIFEST_URL, MANIFEST_URL);
                    if (manifestBlob) {
                        triggerDownload(manifestBlob, MANIFEST_URL);
                        filesDownloadedCount++;
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } else {
                        console.warn(`Manifest file '${MANIFEST_URL}' could not be fetched for unzipped download.`);
                    }
                } else {
                    console.warn("MANIFEST_URL not defined; cannot download manifest file.");
                }

                // 3. Download files listed in the manifest
                let manifestFiles = [];
                try {
                    manifestFiles = await fetchAndParseManifest();
                } catch (manifestError) {
                    console.warn("Could not load files from manifest for unzipped download due to manifest error.", manifestError);
                    // Continue, user already got index.html and maybe info.csv
                }

                if (manifestFiles && manifestFiles.length > 0) {
                    for (const fileInfo of manifestFiles) {
                        button.innerHTML = `Downloading ${fileInfo.name}...`;
                        const blob = await fetchFileAsBlob(fileInfo.url, fileInfo.name);
                        if (blob) {
                            triggerDownload(blob, fileInfo.name);
                            filesDownloadedCount++;
                            await new Promise(resolve => setTimeout(resolve, 300));
                        }
                    }
                }

                const totalExpectedFiles = 1 + (typeof MANIFEST_URL !== 'undefined' ? 1 : 0) + (manifestFiles ? manifestFiles.length : 0);
                if (filesDownloadedCount === 0) {
                    //alert(`Warning: Could not download any files. The app will not work offline.`);
                } else if (filesDownloadedCount < totalExpectedFiles) {
                    //alert(`Warning: Some files (${totalExpectedFiles - filesDownloadedCount} of ${totalExpectedFiles}) could not be downloaded. Check console. The app might not be fully functional offline.`);
                }

                button.innerHTML = originalButtonContent;

            } catch (error) {
                console.error('Error during unzipped app download:', error);
                alert(`Failed to prepare unzipped files for download: ${error.message}. Check console for details.`);
                button.innerHTML = 'Error! Retry Files 📁';
            } finally {
                button.disabled = false;
            }
        }


        function createAndInsertDownloadButtons() {
            const quranHeading = document.getElementById('quran-heading');

            if (!quranHeading) {
                console.warn('Target h2#quran-heading for download buttons not found yet. Retrying...');
                setTimeout(createAndInsertDownloadButtons, 500);
                return;
            }

            if (document.getElementById('downloadAppZippedBtn')) return;

            if (getComputedStyle(quranHeading).display !== 'flex') {
                quranHeading.style.display = 'flex';
                quranHeading.style.justifyContent = 'space-between'; // This will push the button container to the right
                quranHeading.style.alignItems = 'center';
                quranHeading.style.width = '100%';
            }

            // Ensure existing text content of h2 is wrapped in a span if it's just a text node
            // This helps in reliably appending the button container next to the text.
            let textSpanContainer = quranHeading.querySelector('span#quranHeadingText');
            if (!textSpanContainer) {
                textSpanContainer = document.createElement('span');
                textSpanContainer.id = 'quranHeadingText';
                // Move existing children (likely just text node) into the new span
                while (quranHeading.firstChild && quranHeading.firstChild.id !== 'quranHeadingDownloadButtons') {
                    textSpanContainer.appendChild(quranHeading.firstChild);
                }
                quranHeading.insertBefore(textSpanContainer, quranHeading.firstChild); // Add span at the beginning
            }


            const buttonsContainer = document.createElement('div');
            buttonsContainer.id = 'quranHeadingDownloadButtons';
            buttonsContainer.style.display = 'flex';
            buttonsContainer.style.gap = '8px';
            buttonsContainer.style.marginLeft = 'auto';
            buttonsContainer.style.flexShrink = '0';

            const commonButtonStyle = `
                padding: 5px 8px; 
                font-size: 0.85rem;  
                color: white;
                border: none;
                border-radius: var(--border-radius, 4px);
                cursor: pointer;
                vertical-align: middle;
                line-height: normal;
                white-space: nowrap; 
            `;

            const hoverEffect = (btn, originalColor, hoverColor) => {
                btn.addEventListener('mouseover', () => btn.style.backgroundColor = hoverColor);
                btn.addEventListener('mouseout', () => btn.style.backgroundColor = originalColor);
            };

            const downloadZippedButton = document.createElement('button');
            downloadZippedButton.id = 'downloadAppZippedBtn';
            downloadZippedButton.innerHTML = 'Zip 📦';
            downloadZippedButton.title = 'Download App & Data (Zipped)';
            downloadZippedButton.style.cssText = commonButtonStyle;
            downloadZippedButton.style.backgroundColor = 'var(--color-success, #28a745)';
            hoverEffect(downloadZippedButton, 'var(--color-success, #28a745)', 'var(--color-accent-dark, #218838)');
            downloadZippedButton.addEventListener('click', () => handleZippedAppDownload(downloadZippedButton));

            const downloadUnzippedButton = document.createElement('button');
            downloadUnzippedButton.id = 'downloadAppUnzippedBtn';
            downloadUnzippedButton.innerHTML = 'Files 📁';
            downloadUnzippedButton.title = 'Download App & Data (Individual Files)';
            downloadUnzippedButton.style.cssText = commonButtonStyle;
            downloadUnzippedButton.style.backgroundColor = 'var(--color-accent, #007bff)';
            hoverEffect(downloadUnzippedButton, 'var(--color-accent, #007bff)', 'var(--color-accent-dark, #0056b3)');
            downloadUnzippedButton.addEventListener('click', () => handleUnzippedAppDownload(downloadUnzippedButton));

            buttonsContainer.appendChild(downloadZippedButton);
            buttonsContainer.appendChild(downloadUnzippedButton);

            quranHeading.appendChild(buttonsContainer); // Append to the h2
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', createAndInsertDownloadButtons);
        } else {
            createAndInsertDownloadButtons();
        }

    })();
</script>

<script>
    (function () {
        'usese strict';
        // --- Configuration (MODIFIED) ---
        // Maps the PHYSICAL KEY CODE to the section ID.
        // This is the key change to fix the issue.
        const sectionShortcuts = {
            'Digit1': 'quran',
            'Digit2': 'tafsir',
            'Digit3': 'themes',
            'Digit4': 'roots',
            'Digit5': 'recitation',
            'Digit6': 'hifz',
            'Digit7': 'search',
            'Digit8': 'data'
        };
        // --- Helper Functions for Navigation (Unchanged) ---
        function goToNextAyah() {
            if (typeof currentSurah === 'undefined' || typeof currentAyah === 'undefined' || typeof surahAyahCounts === 'undefined' || typeof loadAyah !== 'function') {
                return;
            }
            let nextS = currentSurah;
            let nextA = currentAyah + 1;
            if (nextA > surahAyahCounts[nextS]) {
                if (nextS < 114) {
                    nextS++;
                    nextA = 1;
                } else { return; }
            }
            loadAyah(nextS, nextA);
        }
        function goToPrevAyah() {
            if (typeof currentSurah === 'undefined' || typeof currentAyah === 'undefined' || typeof surahAyahCounts === 'undefined' || typeof loadAyah !== 'function') {
                return;
            }
            let prevS = currentSurah;
            let prevA = currentAyah - 1;
            if (prevA < 1) {
                if (prevS > 1) {
                    prevS--;
                    prevA = surahAyahCounts[prevS];
                } else { return; }
            }
            loadAyah(prevS, prevA);
        }
        /**
         * The main keyboard shortcut handler for the entire application.
         * @param {KeyboardEvent} event The keyboard event.
         */
        function handleGlobalKeyDown(event) {
            // We are interested in the final key press, not the modifier keys themselves.
            if (['Control', 'Shift', 'Alt', 'Meta'].includes(event.key)) {
                return;
            }
            // --- Group logs for this key press for readability ---
            const activeEl = document.activeElement;
            const isTyping = activeEl && ['INPUT', 'TEXTAREA', 'SELECT'].includes(activeEl.tagName.toUpperCase());
            // --- Log initial state ---
            const isModalOpen = !!document.querySelector('.modal[style*="display: flex"]');
            const isReaderOpen = !!document.getElementById('fullScreenReaderOverlay');
            if (isModalOpen || isReaderOpen) {
                return;
            }
            // Exception: Allow Ctrl+S in the tafsir textarea for saving.
            if (isTyping && !(event.ctrlKey && event.key.toLowerCase() === 's' && activeEl.id === 'tafsir-notes')) {
                return;
            }
            // --- Shortcut Logic ---
            // Save Shortcut: Ctrl + S
            if (event.ctrlKey && !event.shiftKey && !event.altKey && event.key.toLowerCase() === 's') {
                event.preventDefault();
                const activeSectionId = document.querySelector('.section.active')?.id;
                if (activeSectionId === 'tafsir') {
                    document.getElementById('save-tafsir-btn')?.click();
                } else if (activeSectionId === 'roots') {
                    document.getElementById('save-root-notes-btn')?.click();
                } else if (activeSectionId === 'recitation') {
                    document.getElementById('save-recitation-btn')?.click();
                }
                // Section Switching: Ctrl + Shift + [1-8] (MODIFIED)
            } else if (event.ctrlKey && event.shiftKey && sectionShortcuts[event.code]) {
                event.preventDefault();
                const sectionId = sectionShortcuts[event.code];
                if (typeof showSection === 'function') {
                    showSection(sectionId);
                } else {
                }
                // Ayah Navigation: Ctrl + Arrow Keys
            } else if (event.ctrlKey && !isTyping && (event.key === 'ArrowRight' || event.key === 'ArrowLeft')) {
                event.preventDefault();
                if (event.key === 'ArrowRight') {
                    goToNextAyah();
                } else {
                    goToPrevAyah();
                }
            } else {
            }
        }
        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            document.addEventListener('keydown', handleGlobalKeyDown);
        });
    })();
</script>


<!-- Ayah Image Generator Module (V3.1 - Word-by-Word Fix) -->
<script>
    (function () {
        'use strict';
        const HTML2CANVAS_CDN = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
        let html2canvasLoaded = false;

        function loadHtml2Canvas() {
            return new Promise((resolve, reject) => {
                if (typeof html2canvas !== 'undefined') {
                    html2canvasLoaded = true;
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = HTML2CANVAS_CDN;
                script.onload = () => {
                    html2canvasLoaded = true;
                    resolve();
                };
                script.onerror = () => reject(new Error("Failed to load image generation library."));
                document.head.appendChild(script);
            });
        }

        async function createImageContainerForCanvas(ayahData, selectedTranslations, wordByWordOptions) {
            const imageContainer = document.createElement('div');
            // --- Basic Styling ---
            const themeBgPrimary = getComputedStyle(document.body).getPropertyValue('--color-bg-primary').trim();
            const themeBgSecondary = getComputedStyle(document.body).getPropertyValue('--color-bg-secondary').trim();
            const themeBorder = getComputedStyle(document.body).getPropertyValue('--color-border').trim();
            const themeTextPrimary = getComputedStyle(document.body).getPropertyValue('--color-text-primary').trim();
            const themeTextSecondary = getComputedStyle(document.body).getPropertyValue('--color-text-secondary').trim();
            imageContainer.style.cssText = `
                width: 800px;
                padding: 40px;
                border: 1px solid ${themeBorder};
                background: linear-gradient(135deg, ${themeBgPrimary} 0%, ${themeBgSecondary} 100%);
                font-family: var(--font-general);
                color: ${themeTextPrimary};
                display: flex;
                flex-direction: column;
                gap: 20px;
            `;

            if (ayahData.surah !== 1 && ayahData.surah !== 9 && ayahData.ayah === 1) {
                const bismillah = document.createElement('div');
                bismillah.textContent = 'بِسْمِ ٱللَّهِ ٱلرَّحْمَـٰنِ ٱلرَّحِيمِ';
                bismillah.style.cssText = "font-family: var(--font-arabic); font-size: 2em; text-align: center; margin-bottom: 20px;";
                imageContainer.appendChild(bismillah);
            }

            const ref = document.createElement('h2');
            ref.textContent = `Surah ${surahNames[ayahData.surah - 1]} (${ayahData.surah}:${ayahData.ayah})`;
            ref.style.cssText = `text-align: center; color: ${themeTextSecondary}; margin-bottom: 10px; font-weight: normal;`;
            imageContainer.appendChild(ref);

            const arabicText = document.createElement('div');
            arabicText.textContent = ayahData.arabic;
            arabicText.style.cssText = "font-family: var(--font-arabic); font-size: 3.2em; text-align: center; direction: rtl; line-height: 1.8; margin-bottom: 20px;";
            imageContainer.appendChild(arabicText);

            selectedTranslations.forEach(trans => {
                const divider = document.createElement('hr');
                divider.style.cssText = "border: none; border-top: 1px solid var(--color-border); opacity: 0.5;";
                imageContainer.appendChild(divider);
                const transContainer = document.createElement('div');
                transContainer.innerHTML = `
                    <h4 style="color:${themeTextSecondary}; margin-bottom:5px; font-size:1em;">${trans.config.label}</h4>
                    <p style="font-family:var(--font-${trans.config.key}); font-size:1.4em; direction:${trans.config.dir}; text-align:left; line-height:1.6; margin:0;">${trans.text}</p>
                `;
                imageContainer.appendChild(transContainer);
            });

            if (wordByWordOptions.include && wordByWordOptions.languages.length > 0) {
                const table = await createWordByWordTable(ayahData, wordByWordOptions.languages);
                if (table) {
                    const divider = document.createElement('hr');
                    divider.style.cssText = "border: none; border-top: 1px solid var(--color-border); margin-top: 20px;";
                    imageContainer.appendChild(divider);
                    const tableHeader = document.createElement('h4');
                    tableHeader.textContent = "Word-by-Word Breakdown";
                    tableHeader.style.cssText = `color:${themeTextSecondary}; margin: 20px 0 0 0; text-align: center;`;
                    imageContainer.appendChild(tableHeader);
                    imageContainer.appendChild(table);
                }
            }

            const watermark = document.createElement('div');
            watermark.textContent = 'Generated by Nur Al-Quran Studio';
            watermark.style.cssText = `margin-top: 30px; text-align: center; font-size: 12px; color: ${themeTextSecondary}; opacity: 0.6;`;
            imageContainer.appendChild(watermark);

            imageContainer.style.position = 'absolute';
            imageContainer.style.left = '-9999px';
            document.body.appendChild(imageContainer);
            return imageContainer;
        }

        async function createWordByWordTable(ayahData, languageKeys) {
            // --- FIX --- Create a map to bridge language keys to DB property names
            const propertyMap = {
                'urdu': 'ur_meaning',
                'english': 'en_meaning',
                'pashto': 'pashto_text',
                'Bangali': 'bn_meaning' // Assuming this key based on your other code
            };

            const metadata = await getAllDataInRange(STORE_WORD_METADATA, IDBKeyRange.bound([ayahData.surah, ayahData.ayah, 0], [ayahData.surah, ayahData.ayah, Infinity]), 'location_idx');
            if (!metadata || metadata.length === 0) return null;

            const wordIds = metadata.map(m => m.word_id);
            const translationPromises = wordIds.map(id => getData(STORE_WORD_TRANSLATIONS, id));
            const translations = await Promise.all(translationPromises);

            const arabicWords = ayahData.arabic.split(/\s+/).filter(w => w);

            const table = document.createElement('table');
            table.className = 'word-table';

            const thead = table.createTHead();
            const headerRow = thead.insertRow();
            headerRow.innerHTML = '<th>Word (Arabic)</th>';
            languageKeys.forEach(key => {
                const config = getTranslationConfig(key);
                headerRow.innerHTML += `<th>${config.label}</th>`;
            });

            const tbody = table.createTBody();
            for (let i = 0; i < arabicWords.length; i++) {
                const row = tbody.insertRow();
                const arabicCell = row.insertCell();
                arabicCell.className = 'arabic-word-cell';
                arabicCell.textContent = arabicWords[i];

                const wordTrans = translations[i] || {};

                languageKeys.forEach(key => {
                    const transCell = row.insertCell();
                    const config = getTranslationConfig(key);
                    // --- FIX --- Use the propertyMap to look up the correct field name
                    const propertyName = propertyMap[key];
                    transCell.textContent = wordTrans[propertyName] || 'N/A';

                    transCell.style.fontFamily = `var(--font-${config.key})`;
                    transCell.style.direction = config.dir;
                });
            }
            return table;
        }

        // The rest of the functions remain the same as the previous version...

        async function generateFinalImage() {
            const modal = document.getElementById('ayahImageModal');
            const createBtn = document.getElementById('createImageBtn');
            createBtn.disabled = true;
            createBtn.textContent = 'Creating...';
            try {
                const surah = parseInt(modal.dataset.surah, 10);
                const ayah = parseInt(modal.dataset.ayah, 10);
                const ayahData = await getData(STORE_QURAN, [surah, ayah]);
                if (!ayahData) throw new Error(`Could not retrieve data for Ayah ${surah}:${ayah}.`);

                const selectedTranslations = Array.from(document.querySelectorAll('#imageTranslationOptions input:checked'))
                    .map(cb => ({ langKey: cb.value, text: ayahData[cb.value], config: getTranslationConfig(cb.value) }));

                const wordByWordOptions = {
                    include: document.getElementById('includeWordByWordTable').checked,
                    languages: Array.from(document.querySelectorAll('#wordByWordLanguageOptions input:checked')).map(cb => cb.value)
                };

                const imageSourceContainer = await createImageContainerForCanvas(ayahData, selectedTranslations, wordByWordOptions);
                const canvas = await html2canvas(imageSourceContainer, { useCORS: true, backgroundColor: null, scale: 2 });
                const link = document.createElement('a');
                link.download = `Ayah_${surah}_${ayah}.png`;
                link.href = canvas.toDataURL("image/png");
                link.click();

                document.body.removeChild(imageSourceContainer);
                modal.style.display = 'none';

            } catch (error) {
                console.error("Error generating final image:", error);
                alert("Sorry, an error occurred. Please check the console for details.");
            } finally {
                createBtn.disabled = false;
                createBtn.textContent = 'Create & Download Image';
            }
        }

        async function openImageSettingsModal(event) {
            const button = event.currentTarget;
            button.disabled = true;
            try {
                if (!html2canvasLoaded) await loadHtml2Canvas();
                const surah = parseInt(button.dataset.surah, 10);
                const ayah = parseInt(button.dataset.ayah, 10);
                const modal = document.getElementById('ayahImageModal');

                modal.dataset.surah = surah;
                modal.dataset.ayah = ayah;

                const ayahData = await getData(STORE_QURAN, [surah, ayah]);
                if (!ayahData) throw new Error(`Could not find data for Ayah ${surah}:${ayah}.`);

                const availableTranslations = window.appManifest.filter(f => f.file_type === 'quran_translation' && ayahData[f.key]);
                const currentlySelectedInUI = document.getElementById('translation-select').value;

                const fullTransOptions = document.getElementById('imageTranslationOptions');
                const wbywLangOptions = document.getElementById('wordByWordLanguageOptions');
                fullTransOptions.innerHTML = '';
                wbywLangOptions.innerHTML = '';

                availableTranslations.forEach(config => {
                    fullTransOptions.innerHTML += `<label><input type="checkbox" value="${config.key}" ${config.key === currentlySelectedInUI ? 'checked' : ''}> ${config.label}</label>`;
                    wbywLangOptions.innerHTML += `<label><input type="checkbox" class="wbyw-lang-option" value="${config.key}" ${config.key === currentlySelectedInUI ? 'checked' : ''}> ${config.label}</label>`;
                });

                const includeWbyWCheckbox = document.getElementById('includeWordByWordTable');
                includeWbyWCheckbox.checked = false;
                wbywLangOptions.style.display = 'none';
                includeWbyWCheckbox.onchange = () => {
                    wbywLangOptions.style.display = includeWbyWCheckbox.checked ? 'flex' : 'none';
                };

                const createBtn = document.getElementById('createImageBtn');
                const newCreateBtn = createBtn.cloneNode(true);
                createBtn.parentNode.replaceChild(newCreateBtn, createBtn);
                newCreateBtn.addEventListener('click', generateFinalImage);

                modal.style.display = 'flex';

            } catch (error) {
                console.error("Error opening image settings modal:", error);
                alert(error.message);
            } finally {
                button.disabled = false;
            }
        }

        function addShareButtonToAyah(surah, ayah) {
            const ayahDiv = document.querySelector(`.ayah[data-surah="${surah}"][data-ayah="${ayah}"]`);
            if (!ayahDiv || ayahDiv.querySelector('.generate-image-btn')) return;
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'ayah-actions';
            const button = document.createElement('button');
            button.className = 'generate-image-btn';
            button.innerHTML = '🖼️ Generate Image';
            button.dataset.surah = surah;
            button.dataset.ayah = ayah;
            button.addEventListener('click', openImageSettingsModal);
            actionsDiv.appendChild(button);
            ayahDiv.appendChild(actionsDiv);
        }

        function patchAndApplyToInitialView() {
            if (window.renderSingleAyahView && !window.renderSingleAyahView.isPatchedForSharing) {
                const originalFunction = window.renderSingleAyahView;
                window.renderSingleAyahView = async function (...args) {
                    await originalFunction.apply(this, args);
                    const [surah, ayah] = args;
                    addShareButtonToAyah(surah, ayah);
                };
                window.renderSingleAyahView.isPatchedForSharing = true;
                console.log("renderSingleAyahView patched for image generation (v3.1).");
            }

            const initialAyahDiv = document.querySelector('#quran-display .ayah[data-surah]');
            if (initialAyahDiv) {
                const surah = parseInt(initialAyahDiv.dataset.surah, 10);
                const ayah = parseInt(initialAyahDiv.dataset.ayah, 10);
                if (!isNaN(surah) && !isNaN(ayah)) {
                    addShareButtonToAyah(surah, ayah);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', patchAndApplyToInitialView);

    })();
</script>