<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quran App</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <style>
        body {
            background-color: #212529;
            color: #f8f9fa;
        }
        .card {
            background-color: #343a40;
            border-color: #454d55;
        }
        .table {
            color: #f8f9fa;
        }
        .table th, .table td {
            border-color: #454d55;
        }
        .form-select, .form-control {
            background-color: #495057;
            color: #f8f9fa;
            border-color: #454d55;
        }
        .btn-primary {
            background-color: #0d6efd;
            border-color: #0d6efd;
        }
        .btn-secondary {
            background-color: #6c757d;
            border-color: #6c757d;
        }
        .bookmark-btn.active {
            color: gold;
        }
        .notes-container {
            margin-top: 20px;
        }
        .search-results-modal .modal-content {
            background-color: #343a40;
            color: #f8f9fa;
        }
         .search-results-modal .modal-header {
             border-bottom-color: #454d55;
         }
        .search-results-modal .modal-footer {
             border-top-color: #454d55;
         }
        .search-result-item {
            cursor: pointer;
        }
         .ayah-mushaf {
            font-size: 1.5rem;
            direction: rtl;
             line-height: 2.5;
         }
    </style>
</head>
<body>
    <div class="container mt-4">
        <div class="card p-4">
            <h1 class="mb-4">Quran App</h1>

            <div class="mb-3 d-flex">
                <div class="flex-grow-1 me-2">
                     <label for="surah-select" class="form-label">Select Surah</label>
                     <select class="form-select" id="surah-select">
                         <!-- Surah options will be populated here -->
                     </select>
                 </div>
                <div class="flex-grow-1">
                    <label for="ayah-select" class="form-label">Select Ayah</label>
                    <select class="form-select" id="ayah-select">
                        <!-- Ayah options will be populated here -->
                    </select>
                </div>
            </div>

             <div class="mb-3">
                 <label for="search-input" class="form-label">Search (Surah/Ayah, Arabic, Urdu, English)</label>
                 <input type="text" class="form-control" id="search-input" placeholder="Enter search term...">
                 <button class="btn btn-primary mt-2" id="search-button">Search</button>
             </div>


            <div class="mb-3">
                 <button class="btn btn-secondary" id="toggle-view-button">Toggle View (Word-by-Word / Ayah)</button>
                <button class="btn btn-secondary" id="bookmark-button">Bookmark Ayah</button>
                <button class="btn btn-secondary" id="audio-toggle-button">Play Audio</button>
                 <button class="btn btn-secondary" id="export-ayah-button">Export Ayah Text</button>
                 <button class="btn btn-secondary" id="mushaf-mode-button">Mushaf Mode</button>
            </div>

            <div id="word-by-word-view" class="mt-4">
                 <h2>Word by Word</h2>
                 <div class="table-responsive">
                    <table class="table table-bordered">
                        <thead>
                            <tr>
                                <th>Arabic</th>
                                <th>Urdu Meaning</th>
                                <th>English Meaning</th>
                            </tr>
                        </thead>
                        <tbody id="word-by-word-table-body">
                            <!-- Word by word data will be displayed here -->
                        </tbody>
                    </table>
                 </div>
            </div>

            <div id="ayah-view" class="mt-4" style="display: none;">
                 <h2>Ayah Translation</h2>
                 <p id="ayah-translation-urdu"><strong>Urdu:</strong></p>
                 <p id="ayah-translation-english"><strong>English:</strong></p>
            </div>

            <div id="mushaf-view" class="mt-4" style="display: none;">
                 <h2>Mushaf View</h2>
                 <div id="mushaf-ayah-text" class="ayah-mushaf">
                    <!-- Ayah text will be displayed here in Mushaf style -->
                 </div>
            </div>

            <div class="notes-container mt-4">
                 <h2>Notes</h2>
                 <textarea id="notes-input" class="form-control" rows="3" placeholder="Add notes for this ayah..."></textarea>
                 <button class="btn btn-primary mt-2" id="save-note-button">Save Note</button>
                 <div id="saved-note" class="mt-2"><strong>Saved Note:</strong> <span id="saved-note-text"></span></div>
             </div>

            <div class="mt-4">
                 <h2>Statistics</h2>
                 <p><strong>Total Words in Surah:</strong> <span id="surah-word-count">0</span></p>
             </div>

             <div class="mt-4">
                  <h2>Backup and Restore</h2>
                  <button class="btn btn-secondary" id="backup-button">Backup Data</button>
                  <input type="file" id="restore-input" style="display: none;">
                  <button class="btn btn-secondary" id="restore-button">Restore Data</button>
              </div>

        </div>
    </div>

    <!-- Search Results Modal -->
    <div class="modal fade search-results-modal" id="searchResultsModal" tabindex="-1" aria-labelledby="searchResultsModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="searchResultsModalLabel">Search Results</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body" id="search-results-body">
            <!-- Search results will be appended here -->
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
     <script src="https://cdn.jsdelivr.net/npm/@howtogeek/js-worker-audio-playback/index.min.js"></script>
    <script>
        // Author: Yasin Ullah, Pakistani

        const DB_NAME = 'QuranAppDB';
        const DB_VERSION = 1;
        const WORDS_STORE_NAME = 'words';
        const BOOKMARKS_STORE_NAME = 'bookmarks';
        const NOTES_STORE_NAME = 'notes';
        const METADATA_STORE_NAME = 'metadata';

        let db;
        let currentSurah = 1;
        let currentAyah = 1;
        let surahLengths = {};
        let ayahPositions = {};
        let allWords = [];
        let mushafQuranText = [];

        const surahNames = {
            1: "Al-Fatiha", 2: "Al-Baqarah", 3: "Al-Imran", 4: "An-Nisa", 5: "Al-Ma'idah",
            6: "Al-An'am", 7: "Al-A'raf", 8: "Al-Anfal", 9: "At-Tawbah", 10: "Yunus",
            11: "Hud", 12: "Yusuf", 13: "Ar-Ra'd", 14: "Ibrahim", 15: "Al-Hijr",
            16: "An-Nahl", 17: "Al-Isra", 18: "Al-Kahf", 19: "Maryam", 20: "Taha",
            21: "Al-Anbiya", 22: "Al-Hajj", 23: "Al-Mu'minun", 24: "An-Nur", 25: "Al-Furqan",
            26: "Ash-Shu'ara", 27: "An-Naml", 28: "Al-Qasas", 29: "Al-'Ankabut", 30: "Ar-Rum",
            31: "Luqman", 32: "As-Sajda", 33: "Al-Ahzab", 34: "Saba", 35: "Fatir",
            36: "Ya-Sin", 37: "As-Saffat", 38: "Sad", 39: "Az-Zumar", 40: "Ghafir",
            41: "Fussilat", 42: "Ash-Shuraa", 43: "Az-Zukhruf", 44: "Ad-Dukhan", 45: "Al-Jathiyah",
            46: "Al-Ahqaf", 47: "Muhammad", 48: "Al-Fath", 49: "Al-Hujurat", 50: "Qaf",
            51: "Adh-Dhariyat", 52: "At-Tur", 53: "An-Najm", 54: "Al-Qamar", 55: "Ar-Rahman",
            56: "Al-Waqi'ah", 57: "Al-Hadid", 58: "Al-Mujadila", 59: "Al-Hashr", 60: "Al-Mumtahanah",
            61: "As-Saff", 62: "Al-Jumu'ah", 63: "Al-Munafiqun", 64: "At-Taghabun", 65: "At-Talaq",
            66: "At-Tahrim", 67: "Al-Mulk", 68: "Al-Qalam", 69: "Al-Haqqah", 70: "Al-Ma'arij",
            71: "Nuh", 72: "Al-Jinn", 73: "Al-Muzzammil", 74: "Al-Muddaththir", 75: "Al-Qiyamah",
            76: "Al-Insan", 77: "Al-Mursalat", 78: "An-Naba", 79: "An-Nazi'at", 80: "'Abasa",
            81: "At-Takwir", 82: "Al-Infitar", 83: "Al-Mutaffifin", 84: "Al-Inshiqaq", 85: "Al-Buruj",
            86: "At-Tariq", 87: "Al-A'la", 88: "Al-Ghashiyah", 89: "Al-Fajr", 90: "Al-Balad",
            91: "Ash-Shams", 92: "Al-Layl", 93: "Ad-Duhaa", 94: "Ash-Sharh", 95: "At-Tin",
            96: "Al-'Alaq", 97: "Al-Qadr", 98: "Al-Bayyinah", 99: "Az-Zalzalah", 100: "Al-'Adiyat",
            101: "Al-Qari'ah", 102: "At-Takathur", 103: "Al-'Asr", 104: "Al-Humazah", 105: "Al-Fil",
            106: "Quraysh", 107: "Al-Ma'un", 108: "Al-Kawthar", 109: "Al-Kafirun", 110: "An-Nasr",
            111: "Al-Masad", 112: "Al-Ikhlas", 113: "Al-Falaq", 114: "An-Nas"
        };

        const ayahCounts = {
            1: 7, 2: 286, 3: 200, 4: 176, 5: 120, 6: 165, 7: 206, 8: 75, 9: 129, 10: 109,
            11: 123, 12: 111, 13: 43, 14: 52, 15: 99, 16: 128, 17: 111, 18: 110, 19: 98, 20: 135,
            21: 112, 22: 78, 23: 118, 24: 64, 25: 77, 26: 227, 27: 93, 28: 88, 29: 69, 30: 60,
            31: 34, 32: 30, 33: 73, 34: 54, 35: 45, 36: 83, 37: 182, 38: 88, 39: 75, 40: 85,
            41: 54, 42: 53, 43: 89, 44: 59, 45: 37, 46: 35, 47: 38, 48: 29, 49: 18, 50: 45,
            51: 60, 52: 49, 53: 62, 54: 55, 55: 78, 56: 96, 57: 29, 58: 22, 59: 24, 60: 13,
            61: 14, 62: 11, 63: 11, 64: 18, 65: 12, 66: 12, 67: 30, 68: 52, 69: 52, 70: 44,
            71: 28, 72: 28, 73: 20, 74: 56, 75: 40, 76: 31, 77: 50, 78: 40, 79: 46, 80: 42,
            81: 29, 82: 19, 83: 36, 84: 25, 85: 22, 86: 17, 87: 19, 88: 26, 89: 30, 90: 20,
            91: 15, 92: 21, 93: 11, 94: 8, 95: 8, 96: 19, 97: 5, 98: 8, 99: 8, 100: 11,
            101: 11, 102: 8, 103: 3, 104: 9, 105: 5, 106: 4, 107: 7, 108: 3, 109: 6, 110: 3,
            111: 5, 112: 4, 113: 5, 114: 6
        };

        let isMushafMode = false;
        let isAudioPlaying = false;
        let audioWorker;
        let audioPlayingBlob = null;


        document.addEventListener('DOMContentLoaded', () => {
            populateSurahSelect();
            initIndexedDB();
            setupEventListeners();
        });

        function openIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (!db.objectStoreNames.contains(WORDS_STORE_NAME)) {
                        db.createObjectStore(WORDS_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    }
                    if (!db.objectStoreNames.contains(BOOKMARKS_STORE_NAME)) {
                        db.createObjectStore(BOOKMARKS_STORE_NAME, { keyPath: ['surah', 'ayah'] });
                    }
                    if (!db.objectStoreNames.contains(NOTES_STORE_NAME)) {
                        db.createObjectStore(NOTES_STORE_NAME, { keyPath: ['surah', 'ayah'] });
                    }
                    if (!db.objectStoreNames.contains(METADATA_STORE_NAME)) {
                        db.createObjectStore(METADATA_STORE_NAME, { keyPath: 'key' });
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.error);
                    alert("Error opening database. Data might not be available.");
                    reject(event.target.error);
                };
            });
        }

         async function initIndexedDB() {
              try {
                  db = await openIndexedDB();
                 await checkAndLoadData();
                 await loadMetadata();
                 await updateAyahSelect();
                  await displayAyahData(currentSurah, currentAyah);
             } catch (error) {
                  console.error("Initialization failed:", error);
                 alert("App failed to initialize. Data loading may have failed.");
             }
          }


         async function checkAndLoadData() {
              try {
                  const count = await getStoreCount(WORDS_STORE_NAME);
                  if (count === 0) {
                      alert("Loading Quran data for the first time. This might take a moment...");
                     await loadData();
                      alert("Data loaded successfully!");
                  }
              } catch (error) {
                  console.error("Error checking or loading data:", error);
                   alert("Error checking or loading data.");
              }
         }


         async function getStoreCount(storeName) {
              return new Promise((resolve, reject) => {
                  if (!db) {
                      resolve(0); // Assume empty if DB isn't ready
                     return;
                  }
                  const transaction = db.transaction(storeName, 'readonly');
                  const store = transaction.objectStore(storeName);
                  const request = store.count();
                  request.onsuccess = () => resolve(request.result);
                  request.onerror = (event) => reject(event.target.error);
              });
         }


         async function loadData() {
             try {
                 const dataResponse = await fetch('data5.AM');
                 const wordMetadataResponse = await fetch('word.AM');

                 if (!dataResponse.ok || !wordMetadataResponse.ok) {
                     throw new Error('Failed to fetch data files.');
                 }

                 const dataText = await dataResponse.text();
                 const wordMetadataText = await wordMetadataResponse.text();

                 const lines = dataText.trim().split('\n').slice(1); // Skip header
                 const wordMetadataLines = wordMetadataText.trim().split('\n');

                 const parsedWords = [];
                 const metadataMap = {};

                 // Parse word.AM (simplified, assuming simple key: value structure per line)
                  wordMetadataLines.forEach(line => {
                     const parts = line.trim().match(/^"(\d+)": (\{.*\})/);
                     if (parts && parts.length === 3) {
                         const key = parseInt(parts[1]);
                         try {
                             const value = JSON.parse(parts[2]);
                             metadataMap[key] = value;
                         } catch (e) {
                             console.error("Error parsing word.AM JSON for key:", key, e);
                         }
                     } else {
                        console.warn("Skipping unparsable word.AM line:", line);
                    }
                 });

                lines.forEach((line, index) => {
                     try {
                        const [quran_text, ur_meaning, en_meaning, ...extra] = line.split(','); // Split by comma

                         // Join back any extra parts to the last meaning field if present
                        const combinedUrMeaning = extra.length > 0 ? [ur_meaning, en_meaning, ...extra].join(',') : ur_meaning;
                         const combinedEnMeaning = extra.length > 0 ? [en_meaning, ...extra].join(',') : en_meaning;

                        const wordId = index + 1; // IDs start from 1 in word.AM
                        const metadata = metadataMap[wordId];

                         if (metadata) {
                              parsedWords.push({
                                  id: wordId,
                                  quran_text: quran_text || '',
                                  ur_meaning: combinedUrMeaning || '',
                                  en_meaning: combinedEnMeaning || '',
                                  surah: metadata.surah,
                                  ayah: metadata.ayah,
                                  position: metadata.position
                              });
                         } else {
                             console.warn(`Metadata not found for word ID: ${wordId}. Skipping word.`);
                         }
                     } catch (e) {
                         console.error("Error processing data5.AM line:", line, e);
                     }
                 });


                await storeDataInIndexedDB(parsedWords);
                await buildMetadata(parsedWords);

            } catch (error) {
                console.error("Error loading or parsing data:", error);
                alert("Failed to load or parse Quran data.");
            }
        }

         async function buildMetadata(words) {
             surahLengths = {};
             ayahPositions = {};
             mushafQuranText = []; // Reset mushaf text

             let currentAyahKey = null;
             let currentAyahWordsInOrder = [];

             // Sort words to build metadata in order
              const sortedWords = words.sort((a, b) => {
                 if (a.surah !== b.surah) return a.surah - b.surah;
                  if (a.ayah !== b.ayah) return a.ayah - b.ayah;
                 return a.position - b.position;
             });

             sortedWords.forEach(word => {
                 const surahAyahKey = `${word.surah}-${word.ayah}`;

                 // Build surahLengths
                 if (!surahLengths[word.surah]) {
                     surahLengths[word.surah] = {};
                 }
                 if (!surahLengths[word.surah][word.ayah]) {
                     surahLengths[word.surah][word.ayah] = 0;
                 }
                 surahLengths[word.surah][word.ayah]++;

                 // Build ayahPositions (Word ID mapping by surah, ayah, position)
                 ayahPositions[surahAyahKey] = ayahPositions[surahAyahKey] || {};
                 ayahPositions[surahAyahKey][word.position] = word.id;

                  // Build mushaf text (combine quran_text for each ayah)
                 if (currentAyahKey !== surahAyahKey) {
                      if (currentAyahWordsInOrder.length > 0) {
                         mushafQuranText.push({ key: currentAyahKey, text: currentAyahWordsInOrder.map(w => w.quran_text).join(' ') });
                      }
                      currentAyahKey = surahAyahKey;
                      currentAyahWordsInOrder = [];
                 }
                  currentAyahWordsInOrder.push(word); // Add the word to the current ayah's words

             });

              // Add the last ayah's mushaf text
             if (currentAyahWordsInOrder.length > 0) {
                  mushafQuranText.push({ key: currentAyahKey, text: currentAyahWordsInOrder.map(w => w.quran_text).join(' ') });
              }


             // Store metadata in IndexedDB
              await storeMetadataInIndexedDB();
         }

        async function storeMetadataInIndexedDB() {
            return new Promise((resolve, reject) => {
                 if (!db) {
                      reject("Database not initialized.");
                      return;
                  }
                const transaction = db.transaction(METADATA_STORE_NAME, 'readwrite');
                const store = transaction.objectStore(METADATA_STORE_NAME);
                const putSurahLengths = store.put({ key: 'surahLengths', value: surahLengths });
                const putAyahPositions = store.put({ key: 'ayahPositions', value: ayahPositions });
                 const putMushafQuranText = store.put({ key: 'mushafQuranText', value: mushafQuranText });


                transaction.oncomplete = () => resolve();
                transaction.onerror = (event) => reject(event.target.error);
                putSurahLengths.onerror = putAyahPositions.onerror = putMushafQuranText.onerror = (event) => reject(event.target.error);
            });
        }

        async function loadMetadata() {
             return new Promise((resolve, reject) => {
                 if (!db) {
                     resolve(); // Proceed if DB is not ready, though functionality will be limited
                      return;
                 }
                const transaction = db.transaction(METADATA_STORE_NAME, 'readonly');
                const store = transaction.objectStore(METADATA_STORE_NAME);

                const requestSurahLengths = store.get('surahLengths');
                requestSurahLengths.onsuccess = () => {
                    surahLengths = requestSurahLengths.result ? requestSurahLengths.result.value : {};
                    const requestAyahPositions = store.get('ayahPositions');
                    requestAyahPositions.onsuccess = () => {
                        ayahPositions = requestAyahPositions.result ? requestAyahPositions.result.value : {};
                         const requestMushafQuranText = store.get('mushafQuranText');
                         requestMushafQuranText.onsuccess = () => {
                             mushafQuranText = requestMushafQuranText.result ? requestMushafQuranText.result.value : [];
                            resolve();
                         };
                        requestMushafQuranText.onerror = (event) => reject(event.target.error);
                    };
                    requestAyahPositions.onerror = (event) => reject(event.target.error);
                };
                requestSurahLengths.onerror = (event) => reject(event.target.error);
            });
        }


        async function storeDataInIndexedDB(data) {
             return new Promise((resolve, reject) => {
                 if (!db) {
                     reject("Database not initialized.");
                      return;
                  }
                 const transaction = db.transaction(WORDS_STORE_NAME, 'readwrite');
                 const store = transaction.objectStore(WORDS_STORE_NAME);

                 let addedCount = 0;
                 let errorCount = 0;
                 const totalItems = data.length;

                 function addNext() {
                      if (data.length === 0) {
                          // Finished adding all items (or ran out of items)
                          if (errorCount > 0) {
                               console.warn(`Finished transaction with ${errorCount} errors.`);
                         }
                          return;
                     }
                      const word = data.shift(); // Get the next item

                      const request = store.add(word);
                      request.onsuccess = () => {
                          addedCount++;
                           if (addedCount % 1000 === 0) {
                              console.log(`Added ${addedCount}/${totalItems} words...`);
                          }
                         addNext(); // Process the next item
                       };
                       request.onerror = (event) => {
                            console.error("Error adding word:", event.target.error, word);
                            errorCount++;
                           // Decide whether to stop or continue. Continuing for now.
                           addNext(); // Try to process the next item
                       };
                 }

                 // Start the recursive adding process
                 addNext();


                 transaction.oncomplete = () => {
                      console.log(`IndexedDB transaction complete. Successfully added ${addedCount} words with ${errorCount} errors.`);
                     resolve();
                 };
                 transaction.onerror = (event) => {
                     console.error("Transaction failed during data storage:", event.target.error);
                      // If a transaction error occurs, the whole transaction is rolled back.
                      // The individual item errors logged above might still be useful for debugging.
                     reject(event.target.error);
                 };
             });
         }


        function populateSurahSelect() {
            const surahSelect = document.getElementById('surah-select');
            surahSelect.innerHTML = ''; // Clear existing options
            for (let i = 1; i <= 114; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${i}. ${surahNames[i]}`;
                surahSelect.appendChild(option);
            }
        }

        async function updateAyahSelect() {
            const ayahSelect = document.getElementById('ayah-select');
            ayahSelect.innerHTML = ''; // Clear previous options
            const numberOfAyahs = ayahCounts[currentSurah] || 0;

            for (let i = 1; i <= numberOfAyahs; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${i}`;
                ayahSelect.appendChild(option);
            }

             // Ensure selected ayah is within bounds
            if (currentAyah > numberOfAyahs) {
                 currentAyah = numberOfAyahs || 1; // Default to 1 if surah has no ayahs
            } else if (currentAyah < 1 && numberOfAyahs > 0) {
                 currentAyah = 1;
             }
            ayahSelect.value = currentAyah;
        }

         function setupEventListeners() {
              document.getElementById('surah-select').addEventListener('change', async (event) => {
                  currentSurah = parseInt(event.target.value);
                  currentAyah = 1; // Reset to first ayah
                  await updateAyahSelect();
                  await displayAyahData(currentSurah, currentAyah);
             });

              document.getElementById('ayah-select').addEventListener('change', async (event) => {
                 currentAyah = parseInt(event.target.value);
                 await displayAyahData(currentSurah, currentAyah);
             });

             document.getElementById('toggle-view-button').addEventListener('click', () => {
                 toggleView();
             });

              document.getElementById('bookmark-button').addEventListener('click', () => {
                  toggleBookmark(currentSurah, currentAyah);
              });

             document.getElementById('audio-toggle-button').addEventListener('click', () => {
                  toggleAudioPlayback(currentSurah, currentAyah);
             });

             document.getElementById('export-ayah-button').addEventListener('click', () => {
                  exportAyahText(currentSurah, currentAyah);
             });

             document.getElementById('save-note-button').addEventListener('click', async () => {
                 const notesInput = document.getElementById('notes-input').value;
                 await saveNote(currentSurah, currentAyah, notesInput);
             });

             document.getElementById('search-button').addEventListener('click', () => {
                  performSearch();
             });

             document.getElementById('mushaf-mode-button').addEventListener('click', () => {
                  toggleMushafMode();
              });


              document.getElementById('backup-button').addEventListener('click', async () => {
                 await backupData();
             });

              document.getElementById('restore-button').addEventListener('click', () => {
                 document.getElementById('restore-input').click(); // Trigger file input click
              });

              document.getElementById('restore-input').addEventListener('change', async (event) => {
                  const file = event.target.files[0];
                  if (file) {
                       await restoreData(file);
                  }
                  event.target.value = ''; // Clear file input
             });

         }

         async function getWordsForAyah(surah, ayah) {
             return new Promise((resolve, reject) => {
                 if (!db) {
                     resolve([]); // Return empty array if DB isn't ready
                      return;
                 }
                 const transaction = db.transaction(WORDS_STORE_NAME, 'readonly');
                 const store = transaction.objectStore(WORDS_STORE_NAME);

                 // To filter by surah and ayah, we can iterate over a cursor
                 // or (more simply for this data structure) fetch all and filter.
                 // For full Quran data, a better approach might be to add indices.
                 // Since id is the key, fetching by ID range would require knowing the start/end IDs.
                 // Let's filter in-memory for now, assuming data is not _prohibitively_ large to hold in memory temporarily.

                 const allWordsInStoreRequest = store.getAll();

                 allWordsInStoreRequest.onsuccess = () => {
                     const ayahWords = allWordsInStoreRequest.result.filter(word =>
                         word.surah === surah && word.ayah === ayah
                     ).sort((a, b) => a.position - b.position); // Ensure correct order
                     resolve(ayahWords);
                 };

                 allWordsInStoreRequest.onerror = (event) => {
                     console.error("Error fetching words for ayah:", event.target.error);
                     reject(event.target.error);
                 };
             });
         }


        async function displayAyahData(surah, ayah) {
             if (!db) {
                 console.warn("Database not ready, skipping displayAyahData.");
                 return; // Do nothing if DB isn't initialized yet
             }

            try {
                const ayahWords = await getWordsForAyah(surah, ayah);
                allWords = ayahWords; // Store globally for ayah generation and export

                // Display Word by Word
                const tableBody = document.getElementById('word-by-word-table-body');
                tableBody.innerHTML = '';
                 if (ayahWords.length > 0) {
                     ayahWords.forEach(word => {
                         const row = document.createElement('tr');
                         row.innerHTML = `
                             <td>${word.quran_text}</td>
                             <td>${word.ur_meaning}</td>
                             <td>${word.en_meaning}</td>
                         `;
                         tableBody.appendChild(row);
                     });
                 } else {
                      tableBody.innerHTML = '<tr><td colspan="3">No word data available for this ayah.</td></tr>';
                 }


                // Generate and Display Ayah Translations
                const ayahUrdu = generateAyahTranslation(ayahWords, 'ur_meaning');
                const ayahEnglish = generateAyahTranslation(ayahWords, 'en_meaning');

                document.getElementById('ayah-translation-urdu').innerHTML = `<strong>Urdu:</strong> ${ayahUrdu}`;
                document.getElementById('ayah-translation-english').innerHTML = `<strong>English:</strong> ${ayahEnglish}`;

                 // Display Mushaf Ayah Text
                 const mushafAyahElement = document.getElementById('mushaf-ayah-text');
                 const surahAyahKey = `${surah}-${ayah}`;
                 const ayahMushafItem = mushafQuranText.find(item => item.key === surahAyahKey);
                 mushafAyahElement.textContent = ayahMushafItem ? ayahMushafItem.text : 'Mushaf text not available.';


                // Check Bookmark Status
                await checkBookmarkStatus(surah, ayah);

                 // Load and Display Note
                 await loadNote(surah, ayah);

                 // Display Statistics (Total Words in Surah)
                 displaySurahStatistics(surah);


            } catch (error) {
                console.error("Error displaying ayah data:", error);
                 alert("Error fetching data for the selected ayah.");
            }
        }


         function generateAyahTranslation(words, meaningKey) {
              if (!words || words.length === 0) return 'Translation not available.';

             let translation = words.map(word => word[meaningKey]).join(' ').trim();

             // Simple grammar adjustments (can be improved)
              translation = translation.replace(/\s*,/g, ',').replace(/,\s*/g, ', ').replace(/\(\s*/g, '(').replace(/\s*\)/g, ')'); // Adjust comma spacing, parentheses
             translation = translation.replace(/,/g, ', ').replace(/\s\s+/g, ' ').trim(); // Add space after comma, normalize spaces


             // Capitalize first letter (basic)
             if (translation.length > 0) {
                  // Only capitalize if it doesn't look like it starts with punctuation or a number
                  if (!/^[\s()"'`‘’.„…]/.test(translation)) {
                      translation = translation.charAt(0).toUpperCase() + translation.slice(1);
                  }
             }

              return translation;
         }


         function toggleView() {
              const wordByWordView = document.getElementById('word-by-word-view');
              const ayahView = document.getElementById('ayah-view');
             const mushafView = document.getElementById('mushaf-view');
             const toggleButton = document.getElementById('toggle-view-button');

              if (mushafView.style.display !== 'none') {
                 // If currently in Mushaf mode, switch to Word-by-Word
                 mushafView.style.display = 'none';
                 wordByWordView.style.display = 'block';
                 ayahView.style.display = 'none';
                 toggleButton.textContent = 'Toggle View (Word-by-Word / Ayah)';
                 isMushafMode = false;
             } else if (wordByWordView.style.display !== 'none') {
                  // If currently in Word-by-Word, switch to Ayah view
                 wordByWordView.style.display = 'none';
                  ayahView.style.display = 'block';
                 mushafView.style.display = 'none';
                 toggleButton.textContent = 'Toggle View (Ayah / Mushaf)';
                 isMushafMode = false;
             } else {
                  // If currently in Ayah view, switch to Word-by-Word view
                 ayahView.style.display = 'none';
                  wordByWordView.style.display = 'block';
                 mushafView.style.display = 'none';
                  toggleButton.textContent = 'Toggle View (Word-by-Word / Ayah)';
                 isMushafMode = false;
             }
         }


        function toggleMushafMode() {
            const wordByWordView = document.getElementById('word-by-word-view');
            const ayahView = document.getElementById('ayah-view');
            const mushafView = document.getElementById('mushaf-view');
             const toggleViewButton = document.getElementById('toggle-view-button');

             isMushafMode = !isMushafMode;

             if (isMushafMode) {
                 wordByWordView.style.display = 'none';
                 ayahView.style.display = 'none';
                 mushafView.style.display = 'block';
                 toggleViewButton.textContent = 'Toggle View'; // Hide specific view names when in Mushaf
             } else {
                 mushafView.style.display = 'none';
                 // Revert to previous state or default to word-by-word
                 wordByWordView.style.display = 'block';
                 ayahView.style.display = 'none';
                  toggleViewButton.textContent = 'Toggle View (Word-by-Word / Ayah)';
            }
        }


        async function toggleBookmark(surah, ayah) {
             if (!db) return;

             const transaction = db.transaction(BOOKMARKS_STORE_NAME, 'readwrite');
             const store = transaction.objectStore(BOOKMARKS_STORE_NAME);

             const key = [surah, ayah];
             const getRequest = store.get(key);

             getRequest.onsuccess = async () => {
                 if (getRequest.result) {
                     // Bookmark exists, remove it
                     const deleteRequest = store.delete(key);
                     deleteRequest.onsuccess = () => {
                         alert(`Bookmark removed for ${surahNames[surah]}:${ayah}`);
                          document.getElementById('bookmark-button').classList.remove('active');
                     };
                     deleteRequest.onerror = (event) => console.error("Error removing bookmark:", event.target.error);
                 } else {
                     // Bookmark doesn't exist, add it
                     const putRequest = store.put({ surah: surah, ayah: ayah });
                     putRequest.onsuccess = () => {
                         alert(`Bookmark added for ${surahNames[surah]}:${ayah}`);
                         document.getElementById('bookmark-button').classList.add('active');
                     };
                     putRequest.onerror = (event) => console.error("Error adding bookmark:", event.target.error);
                 }
             };
              getRequest.onerror = (event) => console.error("Error checking bookmark:", event.target.error);

         }


        async function checkBookmarkStatus(surah, ayah) {
             if (!db) return;

              return new Promise((resolve, reject) => {
                  const transaction = db.transaction(BOOKMARKS_STORE_NAME, 'readonly');
                 const store = transaction.objectStore(BOOKMARKS_STORE_NAME);
                  const request = store.get([surah, ayah]);

                 request.onsuccess = () => {
                     const button = document.getElementById('bookmark-button');
                      if (request.result) {
                          button.classList.add('active');
                     } else {
                          button.classList.remove('active');
                      }
                     resolve();
                 };
                 request.onerror = (event) => {
                      console.error("Error checking bookmark status:", event.target.error);
                     // Don't reject here, just log error so the page can still load
                     resolve();
                  };
              });
         }


         async function saveNote(surah, ayah, note) {
             if (!db) {
                 alert("Database not initialized. Cannot save note.");
                  return;
             }

              const transaction = db.transaction(NOTES_STORE_NAME, 'readwrite');
             const store = transaction.objectStore(NOTES_STORE_NAME);

             const key = [surah, ayah];
              const putRequest = store.put({ surah: surah, ayah: ayah, note: note });

             putRequest.onsuccess = () => {
                  document.getElementById('saved-note-text').textContent = note;
                  alert(`Note saved for ${surahNames[surah]}:${ayah}`);
             };
             putRequest.onerror = (event) => {
                 console.error("Error saving note:", event.target.error);
                  alert("Error saving note.");
              };
         }

         async function loadNote(surah, ayah) {
             if (!db) {
                 document.getElementById('notes-input').value = '';
                 document.getElementById('saved-note-text').textContent = 'DB not ready.';
                 return;
              }

             return new Promise((resolve, reject) => {
                 const transaction = db.transaction(NOTES_STORE_NAME, 'readonly');
                 const store = transaction.objectStore(NOTES_STORE_NAME);
                 const request = store.get([surah, ayah]);

                  request.onsuccess = () => {
                      const note = request.result ? request.result.note : '';
                     document.getElementById('notes-input').value = note;
                      document.getElementById('saved-note-text').textContent = note;
                      resolve();
                  };
                 request.onerror = (event) => {
                     console.error("Error loading note:", event.target.error);
                      document.getElementById('notes-input').value = '';
                     document.getElementById('saved-note-text').textContent = 'Error loading note.';
                     // Don't reject here, just log error
                     resolve();
                 };
              });
         }

         async function displaySurahStatistics(surah) {
              const totalWordsInSurah = Object.values(surahLengths[surah] || {}).reduce((sum, count) => sum + count, 0);
              document.getElementById('surah-word-count').textContent = totalWordsInSurah;
          }

         async function performSearch() {
              if (!db) {
                  alert("Database not initialized. Please wait or reload.");
                  return;
              }

              const searchTerm = document.getElementById('search-input').value.trim();
              if (!searchTerm) {
                  alert("Please enter a search term.");
                  return;
              }

             // Check for surah:ayah format
              const surahAyahMatch = searchTerm.match(/^(\d+):(\d+)$/);
              if (surahAyahMatch) {
                 const surah = parseInt(surahAyahMatch[1]);
                  const ayah = parseInt(surahAyahMatch[2]);

                  if (surah > 0 && surah <= 114 && ayah > 0 && ayah <= (ayahCounts[surah] || 0)) {
                     // Navigate to the selected ayah
                     document.getElementById('surah-select').value = surah;
                      currentSurah = surah;
                      await updateAyahSelect(); // Populate ayahs for the selected surah
                      document.getElementById('ayah-select').value = ayah;
                     currentAyah = ayah;
                     await displayAyahData(currentSurah, currentAyah);

                     // Close the modal if it was open
                      const modalElement = document.getElementById('searchResultsModal');
                      const modal = bootstrap.Modal.getInstance(modalElement);
                      if (modal) modal.hide();

                      return; // Found exact match, navigate directly
                 } else {
                      alert("Invalid Surah:Ayah format or numbers.");
                      return;
                  }
              }

              // General search (can be slow on large datasets without indexes)
              const transaction = db.transaction(WORDS_STORE_NAME, 'readonly');
              const store = transaction.objectStore(WORDS_STORE_NAME);
              const request = store.getAll(); // Fetch all for client-side filtering (simpler for small data)

              request.onsuccess = () => {
                  const searchTermLower = searchTerm.toLowerCase();
                  const results = request.result.filter(word =>
                     // Case-insensitive search
                      (word.quran_text && word.quran_text.toLowerCase().includes(searchTermLower)) ||
                     (word.ur_meaning && word.ur_meaning.toLowerCase().includes(searchTermLower)) ||
                     (word.en_meaning && word.en_meaning.toLowerCase().includes(searchTermLower))
                 );

                  displaySearchResults(results);

              };

              request.onerror = (event) => {
                  console.error("Search error:", event.target.error);
                  alert("Error during search.");
              };
          }

         function displaySearchResults(results) {
             const searchResultsBody = document.getElementById('search-results-body');
              searchResultsBody.innerHTML = ''; // Clear previous results

              if (results.length === 0) {
                 searchResultsBody.innerHTML = '<p>No results found.</p>';
              } else {
                 // Limit results to avoid overwhelming the display (optional)
                 const maxResults = 200; // Increased limit slightly
                 const limitedResults = results.slice(0, maxResults);

                  // Group results by ayah for better readability
                  const resultsByAyah = limitedResults.reduce((acc, word) => {
                      const key = `${word.surah}:${word.ayah}`;
                      if (!acc[key]) {
                          acc[key] = {
                              surah: word.surah,
                              ayah: word.ayah,
                              words: []
                          };
                     }
                      acc[key].words.push(word);
                      return acc;
                 }, {});


                 Object.values(resultsByAyah).forEach(ayahResult => {
                     // Sort words within the ayah by position for ayah translation
                     ayahResult.words.sort((a, b) => a.position - b.position);

                      const resultElement = document.createElement('div');
                      resultElement.classList.add('search-result-item', 'mb-2', 'p-2', 'border', 'rounded');
                     resultElement.innerHTML = `
                         <p><strong>${ayahResult.surah}:${ayahResult.ayah} (${surahNames[ayahResult.surah]})</strong></p>
                         <p><strong>Ayah Arabic:</strong> ${ayahResult.words.map(w => w.quran_text).join(' ')}</p>
                         <p><strong>Ayah Urdu:</strong> ${generateAyahTranslation(ayahResult.words, 'ur_meaning')}</p>
                         <p><strong>Ayah English:</strong> ${generateAyahTranslation(ayahResult.words, 'en_meaning')}</p>
                     `;
                     resultElement.dataset.surah = ayahResult.surah;
                     resultElement.dataset.ayah = ayahResult.ayah;
                      resultElement.addEventListener('click', async (event) => {
                         const selectedSurah = parseInt(event.currentTarget.dataset.surah);
                          const selectedAyah = parseInt(event.currentTarget.dataset.ayah);

                          // Navigate to the selected ayah
                          document.getElementById('surah-select').value = selectedSurah;
                         currentSurah = selectedSurah;
                         await updateAyahSelect();
                          document.getElementById('ayah-select').value = selectedAyah;
                          currentAyah = selectedAyah;
                          await displayAyahData(currentSurah, currentAyah);

                         // Close the modal
                          const modal = bootstrap.Modal.getInstance(document.getElementById('searchResultsModal'));
                          modal.hide();
                     });
                      searchResultsBody.appendChild(resultElement);
                 });


                 if (results.length > maxResults) {
                     searchResultsBody.innerHTML += `<p>Displaying the first ${maxResults} unique ayahs found. Consider refining your search.</p>`;
                 }
              }


              const searchResultsModal = new bootstrap.Modal(document.getElementById('searchResultsModal'));
             searchResultsModal.show();
          }


        async function toggleAudioPlayback(surah, ayah) {
              const audioButton = document.getElementById('audio-toggle-button');
              if (isAudioPlaying) {
                  stopAudioPlayback();
                 audioButton.textContent = 'Play Audio';
                 audioButton.disabled = false; // Enable button
             } else {
                 audioButton.textContent = 'Loading Audio...';
                  audioButton.disabled = true; // Disable button during loading
                  await playAudioForAyah(surah, ayah);
                 // State change handled by worker.onstatechange or playAudioForAyah catch block
              }
              isAudioPlaying = !isAudioPlaying;
          }

          async function playAudioForAyah(surah, ayah) {
               if (audioPlayingBlob) {
                 URL.revokeObjectURL(audioPlayingBlob);
                 audioPlayingBlob = null;
             }

              // Use padded numbers for the audio URL format
               const paddedSurah = String(surah).padStart(3, '0'); // Typically 3 digits
               const paddedAyah = String(ayah).padStart(3, '0');     // Typically 3 digits

               // Example URL structure (verify the actual URL structure of the CDN)
              // Note: CDN links can be volatile. Ensure this one is still active or find a replacement.
               const audioUrl = `https://cdn.islamic.network/quran/audio/128/ar.alafasy/${paddedSurah}${paddedAyah}.mp3`; // Example format, might need adjustment


              try {
                 const response = await fetch(audioUrl);
                  if (!response.ok) throw new Error(`Failed to fetch audio: ${response.status} ${response.statusText}`);
                 const audioBlob = await response.blob();
                  audioPlayingBlob = URL.createObjectURL(audioBlob);

                  if (!audioWorker) {
                      // Lazy initialize AudioWorker
                      audioWorker = new AudioWorker();
                      audioWorker.onerror = (error) => {
                         console.error('Audio Worker Error:', error);
                          stopAudioPlayback();
                         alert("Audio playback failed.");
                         document.getElementById('audio-toggle-button').textContent = 'Play Audio';
                          document.getElementById('audio-toggle-button').disabled = false;
                         isAudioPlaying = false;
                      };
                      audioWorker.onstatechange = (state) => {
                           console.log('Audio Worker State:', state);
                          const audioButton = document.getElementById('audio-toggle-button');
                           if (state === 'playing') {
                             audioButton.textContent = 'Stop Audio';
                              audioButton.disabled = false; // Enable button
                          } else if (state === 'suspended' || state === 'closed' || state === 'decoded' || state === 'ready' || state === 'decoding' || state === 'stopped') {
                             audioButton.textContent = 'Play Audio';
                              audioButton.disabled = false; // Enable button
                              if (audioPlayingBlob) {
                                   URL.revokeObjectURL(audioPlayingBlob);
                                  audioPlayingBlob = null;
                             }
                              isAudioPlaying = false; // Reset internal state if playback stops or fails
                           }
                      };
                      audioWorker.onmessage = (e) => {
                          if (e.data && e.data.event === 'ended') {
                              console.log('Audio playback ended.');
                              stopAudioPlayback(); // Ensure cleanup
                              document.getElementById('audio-toggle-button').textContent = 'Play Audio';
                               document.getElementById('audio-toggle-button').disabled = false;
                              isAudioPlaying = false;
                         }
                      };

                   } else {
                     // Stop any currently playing audio before starting new one
                       audioWorker.postMessage({ command: 'stop' });
                   }

                 audioWorker.postMessage({ command: 'playBlob', url: audioPlayingBlob });

             } catch (error) {
                  console.error("Error playing audio:", error);
                 alert("Could not load audio for this ayah. Please check the internet connection or try another ayah. (CDN might be down or URL format incorrect)");
                  document.getElementById('audio-toggle-button').textContent = 'Play Audio';
                  document.getElementById('audio-toggle-button').disabled = false;
                 isAudioPlaying = false; // Reset state
                 if (audioPlayingBlob) {
                     URL.revokeObjectURL(audioPlayingBlob); // Clean up the blob URL
                     audioPlayingBlob = null;
                  }
              }
          }

         function stopAudioPlayback() {
              if (audioWorker) {
                 audioWorker.postMessage({ command: 'stop' });
                 // The URL revoke happens in the worker's statechange listener or message handler
                  // URL.revokeObjectURL(audioPlayingBlob); // Moved to worker listeners
                 // audioPlayingBlob = null; // Moved to worker listeners
             }
             document.getElementById('audio-toggle-button').textContent = 'Play Audio';
             document.getElementById('audio-toggle-button').disabled = false;
             isAudioPlaying = false;
         }


          function exportAyahText(surah, ayah) {
              const ayahUrdu = document.getElementById('ayah-translation-urdu').textContent.replace('Urdu: ', '');
              const ayahEnglish = document.getElementById('ayah-translation-english').textContent.replace('English: ', '');
             const mushafText = document.getElementById('mushaf-ayah-text').textContent;

             // Ensure words were loaded for this ayah to provide word-by-word
             let wordByWordDetails = '';
             if (allWords && allWords.length > 0) {
                 wordByWordDetails = allWords.map(word =>
                      `  - ${word.quran_text}: Urdu - "${word.ur_meaning}", English - "${word.en_meaning}"`
                  ).join('\n');
                  wordByWordDetails = `Word by Word Details:\n${wordByWordDetails}\n\n`;
              }


              const exportContent = `
Quran Ayah ${surah}:${ayah} (${surahNames[surah]})

Mushaf Text:
${mushafText}

${wordByWordDetails}
Urdu Translation:
${ayahUrdu}

English Translation:
${ayahEnglish}
              `.trim();

              const blob = new Blob([exportContent], { type: 'text/plain' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
             a.download = `quran_ayah_${surah}_${ayah}.txt`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
         }


          async function backupData() {
              if (!db) {
                  alert("Database not initialized. Cannot backup.");
                  return;
              }

              try {
                  const dataToBackup = {};

                  // Get all data from all stores
                  await Promise.all([
                      getAllStoreData(WORDS_STORE_NAME).then(data => dataToBackup[WORDS_STORE_NAME] = data),
                      getAllStoreData(BOOKMARKS_STORE_NAME).then(data => dataToBackup[BOOKMARKS_STORE_NAME] = data),
                      getAllStoreData(NOTES_STORE_NAME).then(data => dataToBackup[NOTES_STORE_NAME] = data),
                      getAllStoreData(METADATA_STORE_NAME).then(data => dataToBackup[METADATA_STORE_NAME] = data)
                  ]);


                  const backupJson = JSON.stringify(dataToBackup);
                 const blob = new Blob([backupJson], { type: 'application/json' });
                 const url = URL.createObjectURL(blob);

                 const a = document.createElement('a');
                  a.href = url;
                 a.download = `quran_app_backup_${new Date().toISOString().replace(/[:.-]/g, '_')}.json`;
                 document.body.appendChild(a);
                 a.click();
                  document.body.removeChild(a);
                 URL.revokeObjectURL(url);

                  alert("Data backed up successfully!");

             } catch (error) {
                  console.error("Backup failed:", error);
                  alert("Failed to backup data.");
             }
         }


         async function getAllStoreData(storeName) {
             return new Promise((resolve, reject) => {
                 if (!db || !db.objectStoreNames.contains(storeName)) {
                     resolve([]); // Return empty array if store doesn't exist or DB isn't ready
                     return;
                 }
                 const transaction = db.transaction(storeName, 'readonly');
                 const store = transaction.objectStore(storeName);
                 const request = store.getAll();

                 request.onsuccess = () => resolve(request.result);
                 request.onerror = (event) => reject(event.target.error);
              });
         }


         async function restoreData(file) {
              if (!db) {
                 alert("Database not initialized. Cannot restore.");
                  return;
             }

              if (!confirm("Restoring will overwrite all existing Quran data, bookmarks, notes, and settings. Are you sure?")) {
                  return;
             }

              const reader = new FileReader();
             reader.onload = async (event) => {
                 try {
                      const backupData = JSON.parse(event.target.result);

                      // Validate basic structure of backupData
                      if (!backupData || typeof backupData !== 'object') {
                          throw new Error("Invalid backup file structure.");
                     }

                      // Clear existing data from stores before restoring
                     await clearAllStores();

                     // Determine which stores are in the backup
                      const storesToRestore = [WORDS_STORE_NAME, BOOKMARKS_STORE_NAME, NOTES_STORE_NAME, METADATA_STORE_NAME]
                         .filter(storeName => backupData[storeName] && Array.isArray(backupData[storeName]));

                      // Add data from backup to stores in parallel
                      const restorePromises = storesToRestore.map(storeName =>
                         addDataToStore(storeName, backupData[storeName])
                      );

                      await Promise.all(restorePromises);

                      alert("Data restored successfully! Reloading app...");
                     window.location.reload(); // Reload to ensure new data is loaded

                 } catch (error) {
                     console.error("Restore failed:", error);
                     alert("Failed to restore data. Invalid file format or data structure: " + error.message);
                  }
              };
             reader.onerror = (event) => {
                 console.error("File reading error during restore:", event.target.error);
                  alert("Error reading backup file.");
              };

              reader.readAsText(file);
         }


         async function clearAllStores() {
             return new Promise((resolve, reject) => {
                 if (!db) {
                      resolve(); // Nothing to clear if DB not ready
                      return;
                  }
                 const transaction = db.transaction(db.objectStoreNames, 'readwrite');

                  const storeNames = Array.from(db.objectStoreNames);
                  let storesCleared = 0;
                  const totalStores = storeNames.length;

                 if (totalStores === 0) {
                      resolve();
                     return;
                 }

                  // Use transaction oncomplete to ensure all clear operations are done
                  transaction.oncomplete = () => resolve();
                 transaction.onerror = (event) => {
                     console.error("Transaction failed during store clearing:", event.target.error);
                     reject(event.target.error);
                  };


                  storeNames.forEach(storeName => {
                      const store = transaction.objectStore(storeName);
                     const request = store.clear();
                      request.onerror = (event) => {
                          console.error(`Error clearing store ${storeName}:`, event.target.error);
                         // Don't reject the whole promise immediately on one store error,
                         // let the transaction error handle the overall failure.
                     };
                  });
              });
         }

         async function addDataToStore(storeName, data) {
             if (!data || !Array.isArray(data) || !db || !db.objectStoreNames.contains(storeName)) {
                  return Promise.resolve();
             }

              return new Promise((resolve, reject) => {
                  const transaction = db.transaction(storeName, 'readwrite');
                  const store = transaction.objectStore(storeName);

                 let itemsAdded = 0;
                 let errorCount = 0;
                 const totalItems = data.length;

                 // Adding items asynchronously within the transaction
                 data.forEach(item => {
                     try {
                          // Need to remove auto-generated 'id' if keyPath was autoincrement initially
                          // But the data structure assumes 'id' is part of the source,
                          // and we set keyPath to 'id', so we should just add.
                           const request = store.add(item); // Or put if items might overwrite

                         request.onsuccess = () => { itemsAdded++; };
                         request.onerror = (event) => {
                             console.error(`Error adding item to ${storeName}:`, event.target.error, item);
                              errorCount++;
                              // Continue processing other items
                           };
                       } catch (e) {
                           console.error(`Exception when trying to add item to ${storeName}:`, e, item);
                            errorCount++;
                            // Continue processing other items
                       }
                 });


                 transaction.oncomplete = () => {
                     console.log(`Finished adding data to ${storeName}. Successfully added ${itemsAdded} items with ${errorCount} errors.`);
                      resolve();
                 };
                  transaction.onerror = (event) => {
                      console.error(`Transaction failed during adding data to ${storeName}:`, event.target.error);
                     // If transaction fails, it's often due to one or more item errors.
                     // The transaction error object might contain more details in event.target.error.
                      reject(event.target.error);
                  };
             });
         }

    </script>
</body>
</html>